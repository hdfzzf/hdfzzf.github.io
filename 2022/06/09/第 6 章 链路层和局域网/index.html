<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="这章就是整个计算机网络 top to down 的最后一章了，当然还有许多内容，只不过最核心的都在这6章。">
<meta property="og:type" content="article">
<meta property="og:title" content="第 6 章 链路层和局域网">
<meta property="og:url" content="https://hdfzzf.github.io/2022/06/09/%E7%AC%AC%206%20%E7%AB%A0%20%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/index.html">
<meta property="og:site_name" content="HDFZZF&#39;s BLOG">
<meta property="og:description" content="这章就是整个计算机网络 top to down 的最后一章了，当然还有许多内容，只不过最核心的都在这6章。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220607220546.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220607224610.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220607224714.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608103758.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608105028.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608161058.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608164316.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608165611.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608172528.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608172616.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608171005.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608173344.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609092740.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609092914.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609093754.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609094935.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609100507.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609111610.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609104035.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609104734.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609111505.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609113713.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609114235.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609114710.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609115034.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609115317.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609144521.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609145733.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609145748.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609145842.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/traditional-arp-process.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609152719.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609153241.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609154223.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609182344.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609154817.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609155144.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609182429.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609182429.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609185936.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609180242.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609181019.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609181236.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609181518.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609181850.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609182106.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609213139.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609220335.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609221819.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609221831.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609221900.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609222338.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609223011.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609223048.png">
<meta property="article:published_time" content="2022-06-08T16:00:00.000Z">
<meta property="article:modified_time" content="2022-06-24T00:19:27.202Z">
<meta property="article:author" content="hdfzzf">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="计算网络教程 自顶向下方法">
<meta property="article:tag" content="B站中科大计网">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220607220546.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/LOGO.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>第 6 章 链路层和局域网</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 6.0.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/tags/">标签</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2022/06/14/%E7%AC%AC%201%20%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2022/06/06/%E7%AC%AC%205%20%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
    </span>
    <br/>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">1.1. 节点的连接方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.</span> <span class="toc-text">1.2. 链路层服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1. 上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2. 具体服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2.3. 适配器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B%E5%92%8C%E7%BA%A0%E6%AD%A3"><span class="toc-number">2.</span> <span class="toc-text">2. 差错检测和纠正</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. 奇偶校验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95bit%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1. 单bit奇偶校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2. 2维奇偶校验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. 校验和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E6%B5%8B"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. 循环冗余检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1. 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2. 例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3. 性能分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%82%B9%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.</span> <span class="toc-text">3. 多点访问协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E9%81%93%E5%88%92%E5%88%86"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. 信道划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. 随机访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%9A%99aloha"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1. 时隙ALOHA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aloha"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2. ALOHA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#csma"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3. CSMA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#csmacd"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4. CSMA&#x2F;CD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#csmaca"><span class="toc-number">3.2.5.</span> <span class="toc-text">3.2.5. CSMA&#x2F;CA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8cd"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">3.2.5.1. 无法使用CD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#csmaca%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.5.2.</span> <span class="toc-text">3.2.5.2. CSMA&#x2F;CA过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rtscts%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.5.3.</span> <span class="toc-text">3.2.5.3. RTS&#x2F;CTS机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%BC%86%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%9C"><span class="toc-number">3.2.6.</span> <span class="toc-text">3.2.6. 线缆接入网络</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AE%E6%B5%81taking-turnsmac%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. 轮流(Taking Turns)MAC协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E4%B8%AD%E5%BC%8F-%E8%BD%AE%E8%AF%A2"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1. 集中式-轮询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BB%A4%E7%89%8C%E4%BC%A0%E9%80%92"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2. 分布式-令牌传递</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mac%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93"><span class="toc-number">3.4.</span> <span class="toc-text">3.4. MAC协议总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lans"><span class="toc-number">4.</span> <span class="toc-text">4. LANs</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mac%E5%9C%B0%E5%9D%80"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. MAC地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#address-resolution-protocolarp"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. Address Resolution Protocol(ARP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ethernet%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. Ethernet(以太网)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E6%8B%93%E6%89%91"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1. 物理拓扑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">4.3.1.1. 总线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BA%BF%E5%99%A8"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">4.3.1.2. 集线器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">4.3.1.3. 交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E8%BD%AC%E5%8F%91%E5%92%8C%E8%BF%87%E6%BB%A4"><span class="toc-number">4.3.1.3.1.</span> <span class="toc-text">4.3.1.3.1. 交换机的转发和过滤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E8%87%AA%E5%AD%A6%E4%B9%A0"><span class="toc-number">4.3.1.3.2.</span> <span class="toc-text">4.3.1.3.2. 交换机的自学习</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">4.3.1.3.3.</span> <span class="toc-text">4.3.1.3.3. 交换机的性质</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ethernet%E5%B8%A7%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2. Ethernet帧结构和服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ethernet%E6%A0%87%E5%87%86%E9%93%BE%E8%B7%AF%E5%92%8C%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-number">4.3.3.</span> <span class="toc-text">4.3.3. Ethernet标准：链路和物理层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#manchester%E7%BC%96%E7%A0%81"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">4.3.3.1. Manchester编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%83%E5%85%86%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">4.3.3.2. 千兆以太网</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A7%E6%9C%80%E5%B0%8F%E9%95%BF%E5%BA%A6"><span class="toc-number">4.3.4.</span> <span class="toc-text">4.3.4. 帧最小长度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#a-day-in-the-life-of-web-request"><span class="toc-number">5.</span> <span class="toc-text">5. a day in the life of web request</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dhcp"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. DHCP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arp"><span class="toc-number">5.2.</span> <span class="toc-text">5.2. ARP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dns"><span class="toc-number">5.3.</span> <span class="toc-text">5.3. DNS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#httptcp"><span class="toc-number">5.4.</span> <span class="toc-text">5.4. HTTP+TCP</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        第 6 章 链路层和局域网
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">hdfzzf</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-06-08T16:00:00.000Z" itemprop="datePublished">2022-06-09</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a> › <a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/B%E7%AB%99%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%BD%91/" rel="tag">B站中科大计网</a>, <a class="tag-link-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a>, <a class="tag-link-link" href="/tags/%E8%AE%A1%E7%AE%97%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/" rel="tag">计算网络教程 自顶向下方法</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>这章就是整个计算机网络 top to down 的最后一章了，当然还有许多内容，只不过最核心的都在这6章。</p>
<span id="more"></span>
<h1 id="概述">1. 概述</h1>
<p>通过之前的学习，我们知道了一个分组如何从一个子网的网关路由器到另一个子网网关路由器，但是还不知道如何将分组从网关路由器发送到目标主机，这就是本章节的内容。</p>
<h2 id="节点的连接方式">1.1. 节点的连接方式</h2>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220607220546.png" /></p>
<ul>
<li>Q：一个子网中的若干节点是如何连接的？</li>
</ul>
<p>我们知道，连接分为两种形式：</p>
<ul>
<li>点到点连接</li>
<li>多点连接</li>
</ul>
<p>如果一个子网中只有5个节点，那么完全可以采用点到点连接的方式，最后连接成一个5角星。一旦子网中的节点数量上去，比如说50个，那么点到点之间的连接就很困难了，每个节点都要与其他的49个相连。显然不切实际。因此，子网中通常采用多点连接。</p>
<p>需要区分一下两种情况：</p>
<ol type="1">
<li><p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220607224610.png" /></p></li>
<li><p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220607224714.png" /></p></li>
</ol>
<p>图1是点到点连接；图2是多点连接。<strong>点到点指的是两点之间有专属的边，多点连接指的是多个连通过公共的边连接在一起。</strong></p>
<p>点到点连接的特点：</p>
<ul>
<li>链路属于连接的双方，因此不存在竞争</li>
<li>没必要寻址（我发的分组，一定就是你收，没有其他人了）</li>
<li>不易扩展（N个节点，链路数量为：<span class="math inline">\(\frac {n(n+1)}{2} ➡ O(n^2)\)</span>）</li>
</ul>
<p>多点连接的特点：</p>
<ul>
<li>易于扩展（1个节点只需要一根线连接到共享介质就可以和其他节点连接到一起。链路数量一般为 <span class="math inline">\(O(n)\)</span>）</li>
<li>存在竞争/碰撞（多个节点一起发送，结果在公共链路上碰到一起了，结果谁都发不出去）</li>
<li>需要寻址（我发的分组大家都能收得到，因此需要标注是发给谁的）</li>
</ul>
<p>WAN一般范围比较大，因此采取点到点连接（一根电缆从西安绕道上海然后到杭州，最后到福州，这是不切实际），实现简单，只需要封装和解封装；</p>
<ul>
<li>此时，链路距离远（延迟大），带宽大（跨越这么远的距离不可能说连接一个带宽很小的链路吧） -&gt; 带宽延迟积大。如果采用多点连接：一旦竞争发生，代价会比较大（本来延迟就大，发生碰撞之后可能就直接超时了）。当然也可以采取协调的方式，但是协调也是需要发送信息的，发送信息就需要时间，因此协调时间也很长</li>
</ul>
<p>LAN因为范围较小，一般采用多点连接方式：</p>
<ul>
<li>连接节点方便</li>
<li>连接到共享介质上，就可以连接所有其他节点</li>
</ul>
<p>但是需要采用一定的方式来实现链路层的复杂功能：</p>
<ol type="1">
<li>多点接入：协调各阶段对共享介质的访问和使用</li>
<li>竞争方式：冲突之后的协调</li>
<li>令牌方式：令牌产生，占有和释放等</li>
</ol>
<h2 id="链路层服务">1.2. 链路层服务</h2>
<p>先介绍一些术语：</p>
<ol type="1">
<li>主机、路由器、网桥和交换机都是节点：nodes</li>
<li>沿着通信路径，连接相邻节点的通信信道称为链路：links
<ul>
<li>有线链路</li>
<li>无线链路</li>
<li>局域网，共享性链路</li>
</ul></li>
<li>第二层协议数据单元：帧，frame。数据报封装之后形成帧</li>
</ol>
<p><strong>数据链路层负责从一个节点通过链路将帧中的数据报发送到相邻的物理节点</strong>。而网络层是端到端，传输层在网络层的基础上实现进程到进程。</p>
<h3 id="上下文">1.2.1. 上下文</h3>
<p>数据报（分组）在不同的链路上以不同的链路协议传送，比方说：</p>
<ul>
<li>第一跳：以太网</li>
<li>中间链路：帧中继链路</li>
<li>最后一跳：802.11</li>
</ul>
<p><strong>不同的链路协议提供不同的服务。比如说：如果物理链路不太可靠，那么就需要在链路层提供可靠的服务，亡羊补牢。</strong></p>
<p>上面的不同链路的传输可以类比为（学生）从高校回家：</p>
<ul>
<li>首先，坐地铁到达机场</li>
<li>然后坐飞机到达福州</li>
<li>从福州机场坐出租回到家</li>
</ul>
<p>上面的例子中：</p>
<ul>
<li>数据报=学生</li>
<li>不同的交通段=不同的通信链路</li>
<li>交通模式=链路层协议</li>
<li>票务代理（如何买票）=路由算法</li>
</ul>
<h3 id="具体服务">1.2.2. 具体服务</h3>
<p>链路层提供的最重要的一个服务，任何链路层协议都提供的服务：<strong>成帧</strong>。</p>
<ul>
<li>将数据报封装在帧中，加上帧头、帧尾</li>
</ul>
<p>还有一个服务也是链路层协议所共有的服务：<strong>流量控制</strong>。如果AB双方，A在链路上发送的速度太快，B的网卡来不及接收数据，那么就会导致分组被丢弃。因此，需要通过流量控制来匹配双方的速度。</p>
<p>如果采用的是共享性介质（多点连接），那么还需要提供：<strong>链路接入和寻址</strong></p>
<ul>
<li>信道接入，获得信道访问权</li>
<li>此时，需要在帧头部使用<strong>MAC地址</strong>来表示源和目的（寻址）</li>
</ul>
<p>除了上述两个服务外，链路层还<strong>可能提供</strong>：<strong>可靠的数据传输</strong>，包括：</p>
<ol type="1">
<li>错误检测</li>
<li><strong>差错纠正</strong></li>
</ol>
<p>错误检测在TCP详细说过。接收方检测到错误会将分组丢弃，然后告知发送端让其重传。差错纠正，接收端检查到<strong>bit错误</strong>之后，可以通过其他没有错误的bit来纠正错误。</p>
<p><strong>这里存在一个问题：传输层已经提供了可靠传输了，为什么链路层也需要提供可靠服务呢？</strong></p>
<p>首先需要明确，链路层的可靠服务是可选的：</p>
<ul>
<li>如果物理链路比较可靠，那么链路层就不提供可靠服务</li>
<li>如果物理链路不可靠，那么链路就提供可靠服务</li>
</ul>
<p>如果链路层不提供可靠服务，我们设想这么一种情况，一个分组从西安到福州，假设路过了5个路由器到达对方主机</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608103758.png" /></p>
<p>如果分组在传输到第一个路由器的途中发生了一个bit的错误，由于路由器只有三层，所以路由器并不会检测到错误，那么这个错误的分组就会到达对方主机，然后到达传输层被TCP检测出错误，接收端丢弃该分组并通知发送方重发。</p>
<p>上述情况中，分组其实在第一个路由器就应该被丢弃然后告诉发送方重发，而不是传送到接收端才这么做。这就是链路层提供可靠服务的意义所在，在不可靠的链路上提供可靠的服务，使得错误早发现，早重传。如果链路十分可靠，那么链路层就没必要提供可靠服务了，因为出错的概率太小了，为了小概率事件使得每个分组都需要额外的时间来检测，不值当。</p>
<p>除了上面提到的服务，链路层还提供：<strong>全双工和半双工</strong></p>
<ul>
<li>半双工：链路层可以双向传输，但一次只能一个方向。如果我在接收，那么我就不能发送</li>
<li>全双工：链路层可以双向传输，并在两个方式能够同时进行。我可以接收的同时发送</li>
</ul>
<h3 id="适配器">1.2.3. 适配器</h3>
<p>链路层在每个主机、路由器、交换机的每个端口上实现。主要通过一个硬件设备 <strong>适配器(network interface card, NIC)</strong> 实现。NIC直接连接到主机的系统总线上。</p>
<blockquote>
<p>我们说的网卡就是NIC</p>
</blockquote>
<p>适配器通信过程如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608105028.png" /></p>
<p>发送方：</p>
<ul>
<li>将数据包封装成帧</li>
<li>加上差错控制便阿门，实现RDT和流量控制等功能</li>
</ul>
<p>接收方：</p>
<ul>
<li>检查有无差错，执行RDT和流量控制等功能</li>
<li>将帧解封装，取出数据报交给上层</li>
</ul>
<h1 id="差错检测和纠正">2. 差错检测和纠正</h1>
<p>在发送节点，为了保护比特免受差错，使用 <strong>差错检测和纠正比特(Error Detection and Correction)</strong> 来增强数据D。监测差错的3种常见的错误：</p>
<ol type="1">
<li>奇偶校验（用来描述差错检测和纠正背后隐含的基本思想）</li>
<li>检验和（多用于运输层）</li>
<li>循环冗余检测（多用于链路层）</li>
</ol>
<p>在[[第3章 传输层#3 1 UDP校验和 checksum]]中也说明了，差错检测不是100%可靠的，但是那样的错误比较少。<strong>更长的EDC字段可以得到更好的检测和纠正错误</strong></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608161058.png" /></p>
<blockquote>
<p>模2运算：加法不进位，减法不借位。其实就是按位异或。</p>
</blockquote>
<h2 id="奇偶校验">2.1. 奇偶校验</h2>
<h3 id="单bit奇偶校验">2.1.1. 单bit奇偶校验</h3>
<p>这种模式下，EDC字段只有1位。假设发送方需要发送的数据D：10101010，其中有4个1，</p>
<ul>
<li>奇校验：D和EDC中1的个数为奇数</li>
<li>偶校验：D和EDC中1的个数为偶数</li>
</ul>
<p>因此，如果采取奇校验，需要将EDC设置为1，最终发送的为：101010101；如果采取偶校验，需要将EDC设置为0，最终发送的为：101010100 。</p>
<p>假设采用的是偶校验，那么接收方收到的就是 101010100。然后检测一下1的个数是否为偶数即可。</p>
<p>这种方法只能够检测1bit的错误，准确来说应该是检测<strong>奇数bit的错误</strong>。可靠性不是很高，因此产生了2维的奇偶校验。</p>
<h3 id="维奇偶校验">2.1.2. 2维奇偶校验</h3>
<p>使用一个例子来说明原理：假设发送的D是 1010101011010111（共16位），将其分成i行i列，这里分为4行4列：</p>
<ol type="1">
<li>对每一行、每一列进行模2运算。每一行的结果写在j+1列的对应行，每一列的结果写在i+1行的对应列</li>
<li>如果采取偶校验，i+1行，j+1列和<span class="math inline">\(d_{i+1, j+1}\)</span> 中1的个数位偶数；奇校验则为奇数。（下面采取的是偶校验）</li>
<li>最后的EDC为 i+j+1 位（就是i+1行，j+1列和<span class="math inline">\(d_{i+1, j+1}\)</span> 的值按某种顺序）</li>
</ol>
<p><span class="math display">\[
\begin{array}{cccc|c}
1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\
0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ \hline
1 &amp; 0 &amp; 1 &amp; 0 &amp; 0
\end{array}
\]</span></p>
<p>这样子接收方接收分组之后，将D拿出来分成i行i列，然后对每一行、每一列进行模2运算，看一下结果是不是和EDC中一样。</p>
<p>该方法还有一个好处就是如果只是1bit出错，能够找出是哪个bit出错了。假设发送的数据D还是 1010101011010111，但是接收方得到的D是 1010111011010111，因此，接收方那边的结果为：</p>
<p><span class="math display">\[
\begin{array}{cccc|c}
1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\
0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ \hline
1 &amp; 1 &amp; 1 &amp; 0 &amp; 0
\end{array}
\]</span></p>
<p>可以看到第二行第二列的0变为了1，这就会导致第i+1行第二列、第二行第j+1列的数都发生变化，因此就能够找到出错的bit了（交叉的地方）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608164316.png" /></p>
<h2 id="校验和">2.2. 校验和</h2>
<p>校验和在传输层说UDP的时候提到了[[第3章 传输层#3 1 UDP校验和 checksum]]，这里不再多说。</p>
<p>只是想说明一点：校验和的方式可靠性不如CRC，因为EDC字段不算长（16bits），但因为这一班用于高层，也就是利用软件实现的，如果采用CRC，时间代价比较大。所以传输层采用校验和。</p>
<h2 id="循环冗余检测">2.3. 循环冗余检测</h2>
<h3 id="原理">2.3.1. 原理</h3>
<p>循环冗余检测 Cyclic Redundancy Check， CRC：</p>
<ul>
<li>强大的差错检测码</li>
<li>生成多项式G：双方协商的r+1位，<strong>首位必须为1</strong>(r+1位正好可以生成r位的R)
<ul>
<li>生成和检查所使用的位模式</li>
</ul></li>
<li>目标：选择r为的CRC附加为 R，使得
<ul>
<li>&lt;D,R&gt; 正好被G整除（模2）</li>
<li>接收方知道G，将 &lt;D,R&gt; 除以G，如果得到非0余数，检查出错误</li>
<li>能检出所有少于 r+1 位的错误</li>
</ul></li>
<li>CRC一般由硬件直接生成，因此计算速度很快</li>
</ul>
<blockquote>
<p>&lt;D,R&gt; 表示高位是D，低位是R</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608165611.png" /></p>
<p>求R的过程如下：</p>
<ol type="1">
<li><p>我们最终需要的是 &lt;D,R&gt; ，且能够被G整除，即 &lt;D,R&gt; = nG。</p></li>
<li><p>&lt;D,R&gt; 等价于 <span class="math inline">\(D \cdot 2^r \bigoplus R\)</span> ，因此 &lt;D,R&gt; = nG 等价于 <span class="math inline">\(D \cdot 2^r \bigoplus R = nG\)</span></p></li>
<li><p>两边同时异或R，得到 <span class="math inline">\(D \cdot 2^r = nG \bigoplus R\)</span></p></li>
<li><p>因为 nG 能被G整除，因此，两边同时除以G取余，右边得到的就是R。所以最后的公式为：（remainder表示取余）<span class="math display">\[R=remainder[\frac {D \cdot 2^r}G ]\]</span> 介绍一下模2除法：除了不借位之外，还有3个原则：</p></li>
<li><p>除数与被除数最高几位异或（除数首位为1），得到商 1</p></li>
<li><p>得到的余数去掉首位（最高位，此时首位必为0）。然后看余数的最高位，如果是1，则继续模2除，商1；如果此时的余数最高位为0，则商0，重复步骤2</p></li>
<li><p>直到余数位数小于除数位数时，运算结束</p></li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608172528.png" /></p>
<p>熟悉规则之后，可以直接把余数高位得到的0全部去掉，直到遇到第一个1。并且如果商为0不用写过程，直接把对应位后一位的数抄下去（对于被除数来说，下图中商为0的位为第5位，直接把第6位的数抄到余数的后面即可）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608172616.png" /></p>
<h3 id="例子">2.3.2. 例子</h3>
<p><strong>（发送方）</strong></p>
<p>假设需要发送的D为 101110，生成多项式G（r+1位）为 1001 （在数学上可以看成 <span class="math inline">\(G=1 \cdot x^3 + 0 \cdot x^2 + 0 \cdot x^1 + 1 \cdot x^0\)</span>），生成R的步骤如下：</p>
<ol type="1">
<li><p><span class="math inline">\(D \cdot 2^r = 101110 000\)</span></p></li>
<li><p>通过公式求R，计算过程见下图</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608171005.png" /></p></li>
</ol>
<p>因为生成多项式是4位，因此CRC是3位，所以要在最后面补上0。中间的减法是模2运算，不借位。</p>
<p>因此，发送方发送的&lt;D,R&gt; = 101110011。</p>
<p><strong>（接收方）</strong></p>
<p>将 10110011 与G进行模2除法，过程如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220608173344.png" /></p>
<p>余数为0表示没有检测到错误。</p>
<h3 id="性能分析">2.3.3. 性能分析</h3>
<ol type="1">
<li>能够检查出所有长度小于 r+1 位的错误</li>
<li>出现长度为 r+1 的错误，检查不出的概率为 <span class="math display">\[\frac 1{2^{r-1}}\]</span></li>
<li>出现长度大于 r+1 的错误，检查不出的概率为 <span class="math display">\[\frac 1{2^r}\]</span></li>
</ol>
<h1 id="多点访问协议">3. 多点访问协议</h1>
<p>上面说了，如果采用多点连接的方式，那么2个或多个站点同时发送就会产生：冲突(collision)</p>
<ul>
<li>冲突：多个节点在同一个时刻发送（或者发送时间相差比较短），则会收到2个或多个信号的叠加</li>
</ul>
<p>因此需要解决该问题，这就是多路访问协议（介质访问控制协议：Medium Access Control Protocol, MAC）</p>
<ul>
<li>采用分布式算法决定节点如何使用共享信道，即：决定节点什么时候发送</li>
<li>关于共享的信道，必须借助信道本身
<ul>
<li>传输控制信息以协调信道使用，没有带外信息用来发送控制信息</li>
<li>传输数据</li>
</ul></li>
</ul>
<p><strong>理想的</strong>MAC应该具有以下必要条件（假设共享信道为Rpbs）：</p>
<ol type="1">
<li>当一个节点发送数据时，以R速度发送</li>
<li>当M个节点发送时，（在一段时间内）每个节点可以获得 R/M 的平均速率（公平性）</li>
<li>应该是完全分布式的：
<ul>
<li>没有特殊的节点来协调发送（路由器和AP并不是协调发送的）</li>
<li>没有时钟和时隙的同步</li>
</ul></li>
<li>简单</li>
</ol>
<p>现在的MAC协议分为3大类：</p>
<ol type="1">
<li><strong>信道划分</strong>
<ul>
<li>把信道划分成小片</li>
<li>分配片给每个节点使用</li>
</ul></li>
<li><strong>随机访问</strong>
<ul>
<li>信道不划分，允许冲突</li>
<li>但是，冲突之后需要一定手段恢复</li>
</ul></li>
<li><strong>依次轮流</strong>（还可以细分为分布式和集中式）
<ul>
<li>节点一次轮流</li>
<li>有很多数据传输的节点可以获得较长的信道使用权</li>
</ul></li>
</ol>
<h2 id="信道划分">3.1. 信道划分</h2>
<p>有三种划分方式：</p>
<ol type="1">
<li>TDMA</li>
<li>FDMA</li>
<li>CDMA</li>
</ol>
<p>具体的原理在[[第1章 概论#6 1 1 电路交换中的多路复用]]中详细说过，这里就说一下不同方式的特点。</p>
<p>TDMA：</p>
<ul>
<li><p>轮流使用信道</p></li>
<li><p>每个站点使用每周期中的固定的时隙（时隙长度=帧传输时间）</p></li>
<li><p>如果站点没有帧传输，那么时隙就会被浪费。下图中2，5，6的时隙就被浪费了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609092740.png" /></p></li>
</ul>
<p>FDMA：</p>
<ul>
<li><p>信道的有效频率范围被分成一个个小的频段</p></li>
<li><p>每个站点被分配一个固定的频段</p></li>
<li><p>站点如果没有帧传输，那么频段浪费。下图中2，5，6的频段就被浪费了</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609092914.png" /></p></li>
</ul>
<p>CDMA：</p>
<ul>
<li>所有站点在整个频段上同时进行传输，采用编码原理加以区分</li>
<li>完全无冲突</li>
<li>信号线性叠加</li>
</ul>
<h2 id="随机访问">3.2. 随机访问</h2>
<p>随机访问协议有以下特点：</p>
<ul>
<li>当节点有帧要发送时，用信道的全部带宽发送；没有节点间的预先协调</li>
<li>两个或更多节点同时传输，会发生冲突</li>
<li><strong>随机访问协议需要规定</strong>：
<ul>
<li><strong>如何检测冲突</strong>？</li>
<li><strong>如何从冲突中恢复</strong>？</li>
</ul></li>
<li>随机MAC协议有：
<ol type="1">
<li>时隙ALOHA</li>
<li>ALOHA</li>
<li>CSMA，CSMA/CD，CSMA/CD</li>
</ol></li>
</ul>
<h3 id="时隙aloha">3.2.1. 时隙ALOHA</h3>
<blockquote>
<p>最简单的解决办法，从信道划分的方法上演变而来</p>
</blockquote>
<p>该协议：</p>
<ul>
<li>假定所有帧的长度相等</li>
<li>时间被划分成相等的时隙，每个时隙可以发送一个帧</li>
<li><strong>节点只在时隙开始时发送</strong></li>
<li>节点在时钟上同步</li>
<li>如果两个或多个节点在同一个时隙中传输，所有的节点都能检测到冲突</li>
</ul>
<p>在该协议下工作的节点：</p>
<ol type="1">
<li>当节点需要传输帧的时候，需要在下一个时隙的开始时刻发送</li>
<li>传输时没有检测到冲突，则帧发送成功。冲突发生只有一种情况，那就是在时隙的一开始就冲突，在时隙的过程中不会产生冲突。因此，一开始没有检测到冲突，那就是没有冲突</li>
<li>传输时如果有检测到冲突，失败。<strong>节点在随后的每一个时隙以概率p进行重传，直到帧成功</strong></li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609093754.png" /></p>
<p>（C：collision，E：empty，S：success）</p>
<ol type="1">
<li>第1个时隙：3个节点同时发送，发生冲突。在随后的时隙中以概率p重传</li>
<li>第2个时隙：1，2节点选择重传，3不重传，仍然冲突。</li>
<li>第3个时隙：1，3选择不重传，2重传成功</li>
<li>第4个时隙：1，3都选择不重传，没有冲突，但是时隙浪费</li>
<li>第5个时隙：1，3都选择重传，冲突</li>
<li>第6个时隙：1，3都选择不重传，没有冲突，但是时隙浪费</li>
<li>第7个时隙：3不重传，1重传成功</li>
<li>第8个时隙：3重传成功</li>
</ol>
<p>从面的例子中可以看出，时隙ALOHA的优点有：</p>
<ol type="1">
<li>节点可以用信道的全部带宽发送</li>
<li>高度分布：仅需要节点之间在时隙上的同步</li>
<li>简单</li>
</ol>
<p>但是缺点也很明显：</p>
<ol type="1">
<li>存在冲突 -&gt; 浪费时隙</li>
<li>即使不存在冲突也可能浪费时隙（时隙4，6）</li>
<li>需要时钟同步</li>
<li>节点检测到冲突的时间 &lt; 帧传输的时间。但是即使检测到冲突，还需要把帧传输完（吃苹果，第一口坏的，还要把它吃完！！！）</li>
</ol>
<p>接下来计算以下该方法的效率，也就是信道利用率。计算的是帧成功传输的时隙，冲突和空的时隙都属于浪费。</p>
<p>假设有N个节点，每个节点都有很多帧要发送，每个节点在每个时隙中的传输概率都是p，并且与重传的概率p一致。那么：</p>
<ul>
<li>一个节点成功传输的概率 = <span class="math inline">\(p(1-p)^{N-1}\)</span></li>
<li>任何一个节点成功传输的概率 = <span class="math inline">\(C_N^1 \cdot p(1-p)^{N-1}\)</span></li>
</ul>
<p>因此得到一个公式 <span class="math inline">\(f(p)=Np(1-p)^{N-1}\)</span> ，将其求导使 <span class="math inline">\(f&#39;(p)=0\)</span> ,当N趋于无穷时，求得 <span class="math inline">\(p=1/e=0.37\)</span>。故信道利用率为 37%</p>
<h3 id="aloha">3.2.2. ALOHA</h3>
<blockquote>
<p>时隙ALOHA的时隙容易浪费，最好的办法就是没有时隙，只要信道空闲，只要有数据就传输。但是ALOAH只做到了只要有数据就传输。</p>
</blockquote>
<ul>
<li>没有时隙的概念</li>
<li>简单，无需节点间在时间是同步（无需时隙同步）</li>
<li><strong>当有帧传输时，马上就传输</strong></li>
<li>上一点就会导致冲突的概率增加</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609094935.png" /></p>
<p>假设我们发送的帧为黄色的，那么可能与绿色的冲突，也可嫩关于紫色的冲突。这是时隙ALOHA中不会发生的情况。</p>
<p>ALOHA情况下，我们发送的区间内可能：上一个区间的发送还没结束，又有新的发送开始；而时隙ALOHA情况下，只有两个同时发送的情况（可以类比为上一个区间的发送没结束）。因此，ALOHA的冲突概率时时隙ALOHA的两倍。</p>
$$
<span class="math display">\[\begin{aligned}
P(指定节点成功) &amp; =P(节点传输) \cdot P(其他节点在[t_0-1,t_0]不传) \cdot p(其他节点在[t_0,t_0+1]不传) \\
&amp; = p \cdot (1-p)^{N-1} \cdot (1-p)^{N-1} \\
&amp; = \frac 1{2e} \\
&amp; = 17.5\% \qquad (N趋于无穷)

\end{aligned}\]</span>
<p>$$</p>
<h3 id="csma">3.2.3. CSMA</h3>
<p>CSMA: Carrier-sense multiple access 载波侦听多路访问。</p>
<p>在ALOHA的基础上，做到“只要空闲信道，那么有数据就发送”。ALOHA已经做到了后者，因此CSMA主要解决的就是前者，<strong>判断信道是否空闲</strong>。</p>
<p>CSMA，在传输之前先侦听信道：</p>
<ul>
<li>如果侦听到信道空闲，传送整个帧</li>
<li>如果侦听信道忙，推迟发送</li>
</ul>
<blockquote>
<p>侦听：帧在传输的时候会发送电磁波，监听电磁波即可</p>
</blockquote>
<p>但是这种方法不能保证冲突一定不发生，<strong>这是因为传播时延的存在</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609100507.png" /></p>
<p>见上图（从左到右依次为1，2，3，4主机）。</p>
<ol type="1">
<li>2号主机在t0时刻侦听信道空闲，所以发送数据（黄色）。</li>
<li>t1时刻，4号主机侦听信道，2号主机发送的电磁波还没到达4号主机（图中黑色虚线与黄色区域的交点就是2号主机电磁波到达的地方），所以4号主机侦听的结果是信道空闲，因此发送数据（红色）</li>
<li>在后面的某一时刻，红色和黄色交接，冲突发生，这时候2和4都不知道发生了冲突</li>
<li>过了一段时间后，4号主机和2号主机才先后知道冲突发生了（红色实现和红黄格子区域的交点）</li>
</ol>
<p>冲突发生后，整个冲突帧的传输时间都被浪费（红黄格子区域全部浪费）。为了减少这种情况发生的概率，就必须<strong>限制最大传播时延</strong>，因此LAN都会规定一个最远距离，即规定了LAN中最大的传播时延。</p>
<h3 id="csmacd">3.2.4. CSMA/CD</h3>
<blockquote>
<p>CSMA虽然一定程度上做到了“只要空闲信道，那么有数据就发送”，但是还是会发生冲突，冲突发生后如何恢复就是 CSMA/CD 的重点。</p>
</blockquote>
<p>CD：collision detection 冲突检测</p>
<p>CSMA/CD：</p>
<ul>
<li>在CSMA的基础之上</li>
<li>一边发送一边检测</li>
<li><strong>冲突发生时传输立即终止，减少对信道的浪费</strong></li>
<li><strong>二进制指数退避方法</strong></li>
<li>冲突检测技术通过检测信号强度（冲突会造成信号叠加，导致原本的信号和冲突时收到的信号不一致），在有线局域网中容易实现。有线的信号衰减小、噪声影响小，因此在不发生冲突的情况下信号基本一致</li>
</ul>
<p>以太网CSMA/CD算法：</p>
<ol type="1">
<li>适配器获取数据报，成帧</li>
<li>发送前：侦听信道CS
<ul>
<li>闲：开始发送帧</li>
<li>忙：等到空闲再发送</li>
</ul></li>
<li>发送过程中执行CD：
<ul>
<li>没有冲突：发送成功（也不一定[[#4 3 4 帧最小长度]]）</li>
<li>检测到冲突：立马放弃发送，之后尝试重发</li>
<li><strong>帧的最后一个bit发送之后，就不会再CD</strong></li>
</ul></li>
</ol>
<p>发送方检测到冲突之后，除了放弃之外，还需要发送一个Jam信号，所有听到冲突的适配器也是如此。因为有时候冲突信号持续比较短（两个相邻的节点同时发送产生冲突，此时冲突信号持续时间就比较短）<strong>Jam信号作用是强化冲突，让所有节点都知道发生了冲突</strong></p>
<p>适配器放弃之后，需要进入指数退避状态。即第k次失败之后，需要等到一段时间之后才可以再次回到步骤2。选择等待时间的算法称为二进制指数退避方法(exponential backoff)。</p>
<p><strong>二进制指数退避方法的目标：对负载进行自适应，在一个变化的碰撞窗口中随机选择时间点尝试重发。</strong></p>
<ul>
<li>高负载：碰撞窗口大，随机选择的时间一样的概率减少，再次冲突的可能性减少，但是等待时间增加</li>
<li>低负载：碰撞窗口小，随机选择的时间一样的概率比较大，再次冲突的可能性比较大（但是因为低负载，因此可能性也没多大），等待时间比较少</li>
</ul>
<p>第k此碰撞之后的碰撞窗口为：<span class="math inline">\([0,2^k-1]\)</span>：</p>
<ul>
<li>首次碰撞：k=1，窗口为 <span class="math inline">\(\{0,1\}\)</span></li>
<li>第2次碰撞：k=2，窗口大小为 <span class="math inline">\(\{0,1,2,3\}\)</span></li>
<li>第10次碰撞：k=10，窗口大小为 <span class="math inline">\(\{0,1,2,3,4,...,1022,1023\}\)</span></li>
</ul>
<p>CSMA/CD的效率：</p>
<ul>
<li><span class="math inline">\(T_{prop}\)</span> = LAN上2个节点的最大传播时延</li>
<li><span class="math inline">\(T_{trans}\)</span> = 传输最大帧的时间</li>
</ul>
<p><span class="math display">\[
efficiency = \frac 1{1+5\frac {T_{proc}}{T_{trans}}}
\]</span></p>
<p>当下面两个条件满足其一时，效率变成1：</p>
<ul>
<li>当 <span class="math inline">\(T_{prop}\)</span> 变成0，即两个节点无限接近，传播时延忽略不计。没有传输，哪里来的冲突</li>
<li>当 <span class="math inline">\(T_{trans}\)</span> 无限大时，即帧大小无限，虽然这是不太可能的。举个极端的例子，一个帧80T，那么接下来的一段时间其他节点等着吧，这段时间信道的利用率肯定是1，都用来传输这个巨无霸了</li>
</ul>
<p>比ALOHA更好的性能，而且简单、廉价、分布式。</p>
<h3 id="csmaca">3.2.5. CSMA/CA</h3>
<p>CA：collision avoidance 冲突避免。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609111610.png" /></p>
<p><strong>两个节点之间的通信，需要经过AP的转发。</strong></p>
<h4 id="无法使用cd">3.2.5.1. 无法使用CD</h4>
<p>首先解释一下为什么WLAN中无法使用CD，主要有两个原因：</p>
<p>第一个原因，发送天线和接收天线同时工作，因为信号衰减的原因，接收天线收到的信号（自己发送的和别人发送的）中，自己的发送信号强度远远大于别人发送的信号强度，即使冲突发生，冲突的信号也没有自己发送的信号强度大。因此检测不到。</p>
<p>第二个原因那就是在WLAN中，<strong>冲突是否发生和帧是否发送成功没有关系</strong>。</p>
<p>因为WLAN中会存在：隐藏终端</p>
<p><strong>隐藏终端的情况</strong>见下图：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609104035.png" /></p>
<p>A，C两个端互相收不到对方的信号（被物理隔绝），但是B（AP）能够收到A和C的信号。A发送帧给B的过程中，C检测信道发现信道空闲，因此也尝试发送帧给B。两个信号在B的周围发送了碰撞，但是碰撞信号也无法到达A和C，但是B知道。所以最后<strong>A和C没有检测到碰撞，但是帧的发送还是不成功</strong>。</p>
<p>其实采用CSMA/CA会导致：<strong>暴露终端的问题</strong>。即两个节点可以同时进行传输，但是因为检测到对方在发送而放弃自己的发送。虽然和不能使用CD没关系，但还是提一下。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609104734.png" /></p>
<p>红色：A的信号覆盖范围；绿色：B的信号覆盖范围；紫色：C的信号覆盖的范围；蓝色：D的信号覆盖的范围（A，C为两个AP或者接收方）</p>
<p>D发送帧给C，此时B可以检测到信号（快到大C的时候），假设这时候B向A发送帧，会产生冲突吗，并不会，因为B的信号到达C的时候衰减没了，因此B的信号能够成功到达A。但是这情况并不会发生，因为B检测到有信号的时候，就不会发送了。</p>
<h4 id="csmaca过程">3.2.5.2. CSMA/CA过程</h4>
<p>因为无法使用CD，所以只有在发送的时候小心一点，争取做到CA：</p>
<ul>
<li>一旦发送，就将帧全部发送，不CD</li>
<li>为了避免无CD带来的信道利用率低的问题看，发送前进行CA</li>
</ul>
<p><strong>（发送方）</strong></p>
<ol type="1">
<li>如果站点侦测到信道空闲持续DIFS的长度，则传输整个帧</li>
<li>如果侦测到信道忙，那么随机选择一个回退值（二进制指数退避方法），<strong>并在信道空闲时（每一个slot检测一次）递减该值</strong>，倒数到0时，发送整个帧。没有收到Ack的话（认为冲突发生），再次进行该步骤</li>
</ol>
<p><strong>（接收方）</strong></p>
<ol type="1">
<li>如果帧正确，则在SIFS之后发送Ack</li>
</ol>
<blockquote>
<p>CSMA/CD中就不需要Ack，因为没有检测到冲突就是发送成功。而CSMA/CA发送出去之后仍可能冲突，因此需要Ack来确保发送成功。</p>
</blockquote>
<p>这里面其实有一个问题，那就是都检测到信道空闲了为什么不发送，而是递减计数器，到0时才发送？</p>
<p>这是因为如果节点有N个，在某一时刻有1个节点在发送帧，其他N-1个节点检测到忙，等待一段时间，等到信道空闲了，N-1个节点都想着发送帧，所以没等到0就发送了，此时产生碰撞，之后的每一次都这样。又因为WLAN中一旦发送就发送完，所以冲突之后的代价比较大。</p>
<p>如果倒数到0才发送，因为退避窗口的存在，N个节点可能绝大部分选择的时间都不一样，小部分选择一样的，那么至少能保证选择不一样的时间的节点能把数据发送出去，而选择一样的再次退避。这样子碰撞的代价就小了。更好的情况就是所有节点的选择时间不一样，那么就能够使所有节点发送成功。</p>
<p>该方法其实不能完全避免冲突：</p>
<ol type="1">
<li>隐藏终端</li>
<li>选择的回退值一样</li>
</ol>
<p>这里的二进制指数退避方法与CSMA/CD不一样，这里的窗口大小为：<span class="math inline">\([0,2^{k+1}]\)</span></p>
<h4 id="rtscts机制">3.2.5.3. RTS/CTS机制</h4>
<p>RTS/CTS: Request To Send/Clear To Send</p>
<p>思想：允许发送方“预约”信道，而不是随机访问信道，避免长数据帧的冲突（可选的机制）</p>
<p>工作流程如下：</p>
<ol type="1">
<li>发送方首先使用CSMA向AP发送一个小的RTS分组
<ul>
<li>RTS可能会冲突，但是比较短，浪费信道比较小</li>
</ul></li>
<li>AP广播 CTS，告诉所有人“接下来的一段时间不要发送了，有人要重要的事情和我说”，CTS作为RTS的响应</li>
<li>CTS能够被所有节点听到：
<ul>
<li>发送方听到，发送数据</li>
<li>其他节点听到，抑制发送</li>
</ul></li>
</ol>
<blockquote>
<p>采用小的预约分组，可以<strong>完全避免</strong>数据帧的冲突</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609111505.png" /></p>
<h3 id="线缆接入网络">3.2.6. 线缆接入网络</h3>
<p>不是重点，稍微谈一点。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609113713.png" /></p>
<p>首先，将信道分为：上行信道和下行信道。上行信道还分成多个时隙，每几个时隙形成一个周期。在一个周期中，有的时隙是分配给用户使用的，有的时隙是需要预约的。</p>
<p>下行的情况下：</p>
<ul>
<li>只有一个CMTS(Cable Modem Termination System)发送数据，因此不需要竞争，也没有冲突。但是需要在发送的帧的头部打上标记（MAC地址），表明接收方是谁。</li>
<li>需要告诉各节点他们预约的时隙是否成功。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609114235.png" /></p>
<p>上行的情况：</p>
<ul>
<li>节点采用分配的时隙进行上行数据传输（分配）</li>
<li>在特殊的上行时隙中，各节点预约该时隙，各站点对该时隙的使用是随机访问的（竞争），如果发生碰撞，那么CMTS没有未它们发配该时隙，下个周期还能竞争。如果没有发生碰撞，那么CMTS会通过下行的MAP帧告诉各节点“某某时隙被xx预约了”，预约成功之后，对应的节点就能使用预约的节点进行数据传输。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609114710.png" /></p>
<h2 id="轮流taking-turnsmac协议">3.3. 轮流(Taking Turns)MAC协议</h2>
<p>信道划分协议：共享信道在高负载时效率高，在低负载时效率低。</p>
<p>随机访问协议：低负载时效率高，高负载时效率低（一直碰撞）</p>
<p>轮流协议：结合了2者的优点，增加了新的缺点。</p>
<h3 id="集中式-轮询">3.3.1. 集中式-轮询</h3>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609115034.png" /></p>
<p><strong>工作流程：主节点依次邀请从节点发送数据，没得到邀请就不能够发送</strong></p>
<p>缺点：</p>
<ul>
<li>轮询开销：轮询本身需要消耗信道资源</li>
<li>等待时间：每个节点需要等待主节点的邀请才能够传输，下次传输需要等到轮询一周后</li>
<li>单点故障：主节点失效，即使从节点正常，整个系统也无法工作</li>
</ul>
<h3 id="分布式-令牌传递">3.3.2. 分布式-令牌传递</h3>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609115317.png" /></p>
<p>特点：</p>
<ul>
<li>控制令牌循环从一个节点到下一个节点传递</li>
<li>令牌报文是一个特殊的帧（某个字段为1表示令牌，为0表示数据帧）</li>
</ul>
<p>工作流程：</p>
<ol type="1">
<li>令牌一直在线路上循环。</li>
<li>令牌到达左边的主机，左边主机没有数据要发送，那么就不用管令牌</li>
<li>令牌到达下边的主机，下边的主机有数据要发送，那么会将令牌接收，然后将字段改为0，最后把数据接到令牌的后面，发送出去</li>
<li>接收方将“令牌+数据”接收之后，将数据保存，然后在某个字段中做标记（表示收到），如果有多个接收方，每个接收方都这么做。最后“令牌+数据”又到达发送方，发送方将数据清楚，令牌字段设置为1，再次将令牌放出来（即使再有数据也无法发送了）</li>
</ol>
<blockquote>
<p>为什么接收方不把数据和令牌都接收，然后重新放出令牌？因为可能存在多个接收方，如果前面的接收了，后面的就收不到了。再者，接收方发出的令牌会打乱原来的顺序，失去公平性。最后，发送方就不知道接收方收到没有。</p>
</blockquote>
<p>缺点：</p>
<ul>
<li>令牌开销</li>
<li>延迟：只有抓住令牌才能发送数据</li>
<li>单点故障：
<ul>
<li>令牌如果丢了整个系统GG</li>
<li>重新生成令牌的机制比较复杂（谁生成？谁弄丢了谁生成。那么怎么知道谁弄丢的？）</li>
</ul></li>
</ul>
<p><strong>因此，即使轮流协议不论在低负载还是高负载都有比较好的效率，但是不可靠，并且比较复杂。</strong></p>
<h2 id="mac协议总结">3.4. MAC协议总结</h2>
<p>信道划分：按时间、频率、编码等</p>
<p>随机访问：</p>
<ul>
<li>ALOHA，时隙ALOHA，CSMA，CSMA/CD，CSMA/CA</li>
<li>载波侦听：有线介质比较简单，无线介质比较困难</li>
<li>CSMA/CD：802.3 Ethernet网络中使用</li>
<li>CSMA/CA：802.11 WLAN中使用</li>
</ul>
<p>依次轮流：</p>
<ul>
<li>集中：有一个中心节点轮询</li>
<li>分布：通过令牌控制</li>
</ul>
<h1 id="lans">4. LANs</h1>
<h2 id="mac地址">4.1. MAC地址</h2>
<p>之前介绍过IP地址：</p>
<ul>
<li>32bits</li>
<li>网络层使用的地址</li>
<li>前n-1跳：用于使分组到达目的IP子网（网络号起作用）</li>
<li>最后一跳：到达子网中的目标节点（主机号起作用）</li>
</ul>
<p>LAN（MAC/物理/以太网）地址：</p>
<ul>
<li>用于使帧从一个网卡传递到与其物理连接的另一个网卡（同一物理网络中）</li>
<li>48bits MAC地址写死在适配器的ROM中</li>
<li>理论上任何2个网卡的MAC地址都不相同</li>
</ul>
<p><strong>IP地址和MAC地址作用是不同的。</strong></p>
<ul>
<li>IP地址是<strong>分层的</strong>
<ul>
<li>一个子网所有站点网络号一致，路由聚集，减少路由表表项。</li>
<li>IP地址主要作用是让分组从一个子网穿越多个子网到达目的子网</li>
<li>希望网络层地址是可以被配置的。如果把IP也写死在网卡上是很麻烦的，比如美国生产的网卡IP地址应该写什么？假设写了某个网络的IP，结果这张网卡被中国买走了该怎么办？</li>
</ul></li>
<li>MAC地址是<strong>平面的</strong>
<ul>
<li>网卡在生产的时候不知道会被用于哪个网络，因此给网卡一个唯一的标识，用于区分一个子网内部不同的网卡即可</li>
<li>可以完成一个子网内部的节点到节点的数据交付</li>
</ul></li>
</ul>
<p>网络地址和MAC地址分离是有诸多好处的：</p>
<ol type="1">
<li>网卡坏了，IP地址不变，再买一个网卡就可以了，不需要任何其他配置</li>
<li>可以支持除了IP之外的其他网络层协议</li>
</ol>
<p>如果将网络地址和MAC地址捆绑，则会：</p>
<ol type="1">
<li>如果仅仅使用IP地址，不适用MAC地址，那么它仅支持IP</li>
<li>每次上电都要重新写入IP地址。网卡坏了IP地址也得跟着换（如果是一个服务器，那么需要修改许多的配置信息）</li>
</ol>
<p>因此，实际的网络采用的就是网络地址和MAC地址分离的办法。既然二者分离了，那么如何将网络地址（假如是IP地址）和MAC地址对上呢？</p>
<p>A知道B的IP，需要发送一个帧给B，但是不知道B的MAC地址就没法成帧（需要源MAC和目标MAC）。如果不写入目标MAC，直接使用IP地址发送出去，即使B收到了这个帧，链路层在检查目标MAC地址的时候发现地址不对，那它该收下这个帧还是丢弃呢？</p>
<p>还有一种情况，假设多个主机连在一个交换机（二层设备）上，A发给B的帧里面没有MAC地址，那么交换机需要怎么知道这个帧的目标是谁呢？交换机又不理解网络层的IP。</p>
<p>ARP协议的出现就是来解决IP地址和MAC地址的映射关系。</p>
<h2 id="address-resolution-protocolarp">4.2. Address Resolution Protocol(ARP)</h2>
<blockquote>
<p>需要注意，ARP工作在网络层</p>
</blockquote>
<blockquote>
<p>路由表上面除了IP地址，下一跳，代价等信息，也包括了下一跳对应的MAC地址。</p>
</blockquote>
<p>首先，LAN上的每个IP节点都有一个ARP表。ARP表包括同一个LAN内<strong>一些其他节点</strong>的IP/MAC地址映射关系，以及映射关系的TTL。 <code>&lt;IP address, MAC address, TTL&gt;</code></p>
<p>TTL时间指地址映射关系失效的时间，一般为20min。</p>
<p><strong>需要强调，ARP工作在同一个子网中</strong>。工作流程如下：</p>
<ul>
<li>A发送帧给B，只知道IP地址，不知道MAC地址，并且A的ARP表中也没有对应的映射关系</li>
<li>A首先<strong>广播</strong>包含B的IP地址的ARP查询包
<ul>
<li>查询包中，目标MAC地址设置为：<code>FF-FF-FF-FF-FF-FF</code>，源MAC地址是A的MAC地址</li>
<li>子网中的所有节点都会收到这个查询包</li>
</ul></li>
<li>B接收到这个查询包，对比自己的IP地址和包中的IP地址，发现匹配。将会发送一个帧给A，告诉A自己的MAC地址。该帧中的目标MAC地址是A的MAC地址</li>
<li>A收到B发的帧，将MAC地址填入要发送的帧中，然后发送。除此之外，还会将B的IP和MAC地址映射关系写入自己的ARP表</li>
</ul>
<p>ARP是即插即用的，节点自己创建ARP表项，无需网络管理员的干预。</p>
<p>下面的例子简单的说明了不同子网的两个主机的通信过程，以及ARP在其中的作用。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609144521.png" /></p>
<p>A要发送分组给B，A知道B的IP地址，不知道B的MAC地址。步骤如下：</p>
<ol type="1">
<li><p>A利用ARP查询R的左边网卡的IP（网关，A肯定知道）对应的MAC地址，然后将源IP、目标IP写入IP数据报，将数据报交给链路层。链路层将源MAC和目标MAC和数据报写入帧中，并将帧发送给R；</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609145733.png" /></p></li>
<li><p>R收到之后，首先比对目标MAC地址和自己是否一致，成功配对之后将数据报取出来交给上层。上层查看目标IP并对比路由表，发现是右边网卡所在的子网，因此，向右边的子网发送ARP查询，得到B的MAC地址。将IP数据报，B的MAC地址递交给链路层，链路层将R的右边网卡的MAC地址、B的MAC地址和IP数据包封装成一个新的帧，然后发送给B</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609145748.png" /></p></li>
<li><p>B收到之后，首先比较MAC地址，匹配之后将IP数据报取出，转交给网络层，网络层匹配目标IP地址，匹配成功之后，该分组就成功到达目标主机。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609145842.png" /></p></li>
</ol>
<p>下面是ARP工作的一个动图：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/traditional-arp-process.gif" /></p>
<h2 id="ethernet以太网">4.3. Ethernet(以太网)</h2>
<h3 id="物理拓扑">4.3.1. 物理拓扑</h3>
<p>Ethernet的物理拓扑大致分为两种类型：</p>
<ol type="1">
<li>总线型</li>
<li>星型
<ul>
<li>hub</li>
<li>switch</li>
</ul></li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609152719.png" /></p>
<h4 id="总线">4.3.1.1. 总线</h4>
<p>介绍一下那个图中的结构，这是早期的Ethernet的拓扑</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609153241.png" /></p>
<p>每台主机可以通过网卡，然后利用某个装置刺入到同轴电缆轴，然后向同轴电缆发送信号，信号顺着同轴电缆向两边移动，遇到信号吸收装置则会把信号吸收（保证信号不反弹回去）</p>
<p>这种结构就是最早期的以太网拓扑——<strong>总线型</strong>。这种拓扑方式有一个致命的问题，那就是电缆暴露在外面，很容易被老鼠咬断，或者被其他东西磨损，使得同轴电缆的某个地方出现了截面，截面反弹信号，使得发送节点误认为是冲突（发送的信号通过截面又反射回发送节点）。并且同轴电缆一个地方损坏会导致整个网络不可用。</p>
<h4 id="集线器">4.3.1.2. 集线器</h4>
<p>因此，出现了<strong>集线器(hub)</strong>。利用集线器之后的物理拓扑为<strong>星型</strong>。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609154223.png" /></p>
<p><strong>这个集线器的作用和总线的作用一致，可以认为这些端口后面连着一根总线</strong>。如果某台主机要向其他主机发送信号，首先到达集线器，然后集线器向所有端口发送该信号。因此和总线型一样，一台主机发送信号，那么其他主机都不能够发送信号，这说明一个集线器上的所有主机属于同一个<strong>碰撞域</strong>。</p>
<blockquote>
<p>判断两台主机是否属于同一碰撞域：这两台主机是否可以同时发送信号。</p>
</blockquote>
<p>集线器解决了：</p>
<ol type="1">
<li>总线不容易磨损</li>
<li>线路坏了，那么对应的主机不能发送信号，不影响其他主机的发送。（如果集线器坏了那就整个网络GG）</li>
</ol>
<p><strong>hub本质上是物理层的中继器</strong>：</p>
<ul>
<li>从一个端口收，转发到所有其他端口</li>
<li>速率一致</li>
<li>没有帧缓存</li>
<li>在hub上没有CSMA/CD机制，由NIC检测冲突</li>
<li>提供网络管理功能（看谁不爽拔谁电线）</li>
</ul>
<p>集线器可以级联：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609182344.png" /></p>
<h4 id="交换机">4.3.1.3. 交换机</h4>
<p>集线器和总线都存在一个问题，那就是所有的主机都在一个碰撞域内。因此出现了交换机。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609154817.png" /></p>
<p>交换机的拓扑和hub的拓扑一模一样，两者的区别在于交换机的每个端口使用独立的以太网协议。简单来说每个端口都是单独的碰撞域。举个例子，最左边的发送信号给右边的主机，先将信号发送给switch，然后swtich会选择最后一个端口转发信号。此时的信号不会被广播！</p>
<p>此时可以多个主机一起发送信号：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609155144.png" /></p>
<p><strong>只有一种情况下不能够同时发送，那就是接收方是同一个主机的情况下无法同时发送</strong>。</p>
<p>交换机的出现：</p>
<ol type="1">
<li>使得每个端口都是一个单独的碰撞域</li>
<li>解决了CSMA/CD在高负载时的效率低下的问题</li>
</ol>
<p>交换机也可以级联：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609182429.png" /></p>
<p>这里会比较详细的介绍一下交换机的工作原理。</p>
<ul>
<li>交换机的任务：接收 <strong>入链路</strong> 的帧，并将这些帧转发到出链路。因为这些帧到达交换机的速度不一致，并且有可能超过接口的（接收）速率，因此，<strong>交换机的接口设有缓存</strong>。</li>
<li>交换机一般是没有MAC地址的，至少在基本功能的实现上不需要用到MAC地址。但是实际上为了方便管理，交换机会有一个MAC地址，这跟它主要功能的实现没有关系。</li>
</ul>
<h5 id="交换机的转发和过滤">4.3.1.3.1. 交换机的转发和过滤</h5>
<p>交换机具有两个功能：</p>
<ol type="1">
<li><strong>过滤</strong>：决定一个帧是否需要转发到某个接口，还是应该将其丢弃</li>
<li><strong>转发</strong>：决定一个帧应该从哪一个端口发送出去</li>
</ol>
<p>为了实现上述的两个功能，交换机需要知道每个端口上连接的主机的MAC地址。所以每个交换机都会维护一个<strong>交换机表</strong>，交换机表有三个表项：</p>
<ol type="1">
<li>MAC地址</li>
<li>通向该MAC地址的交换机接口</li>
<li>表项加入到表中的时间</li>
</ol>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>接口</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64-EF-E7-11-43-A9</td>
<td>1</td>
<td>9:32</td>
</tr>
<tr class="even">
<td>23-AE-EF-FD-12-9F</td>
<td>3</td>
<td>9:40</td>
</tr>
<tr class="odd">
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>为了理解交换机转发和过滤的工作过程，假定目的地址为R的帧到达交换机的接口x，交换机将R与交换机表的地址做对比，会有以下三种情况：</p>
<ol type="1">
<li>R在表中，并且对应表项的接口为y，那么交换机将该帧从y接口转发</li>
<li>R在表中，并且对应表项的接口为x，那么交换机将该帧丢弃</li>
<li>R不在表中，交换机向所有接口（除了x）广播该帧（泛洪）</li>
</ol>
<h5 id="交换机的自学习">4.3.1.3.2. 交换机的自学习</h5>
<p>交换机刚刚开始的时候交换机表是空的，那么该如何在表中填入表项呢？举个例子，上面的交换机表中，刚开始的时候为空：</p>
<ol type="1">
<li>该交换机从接口1<strong>收到</strong>一个帧，这个帧的源MAC地址为：64-EF-E7-11-43-A9，然后将其写入表项，得到：</li>
</ol>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>接口</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64-EF-E7-11-43-A9</td>
<td>1</td>
<td>9:32</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>在9:40从接口3收到一个帧，这个帧的源MAC地址为：23-AE-EF-FD-12-9F，将其写入表中：</li>
</ol>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>接口</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64-EF-E7-11-43-A9</td>
<td>1</td>
<td>9:32</td>
</tr>
<tr class="even">
<td>23-AE-EF-FD-12-9F</td>
<td>3</td>
<td>9:40</td>
</tr>
</tbody>
</table>
<p>这就是交换机的自学习过程。因此，交换机是即插即用设备(plug-and-play device)，不需要网络管理员的干预。</p>
<p>如果交换机级联的情况下，该如何自学习呢？</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609182429.png" /></p>
<p>假设一次交互，A发送到G，G回一个响应。刚开始的时候交换机的表都为空。所有交换机的接口都是从左到右依次递增，最左边为1，上面的接口为4。</p>
<ol type="1">
<li>A发送一个帧给S1，其中目标地址为MACB</li>
<li>S1收到之后，因为交换机表中没有对应表项，故先将该信息写入交换机表，然后向其他接口泛洪</li>
</ol>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>接口</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MACA</td>
<td>1</td>
<td>00:00</td>
</tr>
</tbody>
</table>
<ol start="3" type="1">
<li>S4收到之后，因为交换机表中没有对应表项，故先将该信息写入交换机表，然后向其他接口泛洪</li>
</ol>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>接口</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MACA</td>
<td>1</td>
<td>00:00</td>
</tr>
</tbody>
</table>
<ol start="4" type="1">
<li>S3收到之后，因为交换机表中没有对应表项，故先将该信息写入交换机表，然后向其他接口泛洪。交换机表相同</li>
</ol>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>接口</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MACA</td>
<td>4</td>
<td>00:00</td>
</tr>
</tbody>
</table>
<ol start="5" type="1">
<li>G收到该帧，验证之后回复一个响应</li>
<li>S3收到响应帧之后，因为交换机表中没有对应表项，故先将该信息写入交换机表，然后向其他接口泛洪</li>
</ol>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>接口</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MACA</td>
<td>4</td>
<td>00:00</td>
</tr>
<tr class="even">
<td>MACG</td>
<td>1</td>
<td>00：01</td>
</tr>
</tbody>
</table>
<ol start="7" type="1">
<li>S4收到之后，因为交换机表中没有对应表项，故先将该信息写入交换机表，然后向其他接口泛洪</li>
</ol>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>接口</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MACA</td>
<td>1</td>
<td>00:00</td>
</tr>
<tr class="even">
<td>MACG</td>
<td>3</td>
<td>00:01</td>
</tr>
</tbody>
</table>
<ol start="8" type="1">
<li>S1收到之后，因为交换机表中没有对应表项，故先将该信息写入交换机表，然后向其他接口泛洪</li>
</ol>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>接口</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MACA</td>
<td>1</td>
<td>00:00</td>
</tr>
<tr class="even">
<td>MACG</td>
<td>4</td>
<td>00:01</td>
</tr>
</tbody>
</table>
<ol start="9" type="1">
<li>A收到来自G的响应帧，进行验证，验证通过，流程结束。</li>
</ol>
<h5 id="交换机的性质">4.3.1.3.3. 交换机的性质</h5>
<p>交换机有以下3个性质：</p>
<ol type="1">
<li><strong>消除碰撞</strong>：使用交换机不会产生碰撞。交换机会缓存帧，并且绝不会在网段上同时传输多于一个的帧。因此，即使接收方是同一个，因为缓存的存在，交换机也会依次发送帧，不会造成冲突。就像路由器一样，交换机的最大聚合带宽是该交换机所有接口速率之和。
<ul>
<li>没有碰撞就意味着CSMA/CD在发送前不需要侦听信道是否空闲，交换机能够帮忙解决。没有碰撞就意味着CSMA/CD在高负载的情况下效率也很高（原来在高负载的情况下效率低就是因为碰撞多）</li>
<li>这个原因也是为什么以太网的占有率高的原因。CSMA/CD + 交换机使以太网能够在任何负载的情况下保持高效率。</li>
</ul></li>
<li><strong>异质的链路</strong>：交换机将链路彼此隔离，因此局域网种的不同链路能够以不同的速率运行并且能够在不同的媒体上运行。</li>
<li><strong>管理</strong>：如果某个NIC出现问题，不停的发送帧，交换机能够检测到该问题，并且自动切断异常适配器。交换机还能统计带宽的使用情况和流量类型，并让这些信息为网络管理员使用。</li>
</ol>
<p>交换机、路由器、集线器比较：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>集线器</th>
<th>交换机</th>
<th>路由器</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>流量隔离</td>
<td>无</td>
<td>有</td>
<td>有</td>
</tr>
<tr class="even">
<td>即插即用</td>
<td>有</td>
<td>有</td>
<td>无</td>
</tr>
<tr class="odd">
<td>优化路由</td>
<td>无</td>
<td>无</td>
<td>有</td>
</tr>
</tbody>
</table>
<p>交换机和路由器有一个最大的区别：</p>
<ul>
<li>因为网络太多，因此网络与网络的拓扑很容易变成环，但是路由器不怕，路由算法能够避免环路</li>
<li>交换机表不行，交换机如果多次级联形成环路（A的一个接口接B，B的里一个接口接C，C的一个接口接A的另一个接口），形成环路之后在进行泛洪时就会产生<strong>广播风暴（帧一直在环路中转发，并且会越来越多）</strong>。为了解决该问题，交换机会执行生成树算法，让部分端口处于转发状态，部分端口处于阻塞状态，使其在任何一刻都没有环。</li>
</ul>
<p>一个机构网络例子：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609185936.png" /></p>
<h3 id="ethernet帧结构和服务">4.3.2. Ethernet帧结构和服务</h3>
<p>以太网帧结构如下图：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609180242.png" /></p>
<p>发送方NIC在以太网帧种封装IP数据报，或其他网络层协议的数据单元。</p>
<ul>
<li>前导码：7B的 10101010 加上 1B的 10101011。用来同步发送方和接收方的时钟速率
<ul>
<li>使得接收方将自己的时钟调到发送方的时钟</li>
<li>从而可以按照发送端的时钟来接收所发送的帧</li>
</ul></li>
<li>源/目标地址：6字节的MAC地址
<ul>
<li>目标地址为本节点MAC地址或者为广播地址的时候，节点才会接收该帧，否则就丢弃</li>
</ul></li>
<li>类型：指出网络层使用的协议（一般为IP，也有可能为Novell IPX和AppleTalk）</li>
<li>CRC：在接收方校验。之所以放在后面是因为当前面的所有内容都发送完毕之后，硬件就会自动计算出CRC，然后将其发出去。</li>
</ul>
<p><strong>Ethernet提供的是无连接、不可靠的服务。</strong></p>
<ul>
<li>无连接：帧传输前，发送方和接收方不需要握手</li>
<li>不可靠：接收方NIC不发送Ack或者NAK
<ul>
<li>递交给网络层的数据报流可能有缺失</li>
<li>可靠的服务交给上层协议</li>
</ul></li>
<li>以太网的MAC协议：<strong>采用二进制退避的CSMA/CD</strong> （上一节谈过[[#3 2 4 CSMA CD]]）</li>
</ul>
<h3 id="ethernet标准链路和物理层">4.3.3. Ethernet标准：链路和物理层</h3>
<p>（物理层的内容）</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609181019.png" /></p>
<ul>
<li>copper physical layer：同轴电缆</li>
<li>fiber physical layer：光纤</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609181236.png" /></p>
<h4 id="manchester编码">4.3.3.1. Manchester编码</h4>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609181518.png" /></p>
<ul>
<li>每一个bit的中间有一个信号跳变</li>
<li>允许在接收方和发送方节点之间进行时钟同步</li>
<li>10Mbps的数据，需要使用20M带宽，效率为50%</li>
</ul>
<p>信号的跳变有两个作用：</p>
<ol type="1">
<li>让接收方能够同步时钟</li>
<li>区分0和1。0是向上跳变，1是向下跳变</li>
</ol>
<p>这样子还有一个小问题，那就是如果信号都是0或者都是1，那么就无法同步时钟。因此，利用5b代替4b的数据</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609181850.png" /></p>
<p>要发送左边的4b，就使用右边的5b代替。5bit有32种组合，从其中选择16种“凹凸有致”的信号作为4b的代替。</p>
<h4 id="千兆以太网">4.3.3.2. 千兆以太网</h4>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609182106.png" /></p>
<h3 id="帧最小长度">4.3.4. 帧最小长度</h3>
<p>首先，需要明确什么算是发送成功：</p>
<ol type="1">
<li>帧中的最后一个bit从发送方发出</li>
<li>整个帧被接收方接收</li>
</ol>
<p>答案其实是2。</p>
<blockquote>
<p>下面出现的t其实都是 <span class="math inline">\(\tau\)</span></p>
</blockquote>
<p>早期的Ethernet有一个最长距离：2500m，沿着最长距离从一端A到另一端B的时间称为 t。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609213139.png" /></p>
<p>A在0时刻开始发送帧，在t-时刻，B检测信道，发现信道是空闲的，因此开始传送帧。t-和t之间的某一个时刻，发生了碰撞。这个碰撞的信号大概又经过了t时刻回到A（蓝色虚线），碰撞信号在t时刻到达B（绿色虚线）。如果t-无限接近于t，那么碰撞时间也会无限接近于t，那么A收到碰撞信号就会无限接近于2t。</p>
<p>因此，A发送帧，如果发生冲突，一定会在2t时间内收到冲突信号。换言之，如果发送帧的第一个bit开始计时的2t时间内如果没收到冲突信号，那么就不可能产生冲突了2t时刻，最远的节点都收到A的信号了，所以所有的节点肯定收到了，因此2t时刻之后不可能产生冲突。</p>
<p>但是，如果A发送的帧非常的小，假设只有1bit，那么0时刻A就发送完了，并且A根本不会感觉到冲突。但是这个帧真的能够成功被对方接收吗？不一定，可能发生上图中一样的状况。因此，<strong>不冲突不代表发送成功</strong>。</p>
<p>那么需要怎么做到 “不冲突代表成功” 呢？答案其实很简单，<strong>只要在2t之内，A没有把帧全部发送完即可</strong>，这样一来，在2t之内A会一直执行CD，如果有冲突就能够发现，如果2t之内没冲突，那么就说明不会再产生冲突了。因此，帧的最小长度应该为 <span class="math inline">\(2\tau \cdot R\)</span> ，其中R为链路的带宽。</p>
<p>对于最大长度为2500米的10Mbps网络和四个中继器（来自802.3规范），在最坏的情况下，<strong>往返时间2t</strong>（包括通过四个中继器的传播时间）被确定为接近51.2us。</p>
<p><span class="math display">\[
\begin{aligned}
2\tau \cdot R &amp; = 51.2us \cdot 10Mb/s \\
&amp; = 51.2 \times 10^{-6}s \cdot 10 \times 10^{6} \\
&amp; = 512b \\
&amp; = 64B
\end{aligned}
\]</span></p>
<p>因此，以太网中，帧的最小长度为64字节。如果发送的数据部分加上头部（不包括填充字段）没有到达这个长度，头部中的填充字段会将长度补足。</p>
<h1 id="a-day-in-the-life-of-web-request">5. a day in the life of web request</h1>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609220335.png" /></p>
<p>假设校园中的一台主机需要访问<code>www.google.com</code>。简单分析全过程（以太网）</p>
<p>（下面的图中在封装和解封装的时候是有箭头指示的）</p>
<h2 id="dhcp">5.1. DHCP</h2>
<ol type="1">
<li>客户端发送DHCP请求，该请求封装在UDP中，然后封装到IP数据报中，最后封装到帧</li>
<li>帧到达交换机，并在LAN中被广播（目标MAC地址为 FF-FF-FF-FF-FF-FF），被运行中的DHCP服务接收</li>
<li>DHCP服务器将帧解封装，得到HDCP请求，然后生成 DHCP Ack。通过UDP，IP，以太网层层封装通过交换机（此时交换表中已经有了对应表项）转发到客户端。DHCP ACK中包含以下信息：
<ul>
<li>分配给客户的IP</li>
<li>第一跳路由器的IP（网关）</li>
<li>本地DNS服务器IP</li>
<li>子网掩码（由第一跳路由器的IP可以知道子网掩码）</li>
</ul></li>
<li>客户端解封装，得到IP，终于可以上网了。</li>
</ol>
<p>请求：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609221819.png" /></p>
<p>响应：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609221831.png" /></p>
<h2 id="arp">5.2. ARP</h2>
<p>客户端需要将分组发送到google服务器，首先需要将分组发送给网关路由器。通过DHCP我们知道了网关路由器的IP地址，因此，需要通过ARP获得网关路由器的MAC地址。</p>
<ol type="1">
<li>客户端广播ARP请求帧（UDP -&gt; IP -&gt; 以太网）</li>
<li>网关路由器接收到帧之后进行解封装（以太网 -&gt; IP），确定IP地址为自己之后，发送一个帧给客户端，帧中包含了路由器的MAC地址</li>
<li>客户端得到网关路由器的IP地址</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609221900.png" /></p>
<h2 id="dns">5.3. DNS</h2>
<p>源IP、源MAC、源port（HTTP默认80）、目标IP、目标MAC中已经知道前三个，接下来还需要知道目标IP地址就可以发送了（目标MAC地址不是现在操心的）</p>
<ol type="1">
<li>将包含DNS查询的分组通过LAN交换机转发，到达网关路由器。</li>
<li>分组通过路由到达comcast network，最终到达DNS服务器，被DNS服务器解封装，然后根据域名将对应的IP写入响应帧中回复给客户端。</li>
</ol>
<p>其中，DNS查询是由本地DNS服务器进行的，查询的过程也省略了。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609222338.png" /></p>
<h2 id="httptcp">5.4. HTTP+TCP</h2>
<p>现在已经知道了源IP、源MAC、源port（HTTP默认80）、目标IP。现在需要建立起TCP连接</p>
<ol type="1">
<li>客户端打开web服务器的TCP socket</li>
<li>TCP SYN 域间路由到web服务器</li>
<li>web服务器用 TCP SYNACK应答</li>
<li>客户端回复ACK给web服务器</li>
<li>TCP连接建立成功！</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609223011.png" /></p>
<p>最后，就是发送HTTP请求通过TCP socket -&gt; TCP -&gt; IP -&gt; 以太网 封装成帧，然后通过交换机到达网关路由器，通过网关路由器路由到web服务器所在子网。通过ARP知道web服务器的MAC，写入帧中最后将帧发送到web服务器。</p>
<p>web服务器收到请求后回复一个响应帧，同样的路由到达网关路由器，然后网关路由器也通过ARP获得客户端的MAC地址，最终将响应帧交给客户端。</p>
<p>客户端一层一层解封装，将最终数据交给浏览器进程，浏览器显示出google的网页内容。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220609223048.png" /></p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">1.1. 节点的连接方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.</span> <span class="toc-text">1.2. 链路层服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1. 上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2. 具体服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2.3. 适配器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B%E5%92%8C%E7%BA%A0%E6%AD%A3"><span class="toc-number">2.</span> <span class="toc-text">2. 差错检测和纠正</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. 奇偶校验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95bit%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1. 单bit奇偶校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2. 2维奇偶校验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. 校验和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E6%B5%8B"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. 循环冗余检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1. 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2. 例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3. 性能分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%82%B9%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.</span> <span class="toc-text">3. 多点访问协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E9%81%93%E5%88%92%E5%88%86"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. 信道划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. 随机访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%9A%99aloha"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1. 时隙ALOHA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aloha"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2. ALOHA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#csma"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3. CSMA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#csmacd"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4. CSMA&#x2F;CD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#csmaca"><span class="toc-number">3.2.5.</span> <span class="toc-text">3.2.5. CSMA&#x2F;CA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8cd"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">3.2.5.1. 无法使用CD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#csmaca%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.5.2.</span> <span class="toc-text">3.2.5.2. CSMA&#x2F;CA过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rtscts%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.5.3.</span> <span class="toc-text">3.2.5.3. RTS&#x2F;CTS机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%BC%86%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%9C"><span class="toc-number">3.2.6.</span> <span class="toc-text">3.2.6. 线缆接入网络</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AE%E6%B5%81taking-turnsmac%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. 轮流(Taking Turns)MAC协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E4%B8%AD%E5%BC%8F-%E8%BD%AE%E8%AF%A2"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1. 集中式-轮询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BB%A4%E7%89%8C%E4%BC%A0%E9%80%92"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2. 分布式-令牌传递</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mac%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93"><span class="toc-number">3.4.</span> <span class="toc-text">3.4. MAC协议总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lans"><span class="toc-number">4.</span> <span class="toc-text">4. LANs</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mac%E5%9C%B0%E5%9D%80"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. MAC地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#address-resolution-protocolarp"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. Address Resolution Protocol(ARP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ethernet%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. Ethernet(以太网)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E6%8B%93%E6%89%91"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1. 物理拓扑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">4.3.1.1. 总线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BA%BF%E5%99%A8"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">4.3.1.2. 集线器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">4.3.1.3. 交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E8%BD%AC%E5%8F%91%E5%92%8C%E8%BF%87%E6%BB%A4"><span class="toc-number">4.3.1.3.1.</span> <span class="toc-text">4.3.1.3.1. 交换机的转发和过滤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E8%87%AA%E5%AD%A6%E4%B9%A0"><span class="toc-number">4.3.1.3.2.</span> <span class="toc-text">4.3.1.3.2. 交换机的自学习</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">4.3.1.3.3.</span> <span class="toc-text">4.3.1.3.3. 交换机的性质</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ethernet%E5%B8%A7%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2. Ethernet帧结构和服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ethernet%E6%A0%87%E5%87%86%E9%93%BE%E8%B7%AF%E5%92%8C%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-number">4.3.3.</span> <span class="toc-text">4.3.3. Ethernet标准：链路和物理层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#manchester%E7%BC%96%E7%A0%81"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">4.3.3.1. Manchester编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%83%E5%85%86%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">4.3.3.2. 千兆以太网</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A7%E6%9C%80%E5%B0%8F%E9%95%BF%E5%BA%A6"><span class="toc-number">4.3.4.</span> <span class="toc-text">4.3.4. 帧最小长度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#a-day-in-the-life-of-web-request"><span class="toc-number">5.</span> <span class="toc-text">5. a day in the life of web request</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dhcp"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. DHCP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arp"><span class="toc-number">5.2.</span> <span class="toc-text">5.2. ARP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dns"><span class="toc-number">5.3.</span> <span class="toc-text">5.3. DNS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#httptcp"><span class="toc-number">5.4.</span> <span class="toc-text">5.4. HTTP+TCP</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hdfzzf.github.io/2022/06/09/%E7%AC%AC%206%20%E7%AB%A0%20%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hdfzzf.github.io/2022/06/09/%E7%AC%AC%206%20%E7%AB%A0%20%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/&text=第 6 章 链路层和局域网"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hdfzzf.github.io/2022/06/09/%E7%AC%AC%206%20%E7%AB%A0%20%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/&title=第 6 章 链路层和局域网"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hdfzzf.github.io/2022/06/09/%E7%AC%AC%206%20%E7%AB%A0%20%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/&is_video=false&description=第 6 章 链路层和局域网"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=第 6 章 链路层和局域网&body=Check out this article: https://hdfzzf.github.io/2022/06/09/%E7%AC%AC%206%20%E7%AB%A0%20%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hdfzzf.github.io/2022/06/09/%E7%AC%AC%206%20%E7%AB%A0%20%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/&title=第 6 章 链路层和局域网"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hdfzzf.github.io/2022/06/09/%E7%AC%AC%206%20%E7%AB%A0%20%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/&title=第 6 章 链路层和局域网"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hdfzzf.github.io/2022/06/09/%E7%AC%AC%206%20%E7%AB%A0%20%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/&title=第 6 章 链路层和局域网"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hdfzzf.github.io/2022/06/09/%E7%AC%AC%206%20%E7%AB%A0%20%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/&title=第 6 章 链路层和局域网"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hdfzzf.github.io/2022/06/09/%E7%AC%AC%206%20%E7%AB%A0%20%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/&name=第 6 章 链路层和局域网&description=&lt;p&gt;这章就是整个计算机网络 top to down 的最后一章了，当然还有许多内容，只不过最核心的都在这6章。&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hdfzzf.github.io/2022/06/09/%E7%AC%AC%206%20%E7%AB%A0%20%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/&t=第 6 章 链路层和局域网"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2022
    hdfzzf
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/tags/">标签</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'cactus-1';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
