<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="个人的知识笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="第 4 章 网络层：数据平面">
<meta property="og:url" content="https://hdfzzf.github.io/2022/06/05/%E7%AC%AC%204%20%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/index.html">
<meta property="og:site_name" content="HDFZZF&#39;s BLOG">
<meta property="og:description" content="个人的知识笔记。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-04T16:00:00.000Z">
<meta property="article:modified_time" content="2022-06-24T00:19:16.149Z">
<meta property="article:author" content="hdfzzf">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="计算网络教程 自顶向下方法">
<meta property="article:tag" content="B站中科大计网">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/LOGO.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>第 4 章 网络层：数据平面</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 6.0.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="القائمة"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="القائمة"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="الأعلى" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/tags/">标签</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2022/06/06/%E7%AC%AC%205%20%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2022/06/04/%E7%AC%AC%203%20%E7%AB%A0%20%E4%BC%A0%E8%BE%93%E5%B1%82/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
    </span>
    <br/>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BC%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">1. 导论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.1.</span> <span class="toc-text">1.1. 网络层服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%85%B3%E9%94%AE%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.</span> <span class="toc-text">1.2. 网络层的关键功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E5%88%86%E5%B9%B3%E9%9D%A2"><span class="toc-number">1.3.</span> <span class="toc-text">1.3. 网络层分平面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">1.4. 路由在控制平面的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.4.1. 传统的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sdn%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.4.2. SDN方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="toc-number">1.5.</span> <span class="toc-text">1.5. 连接建立</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">1.6. 网络服务模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%84%E6%88%90"><span class="toc-number">2.</span> <span class="toc-text">2. 路由器组成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. 路由器结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%AB%AF%E5%8F%A3"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. 输入端口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%9B%AE%E6%A0%87%E7%9A%84%E8%BD%AC%E5%8F%91"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1. 基于目标的转发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%AB%AF%E5%8F%A3%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2. 输入端口缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. 交换结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1. 通过内存交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%80%BB%E7%BA%BF%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2. 通过总线交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9Ccrossbar%E7%AD%89%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3.
通过互联网络(crossbar等)交换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%AB%AF%E5%8F%A3"><span class="toc-number">2.4.</span> <span class="toc-text">2.4. 输出端口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1. 调度机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A2%E5%BC%83%E7%AD%96%E7%95%A5"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2. 丢弃策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ip-internet-protocol"><span class="toc-number">3.</span> <span class="toc-text">3. ⭐IP: Internet Protocol</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ip%E5%88%86%E7%89%87%E5%92%8C%E9%87%8D%E7%BB%84fragmentationreassembly"><span class="toc-number">3.1.</span> <span class="toc-text">3.1.
IP分片和重组(fragmentation&amp;reassembly)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ipv4%E5%9C%B0%E5%9D%80"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. IPv4地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BD%91subnets"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1. 子网(subnets)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ip%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2. IP地址分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cidr"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3. CIDR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81mask"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4. 子网掩码(mask)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91%E8%A1%A8%E5%92%8C%E8%BD%AC%E5%8F%91%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.5.</span> <span class="toc-text">3.2.5. 转发表和转发算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AAip%E5%9C%B0%E5%9D%80"><span class="toc-number">3.2.6.</span> <span class="toc-text">3.2.6. 获得一个IP地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dhcp"><span class="toc-number">3.2.6.1.</span> <span class="toc-text">3.2.6.1. DHCP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E5%9C%B0%E5%9D%80%E5%9D%97%E4%BB%A5%E5%8F%8A%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88"><span class="toc-number">3.2.7.</span> <span class="toc-text">3.2.7. 获得地址块以及路由聚合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%A2%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9D%97"><span class="toc-number">3.2.7.1.</span> <span class="toc-text">3.2.7.1. 换的地址块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88"><span class="toc-number">3.2.7.2.</span> <span class="toc-text">3.2.7.2. 路由聚合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nat%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. NAT：网络地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%91%E7%A9%BF%E8%B6%8A"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1. 内网穿越</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ipv6"><span class="toc-number">3.4.</span> <span class="toc-text">3.4. IPv6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%A7%E9%81%93tunneling"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1. 隧道(Tunneling)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E8%BD%AC%E5%8F%91%E5%92%8Csdn"><span class="toc-number">4.</span> <span class="toc-text">4. 通用转发和SDN</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sdn%E6%9E%B6%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. SDN架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1. 数据平面交换机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sdn%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2. SDN控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%BA%94%E7%94%A8"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3. 控制应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sdn%E4%BE%8B%E5%AD%90openflow"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. SDN例子：OpenFlow</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1. 数据平面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E8%A1%A8%E7%9A%84%E8%A1%A8%E9%A1%B9%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2. 流表的表项结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#openflow%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3. OpenFlow工作模式</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        第 4 章 网络层：数据平面
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">hdfzzf</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-06-04T16:00:00.000Z" itemprop="datePublished">2022-06-05</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a> › <a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/B%E7%AB%99%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%BD%91/" rel="tag">B站中科大计网</a>, <a class="tag-link-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a>, <a class="tag-link-link" href="/tags/%E8%AE%A1%E7%AE%97%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/" rel="tag">计算网络教程 自顶向下方法</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>个人的知识笔记。</p>
<span id="more"></span>
<h1 id="导论">1. 导论</h1>
<h2 id="网络层服务">1.1. 网络层服务</h2>
<p>网络层的服务有：</p>
<ol type="1">
<li>在发送主机和接收主机之家传送段(segment)</li>
<li>在发送端将段封装到数据报（不是UDP数据报）中</li>
<li>在接收端，将段上交给传输层实体</li>
<li>网络层的协议存在于<strong>每一个</strong>主机和路由器</li>
<li>路由器检查每一个经过它的IP数据报的头部</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604213409.png" /></p>
<h2 id="网络层的关键功能">1.2. 网络层的关键功能</h2>
<p>网络层有三个关键功能：</p>
<ol type="1">
<li><strong>转发</strong>：将分组从路由器的输入接口转发到合适的输出接口</li>
<li><strong>路由</strong>：使用路由算法来决定分组从发送主机到目标主机的路径</li>
<li><strong>连接建立</strong>：分组传输之前，在两个主机之间通过一些路由器所构成的路径上建立一个网络层连接（有连接）[[#1
5 连接建立]]</li>
</ol>
<p>其中，转发和路由是所有网络架构的关键功能，而连接建立只有在某些网络架构中存在。</p>
<p>转发可以看的出来是针对单个分组的，并且只局限于单个路由器。而路由是全局的，涉及发送主机到目标主机路径之间的所有路由器。</p>
<blockquote>
<p>路由器的端口：路由器的端口都是双向的，既可以输入，也可以输出。这里的输入接口特指接收分组的那个接口，输出接口特指转发分组的接口。</p>
</blockquote>
<h2 id="网络层分平面">1.3. 网络层分平面</h2>
<p>网络层可以分为两个平面：</p>
<ol type="1">
<li>数据平面(data plane)</li>
<li>控制平面(control plane)</li>
</ol>
<p>其中，数据平面是本地的，单个路由器可以完成的功能都属于数据平面。比如刚刚说的转发功能。</p>
<p>控制平面是网络范围内的逻辑，也就是全局的。比如说刚刚的路由就是该平面的功能。</p>
<p>本章节主要描述的就是数据平面。</p>
<h2 id="路由在控制平面的实现">1.4. 路由在控制平面的实现</h2>
<p>路由时控制平面的功能，其实现有两种方法：</p>
<ol type="1">
<li>传统的方法</li>
<li>SDN方法</li>
</ol>
<h3 id="传统的方法">1.4.1. 传统的方法</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604214239.png" /></p>
<p>如上图：</p>
<ol type="1">
<li>每个路由器的控制平面互相交互，从而得到路由表</li>
<li>将路由表交给数据平面使用</li>
<li>一个分组到达路由器，会先进行解封装，然后得到segment，从中取出目标IP地址与路由表的表项做对比，从匹配的对应表项指示的输出链路转发。</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604214652.png" /></p>
<p>从上面的分析中可以得到一个比较奇怪的现象，那就是路由是控制平面的功能，路由表是路由功能的结果，按道理来说应该属于控制平面。但是转发却需要依赖路由表来进行转发，这么一看路由表又属于数据平面。因此，<strong>传统的方法的数据平面和控制平面通过路由表紧耦合</strong>。</p>
<p>并且也可以看出，无论是控制平面还是数据平面，功能的实现都是分布式的。每个路由器都会计算出路由表然后交给数据平面使用。每个路由器根据路由表进行转发。</p>
<p>紧耦合和分布式会导致路由器不好作修改。你想想，如果需要修改控制平面的功能，需要把整个路由器给换了，这就是紧耦合带来的弊端。即使有那个技术和经济把路由器换了，全球这么多路由器，不能够全部都换了吧，这不是经济和技术能做到的。因此，就出现了新的方法——SDN。</p>
<h3 id="sdn方法">1.4.2. SDN方法</h3>
<p><strong>SDN：Software-Defined Networking 软件定义网络</strong></p>
<p><strong>它与传统方法的最大区别是：该方法下拥有一个不同的远程控制器与本地控制代理交互。其中本地控制代理属于数据平面，而远程控制器属于控制平面。并且，所有路由器的控制平面集中在一个远程数据中心</strong></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604215603.png" /></p>
<p>这种方法的工作流程是：</p>
<ol type="1">
<li>远程控制器计算出当前网络中的流表，然后将其通过<strong>南向接口</strong>交给网络中的所有“路由器”；</li>
<li>分组到达“路由器”之后，与传统方法一样，根据流表进行匹配，然后根据匹配的表项<strong>动作</strong></li>
</ol>
<p>此时路由器不再称之为路由器，而是<strong>分组交换机</strong>。因为它已经失去了路由或者说控制平面的功能了。于此同时，它还多了其他数据平面的功能：<strong>泛洪</strong>、<strong>阻止(block)</strong>、<strong>修改</strong>。</p>
<p>这种方法下，匹配也和传统方法不一样。传统方法只匹配目标IP地址，而SDN不止匹配目标IP地址，可能还会匹配目标端口，协议这些字段。</p>
<p>工作流程中第2步的<strong>动作</strong>包括：转发、泛洪、阻止和修改（某些字段）。</p>
<p>这种方法的好处有：</p>
<ol type="1">
<li>数据平面和控制平面解耦合，比较好修改。</li>
<li>计算流表并于分组交换机交互是通过软件实现的。</li>
<li>远程控制器上面运行着网络操作系统，在这之上运行着许多网络应用（不是应用层的应用），比如说路由、防火墙、RDS（Route
Detection System）等复杂网络功能。</li>
<li>控制平面的功能实现是集中的</li>
</ol>
<p>总结来说，分组交换机对到来的分组的动作可以通过远程控制器来指定，而远程控制器可以通过人为的编程来实现某些功能。</p>
<h2 id="连接建立">1.5. 连接建立</h2>
<p>连接建立是某些网络服务模型（网络架构）的重要功能：ATM，frame relay,
X.25</p>
<p>在分组传输之前，在两个主机之间，在通过一些路由器所构成的路径上建立一个网络层连接。</p>
<p>网络层和传输层连接服务的区别：</p>
<ul>
<li><strong>网络层</strong>：<strong>有连接</strong>。在2个主机之间，涉及到路径上的一些路由器。（包括主机和路由器在内都会记住这个连接状态）</li>
<li><strong>传输层</strong>：<strong>面向连接</strong>。在2个进程之间，只体现在端系统之上。（比如TCP连接。只有通信双方主机知道两者有连接，中间的路由器都不知道）</li>
</ul>
<h2 id="网络服务模型">1.6. 网络服务模型</h2>
<p>衡量网络服务模型的几个标准：</p>
<ol type="1">
<li>保证带宽</li>
<li>保证不丢失</li>
<li>保证不乱序</li>
<li>保证时延</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604221052.png" /></p>
<p>其中，这四个都没有保证的网络服务模型称之为 <strong>best
effor，也就是尽力而为</strong>。</p>
<h1 id="路由器组成">2. 路由器组成</h1>
<h2 id="路由器结构">2.1. 路由器结构</h2>
<p>通用路由器体系架构（传统）：</p>
<ul>
<li>路由：运行路由选择算法/协议(RIP, OSPF, BGP)生成路由表</li>
<li>转发：将数据报从输入链路接收，然后根据路由表选择合适的输出链路发送</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605083113.png" /></p>
<h2 id="输入端口">2.2. 输入端口</h2>
<p>输入端口的功能如下图：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605083131.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220604231036.png" /></p>
<p>SDN使用的就是通用转发。</p>
<h3 id="基于目标的转发">2.2.1. 基于目标的转发</h3>
<p><strong>原理：匹配IP数据报中的目标IP地址(Destination Address,
DA)和路由表中的表项，从而决定输出链路。</strong></p>
<table>
<colgroup>
<col style="width: 84%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="header">
<th>DA范围</th>
<th>Link interface</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>11001000 00010111 00010000 00000000 ~ <br>11001000 00010111 00010111
11111111</td>
<td>0</td>
</tr>
<tr class="even">
<td>11001000 00010111 00011000 00000000 ~ <br> 11001000 00010111
00011000 11111111</td>
<td>1</td>
</tr>
<tr class="odd">
<td>11001000 00010111 00011001 00000000 ~ <br> 11001000 00010111
00011001 11111111</td>
<td>2</td>
</tr>
<tr class="even">
<td>otherwise</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>如果DA范围并没有像上表中划分的那么规整该怎么办？使用<strong>最长前缀匹配</strong>。</p>
<blockquote>
<p>在IP协议的时候会细说</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>DA范围</th>
<th>Link interface</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>11001000 00010111 00010*** ********</code></td>
<td>0</td>
</tr>
<tr class="even">
<td><code>11001000 00010111 00011000 ********</code></td>
<td>1</td>
</tr>
<tr class="odd">
<td><code>11001000 00010111 00011*** ********</code></td>
<td>2</td>
</tr>
<tr class="even">
<td>otherwise</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>此时，来了两个DA：</p>
<ul>
<li><code>11001000 00010111 00010110 10100001</code></li>
<li><code>11001000 00010111 00011000 10101010</code></li>
</ul>
<p>前者匹配第一个表项，因此从0接口转发；后者匹配第二个表现，因此从1接口转发。</p>
<h3 id="输入端口缓存">2.2.2. 输入端口缓存</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605081821.png" /></p>
<ul>
<li>当switch
fabric（交换机构）的速率小于输入端口的汇聚速率时，在输入端口可能就需要排队了。其实这种情况不太会发生，更多的情况是如上图中的左边，两个红色的同时在队头，因为两个红的输出端口一致，所以需要等待其中一个处理完成之后，才处理另一个，这时候等待的那个队列就可能来新的分组，这时候就需要队列了。</li>
<li>Head-of-the-line(HOL)
blocking：排在队头的数据报阻止了队列中其他数据报向前移动</li>
</ul>
<blockquote>
<p>交换机构一般都是由硬件实现的，因为这里要交的速率比较快，软件达不到速率。一般来说如果每个端口的输入速率为v，有N个端口，那么交换机构的交换速率大致为Nv。</p>
</blockquote>
<ul>
<li>输入端口缓存满，则会丢弃后面到来的分组。</li>
<li>缓存太大虽然不会丢失，但是会超时</li>
</ul>
<h2 id="交换结构">2.3. 交换结构</h2>
<p>交换结构位于一台路由器的核心部位，因为这是通过这种交换结构，分组才能实际从一个输入端口到达一个输出端口：</p>
<ul>
<li><p>将分组从输入缓冲区交换到合适的输出端口</p></li>
<li><p>交换速率：分组可以按照该速率从输入传输到输出</p>
<ul>
<li>运行速度一般是输入/输出链路速率的若干倍</li>
<li>N个输入，交换结构的交换速率是N倍的输入比较理想，这样才不会成为瓶颈</li>
</ul></li>
<li><p>有三种典型的交换结构</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605083517.png" /></p></li>
</ul>
<h3 id="通过内存交换">2.3.1. 通过内存交换</h3>
<p>第一代路由器：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605083608.png" /></p>
<ul>
<li>在CPU控制下交换</li>
<li>分组首先被拷贝到系统内存中，CPU从分组中提取目标IP，查路由表，找到对应的输出端口，再将其从内存中拷贝到输出端口。</li>
<li>转发速率被内存的带宽限制。分组一共经过两次（计算机内部）系统总线</li>
<li>一次只能转发一个分组（CPU一次只能执行一个工作）</li>
</ul>
<h3 id="通过总线交换">2.3.2. 通过总线交换</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605083942.png" /></p>
<ul>
<li>分组通过共享总线，从输入端口转发到输出端口</li>
<li><strong>总线竞争</strong>：交换速度受限于总线带宽</li>
<li>一次处理一个分组（只能一个分组通过总线）</li>
<li>速度比内存快。只需要经过一次总线</li>
</ul>
<h3 id="通过互联网络crossbar等交换">2.3.3.
通过互联网络(crossbar等)交换</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605084245.png" /></p>
<ul>
<li>可以并发转发多个分组，克服总线带宽限制</li>
<li>分组从端口A到达，转发给Y，控制器只需要短接响应的两个总线（上面最中间那个点）。此时如果B端口要转发到Z，只需要再短接第二层右边的点即可。</li>
<li><strong>高级设计</strong>：将数据报分片为固定长度的信元，通过互联网络交换</li>
</ul>
<h2 id="输出端口">2.4. 输出端口</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605084544.png" /></p>
<ul>
<li>交换机构转发数据报的速度比传输速率快，所以输出的端口需要有缓存</li>
<li>与输入端口不一样，这里的数据报传输是存在不同的<strong>调度规则</strong>的。</li>
<li>输出缓存满，则会丢弃数据报（这里可能不是丢弃后面到来的，有相应的丢弃策略）</li>
<li>缓存太大虽然不会丢失，但是会超时</li>
</ul>
<h3 id="调度机制">2.4.1. 调度机制</h3>
<p><strong>调度：从输出缓存中选择下一个要通过链路传输的分组。</strong></p>
<p>调度规则这里介绍4种：</p>
<ol type="1">
<li>FIFO(first in first out)scheduling</li>
<li>优先权调度</li>
<li>RR(Round Robin)scheduling</li>
<li>WFQ(Weighted Fair Queuing)</li>
</ol>
<p>FIFO比较好理解，就是先来后到。先来的分组先传输，后来的分组后传输。</p>
<p>优先权：这也比较好理解，比如可以将分组设置类别：video，voice，text等。包含视频数据分组优先权大于包含语音分组的优先权大于只包含文字的优先权。这样子，如果队列中同时存在video，voice和text，那么根据调度规则，优先传输video，然后voice，最后text，即使video排在比较后面。这种情况，需要在头部中标记分组类型。</p>
<p>RR：也是将分组分成多个类别（假设三个类别分别为红黄蓝）。那么传输的顺序就是：<code>红-&gt;黄-&gt;蓝-&gt;红-&gt;黄-&gt;蓝...</code>。如果某种类别的分组没了，则跳过。</p>
<p>WFQ：加权公平，也是将分组分类（假设三个类别分别为红黄蓝，并且红的权重为0.5，蓝为0.3，黄为0.2）。那么在一段时间内，不同类别的服务占据传输链路带宽的比重（或者说服务时间）应该与它的权重占整体权重的比重相一致。</p>
<p>假设这段时间为T，某红色类别分组得到的服务时间为t，红色类别权重为<span
class="math inline">\(w_r\)</span>，黄色为<span
class="math inline">\(w_y\)</span>，蓝色为<span
class="math inline">\(w_b\)</span>，那么：</p>
<p><span class="math display">\[
t=\frac {w_r}{w_r+w_y+w_b} * T
\]</span></p>
<p>这种调度规则不会精确到某一时刻，而是衡量一段时间内。这样子，能够保证在最坏的情况下，所有类别的分组都能够有一定的服务时间。</p>
<h3 id="丢弃策略">2.4.2. 丢弃策略</h3>
<p>有调度机制，自然也有丢弃策略。丢弃策略比较简单，常见的就以下三种，当输出缓冲满的时候：</p>
<ol type="1">
<li>tail drop：丢弃后到来的分组</li>
<li>priority：丢弃缓冲中优先权最低的分组</li>
<li>randon：随机从缓冲中丢弃分组</li>
</ol>
<p>其中，priority会导致“饥饿”。就是如果一直存在高优先权的分组，那么低优先权的分组就会被一直丢弃。使得低优先权分组永远得不到服务。调度机制中的优先权也存在这个问题。</p>
<h1 id="ip-internet-protocol">3. ⭐IP: Internet Protocol</h1>
<p>主机、路由器中的网络层功能：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605093143.png" /></p>
<p>从上图中也可以看出，网络层不只有IP协议，还有路由协议以及ICMP协议（信令协议，主要作用是报告错误）</p>
<p>IP数据报格式：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605093234.png" /></p>
<p><strong>Internet checksum：IP头部校验和</strong></p>
<p>一般来说，IP数据报头部占20Bytes，如果有Options那另说。</p>
<p>IP数据报传递到数据链路层，被封装成帧。一个帧的MTU为1500，也就是帧的body部分为1500Bytes。一般而言，IP数据报
= 帧的body = MTU。</p>
<h2 id="ip分片和重组fragmentationreassembly">3.1.
IP分片和重组(fragmentation&amp;reassembly)</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605093507.png" /></p>
<p>如上图，两个路由器连接的是两个网络，这两个网络可能不同架构，因此就会存在不同的MTU。一个路由器假设左端是A网络，MTU为4000Byte，右边是以太网，MTU为1500Byte。那么从左端收到的数据报就应该被分片，才能转发到右边的网络。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605094835.png" /></p>
<p>其中，左边的数据报为：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605094910.png" /></p>
<p>右边三个从上到下分别为：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605094948.png" /></p>
<blockquote>
<p>上面的演示只涉及网络层，不涉及数据链路层的头部，因此分片中的1500指的是整个IP数据报的长度</p>
</blockquote>
<p>因此，IP分片中每个数据报：</p>
<ul>
<li><strong>具有相同的ID</strong>：说明是来自同一个大的数据报的分片。不仅分片之间ID相同，分片与原数据报的ID也相同</li>
<li><strong>不同的偏移量</strong>：说明每个数据报在原数据报中的顺序。以字节为单位</li>
<li><strong>最后一个分片标记为0</strong>：说明该分片是最后一个</li>
<li>分片不是将整个数据报进行分片，而是将数据报中的<strong>数据部分</strong>进行分片</li>
</ul>
<p>以上描述的是分片的过程。重组只在目标主机上进行。如果目标主机收到分片中的任何一片（通过fragflag判断）就会启动一个定时器，如果在定时器结束之前，所有的分片到来，就会关闭定时器，将分片重组（通过offset和ID）往上传。如果定时器结束之前，有一片或者多片没有到来，会将已经到来的分片也丢弃。</p>
<h2 id="ipv4地址">3.2. IPv4地址</h2>
<p>我们常说的IP地址，其实值得就是IPv4地址。</p>
<p><strong>IP地址</strong>：32位标示，对<strong>主机</strong>或者<strong>路由器</strong>的<strong>接口</strong>编址</p>
<p><strong>接口</strong>：主机/路由器和物理链路的连接处</p>
<ul>
<li>路由器通常拥有多个接口（2个及以上）。因为路由连接至少两个子网</li>
<li>主机也有可能有多个接口。可以插多张网卡，接入多个子网</li>
<li><strong>一个IP地址和一个接口关联</strong></li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605103414.png" /></p>
<p>从上图中可以看出：</p>
<ul>
<li>路由器一般通过交换机连接一个子网中的所有主机</li>
<li>如果是Wi-Fi，则路由器通过AP连接一个子网中的所有主机</li>
<li>223.1.1.1是<strong>点分十进制记法</strong>，每8个字节转为10进制，然后用
<code>.</code> 隔开</li>
</ul>
<p><strong>其实路由器和路由器直接的连接通常都是直连。</strong></p>
<h3 id="子网subnets">3.2.1. 子网(subnets)</h3>
<p>上面说，路由器将至少两个子网连在一起。那么子网是什么呢？</p>
<p>IP地址：</p>
<ul>
<li>子网部分（高位bits）</li>
<li>主机部分（地位bits）</li>
</ul>
<p>什么是子网，需要满足以下两个条件：</p>
<ul>
<li>一个子网内的节点（主机或者路由器）它们的IP地址的高位部分相同，这些节点构成的网络</li>
<li>同一子网内，各主机之间的通信<strong>不需要借助路由器</strong>，可能能够直达，或者借助交换机。</li>
</ul>
<p><strong>一般来说，我们直接称子网为网络。</strong></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605104217.png" /></p>
<p>比如上图中就具有3个子网。但是换一个角度想，这三个子网的高位部分（高16位）其实也相同，那么这个网络也可以看成一个子网
<code>223.1.0.0/16</code>
，这个子网内的主机通信可能会借助路由器。这个现象称为<strong>地址聚合/路由聚合/路由摘要</strong>，那么与该路由器相连的路由器里面可能就会有一个表项：<code>223.1.0.0 interface1</code>
，意思是可以通过接口1到达223.1.0.0这个网络。</p>
<p>接下来做一个题，下图中有几个子网？</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605104609.png" /></p>
<p>3？6？答案是6。子网其实看的是接口，除了有主机的三个子网之外，路由器之间的链路也是一个子网，因为该链路</p>
<ul>
<li>两端各有一个接口，并且高位相同；</li>
<li>这两个接口的通信不需要经过路由器</li>
</ul>
<p>因此，三个链路也是子网。所以最后答案是6。</p>
<h3 id="ip地址分类">3.2.2. IP地址分类</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605113011.png" /></p>
<p>解释：</p>
<ul>
<li>A类：高8位为网络号，且第1位为0。因此有 <span
class="math inline">\(2^7=128\)</span> 个A类网络，每个A类网络有<span
class="math inline">\(2^{24}-2\)</span> 个主机。</li>
<li>B类：高16位为网络号，且前2位为10。因此有 <span
class="math inline">\(2^{14}=16384\)</span>个B类网络，每个B类网络有
<span class="math inline">\(2^{16}-2=65534\)</span> 个主机</li>
<li>C类：高24位为网络号，且前三位为110。因此有 <span
class="math inline">\(2^{21}\)</span> 个C类网络，每个C类网络有 <span
class="math inline">\(2^8-2=254\)</span> 个主机</li>
</ul>
<p>除了上面的分类之外，还存在一些特殊的IP地址：</p>
<ul>
<li><p>网络号和主机号全0，表示该网络上的所有主机，可以做源端，不可以做目的端（DHCP时使用）</p></li>
<li><p>网络号全0，主机号为HostID，表示该网络是特定的主机</p></li>
<li><p>127.x.x.x
表示环回地址，工作原理：数据到达网络层之后又转回去了</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605114622.png" /></p></li>
<li><p>网络号和主机号全1，表示在该网络上广播</p></li>
<li><p>网络号为netID，主机号全1.表示在特定网络广播</p></li>
</ul>
<p>除了这些特殊IP之外，还设有专用地址：</p>
<ul>
<li>这些地址永远不会被当作共用地址来分配，不会与共用地址重复
<ul>
<li>只在局部网络中有意义，用于区分不同的设备</li>
</ul></li>
<li>路由器不会对目标地址是专用网络的分组进行转发</li>
<li>专用地址范围：
<ul>
<li>A类: <code>10.0.0.0 ~ 10.255.255.255</code></li>
<li>B类：<code>172.16.0.0 ~ 172.31.255.255</code></li>
<li>C类：<code>192.168.0.0 ~ 192.169.255.255</code></li>
</ul></li>
</ul>
<h3 id="cidr">3.2.3. CIDR</h3>
<p>这么分类其实有一个很大的弊端，A类网络很少，但是每个网络可以拥有非常多的主机不适用。C类网络虽然很多，但是每个C类网络的主机只有254，太少了，稍微大一点的企业就超过了。综合来看，B类是最合适的，但是B类网络的主机数也有一点多，一般来说用不完。</p>
<p>这样子就会造成浪费。一个企业拥有1000台主机该怎么办？办一个B类，太大；办4个C类，企业间主机通信都要通向外网。</p>
<p>为了解决这个分配不当的问题，CIDR(Classless InterDomain
Routing，无类域间路由)出现了。</p>
<ul>
<li>子网部分可以在任何位置切开</li>
<li>地址格式：a.b.c.d/x，其中x是地址中子网的长度。</li>
</ul>
<p>举个例子：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605120955.png" /></p>
<p>上图中的子网部分就是23位，主机部分9位。这不是A，B，C中的任何一类。</p>
<p>CIDR的出现，企业可以根据主机数决定子网部分的位数。比如上面提到的1000台主机，就可以让子网部分占22位，主机部分占10位，<span
class="math inline">\(2^{10}=1024\)</span>
除去全0和全1，正好能够满足要求。</p>
<h3 id="子网掩码mask">3.2.4. 子网掩码(mask)</h3>
<p>需要明确一点，路由器的功能是<strong>连接两个子网</strong>。也就是说路由器是根据分组中的目标IP地址中的网络号来区分两个不同的子网，因此主机号对于路由器是没有用的。</p>
<ul>
<li>192.168.10.124/24</li>
<li>192.168.10.100/24</li>
</ul>
<p>上面两个地址属于同一个网络
192.168.10.0/24，路由器根据前24位（网络号）就可以判断，不需要最后的主机号。</p>
<p>子网掩码：</p>
<ul>
<li>子网部分用全1表示</li>
<li>主机部分用全0表示</li>
<li>32位</li>
</ul>
<p>不同类网络的子网掩码分别是：</p>
<ul>
<li>A类：255.0.0.0</li>
<li>B类：255.255.0.0</li>
<li>C类：255.255.255.0</li>
</ul>
<p>CIDR下的子网掩码例子：</p>
<ul>
<li>11111111 11111111 11111100 00000000</li>
</ul>
<p>还有一种表示方法就是：a.b.c.d/x。后面的x就表示子网的部分。</p>
<p>结论： <span class="math display">\[
子网 = IP \&amp;\&amp; 子网掩码
\]</span></p>
<blockquote>
<p>&amp;&amp;: 按位与</p>
</blockquote>
<p>这个公式在转发算法中使用。</p>
<h3 id="转发表和转发算法">3.2.5. 转发表和转发算法</h3>
<p>转发表如下：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605121532.png" /></p>
<p>其中 next hop
是用来指示从对应接口出去之后会到达的路由器的接口的IP地址，通过IP地址就能够知道下一跳路由器的MAC地址也就是下一跳目标MAC地址，这是数据链路层中封装时需要使用的。每过一条都要修改源MAC地址和目标MAC地址。</p>
<p>转发算法：</p>
<ol type="1">
<li>获得IP数据报中的目标IP地址(IP Des addr)</li>
<li>对于转发表中的每一个表项：
<ul>
<li>如果 <span class="math inline">\((IP　Des　addr) \&amp;\&amp; (Mask)
== Destination　Subnet　Num\)</span>，则按照表项对应的接口转发</li>
<li>如果没有找到，则使用默认表项转发数据报</li>
</ul></li>
</ol>
<h3 id="获得一个ip地址">3.2.6. 获得一个IP地址</h3>
<p>有两个办法：</p>
<ol type="1">
<li>通过修改本地的配置文件</li>
<li>利用DHCP(Dynamic Host Configuration
Protocol)，从服务器中动态获得一个IP地址</li>
</ol>
<h4 id="dhcp">3.2.6.1. DHCP</h4>
<p>目标：允许主机在加入网络的时候，动态的从DHCP服务器那里获得IP地址</p>
<ul>
<li>可以更新对主机在用IP地址的租用期（每个主机获得的IP地址是有租用期的，过期要么续租要么收回）</li>
<li>重新启动时，允许重新使用以前用过的IP地址（除非有新的机器占用了）</li>
<li>支持移动用户加入网络</li>
<li>一个C类的只允许254台主机，但是使用DHCP可以支持更多的用户。假设有400人，400人同时上网的可能性也不大，有可能200人早上，200人晚上用。因此可以同时支持这400人</li>
<li>比起手动配置方便太多了</li>
</ul>
<p>工作概况：</p>
<ol type="1">
<li>主机广播 “DHCP discover” 报文</li>
<li>DHCP服务器用 “DHCP offer” 提供报文响应</li>
<li>主机请求IP地址：发送 “DHCP request” 报文</li>
<li>DHCP服务器发送地址：“DHCP ack”报文</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605144833.png" /></p>
<ol type="1">
<li>DHCP discover：我需要一个IP地址</li>
<li>DHCP offer：这个IP怎么样？并带上一个IP地址</li>
<li>DHCP request：可以，就它了</li>
<li>DHCP ack：OK，这个IP借给你，3600s之后要么续租，要么收回</li>
</ol>
<p>解释：</p>
<ul>
<li>最开始的时候，主机没有IP地址，故使用全0。刚开始的时候不知道DHCP服务器的IP地址，故使用全1的广播地址。</li>
<li>DHCP收到之后给出IP之后其实已经结束了，为什么还需要后面的两步？因为可能主机收到了不止一个DHCP服务器的响应，因此主机需要明确的告诉DHCP服务器自己的选择。</li>
</ul>
<p>这里指示演示了DHCP的工作流程，DHCP返回的不仅仅是IP地址，而是之前说过的主机上网需要4个值：</p>
<ol type="1">
<li>IP地址</li>
<li>第一跳路由器的IP地址（默认网关）</li>
<li>本地DNS服务器的域名和IP地址</li>
<li>子网掩码</li>
</ol>
<h3 id="获得地址块以及路由聚合">3.2.7. 获得地址块以及路由聚合</h3>
<h4 id="换的地址块">3.2.7.1. 换的地址块</h4>
<p>主机可以从DHCP服务器中获得一个IP地址，那么DCHP是如何获得这么多IP地址的呢？</p>
<p>首先，有几个机构用来管理大的地址快：ICANN(Internet Corporation for
Assigned)</p>
<ul>
<li>分配地址</li>
<li>管理DNS</li>
<li>分配域名，解决冲突</li>
</ul>
<p>ISP从ICANN获得一整个地址块，假设为
<code>200.23.16.0/20</code>。然后将这一大块地址分为多个小块，比方说分成8块：</p>
<ul>
<li>ISP: <strong>11001000 00010111 0001</strong>0000 00000000
200.23.16.0/20</li>
<li>机构0: <strong>11001000 00010111 0001000</strong>0 00000000
200.23.16.0/23</li>
<li>机构1: <strong>11001000 00010111 0001001</strong>0 00000000
200.23.18.0/23</li>
<li>机构2: <strong>11001000 00010111 0001010</strong>0 00000000
200.23.20.0/23</li>
<li>机构3: <strong>11001000 00010111 0001011</strong>0 00000000
200.23.22.0/23</li>
<li>机构4: <strong>11001000 00010111 0001100</strong>0 00000000
200.23.24.0/23</li>
<li>机构5: <strong>11001000 00010111 0001101</strong>0 00000000
200.23.26.0/23</li>
<li>机构6: <strong>11001000 00010111 0001110</strong>0 00000000
200.23.28.0/23</li>
<li>机构7: <strong>11001000 00010111 0001111</strong>0 00000000
200.23.30.0/23</li>
</ul>
<p>将这8块就可以分给不同的机构，不同的机构可以将这个网络给DHCP服务器，让其动态分配。或者也可以再将其分成更小的地址块。</p>
<h4 id="路由聚合">3.2.7.2. 路由聚合</h4>
<p>假设机构获得200.23.16.0/20，根据上面的分析，将200.23.18.0/23分配给部门1，将200.23.20.0/23分给部门2。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605154637.png" /></p>
<p>（假设机构路由器上面的接口为lan0，下面的接口为lan1；机构路由器左边的接口为lan3）</p>
<ol type="1">
<li>接下来部门1，2路由器告诉机构路由器（<strong>路由通告</strong>），“如果有对应网络号的数据就转发给我”，机构的路由表里面就存在这样两项：</li>
</ol>
<table>
<thead>
<tr class="header">
<th>DA</th>
<th>mask</th>
<th>next hop</th>
<th>Inf</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>200.23.18.0</td>
<td>23</td>
<td>IPx</td>
<td>lan0</td>
</tr>
<tr class="even">
<td>200.23.20.0</td>
<td>23</td>
<td>IPy</td>
<td>lan1</td>
</tr>
<tr class="odd">
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>机构路由器收集这些信息之后告诉ISP“如果遇到这两个网络的数据就转发给我”，那么ISP的路由表中也会存在上表中的两项，只不过有一些区别：</li>
</ol>
<table>
<thead>
<tr class="header">
<th>DA</th>
<th>mask</th>
<th>next hop</th>
<th>Inf</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>200.23.18.0</td>
<td>23</td>
<td>IPc</td>
<td>lan3</td>
</tr>
<tr class="even">
<td>200.23.20.0</td>
<td>23</td>
<td>IPc</td>
<td>lan3</td>
</tr>
<tr class="odd">
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>这时候只有两个，看过去问题不到，如果8个全部给出去了，那么就会出现9个表项，除了DA不一样，其他全都一样。并且ISP还会告诉Internet中与它直连的路由器这些信息。这样就会导致互联网中的分组如果DA为上面8个之一，只需要转发到同一个路由器（ISP）即可，因此其实只需要一个表项。<strong>这就是路由聚合存在的必要</strong>。</p>
<p>使用路由聚合的情况：</p>
<p>机构路由表不变。但是ISP路由表变成如下：</p>
<table>
<thead>
<tr class="header">
<th>DA</th>
<th>mask</th>
<th>next hop</th>
<th>Inf</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>200.23.16.0</td>
<td>20</td>
<td>IPc</td>
<td>lan3</td>
</tr>
<tr class="even">
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>这1条信息可以包含之前的8条消息。再把这条信息告诉Internet中直连的路由器，这样网络中的信息就会从8条变成1条。网络中遇到这个网络的分组就可以分给ISP，然后ISP给机构，机构中保留有原来的8个就可以找到对应的组织。</p>
<ul>
<li>资源占用少</li>
<li>计算简单</li>
</ul>
<p>如果出现下面这种情况：(路由表中的next hop
Inf不要在乎是什么，只要在乎一不一样)</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605160228.png" /></p>
<p>那么机构路由表为：</p>
<table>
<thead>
<tr class="header">
<th>DA</th>
<th>mask</th>
<th>next hop</th>
<th>Inf</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>200.23.18.0</td>
<td>23</td>
<td>IPa</td>
<td>lan1</td>
</tr>
<tr class="even">
<td>200.23.20.0</td>
<td>23</td>
<td>IPb</td>
<td>lan2</td>
</tr>
<tr class="odd">
<td>200.23.22.0</td>
<td>23</td>
<td>IPc</td>
<td>lan3</td>
</tr>
<tr class="even">
<td>200.23.24.0</td>
<td>23</td>
<td>IPd</td>
<td>lan4</td>
</tr>
<tr class="odd">
<td>200.23.26.0</td>
<td>23</td>
<td>IPe</td>
<td>lan5</td>
</tr>
<tr class="even">
<td>200.23.28.0</td>
<td>23</td>
<td>IPf</td>
<td>lan6</td>
</tr>
<tr class="odd">
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>那么机构会怎么将信息给ISP呢？答案还是聚合成一条给ISP。并且部门8也会给ISP一条信息，因此ISP路由表如下</p>
<table>
<thead>
<tr class="header">
<th>DA</th>
<th>mask</th>
<th>next hop</th>
<th>Inf</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>200.23.16.0</td>
<td>20</td>
<td>IPg</td>
<td>lan3</td>
</tr>
<tr class="even">
<td>200.23.30.0</td>
<td>23</td>
<td>IPk</td>
<td>lan4</td>
</tr>
<tr class="odd">
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>ISP也会将这两条聚合成一条消息给Internet中与它直连的路由器：</p>
<table>
<thead>
<tr class="header">
<th>DA</th>
<th>mask</th>
<th>next hop</th>
<th>Inf</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>200.23.16.0</td>
<td>20</td>
<td>IPo</td>
<td>lan0</td>
</tr>
<tr class="even">
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>此时互联网得到一个DA为200.23.30.8的分组，首先将分组转发给ISP，现在问题来了，这个IP地址其实能与ISP中的两条都匹配的上</p>
<ul>
<li><span class="math inline">\(200.23.30.8 \ \&amp;\&amp;\  (11111111\
11111111\ 11110000\ 00000000) = 200.23.16.0\)</span></li>
<li><span class="math inline">\(200.23.30.8 \ \&amp;\&amp;\  (11111111\
11111111\ 11111110\ 00000000) = 200.23.30.0\)</span></li>
</ul>
<p>那么这个时候分组该如何转发呢？</p>
<p>这个时候就需要用到<strong>最长前缀匹配</strong>。以这个为例，200.23.30.8的前缀（高位）能够与两个网络匹配上，但是后者匹配的前缀比前者要多（多3位），因此这时候路由器认为后者匹配上，因此转发到对应的路由器，直接到部门8。</p>
<p>这里也体现了路由聚合的一个特点：<strong>大概聚合</strong>。本例子中的体现就是200.23.16.0/20网络分成了8个，机构路由器只知道其中6个，不知道另外两个，但是向外聚合的时候还是宣告了
200.23.16.0/20 整个网络，反正有最长前缀匹配兜底。</p>
<h2 id="nat网络地址转换">3.3. NAT：网络地址转换</h2>
<p><strong>NAT: Network Address Translation</strong></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605162433.png" /></p>
<p>路由器拥有一个公网IP地址：138.76.29.7，拥有一个内网IP地址：10.0.0.4（这个称为这个内网的网关），内网的主机分配专用的IP地址。</p>
<p>假设10.0.0.1需要发送分组给外网某台主机，需要先通过网关，然后路由器将源IP地址和源端口修改为138.76.29.7和一个路由器上没被使用的端口，并记录映射关系。外网主机回的响应中，目标IP地址和端口是路由器修改后的信息，到达路由器后通过映射关系修改响应的目标IP和端口为最开始的源IP和端口。</p>
<p>这时候就会有人问了：“为什么这么多主机要共用一个IP呢？多买几个不就好了？”。这就是互联网版“何不食肉糜”。</p>
<p>本地网络只有一个有效IP地址的好处：</p>
<ul>
<li><strong>省钱</strong></li>
<li>即使路由器IP因为DHCP变化了，内网主机的IP也不需要修改</li>
<li>内网主机IP修改也不需要告诉外网的任何设备</li>
<li>内网对于外网来说是透明的，外网只知道138.76.29.7这个IP的设备，并不知道路由器后面的主机</li>
</ul>
<p>实现NAT功能，NAT路由器必须：</p>
<ul>
<li><strong>对于外出数据包</strong>：要将<strong>源地址和端口</strong>修改为NAT
IP地址和新的端口</li>
<li><strong>记住</strong>：需要将每个转换对记录在NAT转换表中
<code>源IP, 源port -&gt; NAT IP, 新port</code></li>
<li><strong>对于进入数据包</strong>：替换<strong>目标IP地址和端口</strong>，采用存储在NAT表中的表项替换</li>
</ul>
<p>一个例子如下图：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605163512.png" /></p>
<ol type="1">
<li>主机 10.0.0.1:3345 发送数据给 128.119.40.186:80</li>
<li>NAT 路由器修改源IP为138.76.29.7，将源port修改为
5001，记录到NAT表中，然后将数据发出</li>
<li>主机收到数据后给目标地址为
138.76.29.7，目标port为5001的设备响应</li>
<li>到达NAT路由器，通过比对NAT表，修改目标地址为
10.0.0.1，修改port为3345，然后转发给对应主机</li>
</ol>
<p>NAT可行吗？一个内网可能有多个主机，每个主机都有65535个端口，NAT路由器端口也就65535，不够映射呀？答案是可行的。</p>
<ul>
<li>内网的主机的所有端口同时存在进程，并且同时与外界通信。一般都不会超过65535个会话，所以够用</li>
</ul>
<p>对NAT其实是有一定争议的。</p>
<ul>
<li>首先，因为路由器只有3层，而端口属于4层的信息，这里NAT路由器对端口进行了修改，也就是3层设备修改了4层消息。</li>
<li>其次，违反了end-to-end原则（复杂性放到端系统实现）</li>
<li>最后，外网的主机无法主动与内网主机连接（外网根本不知道有内网存在）。<strong>解决办法：内网穿越</strong></li>
</ul>
<p><strong>使用NAT也是没有办法的办法，归根结底还是IP不够了，如果每台主机一个IP，全球的主机以亿为单位，根本不够分。因此，现在正在推出IPv6来解决这个问题。</strong></p>
<h3 id="内网穿越">3.3.1. 内网穿越</h3>
<p>问题就是外网的一个客户需要连接 10.0.0.1
的服务器的80端口该怎么办？</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605164420.png" /></p>
<p>有3个方法：</p>
<ol type="1">
<li><p>静态配置NAT。直接在NAT表中写入（服务器IP，服务器端口，新端口）
<code>10.0.0.1, 80, 5001</code>。那么外界直接连接NAT路由器的5001端口就可以访问到10.0.0.1:80的服务。对于外界来说就像是NAT路由器的5001端口提供了服务。</p></li>
<li><p>Universal Plug and Play(UPnP) Internet Gateway
Device(IGD)协议。本质上就是由静态配置NAT变成动态配置NAT</p>
<ol type="1">
<li>允许内网主机获知NAT路由器的公共IP地址，以及存在的端口映射；</li>
<li>找打一个未被使用的端口，将其与内网主机的80端口绑定，并写入NAT表</li>
<li>外网客户就能够通过NAT路由器的端口访问内网主机的80端口的服务</li>
<li>如果内网主机关掉服务，就会找到NAT表中的记录，并删除</li>
</ol></li>
<li><p>中继（used in Skype）</p>
<ol type="1">
<li>内网主机先<strong>主动</strong>与中继建立连接</li>
<li>外网客户连接到中继</li>
<li>之后就可以通过中继进行通信了</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605165238.png" /></p></li>
</ol>
<h2 id="ipv6">3.4. IPv6</h2>
<p>IPv4的地址空间已经被用完了，需要更多的地址空间。这就是IPv6的初始动机。</p>
<p>另外的动机：</p>
<ol type="1">
<li>头部格式的改变帮助加速处理和转发
<ul>
<li>取消TTL字段</li>
<li>取消checksum</li>
<li>取消分片</li>
</ul></li>
<li>头部格式的改变帮助QoS(Quality of service)</li>
</ol>
<p>IPv6 数据报格式：</p>
<ul>
<li>固定的40字节头部</li>
<li>数据报传输过程不允许分片</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605170825.png" /></p>
<ul>
<li>priority:
标示流中数据报的优先级。要配合流量政策一起使用。“大家都是VIP，那么大家都不是VIP”</li>
<li>FLow Label: 标示数据报在一个 “flow”
中。（flow概念没有被严格定义）比方说同一IP的数据报属于同一flow，被打上相同的flow
Label。希望网络对同一flow的数据报作相同的处理</li>
<li>next header：标示上层协议</li>
</ul>
<p>和IPv4的变化：</p>
<ul>
<li>checksum被移除</li>
<li>Options：允许，但是在头部之外，被 “next headder”
指示哪里是options，具体值为多少。</li>
<li>ICMPv6
<ul>
<li>附加了新的报文类型，比方说 "packet too big"</li>
<li>多播组管理功能</li>
</ul></li>
</ul>
<p>因为IPv6不支持分片，所以一旦IPv6路由器收到一个特别大的数据报，会直接丢弃，然后通过ICMPv6发送分组告诉源主机，"packet
too big"。</p>
<h3 id="隧道tunneling">3.4.1. 隧道(Tunneling)</h3>
<p>IPv4到IPv6的升级一定是平滑的、过渡式的。过渡的过程分为早期、晚期、实现三个阶段。</p>
<p><strong>早期的时候</strong>，IPv6的网络少于IPv4的网络。下图中，一整个大圆标示IPv4的网络，小圆标示IPv6的网络。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605171707.png" /></p>
<p>IPv4网络内部的通信，IPv6网络内部的通信都是没问题的。有问题的就是IPv6的网络如何跨过IPv4的网络与另一个IPv6网络通信。这就要使用到隧道技术。</p>
<p>上图中标红的路由器就是双栈路由器（同时支持IPv4和IPv6），左边的数据报到达路由器，将IPv6的数据报封装成IPv4的数据报，然后发到IPv4的路由器，经转发到达右边的双栈路由器，将IPv4的数据报解封装成IPv6的数据报，然后就可以在右边的网络中转发。</p>
<p><strong>隧道技术视图</strong>：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605172401.png" /></p>
<p><strong>晚期的时候，攻守之势异也</strong></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605172217.png" /></p>
<p>但是技术还是那个技术。就不多赘述了。</p>
<p>最后实现了IPv4到IPv6的升级。</p>
<h1 id="通用转发和sdn">4. 通用转发和SDN</h1>
<p>之前介绍过传统的路由方法都是通过分布式，每台设备实现数据平面和控制平面的功能：</p>
<ol type="1">
<li><strong>垂直集成</strong>：每台路由器或其他网络设备，包括：
<ol type="1">
<li>硬件、私有的网络操作系统以及运行在上面的软件</li>
<li>互联网标准协议(IP, RIP, IS-IS, OSPF, BGP)的私有实现</li>
<li>从软件到硬件都有一个产商提供（一个产商的操作系统可能不能运行在另一个产商的硬件之上）</li>
</ol></li>
<li>设备基本上<strong>只能够按照设计好的固定方式工作</strong>，<strong>控制逻辑固化</strong>。不同的网络功能需要不同的网络设备实现。</li>
</ol>
<p>上面的两个特点就导致了传统方式实现网络功能的问题：</p>
<ul>
<li>垂直集成 -&gt; 昂贵、不利于创新生态</li>
<li>分布式、固化设备功能 == 网络设备种类繁多
<ul>
<li>无法改变路由等工作逻辑、无法实现流量工程等高级特性</li>
<li>配置错误影响全网运行；升级和维护会涉及到全网设备 -&gt; 管理困难</li>
<li>要增加新的网络功能，需要涉及、实现以及部署新的特定设备 -&gt;
网络设备种类越来越繁多</li>
</ul></li>
</ul>
<p>SDN的出现就是用来解决以上问题的。SDN主要思路：</p>
<ul>
<li><strong>网络设备的控制平面和数据平面分离</strong></li>
<li>数据平面由分组交换机实现：
<ul>
<li>将路由器、交换机和目前绝大多数网络设备的功能进一步<strong>抽象</strong>成：按照刘表（由控制平面<strong>设置</strong>的控制逻辑）进行分组的动作（包括转发、丢弃、泛洪、阻塞、拷贝）</li>
<li><strong>统一化</strong>设备功能：SDN交换机（分组交换机）<strong>执行</strong>控制逻辑</li>
</ul></li>
<li>控制平面由控制器加上网络应用来实现
<ul>
<li>计算和下方控制逻辑：流表</li>
</ul></li>
</ul>
<p><strong>SDN控制平面和数据平面分离的优势</strong>：</p>
<ol type="1">
<li><strong>水平集成</strong>：创造更好的生态，促进发展
<ul>
<li>分组交换机、控制器和各种控制逻辑网络应用都可以由不同产商生产，只要符合标准即可</li>
</ul></li>
<li><strong>集中式</strong>实现控制逻辑，使得网络管理更容易：
<ul>
<li>集中式控制器了解网络状况，编程简单，而传统方式比较困难</li>
<li>避免路由器的误配置</li>
</ul></li>
<li><strong>基于流表的匹配+行动</strong>的工作方式允许“可编程的”分组交换机
<ul>
<li>实现流量工程等高级特性</li>
<li>在此框架下实现各种新型的网络设备</li>
</ul></li>
</ol>
<p>类比：PC产业</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605200856.png" /></p>
<p>流量工程在传统路由方式下实现困难，比方说下图</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605200938.png" /></p>
<p>如果我们想要流量走uvwz该怎么办呢？在传统方式下只能够通过修改链路的代价，然后流量路由算法以此作运算。但是修改链路的权重这非常困难，很且会影响其他路由。</p>
<p>再比如想让下图中的不同的流量采取不同的路由，传统方式该如何实现呢？答案是无法实现。</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605201138.png" /></p>
<h2 id="sdn架构">4.1. SDN架构</h2>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605201336.png" /></p>
<h3 id="数据平面交换机">4.1.1. 数据平面交换机</h3>
<ul>
<li>快速，简单，商业化交换设备采用硬件实现通用转发功能</li>
<li>流表被控制器计算和下发</li>
<li>基于<strong>南向接口</strong>，SDN控制器访问基于流的交换机</li>
<li>也定义了控制器的协议（只有满足协议才能够使分组交换机正常工作）</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605201744.png" /></p>
<h3 id="sdn控制器">4.1.2. SDN控制器</h3>
<p>SDN控制器也称为网络OS：</p>
<ol type="1">
<li>维护网络状态信息</li>
<li>通过上面的<strong>北向接口</strong>和网络控制应用交互</li>
<li>通过下面的<strong>南向接口</strong>和网络交换机交互</li>
<li>逻辑上集中，但是实现上通常由于性能、可拓展性、容错性以及鲁棒性采用分布式方法（毕竟一台服务器可能无法实现这么多的功能，需要多台服务来实现）</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605201836.png" /></p>
<h3 id="控制应用">4.1.3. 控制应用</h3>
<p>网络控制应用：</p>
<ul>
<li>控制的大脑：采用下层提供的服务，实现网络功能：
<ul>
<li>路由器、交换机</li>
<li>接入控制、防火墙</li>
<li>负载均衡</li>
<li>其他功能</li>
</ul></li>
<li>非绑定：可以由第三方提供，可以与控制器产商不同，与分组交换机产商也可以不同</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605202013.png" /></p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605202110.png" /></p>
<h2 id="sdn例子openflow">4.2. SDN例子：OpenFlow</h2>
<h3 id="数据平面">4.2.1. 数据平面</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605202137.png" /></p>
<p>比方说：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605202204.png" /></p>
<ol type="1">
<li>源IP为 <code>1.2.*.*</code> 目标IP为 <code>3.4.5.*</code>
的分组直接丢弃</li>
<li>源IP为 <code>*.*.*.*</code> 目标IP为 <code>3.4.*.*</code>
的分组转发到端口2</li>
<li>源IP为 <code>10.1.2.3</code> 目标IP为 <code>*.*.*.*</code>
的分组转发送到控制器</li>
</ol>
<h3 id="流表的表项结构">4.2.2. 流表的表项结构</h3>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605202400.png" /></p>
<p>例子：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605202413.png" /></p>
<p>解释：如果分组的目标IP地址是
<code>51.6.0.8</code>，应该通过端口6转发</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605202511.png" /></p>
<p>解释：阻塞所有目标端口为22/TCP的分组</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605202546.png" /></p>
<p>解释：阻塞所有源IP为 128.119.1.1 的分组</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605202617.png" /></p>
<p>解释：所有源MAC地址为 22:A7:23:11:E1:02 都应该通过端口3转发</p>
<h3 id="openflow工作模式">4.2.3. OpenFlow工作模式</h3>
<p><strong>采用<code>match + action</code>统一各种网络设备提供的功能</strong>。比方说：</p>
<ol type="1">
<li>路由器
<ul>
<li>match：最长前缀匹配</li>
<li>action：通过一条链路转发</li>
</ul></li>
<li>防火墙
<ul>
<li>match：IP地址和端口号</li>
<li>action：允许或者阻塞</li>
</ul></li>
<li>交换机
<ul>
<li>match：目标MAC地址</li>
<li>action：转发或者泛洪</li>
</ul></li>
<li>NAT
<ul>
<li>match：IP地址和端口</li>
<li>action：重写地址和端口</li>
</ul></li>
</ol>
<p>目前几乎所有的网络设备都可以在这个 <code>match+action</code>
模式框架下进行描述。</p>
<p>下面是一个例子：</p>
<p><img
src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220605203048.png" /></p>
<p>红色：来自6号主机的分组到达分组交换机s3，因为流表中“源IP为<code>10.3.*.*</code>，目标IP为<code>10.2.*.*</code>的分组通过端口3转发”，所以从端口3出去，到达s1。因为流表从4端口转发，到达s2，最终由4端口转发到达主机4。</p>
<p>绿色过程和上面基本一致，只有在s2不一样，从端口3转发到达主机3。</p>
<p><strong>流表是控制平面计算出来的</strong>。</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BC%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">1. 导论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.1.</span> <span class="toc-text">1.1. 网络层服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%85%B3%E9%94%AE%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.</span> <span class="toc-text">1.2. 网络层的关键功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E5%88%86%E5%B9%B3%E9%9D%A2"><span class="toc-number">1.3.</span> <span class="toc-text">1.3. 网络层分平面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">1.4. 路由在控制平面的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.4.1. 传统的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sdn%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.4.2. SDN方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="toc-number">1.5.</span> <span class="toc-text">1.5. 连接建立</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">1.6. 网络服务模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%84%E6%88%90"><span class="toc-number">2.</span> <span class="toc-text">2. 路由器组成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. 路由器结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%AB%AF%E5%8F%A3"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. 输入端口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%9B%AE%E6%A0%87%E7%9A%84%E8%BD%AC%E5%8F%91"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1. 基于目标的转发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%AB%AF%E5%8F%A3%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2. 输入端口缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. 交换结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1. 通过内存交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%80%BB%E7%BA%BF%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2. 通过总线交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9Ccrossbar%E7%AD%89%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3.
通过互联网络(crossbar等)交换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%AB%AF%E5%8F%A3"><span class="toc-number">2.4.</span> <span class="toc-text">2.4. 输出端口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1. 调度机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A2%E5%BC%83%E7%AD%96%E7%95%A5"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2. 丢弃策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ip-internet-protocol"><span class="toc-number">3.</span> <span class="toc-text">3. ⭐IP: Internet Protocol</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ip%E5%88%86%E7%89%87%E5%92%8C%E9%87%8D%E7%BB%84fragmentationreassembly"><span class="toc-number">3.1.</span> <span class="toc-text">3.1.
IP分片和重组(fragmentation&amp;reassembly)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ipv4%E5%9C%B0%E5%9D%80"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. IPv4地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BD%91subnets"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1. 子网(subnets)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ip%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2. IP地址分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cidr"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3. CIDR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81mask"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4. 子网掩码(mask)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91%E8%A1%A8%E5%92%8C%E8%BD%AC%E5%8F%91%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.5.</span> <span class="toc-text">3.2.5. 转发表和转发算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AAip%E5%9C%B0%E5%9D%80"><span class="toc-number">3.2.6.</span> <span class="toc-text">3.2.6. 获得一个IP地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dhcp"><span class="toc-number">3.2.6.1.</span> <span class="toc-text">3.2.6.1. DHCP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E5%9C%B0%E5%9D%80%E5%9D%97%E4%BB%A5%E5%8F%8A%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88"><span class="toc-number">3.2.7.</span> <span class="toc-text">3.2.7. 获得地址块以及路由聚合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%A2%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9D%97"><span class="toc-number">3.2.7.1.</span> <span class="toc-text">3.2.7.1. 换的地址块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88"><span class="toc-number">3.2.7.2.</span> <span class="toc-text">3.2.7.2. 路由聚合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nat%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. NAT：网络地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%91%E7%A9%BF%E8%B6%8A"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1. 内网穿越</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ipv6"><span class="toc-number">3.4.</span> <span class="toc-text">3.4. IPv6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%A7%E9%81%93tunneling"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1. 隧道(Tunneling)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E8%BD%AC%E5%8F%91%E5%92%8Csdn"><span class="toc-number">4.</span> <span class="toc-text">4. 通用转发和SDN</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sdn%E6%9E%B6%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. SDN架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1. 数据平面交换机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sdn%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2. SDN控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%BA%94%E7%94%A8"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3. 控制应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sdn%E4%BE%8B%E5%AD%90openflow"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. SDN例子：OpenFlow</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1. 数据平面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E8%A1%A8%E7%9A%84%E8%A1%A8%E9%A1%B9%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2. 流表的表项结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#openflow%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3. OpenFlow工作模式</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hdfzzf.github.io/2022/06/05/%E7%AC%AC%204%20%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hdfzzf.github.io/2022/06/05/%E7%AC%AC%204%20%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/&text=第 4 章 网络层：数据平面"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hdfzzf.github.io/2022/06/05/%E7%AC%AC%204%20%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/&title=第 4 章 网络层：数据平面"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hdfzzf.github.io/2022/06/05/%E7%AC%AC%204%20%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/&is_video=false&description=第 4 章 网络层：数据平面"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=第 4 章 网络层：数据平面&body=Check out this article: https://hdfzzf.github.io/2022/06/05/%E7%AC%AC%204%20%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hdfzzf.github.io/2022/06/05/%E7%AC%AC%204%20%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/&title=第 4 章 网络层：数据平面"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hdfzzf.github.io/2022/06/05/%E7%AC%AC%204%20%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/&title=第 4 章 网络层：数据平面"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hdfzzf.github.io/2022/06/05/%E7%AC%AC%204%20%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/&title=第 4 章 网络层：数据平面"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hdfzzf.github.io/2022/06/05/%E7%AC%AC%204%20%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/&title=第 4 章 网络层：数据平面"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hdfzzf.github.io/2022/06/05/%E7%AC%AC%204%20%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/&name=第 4 章 网络层：数据平面&description=&lt;p&gt;个人的知识笔记。&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hdfzzf.github.io/2022/06/05/%E7%AC%AC%204%20%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/&t=第 4 章 网络层：数据平面"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    hdfzzf
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/tags/">标签</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'cactus-1';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
